'use strict'

// The ABNF grammar in the spec is totally ambiguous.
//
// This parser follows the operator precedence defined in the
// `Order of Precedence and Parentheses` section.

module.exports = function (tokens) ***REMOVED***
  var index = 0

  function hasMore () ***REMOVED***
    return index < tokens.length
  ***REMOVED***

  function token () ***REMOVED***
    return hasMore() ? tokens[index] : null
  ***REMOVED***

  function next () ***REMOVED***
    if (!hasMore()) ***REMOVED***
      throw new Error()
    ***REMOVED***
    index++
  ***REMOVED***

  function parseOperator (operator) ***REMOVED***
    var t = token()
    if (t && t.type === 'OPERATOR' && operator === t.string) ***REMOVED***
      next()
      return t.string
    ***REMOVED***
  ***REMOVED***

  function parseWith () ***REMOVED***
    if (parseOperator('WITH')) ***REMOVED***
      var t = token()
      if (t && t.type === 'EXCEPTION') ***REMOVED***
        next()
        return t.string
      ***REMOVED***
      throw new Error('Expected exception after `WITH`')
    ***REMOVED***
  ***REMOVED***

  function parseLicenseRef () ***REMOVED***
    // TODO: Actually, everything is concatenated into one string
    // for backward-compatibility but it could be better to return
    // a nice structure.
    var begin = index
    var string = ''
    var t = token()
    if (t.type === 'DOCUMENTREF') ***REMOVED***
      next()
      string += 'DocumentRef-' + t.string + ':'
      if (!parseOperator(':')) ***REMOVED***
        throw new Error('Expected `:` after `DocumentRef-...`')
      ***REMOVED***
    ***REMOVED***
    t = token()
    if (t.type === 'LICENSEREF') ***REMOVED***
      next()
      string += 'LicenseRef-' + t.string
      return ***REMOVED***license: string***REMOVED***
    ***REMOVED***
    index = begin
  ***REMOVED***

  function parseLicense () ***REMOVED***
    var t = token()
    if (t && t.type === 'LICENSE') ***REMOVED***
      next()
      var node = ***REMOVED***license: t.string***REMOVED***
      if (parseOperator('+')) ***REMOVED***
        node.plus = true
      ***REMOVED***
      var exception = parseWith()
      if (exception) ***REMOVED***
        node.exception = exception
      ***REMOVED***
      return node
    ***REMOVED***
  ***REMOVED***

  function parseParenthesizedExpression () ***REMOVED***
    var left = parseOperator('(')
    if (!left) ***REMOVED***
      return
    ***REMOVED***

    var expr = parseExpression()

    if (!parseOperator(')')) ***REMOVED***
      throw new Error('Expected `)`')
    ***REMOVED***

    return expr
  ***REMOVED***

  function parseAtom () ***REMOVED***
    return (
      parseParenthesizedExpression() ||
      parseLicenseRef() ||
      parseLicense()
    )
  ***REMOVED***

  function makeBinaryOpParser (operator, nextParser) ***REMOVED***
    return function parseBinaryOp () ***REMOVED***
      var left = nextParser()
      if (!left) ***REMOVED***
        return
      ***REMOVED***

      if (!parseOperator(operator)) ***REMOVED***
        return left
      ***REMOVED***

      var right = parseBinaryOp()
      if (!right) ***REMOVED***
        throw new Error('Expected expression')
      ***REMOVED***
      return ***REMOVED***
        left: left,
        conjunction: operator.toLowerCase(),
        right: right
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  var parseAnd = makeBinaryOpParser('AND', parseAtom)
  var parseExpression = makeBinaryOpParser('OR', parseAnd)

  var node = parseExpression()
  if (!node || hasMore()) ***REMOVED***
    throw new Error('Syntax error')
  ***REMOVED***
  return node
***REMOVED***
