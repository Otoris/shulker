'use strict';

var bind = require('./helpers/bind');

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if value is an Array, otherwise false
 */
function isArray(val) ***REMOVED***
  return toString.call(val) === '[object Array]';
***REMOVED***

/**
 * Determine if a value is undefined
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if the value is undefined, otherwise false
 */
function isUndefined(val) ***REMOVED***
  return typeof val === 'undefined';
***REMOVED***

/**
 * Determine if a value is a Buffer
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if value is a Buffer, otherwise false
 */
function isBuffer(val) ***REMOVED***
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
***REMOVED***

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) ***REMOVED***
  return toString.call(val) === '[object ArrayBuffer]';
***REMOVED***

/**
 * Determine if a value is a FormData
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if value is an FormData, otherwise false
 */
function isFormData(val) ***REMOVED***
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
***REMOVED***

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) ***REMOVED***
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) ***REMOVED***
    result = ArrayBuffer.isView(val);
  ***REMOVED*** else ***REMOVED***
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  ***REMOVED***
  return result;
***REMOVED***

/**
 * Determine if a value is a String
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if value is a String, otherwise false
 */
function isString(val) ***REMOVED***
  return typeof val === 'string';
***REMOVED***

/**
 * Determine if a value is a Number
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if value is a Number, otherwise false
 */
function isNumber(val) ***REMOVED***
  return typeof val === 'number';
***REMOVED***

/**
 * Determine if a value is an Object
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if value is an Object, otherwise false
 */
function isObject(val) ***REMOVED***
  return val !== null && typeof val === 'object';
***REMOVED***

/**
 * Determine if a value is a Date
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if value is a Date, otherwise false
 */
function isDate(val) ***REMOVED***
  return toString.call(val) === '[object Date]';
***REMOVED***

/**
 * Determine if a value is a File
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if value is a File, otherwise false
 */
function isFile(val) ***REMOVED***
  return toString.call(val) === '[object File]';
***REMOVED***

/**
 * Determine if a value is a Blob
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if value is a Blob, otherwise false
 */
function isBlob(val) ***REMOVED***
  return toString.call(val) === '[object Blob]';
***REMOVED***

/**
 * Determine if a value is a Function
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if value is a Function, otherwise false
 */
function isFunction(val) ***REMOVED***
  return toString.call(val) === '[object Function]';
***REMOVED***

/**
 * Determine if a value is a Stream
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if value is a Stream, otherwise false
 */
function isStream(val) ***REMOVED***
  return isObject(val) && isFunction(val.pipe);
***REMOVED***

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param ***REMOVED***Object***REMOVED*** val The value to test
 * @returns ***REMOVED***boolean***REMOVED*** True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) ***REMOVED***
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
***REMOVED***

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param ***REMOVED***String***REMOVED*** str The String to trim
 * @returns ***REMOVED***String***REMOVED*** The String freed of excess whitespace
 */
function trim(str) ***REMOVED***
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
***REMOVED***

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() ***REMOVED***
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) ***REMOVED***
    return false;
  ***REMOVED***
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
***REMOVED***

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param ***REMOVED***Object|Array***REMOVED*** obj The object to iterate
 * @param ***REMOVED***Function***REMOVED*** fn The callback to invoke for each item
 */
function forEach(obj, fn) ***REMOVED***
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') ***REMOVED***
    return;
  ***REMOVED***

  // Force an array if not already something iterable
  if (typeof obj !== 'object') ***REMOVED***
    /*eslint no-param-reassign:0*/
    obj = [obj];
  ***REMOVED***

  if (isArray(obj)) ***REMOVED***
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) ***REMOVED***
      fn.call(null, obj[i], i, obj);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    // Iterate over object keys
    for (var key in obj) ***REMOVED***
      if (Object.prototype.hasOwnProperty.call(obj, key)) ***REMOVED***
        fn.call(null, obj[key], key, obj);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge(***REMOVED***foo: 123***REMOVED***, ***REMOVED***foo: 456***REMOVED***);
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param ***REMOVED***Object***REMOVED*** obj1 Object to merge
 * @returns ***REMOVED***Object***REMOVED*** Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) ***REMOVED***
  var result = ***REMOVED******REMOVED***;
  function assignValue(val, key) ***REMOVED***
    if (typeof result[key] === 'object' && typeof val === 'object') ***REMOVED***
      result[key] = merge(result[key], val);
    ***REMOVED*** else ***REMOVED***
      result[key] = val;
    ***REMOVED***
  ***REMOVED***

  for (var i = 0, l = arguments.length; i < l; i++) ***REMOVED***
    forEach(arguments[i], assignValue);
  ***REMOVED***
  return result;
***REMOVED***

/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @param ***REMOVED***Object***REMOVED*** obj1 Object to merge
 * @returns ***REMOVED***Object***REMOVED*** Result of all merge properties
 */
function deepMerge(/* obj1, obj2, obj3, ... */) ***REMOVED***
  var result = ***REMOVED******REMOVED***;
  function assignValue(val, key) ***REMOVED***
    if (typeof result[key] === 'object' && typeof val === 'object') ***REMOVED***
      result[key] = deepMerge(result[key], val);
    ***REMOVED*** else if (typeof val === 'object') ***REMOVED***
      result[key] = deepMerge(***REMOVED******REMOVED***, val);
    ***REMOVED*** else ***REMOVED***
      result[key] = val;
    ***REMOVED***
  ***REMOVED***

  for (var i = 0, l = arguments.length; i < l; i++) ***REMOVED***
    forEach(arguments[i], assignValue);
  ***REMOVED***
  return result;
***REMOVED***

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param ***REMOVED***Object***REMOVED*** a The object to be extended
 * @param ***REMOVED***Object***REMOVED*** b The object to copy properties from
 * @param ***REMOVED***Object***REMOVED*** thisArg The object to bind function to
 * @return ***REMOVED***Object***REMOVED*** The resulting value of object a
 */
function extend(a, b, thisArg) ***REMOVED***
  forEach(b, function assignValue(val, key) ***REMOVED***
    if (thisArg && typeof val === 'function') ***REMOVED***
      a[key] = bind(val, thisArg);
    ***REMOVED*** else ***REMOVED***
      a[key] = val;
    ***REMOVED***
  ***REMOVED***);
  return a;
***REMOVED***

module.exports = ***REMOVED***
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  deepMerge: deepMerge,
  extend: extend,
  trim: trim
***REMOVED***;
