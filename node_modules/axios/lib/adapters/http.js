'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var buildFullPath = require('../core/buildFullPath');
var buildURL = require('./../helpers/buildURL');
var http = require('http');
var https = require('https');
var httpFollow = require('follow-redirects').http;
var httpsFollow = require('follow-redirects').https;
var url = require('url');
var zlib = require('zlib');
var pkg = require('./../../package.json');
var createError = require('../core/createError');
var enhanceError = require('../core/enhanceError');

var isHttps = /https:?/;

/*eslint consistent-return:0*/
module.exports = function httpAdapter(config) ***REMOVED***
  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) ***REMOVED***
    var resolve = function resolve(value) ***REMOVED***
      resolvePromise(value);
    ***REMOVED***;
    var reject = function reject(value) ***REMOVED***
      rejectPromise(value);
    ***REMOVED***;
    var data = config.data;
    var headers = config.headers;

    // Set User-Agent (required by some servers)
    // Only set header if it hasn't been set in config
    // See https://github.com/axios/axios/issues/69
    if (!headers['User-Agent'] && !headers['user-agent']) ***REMOVED***
      headers['User-Agent'] = 'axios/' + pkg.version;
    ***REMOVED***

    if (data && !utils.isStream(data)) ***REMOVED***
      if (Buffer.isBuffer(data)) ***REMOVED***
        // Nothing to do...
      ***REMOVED*** else if (utils.isArrayBuffer(data)) ***REMOVED***
        data = Buffer.from(new Uint8Array(data));
      ***REMOVED*** else if (utils.isString(data)) ***REMOVED***
        data = Buffer.from(data, 'utf-8');
      ***REMOVED*** else ***REMOVED***
        return reject(createError(
          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
          config
        ));
      ***REMOVED***

      // Add Content-Length header if data exists
      headers['Content-Length'] = data.length;
    ***REMOVED***

    // HTTP basic authentication
    var auth = undefined;
    if (config.auth) ***REMOVED***
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      auth = username + ':' + password;
    ***REMOVED***

    // Parse url
    var fullPath = buildFullPath(config.baseURL, config.url);
    var parsed = url.parse(fullPath);
    var protocol = parsed.protocol || 'http:';

    if (!auth && parsed.auth) ***REMOVED***
      var urlAuth = parsed.auth.split(':');
      var urlUsername = urlAuth[0] || '';
      var urlPassword = urlAuth[1] || '';
      auth = urlUsername + ':' + urlPassword;
    ***REMOVED***

    if (auth) ***REMOVED***
      delete headers.Authorization;
    ***REMOVED***

    var isHttpsRequest = isHttps.test(protocol);
    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;

    var options = ***REMOVED***
      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
      method: config.method.toUpperCase(),
      headers: headers,
      agent: agent,
      agents: ***REMOVED*** http: config.httpAgent, https: config.httpsAgent ***REMOVED***,
      auth: auth
    ***REMOVED***;

    if (config.socketPath) ***REMOVED***
      options.socketPath = config.socketPath;
    ***REMOVED*** else ***REMOVED***
      options.hostname = parsed.hostname;
      options.port = parsed.port;
    ***REMOVED***

    var proxy = config.proxy;
    if (!proxy && proxy !== false) ***REMOVED***
      var proxyEnv = protocol.slice(0, -1) + '_proxy';
      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
      if (proxyUrl) ***REMOVED***
        var parsedProxyUrl = url.parse(proxyUrl);
        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
        var shouldProxy = true;

        if (noProxyEnv) ***REMOVED***
          var noProxy = noProxyEnv.split(',').map(function trim(s) ***REMOVED***
            return s.trim();
          ***REMOVED***);

          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) ***REMOVED***
            if (!proxyElement) ***REMOVED***
              return false;
            ***REMOVED***
            if (proxyElement === '*') ***REMOVED***
              return true;
            ***REMOVED***
            if (proxyElement[0] === '.' &&
                parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) ***REMOVED***
              return true;
            ***REMOVED***

            return parsed.hostname === proxyElement;
          ***REMOVED***);
        ***REMOVED***


        if (shouldProxy) ***REMOVED***
          proxy = ***REMOVED***
            host: parsedProxyUrl.hostname,
            port: parsedProxyUrl.port
          ***REMOVED***;

          if (parsedProxyUrl.auth) ***REMOVED***
            var proxyUrlAuth = parsedProxyUrl.auth.split(':');
            proxy.auth = ***REMOVED***
              username: proxyUrlAuth[0],
              password: proxyUrlAuth[1]
            ***REMOVED***;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    if (proxy) ***REMOVED***
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
      options.port = proxy.port;
      options.path = protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path;

      // Basic proxy authorization
      if (proxy.auth) ***REMOVED***
        var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');
        options.headers['Proxy-Authorization'] = 'Basic ' + base64;
      ***REMOVED***
    ***REMOVED***

    var transport;
    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
    if (config.transport) ***REMOVED***
      transport = config.transport;
    ***REMOVED*** else if (config.maxRedirects === 0) ***REMOVED***
      transport = isHttpsProxy ? https : http;
    ***REMOVED*** else ***REMOVED***
      if (config.maxRedirects) ***REMOVED***
        options.maxRedirects = config.maxRedirects;
      ***REMOVED***
      transport = isHttpsProxy ? httpsFollow : httpFollow;
    ***REMOVED***

    if (config.maxContentLength && config.maxContentLength > -1) ***REMOVED***
      options.maxBodyLength = config.maxContentLength;
    ***REMOVED***

    // Create the request
    var req = transport.request(options, function handleResponse(res) ***REMOVED***
      if (req.aborted) return;

      // uncompress the response body transparently if required
      var stream = res;
      switch (res.headers['content-encoding']) ***REMOVED***
      /*eslint default-case:0*/
      case 'gzip':
      case 'compress':
      case 'deflate':
        // add the unzipper to the body stream processing pipeline
        stream = (res.statusCode === 204) ? stream : stream.pipe(zlib.createUnzip());

        // remove the content-encoding in order to not confuse downstream operations
        delete res.headers['content-encoding'];
        break;
      ***REMOVED***

      // return the last request in case of redirects
      var lastRequest = res.req || req;

      var response = ***REMOVED***
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: res.headers,
        config: config,
        request: lastRequest
      ***REMOVED***;

      if (config.responseType === 'stream') ***REMOVED***
        response.data = stream;
        settle(resolve, reject, response);
      ***REMOVED*** else ***REMOVED***
        var responseBuffer = [];
        stream.on('data', function handleStreamData(chunk) ***REMOVED***
          responseBuffer.push(chunk);

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) ***REMOVED***
            stream.destroy();
            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
              config, null, lastRequest));
          ***REMOVED***
        ***REMOVED***);

        stream.on('error', function handleStreamError(err) ***REMOVED***
          if (req.aborted) return;
          reject(enhanceError(err, config, null, lastRequest));
        ***REMOVED***);

        stream.on('end', function handleStreamEnd() ***REMOVED***
          var responseData = Buffer.concat(responseBuffer);
          if (config.responseType !== 'arraybuffer') ***REMOVED***
            responseData = responseData.toString(config.responseEncoding);
          ***REMOVED***

          response.data = responseData;
          settle(resolve, reject, response);
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***);

    // Handle errors
    req.on('error', function handleRequestError(err) ***REMOVED***
      if (req.aborted) return;
      reject(enhanceError(err, config, null, req));
    ***REMOVED***);

    // Handle request timeout
    if (config.timeout) ***REMOVED***
      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devoring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(config.timeout, function handleRequestTimeout() ***REMOVED***
        req.abort();
        reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', req));
      ***REMOVED***);
    ***REMOVED***

    if (config.cancelToken) ***REMOVED***
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) ***REMOVED***
        if (req.aborted) return;

        req.abort();
        reject(cancel);
      ***REMOVED***);
    ***REMOVED***

    // Send the request
    if (utils.isStream(data)) ***REMOVED***
      data.on('error', function handleStreamError(err) ***REMOVED***
        reject(enhanceError(err, config, null, req));
      ***REMOVED***).pipe(req);
    ***REMOVED*** else ***REMOVED***
      req.end(data);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***;
