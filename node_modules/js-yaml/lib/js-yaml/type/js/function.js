'use strict';

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try ***REMOVED***
  // workaround to exclude package from browserify list.
  var _require = require;
  esprima = _require('esprima');
***REMOVED*** catch (_) ***REMOVED***
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
***REMOVED***

var Type = require('../../type');

function resolveJavascriptFunction(data) ***REMOVED***
  if (data === null) return false;

  try ***REMOVED***
    var source = '(' + data + ')',
        ast    = esprima.parse(source, ***REMOVED*** range: true ***REMOVED***);

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) ***REMOVED***
      return false;
    ***REMOVED***

    return true;
  ***REMOVED*** catch (err) ***REMOVED***
    return false;
  ***REMOVED***
***REMOVED***

function constructJavascriptFunction(data) ***REMOVED***
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, ***REMOVED*** range: true ***REMOVED***),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
        ast.body[0].expression.type !== 'FunctionExpression')) ***REMOVED***
    throw new Error('Failed to resolve function');
  ***REMOVED***

  ast.body[0].expression.params.forEach(function (param) ***REMOVED***
    params.push(param.name);
  ***REMOVED***);

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '***REMOVED***' and the last '***REMOVED***' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') ***REMOVED***
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  ***REMOVED***
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
***REMOVED***

function representJavascriptFunction(object /*, style*/) ***REMOVED***
  return object.toString();
***REMOVED***

function isFunction(object) ***REMOVED***
  return Object.prototype.toString.call(object) === '[object Function]';
***REMOVED***

module.exports = new Type('tag:yaml.org,2002:js/function', ***REMOVED***
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
***REMOVED***);
