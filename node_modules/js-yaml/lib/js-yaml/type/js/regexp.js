'use strict';

var Type = require('../../type');

function resolveJavascriptRegExp(data) ***REMOVED***
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') ***REMOVED***
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  ***REMOVED***

  return true;
***REMOVED***

function constructJavascriptRegExp(data) ***REMOVED***
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') ***REMOVED***
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  ***REMOVED***

  return new RegExp(regexp, modifiers);
***REMOVED***

function representJavascriptRegExp(object /*, style*/) ***REMOVED***
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
***REMOVED***

function isRegExp(object) ***REMOVED***
  return Object.prototype.toString.call(object) === '[object RegExp]';
***REMOVED***

module.exports = new Type('tag:yaml.org,2002:js/regexp', ***REMOVED***
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
***REMOVED***);
