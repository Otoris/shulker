import ***REMOVED*** AsyncAction ***REMOVED*** from './AsyncAction';
import ***REMOVED*** AsyncScheduler ***REMOVED*** from './AsyncScheduler';
export class VirtualTimeScheduler extends AsyncScheduler ***REMOVED***
    constructor(SchedulerAction = VirtualAction, maxFrames = Number.POSITIVE_INFINITY) ***REMOVED***
        super(SchedulerAction, () => this.frame);
        this.maxFrames = maxFrames;
        this.frame = 0;
        this.index = -1;
    ***REMOVED***
    flush() ***REMOVED***
        const ***REMOVED*** actions, maxFrames ***REMOVED*** = this;
        let error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) ***REMOVED***
            actions.shift();
            this.frame = action.delay;
            if (error = action.execute(action.state, action.delay)) ***REMOVED***
                break;
            ***REMOVED***
        ***REMOVED***
        if (error) ***REMOVED***
            while (action = actions.shift()) ***REMOVED***
                action.unsubscribe();
            ***REMOVED***
            throw error;
        ***REMOVED***
    ***REMOVED***
***REMOVED***
VirtualTimeScheduler.frameTimeFactor = 10;
export class VirtualAction extends AsyncAction ***REMOVED***
    constructor(scheduler, work, index = scheduler.index += 1) ***REMOVED***
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.index = index;
        this.active = true;
        this.index = scheduler.index = index;
    ***REMOVED***
    schedule(state, delay = 0) ***REMOVED***
        if (!this.id) ***REMOVED***
            return super.schedule(state, delay);
        ***REMOVED***
        this.active = false;
        const action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    ***REMOVED***
    requestAsyncId(scheduler, id, delay = 0) ***REMOVED***
        this.delay = scheduler.frame + delay;
        const ***REMOVED*** actions ***REMOVED*** = scheduler;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    ***REMOVED***
    recycleAsyncId(scheduler, id, delay = 0) ***REMOVED***
        return undefined;
    ***REMOVED***
    _execute(state, delay) ***REMOVED***
        if (this.active === true) ***REMOVED***
            return super._execute(state, delay);
        ***REMOVED***
    ***REMOVED***
    static sortActions(a, b) ***REMOVED***
        if (a.delay === b.delay) ***REMOVED***
            if (a.index === b.index) ***REMOVED***
                return 0;
            ***REMOVED***
            else if (a.index > b.index) ***REMOVED***
                return 1;
            ***REMOVED***
            else ***REMOVED***
                return -1;
            ***REMOVED***
        ***REMOVED***
        else if (a.delay > b.delay) ***REMOVED***
            return 1;
        ***REMOVED***
        else ***REMOVED***
            return -1;
        ***REMOVED***
    ***REMOVED***
***REMOVED***
//# sourceMappingURL=VirtualTimeScheduler.js.map