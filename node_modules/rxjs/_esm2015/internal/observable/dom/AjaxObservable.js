import ***REMOVED*** root ***REMOVED*** from '../../util/root';
import ***REMOVED*** Observable ***REMOVED*** from '../../Observable';
import ***REMOVED*** Subscriber ***REMOVED*** from '../../Subscriber';
import ***REMOVED*** map ***REMOVED*** from '../../operators/map';
function getCORSRequest() ***REMOVED***
    if (root.XMLHttpRequest) ***REMOVED***
        return new root.XMLHttpRequest();
    ***REMOVED***
    else if (!!root.XDomainRequest) ***REMOVED***
        return new root.XDomainRequest();
    ***REMOVED***
    else ***REMOVED***
        throw new Error('CORS is not supported by your browser');
    ***REMOVED***
***REMOVED***
function getXMLHttpRequest() ***REMOVED***
    if (root.XMLHttpRequest) ***REMOVED***
        return new root.XMLHttpRequest();
    ***REMOVED***
    else ***REMOVED***
        let progId;
        try ***REMOVED***
            const progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
            for (let i = 0; i < 3; i++) ***REMOVED***
                try ***REMOVED***
                    progId = progIds[i];
                    if (new root.ActiveXObject(progId)) ***REMOVED***
                        break;
                    ***REMOVED***
                ***REMOVED***
                catch (e) ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            return new root.ActiveXObject(progId);
        ***REMOVED***
        catch (e) ***REMOVED***
            throw new Error('XMLHttpRequest is not supported by your browser');
        ***REMOVED***
    ***REMOVED***
***REMOVED***
export function ajaxGet(url, headers = null) ***REMOVED***
    return new AjaxObservable(***REMOVED*** method: 'GET', url, headers ***REMOVED***);
***REMOVED***
export function ajaxPost(url, body, headers) ***REMOVED***
    return new AjaxObservable(***REMOVED*** method: 'POST', url, body, headers ***REMOVED***);
***REMOVED***
export function ajaxDelete(url, headers) ***REMOVED***
    return new AjaxObservable(***REMOVED*** method: 'DELETE', url, headers ***REMOVED***);
***REMOVED***
export function ajaxPut(url, body, headers) ***REMOVED***
    return new AjaxObservable(***REMOVED*** method: 'PUT', url, body, headers ***REMOVED***);
***REMOVED***
export function ajaxPatch(url, body, headers) ***REMOVED***
    return new AjaxObservable(***REMOVED*** method: 'PATCH', url, body, headers ***REMOVED***);
***REMOVED***
const mapResponse = map((x, index) => x.response);
export function ajaxGetJSON(url, headers) ***REMOVED***
    return mapResponse(new AjaxObservable(***REMOVED***
        method: 'GET',
        url,
        responseType: 'json',
        headers
    ***REMOVED***));
***REMOVED***
export class AjaxObservable extends Observable ***REMOVED***
    constructor(urlOrRequest) ***REMOVED***
        super();
        const request = ***REMOVED***
            async: true,
            createXHR: function () ***REMOVED***
                return this.crossDomain ? getCORSRequest() : getXMLHttpRequest();
            ***REMOVED***,
            crossDomain: true,
            withCredentials: false,
            headers: ***REMOVED******REMOVED***,
            method: 'GET',
            responseType: 'json',
            timeout: 0
        ***REMOVED***;
        if (typeof urlOrRequest === 'string') ***REMOVED***
            request.url = urlOrRequest;
        ***REMOVED***
        else ***REMOVED***
            for (const prop in urlOrRequest) ***REMOVED***
                if (urlOrRequest.hasOwnProperty(prop)) ***REMOVED***
                    request[prop] = urlOrRequest[prop];
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        this.request = request;
    ***REMOVED***
    _subscribe(subscriber) ***REMOVED***
        return new AjaxSubscriber(subscriber, this.request);
    ***REMOVED***
***REMOVED***
AjaxObservable.create = (() => ***REMOVED***
    const create = (urlOrRequest) => ***REMOVED***
        return new AjaxObservable(urlOrRequest);
    ***REMOVED***;
    create.get = ajaxGet;
    create.post = ajaxPost;
    create.delete = ajaxDelete;
    create.put = ajaxPut;
    create.patch = ajaxPatch;
    create.getJSON = ajaxGetJSON;
    return create;
***REMOVED***)();
export class AjaxSubscriber extends Subscriber ***REMOVED***
    constructor(destination, request) ***REMOVED***
        super(destination);
        this.request = request;
        this.done = false;
        const headers = request.headers = request.headers || ***REMOVED******REMOVED***;
        if (!request.crossDomain && !this.getHeader(headers, 'X-Requested-With')) ***REMOVED***
            headers['X-Requested-With'] = 'XMLHttpRequest';
        ***REMOVED***
        let contentTypeHeader = this.getHeader(headers, 'Content-Type');
        if (!contentTypeHeader && !(root.FormData && request.body instanceof root.FormData) && typeof request.body !== 'undefined') ***REMOVED***
            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
        ***REMOVED***
        request.body = this.serializeBody(request.body, this.getHeader(request.headers, 'Content-Type'));
        this.send();
    ***REMOVED***
    next(e) ***REMOVED***
        this.done = true;
        const ***REMOVED*** xhr, request, destination ***REMOVED*** = this;
        let result;
        try ***REMOVED***
            result = new AjaxResponse(e, xhr, request);
        ***REMOVED***
        catch (err) ***REMOVED***
            return destination.error(err);
        ***REMOVED***
        destination.next(result);
    ***REMOVED***
    send() ***REMOVED***
        const ***REMOVED*** request, request: ***REMOVED*** user, method, url, async, password, headers, body ***REMOVED*** ***REMOVED*** = this;
        try ***REMOVED***
            const xhr = this.xhr = request.createXHR();
            this.setupEvents(xhr, request);
            if (user) ***REMOVED***
                xhr.open(method, url, async, user, password);
            ***REMOVED***
            else ***REMOVED***
                xhr.open(method, url, async);
            ***REMOVED***
            if (async) ***REMOVED***
                xhr.timeout = request.timeout;
                xhr.responseType = request.responseType;
            ***REMOVED***
            if ('withCredentials' in xhr) ***REMOVED***
                xhr.withCredentials = !!request.withCredentials;
            ***REMOVED***
            this.setHeaders(xhr, headers);
            if (body) ***REMOVED***
                xhr.send(body);
            ***REMOVED***
            else ***REMOVED***
                xhr.send();
            ***REMOVED***
        ***REMOVED***
        catch (err) ***REMOVED***
            this.error(err);
        ***REMOVED***
    ***REMOVED***
    serializeBody(body, contentType) ***REMOVED***
        if (!body || typeof body === 'string') ***REMOVED***
            return body;
        ***REMOVED***
        else if (root.FormData && body instanceof root.FormData) ***REMOVED***
            return body;
        ***REMOVED***
        if (contentType) ***REMOVED***
            const splitIndex = contentType.indexOf(';');
            if (splitIndex !== -1) ***REMOVED***
                contentType = contentType.substring(0, splitIndex);
            ***REMOVED***
        ***REMOVED***
        switch (contentType) ***REMOVED***
            case 'application/x-www-form-urlencoded':
                return Object.keys(body).map(key => `$***REMOVED***encodeURIComponent(key)***REMOVED***=$***REMOVED***encodeURIComponent(body[key])***REMOVED***`).join('&');
            case 'application/json':
                return JSON.stringify(body);
            default:
                return body;
        ***REMOVED***
    ***REMOVED***
    setHeaders(xhr, headers) ***REMOVED***
        for (let key in headers) ***REMOVED***
            if (headers.hasOwnProperty(key)) ***REMOVED***
                xhr.setRequestHeader(key, headers[key]);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    getHeader(headers, headerName) ***REMOVED***
        for (let key in headers) ***REMOVED***
            if (key.toLowerCase() === headerName.toLowerCase()) ***REMOVED***
                return headers[key];
            ***REMOVED***
        ***REMOVED***
        return undefined;
    ***REMOVED***
    setupEvents(xhr, request) ***REMOVED***
        const progressSubscriber = request.progressSubscriber;
        function xhrTimeout(e) ***REMOVED***
            const ***REMOVED*** subscriber, progressSubscriber, request ***REMOVED*** = xhrTimeout;
            if (progressSubscriber) ***REMOVED***
                progressSubscriber.error(e);
            ***REMOVED***
            let error;
            try ***REMOVED***
                error = new AjaxTimeoutError(this, request);
            ***REMOVED***
            catch (err) ***REMOVED***
                error = err;
            ***REMOVED***
            subscriber.error(error);
        ***REMOVED***
        xhr.ontimeout = xhrTimeout;
        xhrTimeout.request = request;
        xhrTimeout.subscriber = this;
        xhrTimeout.progressSubscriber = progressSubscriber;
        if (xhr.upload && 'withCredentials' in xhr) ***REMOVED***
            if (progressSubscriber) ***REMOVED***
                let xhrProgress;
                xhrProgress = function (e) ***REMOVED***
                    const ***REMOVED*** progressSubscriber ***REMOVED*** = xhrProgress;
                    progressSubscriber.next(e);
                ***REMOVED***;
                if (root.XDomainRequest) ***REMOVED***
                    xhr.onprogress = xhrProgress;
                ***REMOVED***
                else ***REMOVED***
                    xhr.upload.onprogress = xhrProgress;
                ***REMOVED***
                xhrProgress.progressSubscriber = progressSubscriber;
            ***REMOVED***
            let xhrError;
            xhrError = function (e) ***REMOVED***
                const ***REMOVED*** progressSubscriber, subscriber, request ***REMOVED*** = xhrError;
                if (progressSubscriber) ***REMOVED***
                    progressSubscriber.error(e);
                ***REMOVED***
                let error;
                try ***REMOVED***
                    error = new AjaxError('ajax error', this, request);
                ***REMOVED***
                catch (err) ***REMOVED***
                    error = err;
                ***REMOVED***
                subscriber.error(error);
            ***REMOVED***;
            xhr.onerror = xhrError;
            xhrError.request = request;
            xhrError.subscriber = this;
            xhrError.progressSubscriber = progressSubscriber;
        ***REMOVED***
        function xhrReadyStateChange(e) ***REMOVED***
            return;
        ***REMOVED***
        xhr.onreadystatechange = xhrReadyStateChange;
        xhrReadyStateChange.subscriber = this;
        xhrReadyStateChange.progressSubscriber = progressSubscriber;
        xhrReadyStateChange.request = request;
        function xhrLoad(e) ***REMOVED***
            const ***REMOVED*** subscriber, progressSubscriber, request ***REMOVED*** = xhrLoad;
            if (this.readyState === 4) ***REMOVED***
                let status = this.status === 1223 ? 204 : this.status;
                let response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);
                if (status === 0) ***REMOVED***
                    status = response ? 200 : 0;
                ***REMOVED***
                if (status < 400) ***REMOVED***
                    if (progressSubscriber) ***REMOVED***
                        progressSubscriber.complete();
                    ***REMOVED***
                    subscriber.next(e);
                    subscriber.complete();
                ***REMOVED***
                else ***REMOVED***
                    if (progressSubscriber) ***REMOVED***
                        progressSubscriber.error(e);
                    ***REMOVED***
                    let error;
                    try ***REMOVED***
                        error = new AjaxError('ajax error ' + status, this, request);
                    ***REMOVED***
                    catch (err) ***REMOVED***
                        error = err;
                    ***REMOVED***
                    subscriber.error(error);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        xhr.onload = xhrLoad;
        xhrLoad.subscriber = this;
        xhrLoad.progressSubscriber = progressSubscriber;
        xhrLoad.request = request;
    ***REMOVED***
    unsubscribe() ***REMOVED***
        const ***REMOVED*** done, xhr ***REMOVED*** = this;
        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') ***REMOVED***
            xhr.abort();
        ***REMOVED***
        super.unsubscribe();
    ***REMOVED***
***REMOVED***
export class AjaxResponse ***REMOVED***
    constructor(originalEvent, xhr, request) ***REMOVED***
        this.originalEvent = originalEvent;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
        this.responseType = xhr.responseType || request.responseType;
        this.response = parseXhrResponse(this.responseType, xhr);
    ***REMOVED***
***REMOVED***
const AjaxErrorImpl = (() => ***REMOVED***
    function AjaxErrorImpl(message, xhr, request) ***REMOVED***
        Error.call(this);
        this.message = message;
        this.name = 'AjaxError';
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
        this.responseType = xhr.responseType || request.responseType;
        this.response = parseXhrResponse(this.responseType, xhr);
        return this;
    ***REMOVED***
    AjaxErrorImpl.prototype = Object.create(Error.prototype);
    return AjaxErrorImpl;
***REMOVED***)();
export const AjaxError = AjaxErrorImpl;
function parseJson(xhr) ***REMOVED***
    if ('response' in xhr) ***REMOVED***
        return xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');
    ***REMOVED***
    else ***REMOVED***
        return JSON.parse(xhr.responseText || 'null');
    ***REMOVED***
***REMOVED***
function parseXhrResponse(responseType, xhr) ***REMOVED***
    switch (responseType) ***REMOVED***
        case 'json':
            return parseJson(xhr);
        case 'xml':
            return xhr.responseXML;
        case 'text':
        default:
            return ('response' in xhr) ? xhr.response : xhr.responseText;
    ***REMOVED***
***REMOVED***
function AjaxTimeoutErrorImpl(xhr, request) ***REMOVED***
    AjaxError.call(this, 'ajax timeout', xhr, request);
    this.name = 'AjaxTimeoutError';
    return this;
***REMOVED***
export const AjaxTimeoutError = AjaxTimeoutErrorImpl;
//# sourceMappingURL=AjaxObservable.js.map