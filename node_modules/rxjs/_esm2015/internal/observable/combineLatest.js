import ***REMOVED*** isScheduler ***REMOVED*** from '../util/isScheduler';
import ***REMOVED*** isArray ***REMOVED*** from '../util/isArray';
import ***REMOVED*** OuterSubscriber ***REMOVED*** from '../OuterSubscriber';
import ***REMOVED*** subscribeToResult ***REMOVED*** from '../util/subscribeToResult';
import ***REMOVED*** fromArray ***REMOVED*** from './fromArray';
const NONE = ***REMOVED******REMOVED***;
export function combineLatest(...observables) ***REMOVED***
    let resultSelector = null;
    let scheduler = null;
    if (isScheduler(observables[observables.length - 1])) ***REMOVED***
        scheduler = observables.pop();
    ***REMOVED***
    if (typeof observables[observables.length - 1] === 'function') ***REMOVED***
        resultSelector = observables.pop();
    ***REMOVED***
    if (observables.length === 1 && isArray(observables[0])) ***REMOVED***
        observables = observables[0];
    ***REMOVED***
    return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
***REMOVED***
export class CombineLatestOperator ***REMOVED***
    constructor(resultSelector) ***REMOVED***
        this.resultSelector = resultSelector;
    ***REMOVED***
    call(subscriber, source) ***REMOVED***
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    ***REMOVED***
***REMOVED***
export class CombineLatestSubscriber extends OuterSubscriber ***REMOVED***
    constructor(destination, resultSelector) ***REMOVED***
        super(destination);
        this.resultSelector = resultSelector;
        this.active = 0;
        this.values = [];
        this.observables = [];
    ***REMOVED***
    _next(observable) ***REMOVED***
        this.values.push(NONE);
        this.observables.push(observable);
    ***REMOVED***
    _complete() ***REMOVED***
        const observables = this.observables;
        const len = observables.length;
        if (len === 0) ***REMOVED***
            this.destination.complete();
        ***REMOVED***
        else ***REMOVED***
            this.active = len;
            this.toRespond = len;
            for (let i = 0; i < len; i++) ***REMOVED***
                const observable = observables[i];
                this.add(subscribeToResult(this, observable, observable, i));
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    notifyComplete(unused) ***REMOVED***
        if ((this.active -= 1) === 0) ***REMOVED***
            this.destination.complete();
        ***REMOVED***
    ***REMOVED***
    notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) ***REMOVED***
        const values = this.values;
        const oldVal = values[outerIndex];
        const toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) ***REMOVED***
            if (this.resultSelector) ***REMOVED***
                this._tryResultSelector(values);
            ***REMOVED***
            else ***REMOVED***
                this.destination.next(values.slice());
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    _tryResultSelector(values) ***REMOVED***
        let result;
        try ***REMOVED***
            result = this.resultSelector.apply(this, values);
        ***REMOVED***
        catch (err) ***REMOVED***
            this.destination.error(err);
            return;
        ***REMOVED***
        this.destination.next(result);
    ***REMOVED***
***REMOVED***
//# sourceMappingURL=combineLatest.js.map