import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** AsyncSubject ***REMOVED*** from '../AsyncSubject';
import ***REMOVED*** map ***REMOVED*** from '../operators/map';
import ***REMOVED*** canReportError ***REMOVED*** from '../util/canReportError';
import ***REMOVED*** isArray ***REMOVED*** from '../util/isArray';
import ***REMOVED*** isScheduler ***REMOVED*** from '../util/isScheduler';
export function bindCallback(callbackFunc, resultSelector, scheduler) ***REMOVED***
    if (resultSelector) ***REMOVED***
        if (isScheduler(resultSelector)) ***REMOVED***
            scheduler = resultSelector;
        ***REMOVED***
        else ***REMOVED***
            return (...args) => bindCallback(callbackFunc, scheduler)(...args).pipe(map((args) => isArray(args) ? resultSelector(...args) : resultSelector(args)));
        ***REMOVED***
    ***REMOVED***
    return function (...args) ***REMOVED***
        const context = this;
        let subject;
        const params = ***REMOVED***
            context,
            subject,
            callbackFunc,
            scheduler,
        ***REMOVED***;
        return new Observable(subscriber => ***REMOVED***
            if (!scheduler) ***REMOVED***
                if (!subject) ***REMOVED***
                    subject = new AsyncSubject();
                    const handler = (...innerArgs) => ***REMOVED***
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    ***REMOVED***;
                    try ***REMOVED***
                        callbackFunc.apply(context, [...args, handler]);
                    ***REMOVED***
                    catch (err) ***REMOVED***
                        if (canReportError(subject)) ***REMOVED***
                            subject.error(err);
                        ***REMOVED***
                        else ***REMOVED***
                            console.warn(err);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
                return subject.subscribe(subscriber);
            ***REMOVED***
            else ***REMOVED***
                const state = ***REMOVED***
                    args, subscriber, params,
                ***REMOVED***;
                return scheduler.schedule(dispatch, 0, state);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***;
***REMOVED***
function dispatch(state) ***REMOVED***
    const self = this;
    const ***REMOVED*** args, subscriber, params ***REMOVED*** = state;
    const ***REMOVED*** callbackFunc, context, scheduler ***REMOVED*** = params;
    let ***REMOVED*** subject ***REMOVED*** = params;
    if (!subject) ***REMOVED***
        subject = params.subject = new AsyncSubject();
        const handler = (...innerArgs) => ***REMOVED***
            const value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            this.add(scheduler.schedule(dispatchNext, 0, ***REMOVED*** value, subject ***REMOVED***));
        ***REMOVED***;
        try ***REMOVED***
            callbackFunc.apply(context, [...args, handler]);
        ***REMOVED***
        catch (err) ***REMOVED***
            subject.error(err);
        ***REMOVED***
    ***REMOVED***
    this.add(subject.subscribe(subscriber));
***REMOVED***
function dispatchNext(state) ***REMOVED***
    const ***REMOVED*** value, subject ***REMOVED*** = state;
    subject.next(value);
    subject.complete();
***REMOVED***
function dispatchError(state) ***REMOVED***
    const ***REMOVED*** err, subject ***REMOVED*** = state;
    subject.error(err);
***REMOVED***
//# sourceMappingURL=bindCallback.js.map