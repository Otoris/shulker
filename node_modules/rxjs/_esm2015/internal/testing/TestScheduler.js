import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** Notification ***REMOVED*** from '../Notification';
import ***REMOVED*** ColdObservable ***REMOVED*** from './ColdObservable';
import ***REMOVED*** HotObservable ***REMOVED*** from './HotObservable';
import ***REMOVED*** SubscriptionLog ***REMOVED*** from './SubscriptionLog';
import ***REMOVED*** VirtualTimeScheduler, VirtualAction ***REMOVED*** from '../scheduler/VirtualTimeScheduler';
import ***REMOVED*** AsyncScheduler ***REMOVED*** from '../scheduler/AsyncScheduler';
const defaultMaxFrame = 750;
export class TestScheduler extends VirtualTimeScheduler ***REMOVED***
    constructor(assertDeepEqual) ***REMOVED***
        super(VirtualAction, defaultMaxFrame);
        this.assertDeepEqual = assertDeepEqual;
        this.hotObservables = [];
        this.coldObservables = [];
        this.flushTests = [];
        this.runMode = false;
    ***REMOVED***
    createTime(marbles) ***REMOVED***
        const indexOf = marbles.indexOf('|');
        if (indexOf === -1) ***REMOVED***
            throw new Error('marble diagram for time should have a completion marker "|"');
        ***REMOVED***
        return indexOf * TestScheduler.frameTimeFactor;
    ***REMOVED***
    createColdObservable(marbles, values, error) ***REMOVED***
        if (marbles.indexOf('^') !== -1) ***REMOVED***
            throw new Error('cold observable cannot have subscription offset "^"');
        ***REMOVED***
        if (marbles.indexOf('!') !== -1) ***REMOVED***
            throw new Error('cold observable cannot have unsubscription marker "!"');
        ***REMOVED***
        const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);
        const cold = new ColdObservable(messages, this);
        this.coldObservables.push(cold);
        return cold;
    ***REMOVED***
    createHotObservable(marbles, values, error) ***REMOVED***
        if (marbles.indexOf('!') !== -1) ***REMOVED***
            throw new Error('hot observable cannot have unsubscription marker "!"');
        ***REMOVED***
        const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);
        const subject = new HotObservable(messages, this);
        this.hotObservables.push(subject);
        return subject;
    ***REMOVED***
    materializeInnerObservable(observable, outerFrame) ***REMOVED***
        const messages = [];
        observable.subscribe((value) => ***REMOVED***
            messages.push(***REMOVED*** frame: this.frame - outerFrame, notification: Notification.createNext(value) ***REMOVED***);
        ***REMOVED***, (err) => ***REMOVED***
            messages.push(***REMOVED*** frame: this.frame - outerFrame, notification: Notification.createError(err) ***REMOVED***);
        ***REMOVED***, () => ***REMOVED***
            messages.push(***REMOVED*** frame: this.frame - outerFrame, notification: Notification.createComplete() ***REMOVED***);
        ***REMOVED***);
        return messages;
    ***REMOVED***
    expectObservable(observable, subscriptionMarbles = null) ***REMOVED***
        const actual = [];
        const flushTest = ***REMOVED*** actual, ready: false ***REMOVED***;
        const subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);
        const subscriptionFrame = subscriptionParsed.subscribedFrame === Number.POSITIVE_INFINITY ?
            0 : subscriptionParsed.subscribedFrame;
        const unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;
        let subscription;
        this.schedule(() => ***REMOVED***
            subscription = observable.subscribe(x => ***REMOVED***
                let value = x;
                if (x instanceof Observable) ***REMOVED***
                    value = this.materializeInnerObservable(value, this.frame);
                ***REMOVED***
                actual.push(***REMOVED*** frame: this.frame, notification: Notification.createNext(value) ***REMOVED***);
            ***REMOVED***, (err) => ***REMOVED***
                actual.push(***REMOVED*** frame: this.frame, notification: Notification.createError(err) ***REMOVED***);
            ***REMOVED***, () => ***REMOVED***
                actual.push(***REMOVED*** frame: this.frame, notification: Notification.createComplete() ***REMOVED***);
            ***REMOVED***);
        ***REMOVED***, subscriptionFrame);
        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) ***REMOVED***
            this.schedule(() => subscription.unsubscribe(), unsubscriptionFrame);
        ***REMOVED***
        this.flushTests.push(flushTest);
        const ***REMOVED*** runMode ***REMOVED*** = this;
        return ***REMOVED***
            toBe(marbles, values, errorValue) ***REMOVED***
                flushTest.ready = true;
                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
    expectSubscriptions(actualSubscriptionLogs) ***REMOVED***
        const flushTest = ***REMOVED*** actual: actualSubscriptionLogs, ready: false ***REMOVED***;
        this.flushTests.push(flushTest);
        const ***REMOVED*** runMode ***REMOVED*** = this;
        return ***REMOVED***
            toBe(marbles) ***REMOVED***
                const marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;
                flushTest.ready = true;
                flushTest.expected = marblesArray.map(marbles => TestScheduler.parseMarblesAsSubscriptions(marbles, runMode));
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
    flush() ***REMOVED***
        const hotObservables = this.hotObservables;
        while (hotObservables.length > 0) ***REMOVED***
            hotObservables.shift().setup();
        ***REMOVED***
        super.flush();
        this.flushTests = this.flushTests.filter(test => ***REMOVED***
            if (test.ready) ***REMOVED***
                this.assertDeepEqual(test.actual, test.expected);
                return false;
            ***REMOVED***
            return true;
        ***REMOVED***);
    ***REMOVED***
    static parseMarblesAsSubscriptions(marbles, runMode = false) ***REMOVED***
        if (typeof marbles !== 'string') ***REMOVED***
            return new SubscriptionLog(Number.POSITIVE_INFINITY);
        ***REMOVED***
        const len = marbles.length;
        let groupStart = -1;
        let subscriptionFrame = Number.POSITIVE_INFINITY;
        let unsubscriptionFrame = Number.POSITIVE_INFINITY;
        let frame = 0;
        for (let i = 0; i < len; i++) ***REMOVED***
            let nextFrame = frame;
            const advanceFrameBy = (count) => ***REMOVED***
                nextFrame += count * this.frameTimeFactor;
            ***REMOVED***;
            const c = marbles[i];
            switch (c) ***REMOVED***
                case ' ':
                    if (!runMode) ***REMOVED***
                        advanceFrameBy(1);
                    ***REMOVED***
                    break;
                case '-':
                    advanceFrameBy(1);
                    break;
                case '(':
                    groupStart = frame;
                    advanceFrameBy(1);
                    break;
                case ')':
                    groupStart = -1;
                    advanceFrameBy(1);
                    break;
                case '^':
                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) ***REMOVED***
                        throw new Error('found a second subscription point \'^\' in a ' +
                            'subscription marble diagram. There can only be one.');
                    ***REMOVED***
                    subscriptionFrame = groupStart > -1 ? groupStart : frame;
                    advanceFrameBy(1);
                    break;
                case '!':
                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) ***REMOVED***
                        throw new Error('found a second subscription point \'^\' in a ' +
                            'subscription marble diagram. There can only be one.');
                    ***REMOVED***
                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
                    break;
                default:
                    if (runMode && c.match(/^[0-9]$/)) ***REMOVED***
                        if (i === 0 || marbles[i - 1] === ' ') ***REMOVED***
                            const buffer = marbles.slice(i);
                            const match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
                            if (match) ***REMOVED***
                                i += match[0].length - 1;
                                const duration = parseFloat(match[1]);
                                const unit = match[2];
                                let durationInMs;
                                switch (unit) ***REMOVED***
                                    case 'ms':
                                        durationInMs = duration;
                                        break;
                                    case 's':
                                        durationInMs = duration * 1000;
                                        break;
                                    case 'm':
                                        durationInMs = duration * 1000 * 60;
                                        break;
                                    default:
                                        break;
                                ***REMOVED***
                                advanceFrameBy(durationInMs / this.frameTimeFactor);
                                break;
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***
                    throw new Error('there can only be \'^\' and \'!\' markers in a ' +
                        'subscription marble diagram. Found instead \'' + c + '\'.');
            ***REMOVED***
            frame = nextFrame;
        ***REMOVED***
        if (unsubscriptionFrame < 0) ***REMOVED***
            return new SubscriptionLog(subscriptionFrame);
        ***REMOVED***
        else ***REMOVED***
            return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);
        ***REMOVED***
    ***REMOVED***
    static parseMarbles(marbles, values, errorValue, materializeInnerObservables = false, runMode = false) ***REMOVED***
        if (marbles.indexOf('!') !== -1) ***REMOVED***
            throw new Error('conventional marble diagrams cannot have the ' +
                'unsubscription marker "!"');
        ***REMOVED***
        const len = marbles.length;
        const testMessages = [];
        const subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');
        let frame = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);
        const getValue = typeof values !== 'object' ?
            (x) => x :
            (x) => ***REMOVED***
                if (materializeInnerObservables && values[x] instanceof ColdObservable) ***REMOVED***
                    return values[x].messages;
                ***REMOVED***
                return values[x];
            ***REMOVED***;
        let groupStart = -1;
        for (let i = 0; i < len; i++) ***REMOVED***
            let nextFrame = frame;
            const advanceFrameBy = (count) => ***REMOVED***
                nextFrame += count * this.frameTimeFactor;
            ***REMOVED***;
            let notification;
            const c = marbles[i];
            switch (c) ***REMOVED***
                case ' ':
                    if (!runMode) ***REMOVED***
                        advanceFrameBy(1);
                    ***REMOVED***
                    break;
                case '-':
                    advanceFrameBy(1);
                    break;
                case '(':
                    groupStart = frame;
                    advanceFrameBy(1);
                    break;
                case ')':
                    groupStart = -1;
                    advanceFrameBy(1);
                    break;
                case '|':
                    notification = Notification.createComplete();
                    advanceFrameBy(1);
                    break;
                case '^':
                    advanceFrameBy(1);
                    break;
                case '#':
                    notification = Notification.createError(errorValue || 'error');
                    advanceFrameBy(1);
                    break;
                default:
                    if (runMode && c.match(/^[0-9]$/)) ***REMOVED***
                        if (i === 0 || marbles[i - 1] === ' ') ***REMOVED***
                            const buffer = marbles.slice(i);
                            const match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
                            if (match) ***REMOVED***
                                i += match[0].length - 1;
                                const duration = parseFloat(match[1]);
                                const unit = match[2];
                                let durationInMs;
                                switch (unit) ***REMOVED***
                                    case 'ms':
                                        durationInMs = duration;
                                        break;
                                    case 's':
                                        durationInMs = duration * 1000;
                                        break;
                                    case 'm':
                                        durationInMs = duration * 1000 * 60;
                                        break;
                                    default:
                                        break;
                                ***REMOVED***
                                advanceFrameBy(durationInMs / this.frameTimeFactor);
                                break;
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***
                    notification = Notification.createNext(getValue(c));
                    advanceFrameBy(1);
                    break;
            ***REMOVED***
            if (notification) ***REMOVED***
                testMessages.push(***REMOVED*** frame: groupStart > -1 ? groupStart : frame, notification ***REMOVED***);
            ***REMOVED***
            frame = nextFrame;
        ***REMOVED***
        return testMessages;
    ***REMOVED***
    run(callback) ***REMOVED***
        const prevFrameTimeFactor = TestScheduler.frameTimeFactor;
        const prevMaxFrames = this.maxFrames;
        TestScheduler.frameTimeFactor = 1;
        this.maxFrames = Number.POSITIVE_INFINITY;
        this.runMode = true;
        AsyncScheduler.delegate = this;
        const helpers = ***REMOVED***
            cold: this.createColdObservable.bind(this),
            hot: this.createHotObservable.bind(this),
            flush: this.flush.bind(this),
            expectObservable: this.expectObservable.bind(this),
            expectSubscriptions: this.expectSubscriptions.bind(this),
        ***REMOVED***;
        try ***REMOVED***
            const ret = callback(helpers);
            this.flush();
            return ret;
        ***REMOVED***
        finally ***REMOVED***
            TestScheduler.frameTimeFactor = prevFrameTimeFactor;
            this.maxFrames = prevMaxFrames;
            this.runMode = false;
            AsyncScheduler.delegate = undefined;
        ***REMOVED***
    ***REMOVED***
***REMOVED***
//# sourceMappingURL=TestScheduler.js.map