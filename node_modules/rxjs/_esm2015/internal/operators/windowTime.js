import ***REMOVED*** Subject ***REMOVED*** from '../Subject';
import ***REMOVED*** async ***REMOVED*** from '../scheduler/async';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** isNumeric ***REMOVED*** from '../util/isNumeric';
import ***REMOVED*** isScheduler ***REMOVED*** from '../util/isScheduler';
export function windowTime(windowTimeSpan) ***REMOVED***
    let scheduler = async;
    let windowCreationInterval = null;
    let maxWindowSize = Number.POSITIVE_INFINITY;
    if (isScheduler(arguments[3])) ***REMOVED***
        scheduler = arguments[3];
    ***REMOVED***
    if (isScheduler(arguments[2])) ***REMOVED***
        scheduler = arguments[2];
    ***REMOVED***
    else if (isNumeric(arguments[2])) ***REMOVED***
        maxWindowSize = arguments[2];
    ***REMOVED***
    if (isScheduler(arguments[1])) ***REMOVED***
        scheduler = arguments[1];
    ***REMOVED***
    else if (isNumeric(arguments[1])) ***REMOVED***
        windowCreationInterval = arguments[1];
    ***REMOVED***
    return function windowTimeOperatorFunction(source) ***REMOVED***
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
    ***REMOVED***;
***REMOVED***
class WindowTimeOperator ***REMOVED***
    constructor(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) ***REMOVED***
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    ***REMOVED***
    call(subscriber, source) ***REMOVED***
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    ***REMOVED***
***REMOVED***
class CountedSubject extends Subject ***REMOVED***
    constructor() ***REMOVED***
        super(...arguments);
        this._numberOfNextedValues = 0;
    ***REMOVED***
    next(value) ***REMOVED***
        this._numberOfNextedValues++;
        super.next(value);
    ***REMOVED***
    get numberOfNextedValues() ***REMOVED***
        return this._numberOfNextedValues;
    ***REMOVED***
***REMOVED***
class WindowTimeSubscriber extends Subscriber ***REMOVED***
    constructor(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) ***REMOVED***
        super(destination);
        this.destination = destination;
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
        this.windows = [];
        const window = this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) ***REMOVED***
            const closeState = ***REMOVED*** subscriber: this, window, context: null ***REMOVED***;
            const creationState = ***REMOVED*** windowTimeSpan, windowCreationInterval, subscriber: this, scheduler ***REMOVED***;
            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        ***REMOVED***
        else ***REMOVED***
            const timeSpanOnlyState = ***REMOVED*** subscriber: this, window, windowTimeSpan ***REMOVED***;
            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        ***REMOVED***
    ***REMOVED***
    _next(value) ***REMOVED***
        const windows = this.windows;
        const len = windows.length;
        for (let i = 0; i < len; i++) ***REMOVED***
            const window = windows[i];
            if (!window.closed) ***REMOVED***
                window.next(value);
                if (window.numberOfNextedValues >= this.maxWindowSize) ***REMOVED***
                    this.closeWindow(window);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    _error(err) ***REMOVED***
        const windows = this.windows;
        while (windows.length > 0) ***REMOVED***
            windows.shift().error(err);
        ***REMOVED***
        this.destination.error(err);
    ***REMOVED***
    _complete() ***REMOVED***
        const windows = this.windows;
        while (windows.length > 0) ***REMOVED***
            const window = windows.shift();
            if (!window.closed) ***REMOVED***
                window.complete();
            ***REMOVED***
        ***REMOVED***
        this.destination.complete();
    ***REMOVED***
    openWindow() ***REMOVED***
        const window = new CountedSubject();
        this.windows.push(window);
        const destination = this.destination;
        destination.next(window);
        return window;
    ***REMOVED***
    closeWindow(window) ***REMOVED***
        window.complete();
        const windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    ***REMOVED***
***REMOVED***
function dispatchWindowTimeSpanOnly(state) ***REMOVED***
    const ***REMOVED*** subscriber, windowTimeSpan, window ***REMOVED*** = state;
    if (window) ***REMOVED***
        subscriber.closeWindow(window);
    ***REMOVED***
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
***REMOVED***
function dispatchWindowCreation(state) ***REMOVED***
    const ***REMOVED*** windowTimeSpan, subscriber, scheduler, windowCreationInterval ***REMOVED*** = state;
    const window = subscriber.openWindow();
    const action = this;
    let context = ***REMOVED*** action, subscription: null ***REMOVED***;
    const timeSpanState = ***REMOVED*** subscriber, window, context ***REMOVED***;
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
***REMOVED***
function dispatchWindowClose(state) ***REMOVED***
    const ***REMOVED*** subscriber, window, context ***REMOVED*** = state;
    if (context && context.action && context.subscription) ***REMOVED***
        context.action.remove(context.subscription);
    ***REMOVED***
    subscriber.closeWindow(window);
***REMOVED***
//# sourceMappingURL=windowTime.js.map