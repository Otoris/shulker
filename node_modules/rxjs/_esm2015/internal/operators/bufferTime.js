import ***REMOVED*** async ***REMOVED*** from '../scheduler/async';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** isScheduler ***REMOVED*** from '../util/isScheduler';
export function bufferTime(bufferTimeSpan) ***REMOVED***
    let length = arguments.length;
    let scheduler = async;
    if (isScheduler(arguments[arguments.length - 1])) ***REMOVED***
        scheduler = arguments[arguments.length - 1];
        length--;
    ***REMOVED***
    let bufferCreationInterval = null;
    if (length >= 2) ***REMOVED***
        bufferCreationInterval = arguments[1];
    ***REMOVED***
    let maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) ***REMOVED***
        maxBufferSize = arguments[2];
    ***REMOVED***
    return function bufferTimeOperatorFunction(source) ***REMOVED***
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    ***REMOVED***;
***REMOVED***
class BufferTimeOperator ***REMOVED***
    constructor(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) ***REMOVED***
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    ***REMOVED***
    call(subscriber, source) ***REMOVED***
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    ***REMOVED***
***REMOVED***
class Context ***REMOVED***
    constructor() ***REMOVED***
        this.buffer = [];
    ***REMOVED***
***REMOVED***
class BufferTimeSubscriber extends Subscriber ***REMOVED***
    constructor(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) ***REMOVED***
        super(destination);
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
        this.contexts = [];
        const context = this.openContext();
        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (this.timespanOnly) ***REMOVED***
            const timeSpanOnlyState = ***REMOVED*** subscriber: this, context, bufferTimeSpan ***REMOVED***;
            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        ***REMOVED***
        else ***REMOVED***
            const closeState = ***REMOVED*** subscriber: this, context ***REMOVED***;
            const creationState = ***REMOVED*** bufferTimeSpan, bufferCreationInterval, subscriber: this, scheduler ***REMOVED***;
            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        ***REMOVED***
    ***REMOVED***
    _next(value) ***REMOVED***
        const contexts = this.contexts;
        const len = contexts.length;
        let filledBufferContext;
        for (let i = 0; i < len; i++) ***REMOVED***
            const context = contexts[i];
            const buffer = context.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) ***REMOVED***
                filledBufferContext = context;
            ***REMOVED***
        ***REMOVED***
        if (filledBufferContext) ***REMOVED***
            this.onBufferFull(filledBufferContext);
        ***REMOVED***
    ***REMOVED***
    _error(err) ***REMOVED***
        this.contexts.length = 0;
        super._error(err);
    ***REMOVED***
    _complete() ***REMOVED***
        const ***REMOVED*** contexts, destination ***REMOVED*** = this;
        while (contexts.length > 0) ***REMOVED***
            const context = contexts.shift();
            destination.next(context.buffer);
        ***REMOVED***
        super._complete();
    ***REMOVED***
    _unsubscribe() ***REMOVED***
        this.contexts = null;
    ***REMOVED***
    onBufferFull(context) ***REMOVED***
        this.closeContext(context);
        const closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) ***REMOVED***
            context = this.openContext();
            const bufferTimeSpan = this.bufferTimeSpan;
            const timeSpanOnlyState = ***REMOVED*** subscriber: this, context, bufferTimeSpan ***REMOVED***;
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        ***REMOVED***
    ***REMOVED***
    openContext() ***REMOVED***
        const context = new Context();
        this.contexts.push(context);
        return context;
    ***REMOVED***
    closeContext(context) ***REMOVED***
        this.destination.next(context.buffer);
        const contexts = this.contexts;
        const spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) ***REMOVED***
            contexts.splice(contexts.indexOf(context), 1);
        ***REMOVED***
    ***REMOVED***
***REMOVED***
function dispatchBufferTimeSpanOnly(state) ***REMOVED***
    const subscriber = state.subscriber;
    const prevContext = state.context;
    if (prevContext) ***REMOVED***
        subscriber.closeContext(prevContext);
    ***REMOVED***
    if (!subscriber.closed) ***REMOVED***
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    ***REMOVED***
***REMOVED***
function dispatchBufferCreation(state) ***REMOVED***
    const ***REMOVED*** bufferCreationInterval, bufferTimeSpan, subscriber, scheduler ***REMOVED*** = state;
    const context = subscriber.openContext();
    const action = this;
    if (!subscriber.closed) ***REMOVED***
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, ***REMOVED*** subscriber, context ***REMOVED***));
        action.schedule(state, bufferCreationInterval);
    ***REMOVED***
***REMOVED***
function dispatchBufferClose(arg) ***REMOVED***
    const ***REMOVED*** subscriber, context ***REMOVED*** = arg;
    subscriber.closeContext(context);
***REMOVED***
//# sourceMappingURL=bufferTime.js.map