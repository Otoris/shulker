/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
import * as tslib_1 from "tslib";
import ***REMOVED*** Subject ***REMOVED*** from './Subject';
import ***REMOVED*** queue ***REMOVED*** from './scheduler/queue';
import ***REMOVED*** Subscription ***REMOVED*** from './Subscription';
import ***REMOVED*** ObserveOnSubscriber ***REMOVED*** from './operators/observeOn';
import ***REMOVED*** ObjectUnsubscribedError ***REMOVED*** from './util/ObjectUnsubscribedError';
import ***REMOVED*** SubjectSubscription ***REMOVED*** from './SubjectSubscription';
var ReplaySubject = /*@__PURE__*/ (function (_super) ***REMOVED***
    tslib_1.__extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) ***REMOVED***
        if (bufferSize === void 0) ***REMOVED***
            bufferSize = Number.POSITIVE_INFINITY;
        ***REMOVED***
        if (windowTime === void 0) ***REMOVED***
            windowTime = Number.POSITIVE_INFINITY;
        ***REMOVED***
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) ***REMOVED***
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        ***REMOVED***
        else ***REMOVED***
            _this.next = _this.nextTimeWindow;
        ***REMOVED***
        return _this;
    ***REMOVED***
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) ***REMOVED***
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) ***REMOVED***
            _events.shift();
        ***REMOVED***
        _super.prototype.next.call(this, value);
    ***REMOVED***;
    ReplaySubject.prototype.nextTimeWindow = function (value) ***REMOVED***
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    ***REMOVED***;
    ReplaySubject.prototype._subscribe = function (subscriber) ***REMOVED***
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) ***REMOVED***
            throw new ObjectUnsubscribedError();
        ***REMOVED***
        else if (this.isStopped || this.hasError) ***REMOVED***
            subscription = Subscription.EMPTY;
        ***REMOVED***
        else ***REMOVED***
            this.observers.push(subscriber);
            subscription = new SubjectSubscription(this, subscriber);
        ***REMOVED***
        if (scheduler) ***REMOVED***
            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
        ***REMOVED***
        if (_infiniteTimeWindow) ***REMOVED***
            for (var i = 0; i < len && !subscriber.closed; i++) ***REMOVED***
                subscriber.next(_events[i]);
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            for (var i = 0; i < len && !subscriber.closed; i++) ***REMOVED***
                subscriber.next(_events[i].value);
            ***REMOVED***
        ***REMOVED***
        if (this.hasError) ***REMOVED***
            subscriber.error(this.thrownError);
        ***REMOVED***
        else if (this.isStopped) ***REMOVED***
            subscriber.complete();
        ***REMOVED***
        return subscription;
    ***REMOVED***;
    ReplaySubject.prototype._getNow = function () ***REMOVED***
        return (this.scheduler || queue).now();
    ***REMOVED***;
    ReplaySubject.prototype._trimBufferThenGetEvents = function () ***REMOVED***
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) ***REMOVED***
            if ((now - _events[spliceCount].time) < _windowTime) ***REMOVED***
                break;
            ***REMOVED***
            spliceCount++;
        ***REMOVED***
        if (eventsCount > _bufferSize) ***REMOVED***
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        ***REMOVED***
        if (spliceCount > 0) ***REMOVED***
            _events.splice(0, spliceCount);
        ***REMOVED***
        return _events;
    ***REMOVED***;
    return ReplaySubject;
***REMOVED***(Subject));
export ***REMOVED*** ReplaySubject ***REMOVED***;
var ReplayEvent = /*@__PURE__*/ (function () ***REMOVED***
    function ReplayEvent(time, value) ***REMOVED***
        this.time = time;
        this.value = value;
    ***REMOVED***
    return ReplayEvent;
***REMOVED***());
//# sourceMappingURL=ReplaySubject.js.map
