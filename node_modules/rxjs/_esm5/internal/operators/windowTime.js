/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
import * as tslib_1 from "tslib";
import ***REMOVED*** Subject ***REMOVED*** from '../Subject';
import ***REMOVED*** async ***REMOVED*** from '../scheduler/async';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** isNumeric ***REMOVED*** from '../util/isNumeric';
import ***REMOVED*** isScheduler ***REMOVED*** from '../util/isScheduler';
export function windowTime(windowTimeSpan) ***REMOVED***
    var scheduler = async;
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if (isScheduler(arguments[3])) ***REMOVED***
        scheduler = arguments[3];
    ***REMOVED***
    if (isScheduler(arguments[2])) ***REMOVED***
        scheduler = arguments[2];
    ***REMOVED***
    else if (isNumeric(arguments[2])) ***REMOVED***
        maxWindowSize = arguments[2];
    ***REMOVED***
    if (isScheduler(arguments[1])) ***REMOVED***
        scheduler = arguments[1];
    ***REMOVED***
    else if (isNumeric(arguments[1])) ***REMOVED***
        windowCreationInterval = arguments[1];
    ***REMOVED***
    return function windowTimeOperatorFunction(source) ***REMOVED***
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
    ***REMOVED***;
***REMOVED***
var WindowTimeOperator = /*@__PURE__*/ (function () ***REMOVED***
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) ***REMOVED***
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    ***REMOVED***
    WindowTimeOperator.prototype.call = function (subscriber, source) ***REMOVED***
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    ***REMOVED***;
    return WindowTimeOperator;
***REMOVED***());
var CountedSubject = /*@__PURE__*/ (function (_super) ***REMOVED***
    tslib_1.__extends(CountedSubject, _super);
    function CountedSubject() ***REMOVED***
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
    ***REMOVED***
    CountedSubject.prototype.next = function (value) ***REMOVED***
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    ***REMOVED***;
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", ***REMOVED***
        get: function () ***REMOVED***
            return this._numberOfNextedValues;
        ***REMOVED***,
        enumerable: true,
        configurable: true
    ***REMOVED***);
    return CountedSubject;
***REMOVED***(Subject));
var WindowTimeSubscriber = /*@__PURE__*/ (function (_super) ***REMOVED***
    tslib_1.__extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) ***REMOVED***
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) ***REMOVED***
            var closeState = ***REMOVED*** subscriber: _this, window: window, context: null ***REMOVED***;
            var creationState = ***REMOVED*** windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler ***REMOVED***;
            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        ***REMOVED***
        else ***REMOVED***
            var timeSpanOnlyState = ***REMOVED*** subscriber: _this, window: window, windowTimeSpan: windowTimeSpan ***REMOVED***;
            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        ***REMOVED***
        return _this;
    ***REMOVED***
    WindowTimeSubscriber.prototype._next = function (value) ***REMOVED***
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) ***REMOVED***
            var window_1 = windows[i];
            if (!window_1.closed) ***REMOVED***
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) ***REMOVED***
                    this.closeWindow(window_1);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
    WindowTimeSubscriber.prototype._error = function (err) ***REMOVED***
        var windows = this.windows;
        while (windows.length > 0) ***REMOVED***
            windows.shift().error(err);
        ***REMOVED***
        this.destination.error(err);
    ***REMOVED***;
    WindowTimeSubscriber.prototype._complete = function () ***REMOVED***
        var windows = this.windows;
        while (windows.length > 0) ***REMOVED***
            var window_2 = windows.shift();
            if (!window_2.closed) ***REMOVED***
                window_2.complete();
            ***REMOVED***
        ***REMOVED***
        this.destination.complete();
    ***REMOVED***;
    WindowTimeSubscriber.prototype.openWindow = function () ***REMOVED***
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    ***REMOVED***;
    WindowTimeSubscriber.prototype.closeWindow = function (window) ***REMOVED***
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    ***REMOVED***;
    return WindowTimeSubscriber;
***REMOVED***(Subscriber));
function dispatchWindowTimeSpanOnly(state) ***REMOVED***
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) ***REMOVED***
        subscriber.closeWindow(window);
    ***REMOVED***
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
***REMOVED***
function dispatchWindowCreation(state) ***REMOVED***
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = ***REMOVED*** action: action, subscription: null ***REMOVED***;
    var timeSpanState = ***REMOVED*** subscriber: subscriber, window: window, context: context ***REMOVED***;
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
***REMOVED***
function dispatchWindowClose(state) ***REMOVED***
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) ***REMOVED***
        context.action.remove(context.subscription);
    ***REMOVED***
    subscriber.closeWindow(window);
***REMOVED***
//# sourceMappingURL=windowTime.js.map
