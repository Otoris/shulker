import ***REMOVED*** isArray ***REMOVED*** from './util/isArray';
import ***REMOVED*** isObject ***REMOVED*** from './util/isObject';
import ***REMOVED*** isFunction ***REMOVED*** from './util/isFunction';
import ***REMOVED*** UnsubscriptionError ***REMOVED*** from './util/UnsubscriptionError';
import ***REMOVED*** SubscriptionLike, TeardownLogic ***REMOVED*** from './types';

/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
export class Subscription implements SubscriptionLike ***REMOVED***
  /** @nocollapse */
  public static EMPTY: Subscription = (function(empty: any) ***REMOVED***
    empty.closed = true;
    return empty;
  ***REMOVED***(new Subscription()));

  /**
   * A flag to indicate whether this Subscription has already been unsubscribed.
   * @type ***REMOVED***boolean***REMOVED***
   */
  public closed: boolean = false;

  /** @internal */
  protected _parentOrParents: Subscription | Subscription[] = null;
  /** @internal */
  private _subscriptions: SubscriptionLike[] = null;

  /**
   * @param ***REMOVED***function(): void***REMOVED*** [unsubscribe] A function describing how to
   * perform the disposal of resources when the `unsubscribe` method is called.
   */
  constructor(unsubscribe?: () => void) ***REMOVED***
    if (unsubscribe) ***REMOVED***
      (<any> this)._unsubscribe = unsubscribe;
    ***REMOVED***
  ***REMOVED***

  /**
   * Disposes the resources held by the subscription. May, for instance, cancel
   * an ongoing Observable execution or cancel any other type of work that
   * started when the Subscription was created.
   * @return ***REMOVED***void***REMOVED***
   */
  unsubscribe(): void ***REMOVED***
    let errors: any[];

    if (this.closed) ***REMOVED***
      return;
    ***REMOVED***

    let ***REMOVED*** _parentOrParents, _unsubscribe, _subscriptions ***REMOVED*** = (<any> this);

    this.closed = true;
    this._parentOrParents = null;
    // null out _subscriptions first so any child subscriptions that attempt
    // to remove themselves from this subscription will noop
    this._subscriptions = null;

    if (_parentOrParents instanceof Subscription) ***REMOVED***
      _parentOrParents.remove(this);
    ***REMOVED*** else if (_parentOrParents !== null) ***REMOVED***
      for (let index = 0; index < _parentOrParents.length; ++index) ***REMOVED***
        const parent = _parentOrParents[index];
        parent.remove(this);
      ***REMOVED***
    ***REMOVED***

    if (isFunction(_unsubscribe)) ***REMOVED***
      try ***REMOVED***
        _unsubscribe.call(this);
      ***REMOVED*** catch (e) ***REMOVED***
        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
      ***REMOVED***
    ***REMOVED***

    if (isArray(_subscriptions)) ***REMOVED***
      let index = -1;
      let len = _subscriptions.length;

      while (++index < len) ***REMOVED***
        const sub = _subscriptions[index];
        if (isObject(sub)) ***REMOVED***
          try ***REMOVED***
            sub.unsubscribe();
          ***REMOVED*** catch (e) ***REMOVED***
            errors = errors || [];
            if (e instanceof UnsubscriptionError) ***REMOVED***
              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
            ***REMOVED*** else ***REMOVED***
              errors.push(e);
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    if (errors) ***REMOVED***
      throw new UnsubscriptionError(errors);
    ***REMOVED***
  ***REMOVED***

  /**
   * Adds a tear down to be called during the unsubscribe() of this
   * Subscription. Can also be used to add a child subscription.
   *
   * If the tear down being added is a subscription that is already
   * unsubscribed, is the same reference `add` is being called on, or is
   * `Subscription.EMPTY`, it will not be added.
   *
   * If this subscription is already in an `closed` state, the passed
   * tear down logic will be executed immediately.
   *
   * When a parent subscription is unsubscribed, any child subscriptions that were added to it are also unsubscribed.
   *
   * @param ***REMOVED***TeardownLogic***REMOVED*** teardown The additional logic to execute on
   * teardown.
   * @return ***REMOVED***Subscription***REMOVED*** Returns the Subscription used or created to be
   * added to the inner subscriptions list. This Subscription can be used with
   * `remove()` to remove the passed teardown logic from the inner subscriptions
   * list.
   */
  add(teardown: TeardownLogic): Subscription ***REMOVED***
    let subscription = (<Subscription>teardown);

    if (!(<any>teardown)) ***REMOVED***
      return Subscription.EMPTY;
    ***REMOVED***

    switch (typeof teardown) ***REMOVED***
      case 'function':
        subscription = new Subscription(<(() => void)>teardown);
      case 'object':
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') ***REMOVED***
          // This also covers the case where `subscription` is `Subscription.EMPTY`, which is always in `closed` state.
          return subscription;
        ***REMOVED*** else if (this.closed) ***REMOVED***
          subscription.unsubscribe();
          return subscription;
        ***REMOVED*** else if (!(subscription instanceof Subscription)) ***REMOVED***
          const tmp = subscription;
          subscription = new Subscription();
          subscription._subscriptions = [tmp];
        ***REMOVED***
        break;
      default: ***REMOVED***
        throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
      ***REMOVED***
    ***REMOVED***

    // Add `this` as parent of `subscription` if that's not already the case.
    let ***REMOVED*** _parentOrParents ***REMOVED*** = subscription;
    if (_parentOrParents === null) ***REMOVED***
      // If we don't have a parent, then set `subscription._parents` to
      // the `this`, which is the common case that we optimize for.
      subscription._parentOrParents = this;
    ***REMOVED*** else if (_parentOrParents instanceof Subscription) ***REMOVED***
      if (_parentOrParents === this) ***REMOVED***
        // The `subscription` already has `this` as a parent.
        return subscription;
      ***REMOVED***
      // If there's already one parent, but not multiple, allocate an
      // Array to store the rest of the parent Subscriptions.
      subscription._parentOrParents = [_parentOrParents, this];
    ***REMOVED*** else if (_parentOrParents.indexOf(this) === -1) ***REMOVED***
      // Only add `this` to the _parentOrParents list if it's not already there.
      _parentOrParents.push(this);
    ***REMOVED*** else ***REMOVED***
      // The `subscription` already has `this` as a parent.
      return subscription;
    ***REMOVED***

    // Optimize for the common case when adding the first subscription.
    const subscriptions = this._subscriptions;
    if (subscriptions === null) ***REMOVED***
      this._subscriptions = [subscription];
    ***REMOVED*** else ***REMOVED***
      subscriptions.push(subscription);
    ***REMOVED***

    return subscription;
  ***REMOVED***

  /**
   * Removes a Subscription from the internal list of subscriptions that will
   * unsubscribe during the unsubscribe process of this Subscription.
   * @param ***REMOVED***Subscription***REMOVED*** subscription The subscription to remove.
   * @return ***REMOVED***void***REMOVED***
   */
  remove(subscription: Subscription): void ***REMOVED***
    const subscriptions = this._subscriptions;
    if (subscriptions) ***REMOVED***
      const subscriptionIndex = subscriptions.indexOf(subscription);
      if (subscriptionIndex !== -1) ***REMOVED***
        subscriptions.splice(subscriptionIndex, 1);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function flattenUnsubscriptionErrors(errors: any[]) ***REMOVED***
 return errors.reduce((errs, err) => errs.concat((err instanceof UnsubscriptionError) ? err.errors : err), []);
***REMOVED***
