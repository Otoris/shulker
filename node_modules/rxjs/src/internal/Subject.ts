import ***REMOVED*** Operator ***REMOVED*** from './Operator';
import ***REMOVED*** Observable ***REMOVED*** from './Observable';
import ***REMOVED*** Subscriber ***REMOVED*** from './Subscriber';
import ***REMOVED*** Subscription ***REMOVED*** from './Subscription';
import ***REMOVED*** Observer, SubscriptionLike, TeardownLogic ***REMOVED*** from './types';
import ***REMOVED*** ObjectUnsubscribedError ***REMOVED*** from './util/ObjectUnsubscribedError';
import ***REMOVED*** SubjectSubscription ***REMOVED*** from './SubjectSubscription';
import ***REMOVED*** rxSubscriber as rxSubscriberSymbol ***REMOVED*** from '../internal/symbol/rxSubscriber';

/**
 * @class SubjectSubscriber<T>
 */
export class SubjectSubscriber<T> extends Subscriber<T> ***REMOVED***
  constructor(protected destination: Subject<T>) ***REMOVED***
    super(destination);
  ***REMOVED***
***REMOVED***

/**
 * A Subject is a special type of Observable that allows values to be
 * multicasted to many Observers. Subjects are like EventEmitters.
 *
 * Every Subject is an Observable and an Observer. You can subscribe to a
 * Subject, and you can call next to feed values as well as error and complete.
 *
 * @class Subject<T>
 */
export class Subject<T> extends Observable<T> implements SubscriptionLike ***REMOVED***

  [rxSubscriberSymbol]() ***REMOVED***
    return new SubjectSubscriber(this);
  ***REMOVED***

  observers: Observer<T>[] = [];

  closed = false;

  isStopped = false;

  hasError = false;

  thrownError: any = null;

  constructor() ***REMOVED***
    super();
  ***REMOVED***

  /**@nocollapse
   * @deprecated use new Subject() instead
  */
  static create: Function = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => ***REMOVED***
    return new AnonymousSubject<T>(destination, source);
  ***REMOVED***

  lift<R>(operator: Operator<T, R>): Observable<R> ***REMOVED***
    const subject = new AnonymousSubject(this, this);
    subject.operator = <any>operator;
    return <any>subject;
  ***REMOVED***

  next(value?: T) ***REMOVED***
    if (this.closed) ***REMOVED***
      throw new ObjectUnsubscribedError();
    ***REMOVED***
    if (!this.isStopped) ***REMOVED***
      const ***REMOVED*** observers ***REMOVED*** = this;
      const len = observers.length;
      const copy = observers.slice();
      for (let i = 0; i < len; i++) ***REMOVED***
        copy[i].next(value);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  error(err: any) ***REMOVED***
    if (this.closed) ***REMOVED***
      throw new ObjectUnsubscribedError();
    ***REMOVED***
    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    const ***REMOVED*** observers ***REMOVED*** = this;
    const len = observers.length;
    const copy = observers.slice();
    for (let i = 0; i < len; i++) ***REMOVED***
      copy[i].error(err);
    ***REMOVED***
    this.observers.length = 0;
  ***REMOVED***

  complete() ***REMOVED***
    if (this.closed) ***REMOVED***
      throw new ObjectUnsubscribedError();
    ***REMOVED***
    this.isStopped = true;
    const ***REMOVED*** observers ***REMOVED*** = this;
    const len = observers.length;
    const copy = observers.slice();
    for (let i = 0; i < len; i++) ***REMOVED***
      copy[i].complete();
    ***REMOVED***
    this.observers.length = 0;
  ***REMOVED***

  unsubscribe() ***REMOVED***
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
  ***REMOVED***

  /** @deprecated This is an internal implementation detail, do not use. */
  _trySubscribe(subscriber: Subscriber<T>): TeardownLogic ***REMOVED***
    if (this.closed) ***REMOVED***
      throw new ObjectUnsubscribedError();
    ***REMOVED*** else ***REMOVED***
      return super._trySubscribe(subscriber);
    ***REMOVED***
  ***REMOVED***

  /** @deprecated This is an internal implementation detail, do not use. */
  _subscribe(subscriber: Subscriber<T>): Subscription ***REMOVED***
    if (this.closed) ***REMOVED***
      throw new ObjectUnsubscribedError();
    ***REMOVED*** else if (this.hasError) ***REMOVED***
      subscriber.error(this.thrownError);
      return Subscription.EMPTY;
    ***REMOVED*** else if (this.isStopped) ***REMOVED***
      subscriber.complete();
      return Subscription.EMPTY;
    ***REMOVED*** else ***REMOVED***
      this.observers.push(subscriber);
      return new SubjectSubscription(this, subscriber);
    ***REMOVED***
  ***REMOVED***

  /**
   * Creates a new Observable with this Subject as the source. You can do this
   * to create customize Observer-side logic of the Subject and conceal it from
   * code that uses the Observable.
   * @return ***REMOVED***Observable***REMOVED*** Observable that the Subject casts to
   */
  asObservable(): Observable<T> ***REMOVED***
    const observable = new Observable<T>();
    (<any>observable).source = this;
    return observable;
  ***REMOVED***
***REMOVED***

/**
 * @class AnonymousSubject<T>
 */
export class AnonymousSubject<T> extends Subject<T> ***REMOVED***
  constructor(protected destination?: Observer<T>, source?: Observable<T>) ***REMOVED***
    super();
    this.source = source;
  ***REMOVED***

  next(value: T) ***REMOVED***
    const ***REMOVED*** destination ***REMOVED*** = this;
    if (destination && destination.next) ***REMOVED***
      destination.next(value);
    ***REMOVED***
  ***REMOVED***

  error(err: any) ***REMOVED***
    const ***REMOVED*** destination ***REMOVED*** = this;
    if (destination && destination.error) ***REMOVED***
      this.destination.error(err);
    ***REMOVED***
  ***REMOVED***

  complete() ***REMOVED***
    const ***REMOVED*** destination ***REMOVED*** = this;
    if (destination && destination.complete) ***REMOVED***
      this.destination.complete();
    ***REMOVED***
  ***REMOVED***

  /** @deprecated This is an internal implementation detail, do not use. */
  _subscribe(subscriber: Subscriber<T>): Subscription ***REMOVED***
    const ***REMOVED*** source ***REMOVED*** = this;
    if (source) ***REMOVED***
      return this.source.subscribe(subscriber);
    ***REMOVED*** else ***REMOVED***
      return Subscription.EMPTY;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
