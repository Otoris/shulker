import ***REMOVED*** Scheduler ***REMOVED*** from '../Scheduler';
import ***REMOVED*** Action ***REMOVED*** from './Action';
import ***REMOVED*** AsyncAction ***REMOVED*** from './AsyncAction';
import ***REMOVED*** SchedulerAction ***REMOVED*** from '../types';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';

export class AsyncScheduler extends Scheduler ***REMOVED***
  public static delegate?: Scheduler;
  public actions: Array<AsyncAction<any>> = [];
  /**
   * A flag to indicate whether the Scheduler is currently executing a batch of
   * queued actions.
   * @type ***REMOVED***boolean***REMOVED***
   * @deprecated internal use only
   */
  public active: boolean = false;
  /**
   * An internal ID used to track the latest asynchronous task such as those
   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
   * others.
   * @type ***REMOVED***any***REMOVED***
   * @deprecated internal use only
   */
  public scheduled: any = undefined;

  constructor(SchedulerAction: typeof Action,
              now: () => number = Scheduler.now) ***REMOVED***
    super(SchedulerAction, () => ***REMOVED***
      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) ***REMOVED***
        return AsyncScheduler.delegate.now();
      ***REMOVED*** else ***REMOVED***
        return now();
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription ***REMOVED***
    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) ***REMOVED***
      return AsyncScheduler.delegate.schedule(work, delay, state);
    ***REMOVED*** else ***REMOVED***
      return super.schedule(work, delay, state);
    ***REMOVED***
  ***REMOVED***

  public flush(action: AsyncAction<any>): void ***REMOVED***

    const ***REMOVED***actions***REMOVED*** = this;

    if (this.active) ***REMOVED***
      actions.push(action);
      return;
    ***REMOVED***

    let error: any;
    this.active = true;

    do ***REMOVED***
      if (error = action.execute(action.state, action.delay)) ***REMOVED***
        break;
      ***REMOVED***
    ***REMOVED*** while (action = actions.shift()); // exhaust the scheduler queue

    this.active = false;

    if (error) ***REMOVED***
      while (action = actions.shift()) ***REMOVED***
        action.unsubscribe();
      ***REMOVED***
      throw error;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
