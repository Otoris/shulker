import ***REMOVED*** Action ***REMOVED*** from './Action';
import ***REMOVED*** SchedulerAction ***REMOVED*** from '../types';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';
import ***REMOVED*** AsyncScheduler ***REMOVED*** from './AsyncScheduler';

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
export class AsyncAction<T> extends Action<T> ***REMOVED***

  public id: any;
  public state: T;
  public delay: number;
  protected pending: boolean = false;

  constructor(protected scheduler: AsyncScheduler,
              protected work: (this: SchedulerAction<T>, state?: T) => void) ***REMOVED***
    super(scheduler, work);
  ***REMOVED***

  public schedule(state?: T, delay: number = 0): Subscription ***REMOVED***

    if (this.closed) ***REMOVED***
      return this;
    ***REMOVED***

    // Always replace the current state with the new state.
    this.state = state;

    const id = this.id;
    const scheduler = this.scheduler;

    //
    // Important implementation note:
    //
    // Actions only execute once by default, unless rescheduled from within the
    // scheduled callback. This allows us to implement single and repeat
    // actions via the same code path, without adding API surface area, as well
    // as mimic traditional recursion but across asynchronous boundaries.
    //
    // However, JS runtimes and timers distinguish between intervals achieved by
    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
    // serial `setTimeout` calls can be individually delayed, which delays
    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
    // guarantee the interval callback will be invoked more precisely to the
    // interval period, regardless of load.
    //
    // Therefore, we use `setInterval` to schedule single and repeat actions.
    // If the action reschedules itself with the same delay, the interval is not
    // canceled. If the action doesn't reschedule, or reschedules with a
    // different delay, the interval will be canceled after scheduled callback
    // execution.
    //
    if (id != null) ***REMOVED***
      this.id = this.recycleAsyncId(scheduler, id, delay);
    ***REMOVED***

    // Set the pending flag indicating that this action has been scheduled, or
    // has recursively rescheduled itself.
    this.pending = true;

    this.delay = delay;
    // If this action has already an async Id, don't request a new one.
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);

    return this;
  ***REMOVED***

  protected requestAsyncId(scheduler: AsyncScheduler, id?: any, delay: number = 0): any ***REMOVED***
    return setInterval(scheduler.flush.bind(scheduler, this), delay);
  ***REMOVED***

  protected recycleAsyncId(scheduler: AsyncScheduler, id: any, delay: number = 0): any ***REMOVED***
    // If this action is rescheduled with the same delay time, don't clear the interval id.
    if (delay !== null && this.delay === delay && this.pending === false) ***REMOVED***
      return id;
    ***REMOVED***
    // Otherwise, if the action's delay time is different from the current delay,
    // or the action has been rescheduled before it's executed, clear the interval id
    clearInterval(id);
    return undefined;
  ***REMOVED***

  /**
   * Immediately executes this action and the `work` it contains.
   * @return ***REMOVED***any***REMOVED***
   */
  public execute(state: T, delay: number): any ***REMOVED***

    if (this.closed) ***REMOVED***
      return new Error('executing a cancelled action');
    ***REMOVED***

    this.pending = false;
    const error = this._execute(state, delay);
    if (error) ***REMOVED***
      return error;
    ***REMOVED*** else if (this.pending === false && this.id != null) ***REMOVED***
      // Dequeue if the action didn't reschedule itself. Don't call
      // unsubscribe(), because the action could reschedule later.
      // For example:
      // ```
      // scheduler.schedule(function doWork(counter) ***REMOVED***
      //   /* ... I'm a busy worker bee ... */
      //   var originalAction = this;
      //   /* wait 100ms before rescheduling the action */
      //   setTimeout(function () ***REMOVED***
      //     originalAction.schedule(counter + 1);
      //   ***REMOVED***, 100);
      // ***REMOVED***, 1000);
      // ```
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    ***REMOVED***
  ***REMOVED***

  protected _execute(state: T, delay: number): any ***REMOVED***
    let errored: boolean = false;
    let errorValue: any = undefined;
    try ***REMOVED***
      this.work(state);
    ***REMOVED*** catch (e) ***REMOVED***
      errored = true;
      errorValue = !!e && e || new Error(e);
    ***REMOVED***
    if (errored) ***REMOVED***
      this.unsubscribe();
      return errorValue;
    ***REMOVED***
  ***REMOVED***

  /** @deprecated This is an internal implementation detail, do not use. */
  _unsubscribe() ***REMOVED***

    const id = this.id;
    const scheduler = this.scheduler;
    const actions = scheduler.actions;
    const index = actions.indexOf(this);

    this.work  = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;

    if (index !== -1) ***REMOVED***
      actions.splice(index, 1);
    ***REMOVED***

    if (id != null) ***REMOVED***
      this.id = this.recycleAsyncId(scheduler, id, null);
    ***REMOVED***

    this.delay = null;
  ***REMOVED***
***REMOVED***
