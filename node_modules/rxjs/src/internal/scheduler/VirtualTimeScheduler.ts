import ***REMOVED*** AsyncAction ***REMOVED*** from './AsyncAction';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';
import ***REMOVED*** AsyncScheduler ***REMOVED*** from './AsyncScheduler';
import ***REMOVED*** SchedulerAction ***REMOVED*** from '../types';

export class VirtualTimeScheduler extends AsyncScheduler ***REMOVED***

  protected static frameTimeFactor: number = 10;

  public frame: number = 0;
  public index: number = -1;

  constructor(SchedulerAction: typeof AsyncAction = VirtualAction as any,
              public maxFrames: number = Number.POSITIVE_INFINITY) ***REMOVED***
    super(SchedulerAction, () => this.frame);
  ***REMOVED***

  /**
   * Prompt the Scheduler to execute all of its queued actions, therefore
   * clearing its queue.
   * @return ***REMOVED***void***REMOVED***
   */
  public flush(): void ***REMOVED***

    const ***REMOVED***actions, maxFrames***REMOVED*** = this;
    let error: any, action: AsyncAction<any>;

    while ((action = actions[0]) && action.delay <= maxFrames) ***REMOVED***
      actions.shift();
      this.frame = action.delay;

      if (error = action.execute(action.state, action.delay)) ***REMOVED***
        break;
      ***REMOVED***
    ***REMOVED***

    if (error) ***REMOVED***
      while (action = actions.shift()) ***REMOVED***
        action.unsubscribe();
      ***REMOVED***
      throw error;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @nodoc
 */
export class VirtualAction<T> extends AsyncAction<T> ***REMOVED***

  protected active: boolean = true;

  constructor(protected scheduler: VirtualTimeScheduler,
              protected work: (this: SchedulerAction<T>, state?: T) => void,
              protected index: number = scheduler.index += 1) ***REMOVED***
    super(scheduler, work);
    this.index = scheduler.index = index;
  ***REMOVED***

  public schedule(state?: T, delay: number = 0): Subscription ***REMOVED***
    if (!this.id) ***REMOVED***
      return super.schedule(state, delay);
    ***REMOVED***
    this.active = false;
    // If an action is rescheduled, we save allocations by mutating its state,
    // pushing it to the end of the scheduler queue, and recycling the action.
    // But since the VirtualTimeScheduler is used for testing, VirtualActions
    // must be immutable so they can be inspected later.
    const action = new VirtualAction(this.scheduler, this.work);
    this.add(action);
    return action.schedule(state, delay);
  ***REMOVED***

  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): any ***REMOVED***
    this.delay = scheduler.frame + delay;
    const ***REMOVED***actions***REMOVED*** = scheduler;
    actions.push(this);
    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);
    return true;
  ***REMOVED***

  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): any ***REMOVED***
    return undefined;
  ***REMOVED***

  protected _execute(state: T, delay: number): any ***REMOVED***
    if (this.active === true) ***REMOVED***
      return super._execute(state, delay);
    ***REMOVED***
  ***REMOVED***

  public static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) ***REMOVED***
    if (a.delay === b.delay) ***REMOVED***
      if (a.index === b.index) ***REMOVED***
        return 0;
      ***REMOVED*** else if (a.index > b.index) ***REMOVED***
        return 1;
      ***REMOVED*** else ***REMOVED***
        return -1;
      ***REMOVED***
    ***REMOVED*** else if (a.delay > b.delay) ***REMOVED***
      return 1;
    ***REMOVED*** else ***REMOVED***
      return -1;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
