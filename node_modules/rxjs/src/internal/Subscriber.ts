import ***REMOVED*** isFunction ***REMOVED*** from './util/isFunction';
import ***REMOVED*** empty as emptyObserver ***REMOVED*** from './Observer';
import ***REMOVED*** Observer, PartialObserver, TeardownLogic ***REMOVED*** from './types';
import ***REMOVED*** Subscription ***REMOVED*** from './Subscription';
import ***REMOVED*** rxSubscriber as rxSubscriberSymbol ***REMOVED*** from '../internal/symbol/rxSubscriber';
import ***REMOVED*** config ***REMOVED*** from './config';
import ***REMOVED*** hostReportError ***REMOVED*** from './util/hostReportError';

/**
 * Implements the ***REMOVED***@link Observer***REMOVED*** interface and extends the
 * ***REMOVED***@link Subscription***REMOVED*** class. While the ***REMOVED***@link Observer***REMOVED*** is the public API for
 * consuming the values of an ***REMOVED***@link Observable***REMOVED***, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
export class Subscriber<T> extends Subscription implements Observer<T> ***REMOVED***

  [rxSubscriberSymbol]() ***REMOVED*** return this; ***REMOVED***

  /**
   * A static factory for a Subscriber, given a (potentially partial) definition
   * of an Observer.
   * @param ***REMOVED***function(x: ?T): void***REMOVED*** [next] The `next` callback of an Observer.
   * @param ***REMOVED***function(e: ?any): void***REMOVED*** [error] The `error` callback of an
   * Observer.
   * @param ***REMOVED***function(): void***REMOVED*** [complete] The `complete` callback of an
   * Observer.
   * @return ***REMOVED***Subscriber<T>***REMOVED*** A Subscriber wrapping the (partially defined)
   * Observer represented by the given arguments.
   * @nocollapse
   */
  static create<T>(next?: (x?: T) => void,
                   error?: (e?: any) => void,
                   complete?: () => void): Subscriber<T> ***REMOVED***
    const subscriber = new Subscriber(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  ***REMOVED***

  /** @internal */ syncErrorValue: any = null;
  /** @internal */ syncErrorThrown: boolean = false;
  /** @internal */ syncErrorThrowable: boolean = false;

  protected isStopped: boolean = false;
  protected destination: PartialObserver<any> | Subscriber<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)

  /**
   * @param ***REMOVED***Observer|function(value: T): void***REMOVED*** [destinationOrNext] A partially
   * defined Observer or a `next` callback function.
   * @param ***REMOVED***function(e: ?any): void***REMOVED*** [error] The `error` callback of an
   * Observer.
   * @param ***REMOVED***function(): void***REMOVED*** [complete] The `complete` callback of an
   * Observer.
   */
  constructor(destinationOrNext?: PartialObserver<any> | ((value: T) => void),
              error?: (e?: any) => void,
              complete?: () => void) ***REMOVED***
    super();

    switch (arguments.length) ***REMOVED***
      case 0:
        this.destination = emptyObserver;
        break;
      case 1:
        if (!destinationOrNext) ***REMOVED***
          this.destination = emptyObserver;
          break;
        ***REMOVED***
        if (typeof destinationOrNext === 'object') ***REMOVED***
          if (destinationOrNext instanceof Subscriber) ***REMOVED***
            this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            this.destination = destinationOrNext;
            destinationOrNext.add(this);
          ***REMOVED*** else ***REMOVED***
            this.syncErrorThrowable = true;
            this.destination = new SafeSubscriber<T>(this, <PartialObserver<any>> destinationOrNext);
          ***REMOVED***
          break;
        ***REMOVED***
      default:
        this.syncErrorThrowable = true;
        this.destination = new SafeSubscriber<T>(this, <((value: T) => void)> destinationOrNext, error, complete);
        break;
    ***REMOVED***
  ***REMOVED***

  /**
   * The ***REMOVED***@link Observer***REMOVED*** callback to receive notifications of type `next` from
   * the Observable, with a value. The Observable may call this method 0 or more
   * times.
   * @param ***REMOVED***T***REMOVED*** [value] The `next` value.
   * @return ***REMOVED***void***REMOVED***
   */
  next(value?: T): void ***REMOVED***
    if (!this.isStopped) ***REMOVED***
      this._next(value);
    ***REMOVED***
  ***REMOVED***

  /**
   * The ***REMOVED***@link Observer***REMOVED*** callback to receive notifications of type `error` from
   * the Observable, with an attached `Error`. Notifies the Observer that
   * the Observable has experienced an error condition.
   * @param ***REMOVED***any***REMOVED*** [err] The `error` exception.
   * @return ***REMOVED***void***REMOVED***
   */
  error(err?: any): void ***REMOVED***
    if (!this.isStopped) ***REMOVED***
      this.isStopped = true;
      this._error(err);
    ***REMOVED***
  ***REMOVED***

  /**
   * The ***REMOVED***@link Observer***REMOVED*** callback to receive a valueless notification of type
   * `complete` from the Observable. Notifies the Observer that the Observable
   * has finished sending push-based notifications.
   * @return ***REMOVED***void***REMOVED***
   */
  complete(): void ***REMOVED***
    if (!this.isStopped) ***REMOVED***
      this.isStopped = true;
      this._complete();
    ***REMOVED***
  ***REMOVED***

  unsubscribe(): void ***REMOVED***
    if (this.closed) ***REMOVED***
      return;
    ***REMOVED***
    this.isStopped = true;
    super.unsubscribe();
  ***REMOVED***

  protected _next(value: T): void ***REMOVED***
    this.destination.next(value);
  ***REMOVED***

  protected _error(err: any): void ***REMOVED***
    this.destination.error(err);
    this.unsubscribe();
  ***REMOVED***

  protected _complete(): void ***REMOVED***
    this.destination.complete();
    this.unsubscribe();
  ***REMOVED***

  /** @deprecated This is an internal implementation detail, do not use. */
  _unsubscribeAndRecycle(): Subscriber<T> ***REMOVED***
    const ***REMOVED***  _parentOrParents ***REMOVED*** = this;
    this._parentOrParents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parentOrParents = _parentOrParents;
    return this;
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
export class SafeSubscriber<T> extends Subscriber<T> ***REMOVED***

  private _context: any;

  constructor(private _parentSubscriber: Subscriber<T>,
              observerOrNext?: PartialObserver<T> | ((value: T) => void),
              error?: (e?: any) => void,
              complete?: () => void) ***REMOVED***
    super();

    let next: ((value: T) => void);
    let context: any = this;

    if (isFunction(observerOrNext)) ***REMOVED***
      next = (<((value: T) => void)> observerOrNext);
    ***REMOVED*** else if (observerOrNext) ***REMOVED***
      next = (<PartialObserver<T>> observerOrNext).next;
      error = (<PartialObserver<T>> observerOrNext).error;
      complete = (<PartialObserver<T>> observerOrNext).complete;
      if (observerOrNext !== emptyObserver) ***REMOVED***
        context = Object.create(observerOrNext);
        if (isFunction(context.unsubscribe)) ***REMOVED***
          this.add(<() => void> context.unsubscribe.bind(context));
        ***REMOVED***
        context.unsubscribe = this.unsubscribe.bind(this);
      ***REMOVED***
    ***REMOVED***

    this._context = context;
    this._next = next;
    this._error = error;
    this._complete = complete;
  ***REMOVED***

  next(value?: T): void ***REMOVED***
    if (!this.isStopped && this._next) ***REMOVED***
      const ***REMOVED*** _parentSubscriber ***REMOVED*** = this;
      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) ***REMOVED***
        this.__tryOrUnsub(this._next, value);
      ***REMOVED*** else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) ***REMOVED***
        this.unsubscribe();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  error(err?: any): void ***REMOVED***
    if (!this.isStopped) ***REMOVED***
      const ***REMOVED*** _parentSubscriber ***REMOVED*** = this;
      const ***REMOVED*** useDeprecatedSynchronousErrorHandling ***REMOVED*** = config;
      if (this._error) ***REMOVED***
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) ***REMOVED***
          this.__tryOrUnsub(this._error, err);
          this.unsubscribe();
        ***REMOVED*** else ***REMOVED***
          this.__tryOrSetError(_parentSubscriber, this._error, err);
          this.unsubscribe();
        ***REMOVED***
      ***REMOVED*** else if (!_parentSubscriber.syncErrorThrowable) ***REMOVED***
        this.unsubscribe();
        if (useDeprecatedSynchronousErrorHandling) ***REMOVED***
          throw err;
        ***REMOVED***
        hostReportError(err);
      ***REMOVED*** else ***REMOVED***
        if (useDeprecatedSynchronousErrorHandling) ***REMOVED***
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        ***REMOVED*** else ***REMOVED***
          hostReportError(err);
        ***REMOVED***
        this.unsubscribe();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  complete(): void ***REMOVED***
    if (!this.isStopped) ***REMOVED***
      const ***REMOVED*** _parentSubscriber ***REMOVED*** = this;
      if (this._complete) ***REMOVED***
        const wrappedComplete = () => this._complete.call(this._context);

        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) ***REMOVED***
          this.__tryOrUnsub(wrappedComplete);
          this.unsubscribe();
        ***REMOVED*** else ***REMOVED***
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);
          this.unsubscribe();
        ***REMOVED***
      ***REMOVED*** else ***REMOVED***
        this.unsubscribe();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  private __tryOrUnsub(fn: Function, value?: any): void ***REMOVED***
    try ***REMOVED***
      fn.call(this._context, value);
    ***REMOVED*** catch (err) ***REMOVED***
      this.unsubscribe();
      if (config.useDeprecatedSynchronousErrorHandling) ***REMOVED***
        throw err;
      ***REMOVED*** else ***REMOVED***
        hostReportError(err);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  private __tryOrSetError(parent: Subscriber<T>, fn: Function, value?: any): boolean ***REMOVED***
    if (!config.useDeprecatedSynchronousErrorHandling) ***REMOVED***
      throw new Error('bad call');
    ***REMOVED***
    try ***REMOVED***
      fn.call(this._context, value);
    ***REMOVED*** catch (err) ***REMOVED***
      if (config.useDeprecatedSynchronousErrorHandling) ***REMOVED***
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      ***REMOVED*** else ***REMOVED***
        hostReportError(err);
        return true;
      ***REMOVED***
    ***REMOVED***
    return false;
  ***REMOVED***

  /** @internal This is an internal implementation detail, do not use. */
  _unsubscribe(): void ***REMOVED***
    const ***REMOVED*** _parentSubscriber ***REMOVED*** = this;
    this._context = null;
    this._parentSubscriber = null;
    _parentSubscriber.unsubscribe();
  ***REMOVED***
***REMOVED***
