import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** Notification ***REMOVED*** from '../Notification';
import ***REMOVED*** ColdObservable ***REMOVED*** from './ColdObservable';
import ***REMOVED*** HotObservable ***REMOVED*** from './HotObservable';
import ***REMOVED*** TestMessage ***REMOVED*** from './TestMessage';
import ***REMOVED*** SubscriptionLog ***REMOVED*** from './SubscriptionLog';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';
import ***REMOVED*** VirtualTimeScheduler, VirtualAction ***REMOVED*** from '../scheduler/VirtualTimeScheduler';
import ***REMOVED*** AsyncScheduler ***REMOVED*** from '../scheduler/AsyncScheduler';

const defaultMaxFrame: number = 750;

export interface RunHelpers ***REMOVED***
  cold: typeof TestScheduler.prototype.createColdObservable;
  hot: typeof TestScheduler.prototype.createHotObservable;
  flush: typeof TestScheduler.prototype.flush;
  expectObservable: typeof TestScheduler.prototype.expectObservable;
  expectSubscriptions: typeof TestScheduler.prototype.expectSubscriptions;
***REMOVED***

interface FlushableTest ***REMOVED***
  ready: boolean;
  actual?: any[];
  expected?: any[];
***REMOVED***

export type observableToBeFn = (marbles: string, values?: any, errorValue?: any) => void;
export type subscriptionLogsToBeFn = (marbles: string | string[]) => void;

export class TestScheduler extends VirtualTimeScheduler ***REMOVED***
  public readonly hotObservables: HotObservable<any>[] = [];
  public readonly coldObservables: ColdObservable<any>[] = [];
  private flushTests: FlushableTest[] = [];
  private runMode = false;

  constructor(public assertDeepEqual: (actual: any, expected: any) => boolean | void) ***REMOVED***
    super(VirtualAction, defaultMaxFrame);
  ***REMOVED***

  createTime(marbles: string): number ***REMOVED***
    const indexOf: number = marbles.indexOf('|');
    if (indexOf === -1) ***REMOVED***
      throw new Error('marble diagram for time should have a completion marker "|"');
    ***REMOVED***
    return indexOf * TestScheduler.frameTimeFactor;
  ***REMOVED***

  /**
   * @param marbles A diagram in the marble DSL. Letters map to keys in `values` if provided.
   * @param values Values to use for the letters in `marbles`. If ommitted, the letters themselves are used.
   * @param error The error to use for the `#` marble (if present).
   */
  createColdObservable<T = string>(marbles: string, values?: ***REMOVED*** [marble: string]: T ***REMOVED***, error?: any): ColdObservable<T> ***REMOVED***
    if (marbles.indexOf('^') !== -1) ***REMOVED***
      throw new Error('cold observable cannot have subscription offset "^"');
    ***REMOVED***
    if (marbles.indexOf('!') !== -1) ***REMOVED***
      throw new Error('cold observable cannot have unsubscription marker "!"');
    ***REMOVED***
    const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);
    const cold = new ColdObservable<T>(messages, this);
    this.coldObservables.push(cold);
    return cold;
  ***REMOVED***

  /**
   * @param marbles A diagram in the marble DSL. Letters map to keys in `values` if provided.
   * @param values Values to use for the letters in `marbles`. If ommitted, the letters themselves are used.
   * @param error The error to use for the `#` marble (if present).
   */
  createHotObservable<T = string>(marbles: string, values?: ***REMOVED*** [marble: string]: T ***REMOVED***, error?: any): HotObservable<T> ***REMOVED***
    if (marbles.indexOf('!') !== -1) ***REMOVED***
      throw new Error('hot observable cannot have unsubscription marker "!"');
    ***REMOVED***
    const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);
    const subject = new HotObservable<T>(messages, this);
    this.hotObservables.push(subject);
    return subject;
  ***REMOVED***

  private materializeInnerObservable(observable: Observable<any>,
                                     outerFrame: number): TestMessage[] ***REMOVED***
    const messages: TestMessage[] = [];
    observable.subscribe((value) => ***REMOVED***
      messages.push(***REMOVED*** frame: this.frame - outerFrame, notification: Notification.createNext(value) ***REMOVED***);
    ***REMOVED***, (err) => ***REMOVED***
      messages.push(***REMOVED*** frame: this.frame - outerFrame, notification: Notification.createError(err) ***REMOVED***);
    ***REMOVED***, () => ***REMOVED***
      messages.push(***REMOVED*** frame: this.frame - outerFrame, notification: Notification.createComplete() ***REMOVED***);
    ***REMOVED***);
    return messages;
  ***REMOVED***

  expectObservable(observable: Observable<any>,
                   subscriptionMarbles: string = null): (***REMOVED*** toBe: observableToBeFn ***REMOVED***) ***REMOVED***
    const actual: TestMessage[] = [];
    const flushTest: FlushableTest = ***REMOVED*** actual, ready: false ***REMOVED***;
    const subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);
    const subscriptionFrame = subscriptionParsed.subscribedFrame === Number.POSITIVE_INFINITY ?
      0 : subscriptionParsed.subscribedFrame;
    const unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;
    let subscription: Subscription;

    this.schedule(() => ***REMOVED***
      subscription = observable.subscribe(x => ***REMOVED***
        let value = x;
        // Support Observable-of-Observables
        if (x instanceof Observable) ***REMOVED***
          value = this.materializeInnerObservable(value, this.frame);
        ***REMOVED***
        actual.push(***REMOVED*** frame: this.frame, notification: Notification.createNext(value) ***REMOVED***);
      ***REMOVED***, (err) => ***REMOVED***
        actual.push(***REMOVED*** frame: this.frame, notification: Notification.createError(err) ***REMOVED***);
      ***REMOVED***, () => ***REMOVED***
        actual.push(***REMOVED*** frame: this.frame, notification: Notification.createComplete() ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***, subscriptionFrame);

    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) ***REMOVED***
      this.schedule(() => subscription.unsubscribe(), unsubscriptionFrame);
    ***REMOVED***

    this.flushTests.push(flushTest);
    const ***REMOVED*** runMode ***REMOVED*** = this;

    return ***REMOVED***
      toBe(marbles: string, values?: any, errorValue?: any) ***REMOVED***
        flushTest.ready = true;
        flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***

  expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]): (***REMOVED*** toBe: subscriptionLogsToBeFn ***REMOVED***) ***REMOVED***
    const flushTest: FlushableTest = ***REMOVED*** actual: actualSubscriptionLogs, ready: false ***REMOVED***;
    this.flushTests.push(flushTest);
    const ***REMOVED*** runMode ***REMOVED*** = this;
    return ***REMOVED***
      toBe(marbles: string | string[]) ***REMOVED***
        const marblesArray: string[] = (typeof marbles === 'string') ? [marbles] : marbles;
        flushTest.ready = true;
        flushTest.expected = marblesArray.map(marbles =>
          TestScheduler.parseMarblesAsSubscriptions(marbles, runMode)
        );
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***

  flush() ***REMOVED***
    const hotObservables = this.hotObservables;
    while (hotObservables.length > 0) ***REMOVED***
      hotObservables.shift().setup();
    ***REMOVED***

    super.flush();

    this.flushTests = this.flushTests.filter(test => ***REMOVED***
      if (test.ready) ***REMOVED***
        this.assertDeepEqual(test.actual, test.expected);
        return false;
      ***REMOVED***
      return true;
    ***REMOVED***);
  ***REMOVED***

  /** @nocollapse */
  static parseMarblesAsSubscriptions(marbles: string, runMode = false): SubscriptionLog ***REMOVED***
    if (typeof marbles !== 'string') ***REMOVED***
      return new SubscriptionLog(Number.POSITIVE_INFINITY);
    ***REMOVED***
    const len = marbles.length;
    let groupStart = -1;
    let subscriptionFrame = Number.POSITIVE_INFINITY;
    let unsubscriptionFrame = Number.POSITIVE_INFINITY;
    let frame = 0;

    for (let i = 0; i < len; i++) ***REMOVED***
      let nextFrame = frame;
      const advanceFrameBy = (count: number) => ***REMOVED***
        nextFrame += count * this.frameTimeFactor;
      ***REMOVED***;
      const c = marbles[i];
      switch (c) ***REMOVED***
        case ' ':
          // Whitespace no longer advances time
          if (!runMode) ***REMOVED***
            advanceFrameBy(1);
          ***REMOVED***
          break;
        case '-':
          advanceFrameBy(1);
          break;
        case '(':
          groupStart = frame;
          advanceFrameBy(1);
          break;
        case ')':
          groupStart = -1;
          advanceFrameBy(1);
          break;
        case '^':
          if (subscriptionFrame !== Number.POSITIVE_INFINITY) ***REMOVED***
            throw new Error('found a second subscription point \'^\' in a ' +
              'subscription marble diagram. There can only be one.');
          ***REMOVED***
          subscriptionFrame = groupStart > -1 ? groupStart : frame;
          advanceFrameBy(1);
          break;
        case '!':
          if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) ***REMOVED***
            throw new Error('found a second subscription point \'^\' in a ' +
              'subscription marble diagram. There can only be one.');
          ***REMOVED***
          unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
          break;
        default:
          // time progression syntax
          if (runMode && c.match(/^[0-9]$/)) ***REMOVED***
            // Time progression must be preceeded by at least one space
            // if it's not at the beginning of the diagram
            if (i === 0 || marbles[i - 1] === ' ') ***REMOVED***
              const buffer = marbles.slice(i);
              const match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
              if (match) ***REMOVED***
                i += match[0].length - 1;
                const duration = parseFloat(match[1]);
                const unit = match[2];
                let durationInMs: number;

                switch (unit) ***REMOVED***
                  case 'ms':
                    durationInMs = duration;
                    break;
                  case 's':
                    durationInMs = duration * 1000;
                    break;
                  case 'm':
                    durationInMs = duration * 1000 * 60;
                    break;
                  default:
                    break;
                ***REMOVED***

                advanceFrameBy(durationInMs / this.frameTimeFactor);
                break;
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***

          throw new Error('there can only be \'^\' and \'!\' markers in a ' +
            'subscription marble diagram. Found instead \'' + c + '\'.');
      ***REMOVED***

      frame = nextFrame;
    ***REMOVED***

    if (unsubscriptionFrame < 0) ***REMOVED***
      return new SubscriptionLog(subscriptionFrame);
    ***REMOVED*** else ***REMOVED***
      return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);
    ***REMOVED***
  ***REMOVED***

  /** @nocollapse */
  static parseMarbles(marbles: string,
                      values?: any,
                      errorValue?: any,
                      materializeInnerObservables: boolean = false,
                      runMode = false): TestMessage[] ***REMOVED***
    if (marbles.indexOf('!') !== -1) ***REMOVED***
      throw new Error('conventional marble diagrams cannot have the ' +
        'unsubscription marker "!"');
    ***REMOVED***
    const len = marbles.length;
    const testMessages: TestMessage[] = [];
    const subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');
    let frame = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);
    const getValue = typeof values !== 'object' ?
      (x: any) => x :
      (x: any) => ***REMOVED***
        // Support Observable-of-Observables
        if (materializeInnerObservables && values[x] instanceof ColdObservable) ***REMOVED***
          return values[x].messages;
        ***REMOVED***
        return values[x];
      ***REMOVED***;
    let groupStart = -1;

    for (let i = 0; i < len; i++) ***REMOVED***
      let nextFrame = frame;
      const advanceFrameBy = (count: number) => ***REMOVED***
        nextFrame += count * this.frameTimeFactor;
      ***REMOVED***;

      let notification: Notification<any>;
      const c = marbles[i];
      switch (c) ***REMOVED***
        case ' ':
          // Whitespace no longer advances time
          if (!runMode) ***REMOVED***
            advanceFrameBy(1);
          ***REMOVED***
          break;
        case '-':
          advanceFrameBy(1);
          break;
        case '(':
          groupStart = frame;
          advanceFrameBy(1);
          break;
        case ')':
          groupStart = -1;
          advanceFrameBy(1);
          break;
        case '|':
          notification = Notification.createComplete();
          advanceFrameBy(1);
          break;
        case '^':
          advanceFrameBy(1);
          break;
        case '#':
          notification = Notification.createError(errorValue || 'error');
          advanceFrameBy(1);
          break;
        default:
          // Might be time progression syntax, or a value literal
          if (runMode && c.match(/^[0-9]$/)) ***REMOVED***
            // Time progression must be preceeded by at least one space
            // if it's not at the beginning of the diagram
            if (i === 0 || marbles[i - 1] === ' ') ***REMOVED***
              const buffer = marbles.slice(i);
              const match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
              if (match) ***REMOVED***
                i += match[0].length - 1;
                const duration = parseFloat(match[1]);
                const unit = match[2];
                let durationInMs: number;

                switch (unit) ***REMOVED***
                  case 'ms':
                    durationInMs = duration;
                    break;
                  case 's':
                    durationInMs = duration * 1000;
                    break;
                  case 'm':
                    durationInMs = duration * 1000 * 60;
                    break;
                  default:
                    break;
                ***REMOVED***

                advanceFrameBy(durationInMs / this.frameTimeFactor);
                break;
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***

          notification = Notification.createNext(getValue(c));
          advanceFrameBy(1);
          break;
      ***REMOVED***

      if (notification) ***REMOVED***
        testMessages.push(***REMOVED*** frame: groupStart > -1 ? groupStart : frame, notification ***REMOVED***);
      ***REMOVED***

      frame = nextFrame;
    ***REMOVED***
    return testMessages;
  ***REMOVED***

  run<T>(callback: (helpers: RunHelpers) => T): T ***REMOVED***
    const prevFrameTimeFactor = TestScheduler.frameTimeFactor;
    const prevMaxFrames = this.maxFrames;

    TestScheduler.frameTimeFactor = 1;
    this.maxFrames = Number.POSITIVE_INFINITY;
    this.runMode = true;
    AsyncScheduler.delegate = this;

    const helpers = ***REMOVED***
      cold: this.createColdObservable.bind(this),
      hot: this.createHotObservable.bind(this),
      flush: this.flush.bind(this),
      expectObservable: this.expectObservable.bind(this),
      expectSubscriptions: this.expectSubscriptions.bind(this),
    ***REMOVED***;
    try ***REMOVED***
      const ret = callback(helpers);
      this.flush();
      return ret;
    ***REMOVED*** finally ***REMOVED***
      TestScheduler.frameTimeFactor = prevFrameTimeFactor;
      this.maxFrames = prevMaxFrames;
      this.runMode = false;
      AsyncScheduler.delegate = undefined;
    ***REMOVED***
  ***REMOVED***
***REMOVED***
