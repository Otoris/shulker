import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** SchedulerLike ***REMOVED*** from '../types';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';
import ***REMOVED*** iterator as Symbol_iterator ***REMOVED*** from '../symbol/iterator';

export function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) ***REMOVED***
  if (!input) ***REMOVED***
    throw new Error('Iterable cannot be null');
  ***REMOVED***
  return new Observable<T>(subscriber => ***REMOVED***
    const sub = new Subscription();
    let iterator: Iterator<T>;
    sub.add(() => ***REMOVED***
      // Finalize generators
      if (iterator && typeof iterator.return === 'function') ***REMOVED***
        iterator.return();
      ***REMOVED***
    ***REMOVED***);
    sub.add(scheduler.schedule(() => ***REMOVED***
      iterator = input[Symbol_iterator]();
      sub.add(scheduler.schedule(function () ***REMOVED***
        if (subscriber.closed) ***REMOVED***
          return;
        ***REMOVED***
        let value: T;
        let done: boolean;
        try ***REMOVED***
          const result = iterator.next();
          value = result.value;
          done = result.done;
        ***REMOVED*** catch (err) ***REMOVED***
          subscriber.error(err);
          return;
        ***REMOVED***
        if (done) ***REMOVED***
          subscriber.complete();
        ***REMOVED*** else ***REMOVED***
          subscriber.next(value);
          this.schedule();
        ***REMOVED***
      ***REMOVED***));
    ***REMOVED***));
    return sub;
  ***REMOVED***);
***REMOVED***
