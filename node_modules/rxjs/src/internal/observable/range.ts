import ***REMOVED*** SchedulerAction, SchedulerLike ***REMOVED*** from '../types';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';

/**
 * Creates an Observable that emits a sequence of numbers within a specified
 * range.
 *
 * <span class="informal">Emits a sequence of numbers in a range.</span>
 *
 * ![](range.png)
 *
 * `range` operator emits a range of sequential integers, in order, where you
 * select the `start` of the range and its `length`. By default, uses no
 * ***REMOVED***@link SchedulerLike***REMOVED*** and just delivers the notifications synchronously, but may use
 * an optional ***REMOVED***@link SchedulerLike***REMOVED*** to regulate those deliveries.
 *
 * ## Example
 * Emits the numbers 1 to 10</caption>
 * ```ts
 * import ***REMOVED*** range ***REMOVED*** from 'rxjs';
 *
 * const numbers = range(1, 10);
 * numbers.subscribe(x => console.log(x));
 * ```
 * @see ***REMOVED***@link timer***REMOVED***
 * @see ***REMOVED***@link index/interval***REMOVED***
 *
 * @param ***REMOVED***number***REMOVED*** [start=0] The value of the first integer in the sequence.
 * @param ***REMOVED***number***REMOVED*** count The number of sequential integers to generate.
 * @param ***REMOVED***SchedulerLike***REMOVED*** [scheduler] A ***REMOVED***@link SchedulerLike***REMOVED*** to use for scheduling
 * the emissions of the notifications.
 * @return ***REMOVED***Observable***REMOVED*** An Observable of numbers that emits a finite range of
 * sequential integers.
 * @static true
 * @name range
 * @owner Observable
 */
export function range(start: number = 0,
                      count?: number,
                      scheduler?: SchedulerLike): Observable<number> ***REMOVED***
  return new Observable<number>(subscriber => ***REMOVED***
    if (count === undefined) ***REMOVED***
      count = start;
      start = 0;
    ***REMOVED***

    let index = 0;
    let current = start;

    if (scheduler) ***REMOVED***
      return scheduler.schedule(dispatch, 0, ***REMOVED***
        index, count, start, subscriber
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      do ***REMOVED***
        if (index++ >= count) ***REMOVED***
          subscriber.complete();
          break;
        ***REMOVED***
        subscriber.next(current++);
        if (subscriber.closed) ***REMOVED***
          break;
        ***REMOVED***
      ***REMOVED*** while (true);
    ***REMOVED***

    return undefined;
  ***REMOVED***);
***REMOVED***

/** @internal */
export function dispatch(this: SchedulerAction<any>, state: any) ***REMOVED***
  const ***REMOVED*** start, index, count, subscriber ***REMOVED*** = state;

  if (index >= count) ***REMOVED***
    subscriber.complete();
    return;
  ***REMOVED***

  subscriber.next(start);

  if (subscriber.closed) ***REMOVED***
    return;
  ***REMOVED***

  state.index = index + 1;
  state.start = start + 1;

  this.schedule(state);
***REMOVED***
