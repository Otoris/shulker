import ***REMOVED*** Subject, SubjectSubscriber ***REMOVED*** from '../Subject';
import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';
import ***REMOVED*** TeardownLogic ***REMOVED*** from '../types';
import ***REMOVED*** refCount as higherOrderRefCount ***REMOVED*** from '../operators/refCount';

/**
 * @class ConnectableObservable<T>
 */
export class ConnectableObservable<T> extends Observable<T> ***REMOVED***

  protected _subject: Subject<T>;
  protected _refCount: number = 0;
  protected _connection: Subscription;
  /** @internal */
  _isComplete = false;

  constructor(public source: Observable<T>,
              protected subjectFactory: () => Subject<T>) ***REMOVED***
    super();
  ***REMOVED***

  /** @deprecated This is an internal implementation detail, do not use. */
  _subscribe(subscriber: Subscriber<T>) ***REMOVED***
    return this.getSubject().subscribe(subscriber);
  ***REMOVED***

  protected getSubject(): Subject<T> ***REMOVED***
    const subject = this._subject;
    if (!subject || subject.isStopped) ***REMOVED***
      this._subject = this.subjectFactory();
    ***REMOVED***
    return this._subject;
  ***REMOVED***

  connect(): Subscription ***REMOVED***
    let connection = this._connection;
    if (!connection) ***REMOVED***
      this._isComplete = false;
      connection = this._connection = new Subscription();
      connection.add(this.source
        .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
      if (connection.closed) ***REMOVED***
        this._connection = null;
        connection = Subscription.EMPTY;
      ***REMOVED***
    ***REMOVED***
    return connection;
  ***REMOVED***

  refCount(): Observable<T> ***REMOVED***
    return higherOrderRefCount()(this) as Observable<T>;
  ***REMOVED***
***REMOVED***

export const connectableObservableDescriptor: PropertyDescriptorMap = (() => ***REMOVED***
  const connectableProto = <any>ConnectableObservable.prototype;
  return ***REMOVED***
    operator: ***REMOVED*** value: null as null ***REMOVED***,
    _refCount: ***REMOVED*** value: 0, writable: true ***REMOVED***,
    _subject: ***REMOVED*** value: null as null, writable: true ***REMOVED***,
    _connection: ***REMOVED*** value: null as null, writable: true ***REMOVED***,
    _subscribe: ***REMOVED*** value: connectableProto._subscribe ***REMOVED***,
    _isComplete: ***REMOVED*** value: connectableProto._isComplete, writable: true ***REMOVED***,
    getSubject: ***REMOVED*** value: connectableProto.getSubject ***REMOVED***,
    connect: ***REMOVED*** value: connectableProto.connect ***REMOVED***,
    refCount: ***REMOVED*** value: connectableProto.refCount ***REMOVED***
  ***REMOVED***;
***REMOVED***)();

class ConnectableSubscriber<T> extends SubjectSubscriber<T> ***REMOVED***
  constructor(destination: Subject<T>,
              private connectable: ConnectableObservable<T>) ***REMOVED***
    super(destination);
  ***REMOVED***
  protected _error(err: any): void ***REMOVED***
    this._unsubscribe();
    super._error(err);
  ***REMOVED***
  protected _complete(): void ***REMOVED***
    this.connectable._isComplete = true;
    this._unsubscribe();
    super._complete();
  ***REMOVED***
  protected _unsubscribe() ***REMOVED***
    const connectable = <any>this.connectable;
    if (connectable) ***REMOVED***
      this.connectable = null;
      const connection = connectable._connection;
      connectable._refCount = 0;
      connectable._subject = null;
      connectable._connection = null;
      if (connection) ***REMOVED***
        connection.unsubscribe();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

class RefCountOperator<T> implements Operator<T, T> ***REMOVED***
  constructor(private connectable: ConnectableObservable<T>) ***REMOVED***
  ***REMOVED***
  call(subscriber: Subscriber<T>, source: any): TeardownLogic ***REMOVED***

    const ***REMOVED*** connectable ***REMOVED*** = this;
    (<any> connectable)._refCount++;

    const refCounter = new RefCountSubscriber(subscriber, connectable);
    const subscription = source.subscribe(refCounter);

    if (!refCounter.closed) ***REMOVED***
      (<any> refCounter).connection = connectable.connect();
    ***REMOVED***

    return subscription;
  ***REMOVED***
***REMOVED***

class RefCountSubscriber<T> extends Subscriber<T> ***REMOVED***

  private connection: Subscription;

  constructor(destination: Subscriber<T>,
              private connectable: ConnectableObservable<T>) ***REMOVED***
    super(destination);
  ***REMOVED***

  protected _unsubscribe() ***REMOVED***

    const ***REMOVED*** connectable ***REMOVED*** = this;
    if (!connectable) ***REMOVED***
      this.connection = null;
      return;
    ***REMOVED***

    this.connectable = null;
    const refCount = (<any> connectable)._refCount;
    if (refCount <= 0) ***REMOVED***
      this.connection = null;
      return;
    ***REMOVED***

    (<any> connectable)._refCount = refCount - 1;
    if (refCount > 1) ***REMOVED***
      this.connection = null;
      return;
    ***REMOVED***

    ///
    // Compare the local RefCountSubscriber's connection Subscription to the
    // connection Subscription on the shared ConnectableObservable. In cases
    // where the ConnectableObservable source synchronously emits values, and
    // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
    // execution continues to here before the RefCountOperator has a chance to
    // supply the RefCountSubscriber with the shared connection Subscription.
    // For example:
    // ```
    // range(0, 10).pipe(
    //   publish(),
    //   refCount(),
    //   take(5),
    // ).subscribe();
    // ```
    // In order to account for this case, RefCountSubscriber should only dispose
    // the ConnectableObservable's shared connection Subscription if the
    // connection Subscription exists, *and* either:
    //   a. RefCountSubscriber doesn't have a reference to the shared connection
    //      Subscription yet, or,
    //   b. RefCountSubscriber's connection Subscription reference is identical
    //      to the shared connection Subscription
    ///
    const ***REMOVED*** connection ***REMOVED*** = this;
    const sharedConnection = (<any> connectable)._connection;
    this.connection = null;

    if (sharedConnection && (!connection || sharedConnection === connection)) ***REMOVED***
      sharedConnection.unsubscribe();
    ***REMOVED***
  ***REMOVED***
***REMOVED***
