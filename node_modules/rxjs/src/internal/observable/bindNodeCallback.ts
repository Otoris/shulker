import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** AsyncSubject ***REMOVED*** from '../AsyncSubject';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** SchedulerAction, SchedulerLike ***REMOVED*** from '../types';
import ***REMOVED*** map ***REMOVED*** from '../operators/map';
import ***REMOVED*** canReportError ***REMOVED*** from '../util/canReportError';
import ***REMOVED*** isScheduler ***REMOVED*** from '../util/isScheduler';
import ***REMOVED*** isArray ***REMOVED*** from '../util/isArray';

/* tslint:disable:max-line-length */
/** @deprecated resultSelector is deprecated, pipe to map instead */
export function bindNodeCallback(callbackFunc: Function, resultSelector: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any>;

export function bindNodeCallback<R1, R2, R3, R4>(callbackFunc: (callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
export function bindNodeCallback<R1, R2, R3>(callbackFunc: (callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2, R3]>;
export function bindNodeCallback<R1, R2>(callbackFunc: (callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): () => Observable<[R1, R2]>;
export function bindNodeCallback<R1>(callbackFunc: (callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): () => Observable<R1>;
export function bindNodeCallback(callbackFunc: (callback: (err: any) => any) => any, scheduler?: SchedulerLike): () => Observable<void>;

export function bindNodeCallback<A1, R1, R2, R3, R4>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
export function bindNodeCallback<A1, R1, R2, R3>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2, R3]>;
export function bindNodeCallback<A1, R1, R2>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<[R1, R2]>;
export function bindNodeCallback<A1, R1>(callbackFunc: (arg1: A1, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<R1>;
export function bindNodeCallback<A1>(callbackFunc: (arg1: A1, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1) => Observable<void>;

export function bindNodeCallback<A1, A2, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
export function bindNodeCallback<A1, A2, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2, R3]>;
export function bindNodeCallback<A1, A2, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<[R1, R2]>;
export function bindNodeCallback<A1, A2, R1>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<R1>;
export function bindNodeCallback<A1, A2>(callbackFunc: (arg1: A1, arg2: A2, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2) => Observable<void>;

export function bindNodeCallback<A1, A2, A3, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
export function bindNodeCallback<A1, A2, A3, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2, R3]>;
export function bindNodeCallback<A1, A2, A3, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<[R1, R2]>;
export function bindNodeCallback<A1, A2, A3, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<R1>;
export function bindNodeCallback<A1, A2, A3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3) => Observable<void>;

export function bindNodeCallback<A1, A2, A3, A4, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
export function bindNodeCallback<A1, A2, A3, A4, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2, R3]>;
export function bindNodeCallback<A1, A2, A3, A4, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<[R1, R2]>;
export function bindNodeCallback<A1, A2, A3, A4, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<R1>;
export function bindNodeCallback<A1, A2, A3, A4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4) => Observable<void>;

export function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2, R3, R4>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3, res4: R4, ...args: any[]) => any) => any, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
export function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2, R3>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2, res3: R3) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2, R3]>;
export function bindNodeCallback<A1, A2, A3, A4, A5, R1, R2>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1, res2: R2) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<[R1, R2]>;
export function bindNodeCallback<A1, A2, A3, A4, A5, R1>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any, res1: R1) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<R1>;
export function bindNodeCallback<A1, A2, A3, A4, A5>(callbackFunc: (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5, callback: (err: any) => any) => any, scheduler?: SchedulerLike): (arg1: A1, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Observable<void>; /* tslint:enable:max-line-length */

export function bindNodeCallback(callbackFunc: Function, scheduler?: SchedulerLike): (...args: any[]) => Observable<any[]>;
/**
 * Converts a Node.js-style callback API to a function that returns an
 * Observable.
 *
 * <span class="informal">It's just like ***REMOVED***@link bindCallback***REMOVED***, but the
 * callback is expected to be of type `callback(error, result)`.</span>
 *
 * `bindNodeCallback` is not an operator because its input and output are not
 * Observables. The input is a function `func` with some parameters, but the
 * last parameter must be a callback function that `func` calls when it is
 * done. The callback function is expected to follow Node.js conventions,
 * where the first argument to the callback is an error object, signaling
 * whether call was successful. If that object is passed to callback, it means
 * something went wrong.
 *
 * The output of `bindNodeCallback` is a function that takes the same
 * parameters as `func`, except the last one (the callback). When the output
 * function is called with arguments, it will return an Observable.
 * If `func` calls its callback with error parameter present, Observable will
 * error with that value as well. If error parameter is not passed, Observable will emit
 * second parameter. If there are more parameters (third and so on),
 * Observable will emit an array with all arguments, except first error argument.
 *
 * Note that `func` will not be called at the same time output function is,
 * but rather whenever resulting Observable is subscribed. By default call to
 * `func` will happen synchronously after subscription, but that can be changed
 * with proper `scheduler` provided as optional third parameter. ***REMOVED***@link SchedulerLike***REMOVED***
 * can also control when values from callback will be emitted by Observable.
 * To find out more, check out documentation for ***REMOVED***@link bindCallback***REMOVED***, where
 * ***REMOVED***@link SchedulerLike***REMOVED*** works exactly the same.
 *
 * As in ***REMOVED***@link bindCallback***REMOVED***, context (`this` property) of input function will be set to context
 * of returned function, when it is called.
 *
 * After Observable emits value, it will complete immediately. This means
 * even if `func` calls callback again, values from second and consecutive
 * calls will never appear on the stream. If you need to handle functions
 * that call callbacks multiple times, check out ***REMOVED***@link fromEvent***REMOVED*** or
 * ***REMOVED***@link fromEventPattern***REMOVED*** instead.
 *
 * Note that `bindNodeCallback` can be used in non-Node.js environments as well.
 * "Node.js-style" callbacks are just a convention, so if you write for
 * browsers or any other environment and API you use implements that callback style,
 * `bindNodeCallback` can be safely used on that API functions as well.
 *
 * Remember that Error object passed to callback does not have to be an instance
 * of JavaScript built-in `Error` object. In fact, it does not even have to an object.
 * Error parameter of callback function is interpreted as "present", when value
 * of that parameter is truthy. It could be, for example, non-zero number, non-empty
 * string or boolean `true`. In all of these cases resulting Observable would error
 * with that value. This means usually regular style callbacks will fail very often when
 * `bindNodeCallback` is used. If your Observable errors much more often then you
 * would expect, check if callback really is called in Node.js-style and, if not,
 * switch to ***REMOVED***@link bindCallback***REMOVED*** instead.
 *
 * Note that even if error parameter is technically present in callback, but its value
 * is falsy, it still won't appear in array emitted by Observable.
 *
 * ## Examples
 * ###  Read a file from the filesystem and get the data as an Observable
 * ```ts
 * import * as fs from 'fs';
 * const readFileAsObservable = bindNodeCallback(fs.readFile);
 * const result = readFileAsObservable('./roadNames.txt', 'utf8');
 * result.subscribe(x => console.log(x), e => console.error(e));
 * ```
 *
 * ### Use on function calling callback with multiple arguments
 * ```ts
 * someFunction((err, a, b) => ***REMOVED***
 *   console.log(err); // null
 *   console.log(a); // 5
 *   console.log(b); // "some string"
 * ***REMOVED***);
 * const boundSomeFunction = bindNodeCallback(someFunction);
 * boundSomeFunction()
 * .subscribe(value => ***REMOVED***
 *   console.log(value); // [5, "some string"]
 * ***REMOVED***);
 * ```
 *
 * ### Use on function calling callback in regular style
 * ```ts
 * someFunction(a => ***REMOVED***
 *   console.log(a); // 5
 * ***REMOVED***);
 * const boundSomeFunction = bindNodeCallback(someFunction);
 * boundSomeFunction()
 * .subscribe(
 *   value => ***REMOVED******REMOVED***             // never gets called
 *   err => console.log(err) // 5
 * );
 * ```
 *
 * @see ***REMOVED***@link bindCallback***REMOVED***
 * @see ***REMOVED***@link from***REMOVED***
 *
 * @param ***REMOVED***function***REMOVED*** func Function with a Node.js-style callback as the last parameter.
 * @param ***REMOVED***SchedulerLike***REMOVED*** [scheduler] The scheduler on which to schedule the
 * callbacks.
 * @return ***REMOVED***function(...params: *): Observable***REMOVED*** A function which returns the
 * Observable that delivers the same values the Node.js callback would
 * deliver.
 * @name bindNodeCallback
 */
export function bindNodeCallback<T>(
  callbackFunc: Function,
  resultSelector: Function|SchedulerLike,
  scheduler?: SchedulerLike
): (...args: any[]) => Observable<T> ***REMOVED***

  if (resultSelector) ***REMOVED***
    if (isScheduler(resultSelector)) ***REMOVED***
      scheduler = resultSelector;
    ***REMOVED*** else ***REMOVED***
      // DEPRECATED PATH
      return (...args: any[]) => bindNodeCallback(callbackFunc, scheduler)(...args).pipe(
        map(args => isArray(args) ? resultSelector(...args) : resultSelector(args))
      );
    ***REMOVED***
  ***REMOVED***

  return function(this: any, ...args: any[]): Observable<T> ***REMOVED***
    const params: ParamsState<T> = ***REMOVED***
      subject: undefined,
      args,
      callbackFunc,
      scheduler,
      context: this,
    ***REMOVED***;
    return new Observable<T>(subscriber => ***REMOVED***
      const ***REMOVED*** context ***REMOVED*** = params;
      let ***REMOVED*** subject ***REMOVED*** = params;
      if (!scheduler) ***REMOVED***
        if (!subject) ***REMOVED***
          subject = params.subject = new AsyncSubject<T>();
          const handler = (...innerArgs: any[]) => ***REMOVED***
            const err = innerArgs.shift();

            if (err) ***REMOVED***
              subject.error(err);
              return;
            ***REMOVED***

            subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
            subject.complete();
          ***REMOVED***;

          try ***REMOVED***
            callbackFunc.apply(context, [...args, handler]);
          ***REMOVED*** catch (err) ***REMOVED***
            if (canReportError(subject)) ***REMOVED***
              subject.error(err);
            ***REMOVED*** else ***REMOVED***
              console.warn(err);
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
        return subject.subscribe(subscriber);
      ***REMOVED*** else ***REMOVED***
        return scheduler.schedule<DispatchState<T>>(dispatch, 0, ***REMOVED*** params, subscriber, context ***REMOVED***);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***;
***REMOVED***

interface DispatchState<T> ***REMOVED***
  subscriber: Subscriber<T>;
  context: any;
  params: ParamsState<T>;
***REMOVED***

interface ParamsState<T> ***REMOVED***
  callbackFunc: Function;
  args: any[];
  scheduler: SchedulerLike;
  subject: AsyncSubject<T>;
  context: any;
***REMOVED***

function dispatch<T>(this: SchedulerAction<DispatchState<T>>, state: DispatchState<T>) ***REMOVED***
  const ***REMOVED*** params, subscriber, context ***REMOVED*** = state;
  const ***REMOVED*** callbackFunc, args, scheduler ***REMOVED*** = params;
  let subject = params.subject;

  if (!subject) ***REMOVED***
    subject = params.subject = new AsyncSubject<T>();

    const handler = (...innerArgs: any[]) => ***REMOVED***
      const err = innerArgs.shift();
      if (err) ***REMOVED***
        this.add(scheduler.schedule<DispatchErrorArg<T>>(dispatchError, 0, ***REMOVED*** err, subject ***REMOVED***));
      ***REMOVED*** else ***REMOVED***
        const value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
        this.add(scheduler.schedule<DispatchNextArg<T>>(dispatchNext, 0, ***REMOVED*** value, subject ***REMOVED***));
      ***REMOVED***
    ***REMOVED***;

    try ***REMOVED***
      callbackFunc.apply(context, [...args, handler]);
    ***REMOVED*** catch (err) ***REMOVED***
      this.add(scheduler.schedule<DispatchErrorArg<T>>(dispatchError, 0, ***REMOVED*** err, subject ***REMOVED***));
    ***REMOVED***
  ***REMOVED***

  this.add(subject.subscribe(subscriber));
***REMOVED***

interface DispatchNextArg<T> ***REMOVED***
  subject: AsyncSubject<T>;
  value: T;
***REMOVED***

function dispatchNext<T>(arg: DispatchNextArg<T>) ***REMOVED***
  const ***REMOVED*** value, subject ***REMOVED*** = arg;
  subject.next(value);
  subject.complete();
***REMOVED***

interface DispatchErrorArg<T> ***REMOVED***
  subject: AsyncSubject<T>;
  err: any;
***REMOVED***

function dispatchError<T>(arg: DispatchErrorArg<T>) ***REMOVED***
  const ***REMOVED*** err, subject ***REMOVED*** = arg;
  subject.error(err);
***REMOVED***
