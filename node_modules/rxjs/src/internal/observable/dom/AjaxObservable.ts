import ***REMOVED*** root ***REMOVED*** from '../../util/root';
import ***REMOVED*** Observable ***REMOVED*** from '../../Observable';
import ***REMOVED*** Subscriber ***REMOVED*** from '../../Subscriber';
import ***REMOVED*** TeardownLogic ***REMOVED*** from '../../types';
import ***REMOVED*** map ***REMOVED*** from '../../operators/map';

export interface AjaxRequest ***REMOVED***
  url?: string;
  body?: any;
  user?: string;
  async?: boolean;
  method?: string;
  headers?: Object;
  timeout?: number;
  password?: string;
  hasContent?: boolean;
  crossDomain?: boolean;
  withCredentials?: boolean;
  createXHR?: () => XMLHttpRequest;
  progressSubscriber?: Subscriber<any>;
  responseType?: string;
***REMOVED***

function getCORSRequest(): XMLHttpRequest ***REMOVED***
  if (root.XMLHttpRequest) ***REMOVED***
    return new root.XMLHttpRequest();
  ***REMOVED*** else if (!!root.XDomainRequest) ***REMOVED***
    return new root.XDomainRequest();
  ***REMOVED*** else ***REMOVED***
    throw new Error('CORS is not supported by your browser');
  ***REMOVED***
***REMOVED***

function getXMLHttpRequest(): XMLHttpRequest ***REMOVED***
  if (root.XMLHttpRequest) ***REMOVED***
    return new root.XMLHttpRequest();
  ***REMOVED*** else ***REMOVED***
    let progId: string;
    try ***REMOVED***
      const progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
      for (let i = 0; i < 3; i++) ***REMOVED***
        try ***REMOVED***
          progId = progIds[i];
          if (new root.ActiveXObject(progId)) ***REMOVED***
            break;
          ***REMOVED***
        ***REMOVED*** catch (e) ***REMOVED***
          //suppress exceptions
        ***REMOVED***
      ***REMOVED***
      return new root.ActiveXObject(progId);
    ***REMOVED*** catch (e) ***REMOVED***
      throw new Error('XMLHttpRequest is not supported by your browser');
    ***REMOVED***
  ***REMOVED***
***REMOVED***

export interface AjaxCreationMethod ***REMOVED***
  (urlOrRequest: string | AjaxRequest): Observable<AjaxResponse>;
  get(url: string, headers?: Object): Observable<AjaxResponse>;
  post(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;
  put(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;
  patch(url: string, body?: any, headers?: Object): Observable<AjaxResponse>;
  delete(url: string, headers?: Object): Observable<AjaxResponse>;
  getJSON<T>(url: string, headers?: Object): Observable<T>;
***REMOVED***

export function ajaxGet(url: string, headers: Object = null) ***REMOVED***
  return new AjaxObservable<AjaxResponse>(***REMOVED*** method: 'GET', url, headers ***REMOVED***);
***REMOVED***

export function ajaxPost(url: string, body?: any, headers?: Object): Observable<AjaxResponse> ***REMOVED***
  return new AjaxObservable<AjaxResponse>(***REMOVED*** method: 'POST', url, body, headers ***REMOVED***);
***REMOVED***

export function ajaxDelete(url: string, headers?: Object): Observable<AjaxResponse> ***REMOVED***
  return new AjaxObservable<AjaxResponse>(***REMOVED*** method: 'DELETE', url, headers ***REMOVED***);
***REMOVED***

export function ajaxPut(url: string, body?: any, headers?: Object): Observable<AjaxResponse> ***REMOVED***
  return new AjaxObservable<AjaxResponse>(***REMOVED*** method: 'PUT', url, body, headers ***REMOVED***);
***REMOVED***

export function ajaxPatch(url: string, body?: any, headers?: Object): Observable<AjaxResponse> ***REMOVED***
  return new AjaxObservable<AjaxResponse>(***REMOVED*** method: 'PATCH', url, body, headers ***REMOVED***);
***REMOVED***

const mapResponse = map((x: AjaxResponse, index: number) => x.response);

export function ajaxGetJSON<T>(url: string, headers?: Object): Observable<T> ***REMOVED***
  return mapResponse(
    new AjaxObservable<AjaxResponse>(***REMOVED***
      method: 'GET',
      url,
      responseType: 'json',
      headers
    ***REMOVED***)
  );
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends ***REMOVED***Ignored***REMOVED***
 * @hide true
 */
export class AjaxObservable<T> extends Observable<T> ***REMOVED***
  /**
   * Creates an observable for an Ajax request with either a request object with
   * url, headers, etc or a string for a URL.
   *
   * ## Example
   * ```ts
   * import ***REMOVED*** ajax ***REMOVED*** from 'rxjs/ajax';
 *
   * const source1 = ajax('/products');
   * const source2 = ajax(***REMOVED*** url: 'products', method: 'GET' ***REMOVED***);
   * ```
   *
   * @param ***REMOVED***string|Object***REMOVED*** request Can be one of the following:
   *   A string of the URL to make the Ajax call.
   *   An object with the following properties
   *   - url: URL of the request
   *   - body: The body of the request
   *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
   *   - async: Whether the request is async
   *   - headers: Optional headers
   *   - crossDomain: true if a cross domain request, else false
   *   - createXHR: a function to override if you need to use an alternate
   *   XMLHttpRequest implementation.
   *   - resultSelector: a function to use to alter the output value type of
   *   the Observable. Gets ***REMOVED***@link AjaxResponse***REMOVED*** as an argument.
   * @return ***REMOVED***Observable***REMOVED*** An observable sequence containing the XMLHttpRequest.
   * @static true
   * @name ajax
   * @owner Observable
   * @nocollapse
  */
  static create: AjaxCreationMethod = (() => ***REMOVED***
    const create: any = (urlOrRequest: string | AjaxRequest) => ***REMOVED***
      return new AjaxObservable(urlOrRequest);
    ***REMOVED***;

    create.get = ajaxGet;
    create.post = ajaxPost;
    create.delete = ajaxDelete;
    create.put = ajaxPut;
    create.patch = ajaxPatch;
    create.getJSON = ajaxGetJSON;

    return <AjaxCreationMethod>create;
  ***REMOVED***)();

  private request: AjaxRequest;

  constructor(urlOrRequest: string | AjaxRequest) ***REMOVED***
    super();

    const request: AjaxRequest = ***REMOVED***
      async: true,
      createXHR: function(this: AjaxRequest) ***REMOVED***
        return this.crossDomain ? getCORSRequest() : getXMLHttpRequest();
      ***REMOVED***,
      crossDomain: true,
      withCredentials: false,
      headers: ***REMOVED******REMOVED***,
      method: 'GET',
      responseType: 'json',
      timeout: 0
    ***REMOVED***;

    if (typeof urlOrRequest === 'string') ***REMOVED***
      request.url = urlOrRequest;
    ***REMOVED*** else ***REMOVED***
      for (const prop in urlOrRequest) ***REMOVED***
        if (urlOrRequest.hasOwnProperty(prop)) ***REMOVED***
          request[prop] = urlOrRequest[prop];
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    this.request = request;
  ***REMOVED***

  /** @deprecated This is an internal implementation detail, do not use. */
  _subscribe(subscriber: Subscriber<T>): TeardownLogic ***REMOVED***
    return new AjaxSubscriber(subscriber, this.request);
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
export class AjaxSubscriber<T> extends Subscriber<Event> ***REMOVED***
  private xhr: XMLHttpRequest;
  private done: boolean = false;

  constructor(destination: Subscriber<T>, public request: AjaxRequest) ***REMOVED***
    super(destination);

    const headers = request.headers = request.headers || ***REMOVED******REMOVED***;

    // force CORS if requested
    if (!request.crossDomain && !this.getHeader(headers, 'X-Requested-With')) ***REMOVED***
      headers['X-Requested-With'] = 'XMLHttpRequest';
    ***REMOVED***

    // ensure content type is set
    let contentTypeHeader = this.getHeader(headers, 'Content-Type');
    if (!contentTypeHeader && !(root.FormData && request.body instanceof root.FormData) && typeof request.body !== 'undefined') ***REMOVED***
      headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
    ***REMOVED***

    // properly serialize body
    request.body = this.serializeBody(request.body, this.getHeader(request.headers, 'Content-Type'));

    this.send();
  ***REMOVED***

  next(e: Event): void ***REMOVED***
    this.done = true;
    const ***REMOVED*** xhr, request, destination ***REMOVED*** = this;
    let result;
    try ***REMOVED***
      result = new AjaxResponse(e, xhr, request);
    ***REMOVED*** catch (err) ***REMOVED***
      return destination.error(err);
    ***REMOVED***
    destination.next(result);
  ***REMOVED***

  private send(): void ***REMOVED***
    const ***REMOVED***
      request,
      request: ***REMOVED*** user, method, url, async, password, headers, body ***REMOVED***
    ***REMOVED*** = this;
    try ***REMOVED***
      const xhr = this.xhr = request.createXHR();

      // set up the events before open XHR
      // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
      // You need to add the event listeners before calling open() on the request.
      // Otherwise the progress events will not fire.
      this.setupEvents(xhr, request);
      // open XHR
      if (user) ***REMOVED***
        xhr.open(method, url, async, user, password);
      ***REMOVED*** else ***REMOVED***
        xhr.open(method, url, async);
      ***REMOVED***

      // timeout, responseType and withCredentials can be set once the XHR is open
      if (async) ***REMOVED***
        xhr.timeout = request.timeout;
        xhr.responseType = request.responseType as any;
      ***REMOVED***

      if ('withCredentials' in xhr) ***REMOVED***
        xhr.withCredentials = !!request.withCredentials;
      ***REMOVED***

      // set headers
      this.setHeaders(xhr, headers);

      // finally send the request
      if (body) ***REMOVED***
        xhr.send(body);
      ***REMOVED*** else ***REMOVED***
        xhr.send();
      ***REMOVED***
    ***REMOVED*** catch (err) ***REMOVED***
      this.error(err);
    ***REMOVED***
  ***REMOVED***

  private serializeBody(body: any, contentType?: string) ***REMOVED***
    if (!body || typeof body === 'string') ***REMOVED***
      return body;
    ***REMOVED*** else if (root.FormData && body instanceof root.FormData) ***REMOVED***
      return body;
    ***REMOVED***

    if (contentType) ***REMOVED***
      const splitIndex = contentType.indexOf(';');
      if (splitIndex !== -1) ***REMOVED***
        contentType = contentType.substring(0, splitIndex);
      ***REMOVED***
    ***REMOVED***

    switch (contentType) ***REMOVED***
      case 'application/x-www-form-urlencoded':
        return Object.keys(body).map(key => `$***REMOVED***encodeURIComponent(key)***REMOVED***=$***REMOVED***encodeURIComponent(body[key])***REMOVED***`).join('&');
      case 'application/json':
        return JSON.stringify(body);
      default:
        return body;
    ***REMOVED***
  ***REMOVED***

  private setHeaders(xhr: XMLHttpRequest, headers: Object) ***REMOVED***
    for (let key in headers) ***REMOVED***
      if (headers.hasOwnProperty(key)) ***REMOVED***
        xhr.setRequestHeader(key, headers[key]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  private getHeader(headers: ***REMOVED******REMOVED***, headerName: string): any ***REMOVED***
    for (let key in headers) ***REMOVED***
      if (key.toLowerCase() === headerName.toLowerCase()) ***REMOVED***
        return headers[key];
      ***REMOVED***
    ***REMOVED***

    return undefined;
  ***REMOVED***

  private setupEvents(xhr: XMLHttpRequest, request: AjaxRequest) ***REMOVED***
    const progressSubscriber = request.progressSubscriber;

    function xhrTimeout(this: XMLHttpRequest, e: ProgressEvent): void ***REMOVED***
      const ***REMOVED***subscriber, progressSubscriber, request ***REMOVED*** = (<any>xhrTimeout);
      if (progressSubscriber) ***REMOVED***
        progressSubscriber.error(e);
      ***REMOVED***
      let error;
      try ***REMOVED***
        error = new AjaxTimeoutError(this, request); // TODO: Make betterer.
      ***REMOVED*** catch (err) ***REMOVED***
        error = err;
      ***REMOVED***
      subscriber.error(error);
    ***REMOVED***
    xhr.ontimeout = xhrTimeout;
    (<any>xhrTimeout).request = request;
    (<any>xhrTimeout).subscriber = this;
    (<any>xhrTimeout).progressSubscriber = progressSubscriber;
    if (xhr.upload && 'withCredentials' in xhr) ***REMOVED***
      if (progressSubscriber) ***REMOVED***
        let xhrProgress: (e: ProgressEvent) => void;
        xhrProgress = function(e: ProgressEvent) ***REMOVED***
          const ***REMOVED*** progressSubscriber ***REMOVED*** = (<any>xhrProgress);
          progressSubscriber.next(e);
        ***REMOVED***;
        if (root.XDomainRequest) ***REMOVED***
          xhr.onprogress = xhrProgress;
        ***REMOVED*** else ***REMOVED***
          xhr.upload.onprogress = xhrProgress;
        ***REMOVED***
        (<any>xhrProgress).progressSubscriber = progressSubscriber;
      ***REMOVED***
      let xhrError: (e: any) => void;
      xhrError = function(this: XMLHttpRequest, e: ErrorEvent) ***REMOVED***
        const ***REMOVED*** progressSubscriber, subscriber, request ***REMOVED*** = (<any>xhrError);
        if (progressSubscriber) ***REMOVED***
          progressSubscriber.error(e);
        ***REMOVED***
        let error;
        try ***REMOVED***
          error = new AjaxError('ajax error', this, request);
        ***REMOVED*** catch (err) ***REMOVED***
          error = err;
        ***REMOVED***
        subscriber.error(error);
      ***REMOVED***;
      xhr.onerror = xhrError;
      (<any>xhrError).request = request;
      (<any>xhrError).subscriber = this;
      (<any>xhrError).progressSubscriber = progressSubscriber;
    ***REMOVED***

    function xhrReadyStateChange(this: XMLHttpRequest, e: Event) ***REMOVED***
      return;
    ***REMOVED***
    xhr.onreadystatechange = xhrReadyStateChange;
    (<any>xhrReadyStateChange).subscriber = this;
    (<any>xhrReadyStateChange).progressSubscriber = progressSubscriber;
    (<any>xhrReadyStateChange).request = request;

    function xhrLoad(this: XMLHttpRequest, e: Event) ***REMOVED***
      const ***REMOVED*** subscriber, progressSubscriber, request ***REMOVED*** = (<any>xhrLoad);
      if (this.readyState === 4) ***REMOVED***
        // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
        let status: number = this.status === 1223 ? 204 : this.status;
        let response: any = (this.responseType === 'text' ?  (
          this.response || this.responseText) : this.response);

        // fix status code when it is 0 (0 status is undocumented).
        // Occurs when accessing file resources or on Android 4.1 stock browser
        // while retrieving files from application cache.
        if (status === 0) ***REMOVED***
          status = response ? 200 : 0;
        ***REMOVED***

        // 4xx and 5xx should error (https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)
        if (status < 400) ***REMOVED***
          if (progressSubscriber) ***REMOVED***
            progressSubscriber.complete();
          ***REMOVED***
          subscriber.next(e);
          subscriber.complete();
        ***REMOVED*** else ***REMOVED***
          if (progressSubscriber) ***REMOVED***
            progressSubscriber.error(e);
          ***REMOVED***
          let error;
          try ***REMOVED***
            error = new AjaxError('ajax error ' + status, this, request);
          ***REMOVED*** catch (err) ***REMOVED***
            error = err;
          ***REMOVED***
          subscriber.error(error);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    xhr.onload = xhrLoad;
    (<any>xhrLoad).subscriber = this;
    (<any>xhrLoad).progressSubscriber = progressSubscriber;
    (<any>xhrLoad).request = request;
  ***REMOVED***

  unsubscribe() ***REMOVED***
    const ***REMOVED*** done, xhr ***REMOVED*** = this;
    if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') ***REMOVED***
      xhr.abort();
    ***REMOVED***
    super.unsubscribe();
  ***REMOVED***
***REMOVED***

/**
 * A normalized AJAX response.
 *
 * @see ***REMOVED***@link ajax***REMOVED***
 *
 * @class AjaxResponse
 */
export class AjaxResponse ***REMOVED***
  /** @type ***REMOVED***number***REMOVED*** The HTTP status code */
  status: number;

  /** @type ***REMOVED***string|ArrayBuffer|Document|object|any***REMOVED*** The response data */
  response: any;

  /** @type ***REMOVED***string***REMOVED*** The raw responseText */
  responseText: string;

  /** @type ***REMOVED***string***REMOVED*** The responseType (e.g. 'json', 'arraybuffer', or 'xml') */
  responseType: string;

  constructor(public originalEvent: Event, public xhr: XMLHttpRequest, public request: AjaxRequest) ***REMOVED***
    this.status = xhr.status;
    this.responseType = xhr.responseType || request.responseType;
    this.response = parseXhrResponse(this.responseType, xhr);
  ***REMOVED***
***REMOVED***

export type AjaxErrorNames = 'AjaxError' | 'AjaxTimeoutError';

/**
 * A normalized AJAX error.
 *
 * @see ***REMOVED***@link ajax***REMOVED***
 *
 * @class AjaxError
 */
export interface AjaxError extends Error ***REMOVED***
  /** @type ***REMOVED***XMLHttpRequest***REMOVED*** The XHR instance associated with the error */
  xhr: XMLHttpRequest;

  /** @type ***REMOVED***AjaxRequest***REMOVED*** The AjaxRequest associated with the error */
  request: AjaxRequest;

  /** @type ***REMOVED***number***REMOVED*** The HTTP status code */
  status: number;

  /** @type ***REMOVED***string***REMOVED*** The responseType (e.g. 'json', 'arraybuffer', or 'xml') */
  responseType: string;

  /** @type ***REMOVED***string|ArrayBuffer|Document|object|any***REMOVED*** The response data */
  response: any;
***REMOVED***

export interface AjaxErrorCtor ***REMOVED***
  new(message: string, xhr: XMLHttpRequest, request: AjaxRequest): AjaxError;
***REMOVED***

const AjaxErrorImpl = (() => ***REMOVED***
  function AjaxErrorImpl(this: any, message: string, xhr: XMLHttpRequest, request: AjaxRequest): AjaxError ***REMOVED***
    Error.call(this);
    this.message = message;
    this.name = 'AjaxError';
    this.xhr = xhr;
    this.request = request;
    this.status = xhr.status;
    this.responseType = xhr.responseType || request.responseType;
    this.response = parseXhrResponse(this.responseType, xhr);
    return this;
  ***REMOVED***
  AjaxErrorImpl.prototype = Object.create(Error.prototype);
  return AjaxErrorImpl;
***REMOVED***)();

export const AjaxError: AjaxErrorCtor = AjaxErrorImpl as any;

function parseJson(xhr: XMLHttpRequest) ***REMOVED***
  // HACK(benlesh): TypeScript shennanigans
  // tslint:disable-next-line:no-any XMLHttpRequest is defined to always have 'response' inferring xhr as never for the else clause.
  if ('response' in (xhr as any)) ***REMOVED***
    //IE does not support json as responseType, parse it internally
    return xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');
  ***REMOVED*** else ***REMOVED***
    return JSON.parse((xhr as any).responseText || 'null');
  ***REMOVED***
***REMOVED***

function parseXhrResponse(responseType: string, xhr: XMLHttpRequest) ***REMOVED***
  switch (responseType) ***REMOVED***
    case 'json':
        return parseJson(xhr);
      case 'xml':
        return xhr.responseXML;
      case 'text':
      default:
          // HACK(benlesh): TypeScript shennanigans
          // tslint:disable-next-line:no-any XMLHttpRequest is defined to always have 'response' inferring xhr as never for the else sub-expression.
          return  ('response' in (xhr as any)) ? xhr.response : xhr.responseText;
  ***REMOVED***
***REMOVED***

export interface AjaxTimeoutError extends AjaxError ***REMOVED***
***REMOVED***

export interface AjaxTimeoutErrorCtor ***REMOVED***
  new(xhr: XMLHttpRequest, request: AjaxRequest): AjaxTimeoutError;
***REMOVED***

function AjaxTimeoutErrorImpl(this: any, xhr: XMLHttpRequest, request: AjaxRequest) ***REMOVED***
  AjaxError.call(this, 'ajax timeout', xhr, request);
  this.name = 'AjaxTimeoutError';
  return this;
***REMOVED***

/**
 * @see ***REMOVED***@link ajax***REMOVED***
 *
 * @class AjaxTimeoutError
 */
export const AjaxTimeoutError: AjaxTimeoutErrorCtor = AjaxTimeoutErrorImpl as any;
