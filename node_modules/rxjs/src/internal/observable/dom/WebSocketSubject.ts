import ***REMOVED*** Subject, AnonymousSubject ***REMOVED*** from '../../Subject';
import ***REMOVED*** Subscriber ***REMOVED*** from '../../Subscriber';
import ***REMOVED*** Observable ***REMOVED*** from '../../Observable';
import ***REMOVED*** Subscription ***REMOVED*** from '../../Subscription';
import ***REMOVED*** Operator ***REMOVED*** from '../../Operator';
import ***REMOVED*** ReplaySubject ***REMOVED*** from '../../ReplaySubject';
import ***REMOVED*** Observer, NextObserver ***REMOVED*** from '../../types';

/**
 * WebSocketSubjectConfig is a plain Object that allows us to make our
 * webSocket configurable.
 *
 * <span class="informal">Provides flexibility to ***REMOVED***@link webSocket***REMOVED***</span>
 *
 * It defines a set of properties to provide custom behavior in specific
 * moments of the socket's lifecycle. When the connection opens we can
 * use `openObserver`, when the connection is closed `closeObserver`, if we
 * are interested in listening for data comming from server: `deserializer`,
 * which allows us to customize the deserialization strategy of data before passing it
 * to the socket client. By default `deserializer` is going to apply `JSON.parse` to each message comming
 * from the Server.
 *
 * ## Example
 * **deserializer**, the default for this property is `JSON.parse` but since there are just two options
 * for incomming data, either be text or binarydata. We can apply a custom deserialization strategy
 * or just simply skip the default behaviour.
 * ```ts
 * import ***REMOVED*** webSocket ***REMOVED*** from 'rxjs/webSocket';
 *
 * const wsSubject = webSocket(***REMOVED***
 *     url: 'ws://localhost:8081',
 * //Apply any transformation of your choice.
 *     deserializer: (***REMOVED***data***REMOVED***) => data
 * ***REMOVED***);
 *
 * wsSubject.subscribe(console.log);
 *
 * // Let's suppose we have this on the Server: ws.send("This is a msg from the server")
 * //output
 * //
 * // This is a msg from the server
 * ```
 *
 * **serializer** allows us tom apply custom serialization strategy but for the outgoing messages
 * ```ts
 * import ***REMOVED*** webSocket ***REMOVED*** from 'rxjs/webSocket';
 *
 * const wsSubject = webSocket(***REMOVED***
 *     url: 'ws://localhost:8081',
 * //Apply any transformation of your choice.
 *     serializer: msg => JSON.stringify(***REMOVED***channel: "webDevelopment", msg: msg***REMOVED***)
 * ***REMOVED***);
 *
 * wsSubject.subscribe(() => subject.next("msg to the server"));
 *
 * // Let's suppose we have this on the Server: ws.send("This is a msg from the server")
 * //output
 * //
 * // ***REMOVED***"channel":"webDevelopment","msg":"msg to the server"***REMOVED***
 * ```
 *
 * **closeObserver** allows us to set a custom error when an error raise up.
 * ```ts
 * import ***REMOVED*** webSocket ***REMOVED*** from 'rxjs/webSocket';
 *
 * const wsSubject = webSocket(***REMOVED***
 *     url: 'ws://localhost:8081',
 *     closeObserver: ***REMOVED***
        next(closeEvent) ***REMOVED***
            const customError = ***REMOVED*** code: 6666, reason: "Custom evil reason" ***REMOVED***
            console.log(`code: $***REMOVED***customError.code***REMOVED***, reason: $***REMOVED***customError.reason***REMOVED***`);
        ***REMOVED***
    ***REMOVED***
 * ***REMOVED***);
 *
 * //output
 * // code: 6666, reason: Custom evil reason
 * ```
 *
 * **openObserver**, Let's say we need to make some kind of init task before sending/receiving msgs to the
 * webSocket or sending notification that the connection was successful, this is when
 * openObserver is usefull for.
 * ```ts
 * import ***REMOVED*** webSocket ***REMOVED*** from 'rxjs/webSocket';
 *
 * const wsSubject = webSocket(***REMOVED***
 *     url: 'ws://localhost:8081',
 *     openObserver: ***REMOVED***
 *         next: () => ***REMOVED***
 *             console.log('connetion ok');
 *         ***REMOVED***
 *     ***REMOVED***,
 * ***REMOVED***);
 *
 * //output
 * // connetion ok`
 * ```
 * */

export interface WebSocketSubjectConfig<T> ***REMOVED***
  /** The url of the socket server to connect to */
  url: string;
  /** The protocol to use to connect */
  protocol?: string | Array<string>;
  /** @deprecated use ***REMOVED***@link deserializer***REMOVED*** */
  resultSelector?: (e: MessageEvent) => T;
  /**
   * A serializer used to create messages from passed values before the
   * messages are sent to the server. Defaults to JSON.stringify.
   */
  serializer?: (value: T) => WebSocketMessage;
  /**
   * A deserializer used for messages arriving on the socket from the
   * server. Defaults to JSON.parse.
   */
  deserializer?: (e: MessageEvent) => T;
  /**
   * An Observer that watches when open events occur on the underlying web socket.
   */
  openObserver?: NextObserver<Event>;
  /**
   * An Observer than watches when close events occur on the underlying webSocket
   */
  closeObserver?: NextObserver<CloseEvent>;
  /**
   * An Observer that watches when a close is about to occur due to
   * unsubscription.
   */
  closingObserver?: NextObserver<void>;
  /**
   * A WebSocket constructor to use. This is useful for situations like using a
   * WebSocket impl in Node (WebSocket is a DOM API), or for mocking a WebSocket
   * for testing purposes
   */
  WebSocketCtor?: ***REMOVED*** new(url: string, protocols?: string|string[]): WebSocket ***REMOVED***;
  /** Sets the `binaryType` property of the underlying WebSocket. */
  binaryType?: 'blob' | 'arraybuffer';
***REMOVED***

const DEFAULT_WEBSOCKET_CONFIG: WebSocketSubjectConfig<any> = ***REMOVED***
  url: '',
  deserializer: (e: MessageEvent) => JSON.parse(e.data),
  serializer: (value: any) => JSON.stringify(value),
***REMOVED***;

const WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT =
  'WebSocketSubject.error must be called with an object with an error code, and an optional reason: ***REMOVED*** code: number, reason: string ***REMOVED***';

export type WebSocketMessage = string | ArrayBuffer | Blob | ArrayBufferView;

export class WebSocketSubject<T> extends AnonymousSubject<T> ***REMOVED***

  private _config: WebSocketSubjectConfig<T>;

  /** @deprecated This is an internal implementation detail, do not use. */
  _output: Subject<T>;

  private _socket: WebSocket;

  constructor(urlConfigOrSource: string | WebSocketSubjectConfig<T> | Observable<T>, destination?: Observer<T>) ***REMOVED***
    super();
    if (urlConfigOrSource instanceof Observable) ***REMOVED***
      this.destination = destination;
      this.source = urlConfigOrSource as Observable<T>;
    ***REMOVED*** else ***REMOVED***
      const config = this._config = ***REMOVED*** ...DEFAULT_WEBSOCKET_CONFIG ***REMOVED***;
      this._output = new Subject<T>();
      if (typeof urlConfigOrSource === 'string') ***REMOVED***
        config.url = urlConfigOrSource;
      ***REMOVED*** else ***REMOVED***
        for (let key in urlConfigOrSource) ***REMOVED***
          if (urlConfigOrSource.hasOwnProperty(key)) ***REMOVED***
            config[key] = urlConfigOrSource[key];
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      if (!config.WebSocketCtor && WebSocket) ***REMOVED***
        config.WebSocketCtor = WebSocket;
      ***REMOVED*** else if (!config.WebSocketCtor) ***REMOVED***
        throw new Error('no WebSocket constructor can be found');
      ***REMOVED***
      this.destination = new ReplaySubject();
    ***REMOVED***
  ***REMOVED***

  lift<R>(operator: Operator<T, R>): WebSocketSubject<R> ***REMOVED***
    const sock = new WebSocketSubject<R>(this._config as WebSocketSubjectConfig<any>, <any> this.destination);
    sock.operator = operator;
    sock.source = this;
    return sock;
  ***REMOVED***

  private _resetState() ***REMOVED***
    this._socket = null;
    if (!this.source) ***REMOVED***
      this.destination = new ReplaySubject();
    ***REMOVED***
    this._output = new Subject<T>();
  ***REMOVED***

  /**
   * Creates an ***REMOVED***@link Observable***REMOVED***, that when subscribed to, sends a message,
   * defined by the `subMsg` function, to the server over the socket to begin a
   * subscription to data over that socket. Once data arrives, the
   * `messageFilter` argument will be used to select the appropriate data for
   * the resulting Observable. When teardown occurs, either due to
   * unsubscription, completion or error, a message defined by the `unsubMsg`
   * argument will be send to the server over the WebSocketSubject.
   *
   * @param subMsg A function to generate the subscription message to be sent to
   * the server. This will still be processed by the serializer in the
   * WebSocketSubject's config. (Which defaults to JSON serialization)
   * @param unsubMsg A function to generate the unsubscription message to be
   * sent to the server at teardown. This will still be processed by the
   * serializer in the WebSocketSubject's config.
   * @param messageFilter A predicate for selecting the appropriate messages
   * from the server for the output stream.
   */
  multiplex(subMsg: () => any, unsubMsg: () => any, messageFilter: (value: T) => boolean) ***REMOVED***
    const self = this;
    return new Observable((observer: Observer<any>) => ***REMOVED***
      try ***REMOVED***
        self.next(subMsg());
      ***REMOVED*** catch (err) ***REMOVED***
        observer.error(err);
      ***REMOVED***

      const subscription = self.subscribe(x => ***REMOVED***
        try ***REMOVED***
          if (messageFilter(x)) ***REMOVED***
            observer.next(x);
          ***REMOVED***
        ***REMOVED*** catch (err) ***REMOVED***
          observer.error(err);
        ***REMOVED***
      ***REMOVED***,
        err => observer.error(err),
        () => observer.complete());

      return () => ***REMOVED***
        try ***REMOVED***
          self.next(unsubMsg());
        ***REMOVED*** catch (err) ***REMOVED***
          observer.error(err);
        ***REMOVED***
        subscription.unsubscribe();
      ***REMOVED***;
    ***REMOVED***);
  ***REMOVED***

  private _connectSocket() ***REMOVED***
    const ***REMOVED*** WebSocketCtor, protocol, url, binaryType ***REMOVED*** = this._config;
    const observer = this._output;

    let socket: WebSocket = null;
    try ***REMOVED***
      socket = protocol ?
        new WebSocketCtor(url, protocol) :
        new WebSocketCtor(url);
      this._socket = socket;
      if (binaryType) ***REMOVED***
        this._socket.binaryType = binaryType;
      ***REMOVED***
    ***REMOVED*** catch (e) ***REMOVED***
      observer.error(e);
      return;
    ***REMOVED***

    const subscription = new Subscription(() => ***REMOVED***
      this._socket = null;
      if (socket && socket.readyState === 1) ***REMOVED***
        socket.close();
      ***REMOVED***
    ***REMOVED***);

    socket.onopen = (e: Event) => ***REMOVED***
      const ***REMOVED*** _socket ***REMOVED*** = this;
      if (!_socket) ***REMOVED***
        socket.close();
        this._resetState();
        return;
      ***REMOVED***
      const ***REMOVED*** openObserver ***REMOVED*** = this._config;
      if (openObserver) ***REMOVED***
        openObserver.next(e);
      ***REMOVED***

      const queue = this.destination;

      this.destination = Subscriber.create<T>(
        (x) => ***REMOVED***
          if (socket.readyState === 1) ***REMOVED***
            try ***REMOVED***
              const ***REMOVED*** serializer ***REMOVED*** = this._config;
              socket.send(serializer(x));
              ***REMOVED*** catch (e) ***REMOVED***
              this.destination.error(e);
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***,
        (e) => ***REMOVED***
          const ***REMOVED*** closingObserver ***REMOVED*** = this._config;
          if (closingObserver) ***REMOVED***
            closingObserver.next(undefined);
          ***REMOVED***
          if (e && e.code) ***REMOVED***
            socket.close(e.code, e.reason);
          ***REMOVED*** else ***REMOVED***
            observer.error(new TypeError(WEBSOCKETSUBJECT_INVALID_ERROR_OBJECT));
          ***REMOVED***
          this._resetState();
        ***REMOVED***,
        () => ***REMOVED***
          const ***REMOVED*** closingObserver ***REMOVED*** = this._config;
          if (closingObserver) ***REMOVED***
            closingObserver.next(undefined);
          ***REMOVED***
          socket.close();
          this._resetState();
        ***REMOVED***
      ) as Subscriber<any>;

      if (queue && queue instanceof ReplaySubject) ***REMOVED***
        subscription.add((<ReplaySubject<T>>queue).subscribe(this.destination));
      ***REMOVED***
    ***REMOVED***;

    socket.onerror = (e: Event) => ***REMOVED***
      this._resetState();
      observer.error(e);
    ***REMOVED***;

    socket.onclose = (e: CloseEvent) => ***REMOVED***
      this._resetState();
      const ***REMOVED*** closeObserver ***REMOVED*** = this._config;
      if (closeObserver) ***REMOVED***
        closeObserver.next(e);
      ***REMOVED***
      if (e.wasClean) ***REMOVED***
        observer.complete();
      ***REMOVED*** else ***REMOVED***
        observer.error(e);
      ***REMOVED***
    ***REMOVED***;

    socket.onmessage = (e: MessageEvent) => ***REMOVED***
      try ***REMOVED***
        const ***REMOVED*** deserializer ***REMOVED*** = this._config;
        observer.next(deserializer(e));
      ***REMOVED*** catch (err) ***REMOVED***
        observer.error(err);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***

  /** @deprecated This is an internal implementation detail, do not use. */
  _subscribe(subscriber: Subscriber<T>): Subscription ***REMOVED***
    const ***REMOVED*** source ***REMOVED*** = this;
    if (source) ***REMOVED***
      return source.subscribe(subscriber);
    ***REMOVED***
    if (!this._socket) ***REMOVED***
      this._connectSocket();
    ***REMOVED***
    this._output.subscribe(subscriber);
    subscriber.add(() => ***REMOVED***
      const ***REMOVED*** _socket ***REMOVED*** = this;
      if (this._output.observers.length === 0) ***REMOVED***
        if (_socket && _socket.readyState === 1) ***REMOVED***
          _socket.close();
        ***REMOVED***
        this._resetState();
      ***REMOVED***
    ***REMOVED***);
    return subscriber;
  ***REMOVED***

  unsubscribe() ***REMOVED***
    const ***REMOVED*** _socket ***REMOVED*** = this;
    if (_socket && _socket.readyState === 1) ***REMOVED***
      _socket.close();
    ***REMOVED***
    this._resetState();
    super.unsubscribe();
  ***REMOVED***
***REMOVED***
