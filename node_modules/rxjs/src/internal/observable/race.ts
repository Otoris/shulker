import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** isArray ***REMOVED*** from '../util/isArray';
import ***REMOVED*** fromArray ***REMOVED*** from './fromArray';
import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';
import ***REMOVED*** TeardownLogic, ObservableInput ***REMOVED*** from '../types';
import ***REMOVED*** OuterSubscriber ***REMOVED*** from '../OuterSubscriber';
import ***REMOVED*** InnerSubscriber ***REMOVED*** from '../InnerSubscriber';
import ***REMOVED*** subscribeToResult ***REMOVED*** from '../util/subscribeToResult';

// tslint:disable:max-line-length
export function race<A>(arg: [ObservableInput<A>]): Observable<A>;
export function race<A, B>(arg: [ObservableInput<A>, ObservableInput<B>]): Observable<A | B>;
export function race<A, B, C>(arg: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>]): Observable<A | B | C>;
export function race<A, B, C, D>(arg: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>]): Observable<A | B | C | D>;
export function race<A, B, C, D, E>(arg: [ObservableInput<A>, ObservableInput<B>, ObservableInput<C>, ObservableInput<D>, ObservableInput<E>]): Observable<A | B | C | D | E>;
export function race<T>(arg: ObservableInput<T>[]): Observable<T>;
export function race(arg: ObservableInput<any>[]): Observable<***REMOVED******REMOVED***>;

export function race<A>(a: ObservableInput<A>): Observable<A>;
export function race<A, B>(a: ObservableInput<A>, b: ObservableInput<B>): Observable<A | B>;
export function race<A, B, C>(a: ObservableInput<A>, b: ObservableInput<B>, c: ObservableInput<C>): Observable<A | B | C>;
export function race<A, B, C, D>(a: ObservableInput<A>, b: ObservableInput<B>, c: ObservableInput<C>, d: ObservableInput<D>): Observable<A | B | C | D>;
export function race<A, B, C, D, E>(a: ObservableInput<A>, b: ObservableInput<B>, c: ObservableInput<C>, d: ObservableInput<D>, e: ObservableInput<E>): Observable<A | B | C | D | E>;
// tslint:enable:max-line-length

export function race<T>(observables: ObservableInput<T>[]): Observable<T>;
export function race(observables: ObservableInput<any>[]): Observable<***REMOVED******REMOVED***>;
export function race<T>(...observables: ObservableInput<T>[]): Observable<T>;
export function race(...observables: ObservableInput<any>[]): Observable<***REMOVED******REMOVED***>;

/**
 * Returns an Observable that mirrors the first source Observable to emit an item.
 *
 * ## Example
 * ### Subscribes to the observable that was the first to start emitting.
 *
 * ```ts
 * import ***REMOVED*** race, interval ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** mapTo ***REMOVED*** from 'rxjs/operators';
 *
 * const obs1 = interval(1000).pipe(mapTo('fast one'));
 * const obs2 = interval(3000).pipe(mapTo('medium one'));
 * const obs3 = interval(5000).pipe(mapTo('slow one'));
 *
 * race(obs3, obs1, obs2)
 * .subscribe(
 *   winner => console.log(winner)
 * );
 *
 * // result:
 * // a series of 'fast one'
 * ```
 *
 * @param ***REMOVED***...Observables***REMOVED*** ...observables sources used to race for which Observable emits first.
 * @return ***REMOVED***Observable***REMOVED*** an Observable that mirrors the output of the first Observable to emit an item.
 * @static true
 * @name race
 * @owner Observable
 */
export function race<T>(...observables: ObservableInput<any>[]): Observable<T> ***REMOVED***
  // if the only argument is an array, it was most likely called with
  // `race([obs1, obs2, ...])`
  if (observables.length === 1) ***REMOVED***
    if (isArray(observables[0])) ***REMOVED***
      observables = observables[0] as Observable<any>[];
    ***REMOVED*** else ***REMOVED***
      return observables[0] as Observable<T>;
    ***REMOVED***
  ***REMOVED***

  return fromArray(observables, undefined).lift(new RaceOperator<T>());
***REMOVED***

export class RaceOperator<T> implements Operator<T, T> ***REMOVED***
  call(subscriber: Subscriber<T>, source: any): TeardownLogic ***REMOVED***
    return source.subscribe(new RaceSubscriber(subscriber));
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
export class RaceSubscriber<T> extends OuterSubscriber<T, T> ***REMOVED***
  private hasFirst: boolean = false;
  private observables: Observable<any>[] = [];
  private subscriptions: Subscription[] = [];

  constructor(destination: Subscriber<T>) ***REMOVED***
    super(destination);
  ***REMOVED***

  protected _next(observable: any): void ***REMOVED***
    this.observables.push(observable);
  ***REMOVED***

  protected _complete() ***REMOVED***
    const observables = this.observables;
    const len = observables.length;

    if (len === 0) ***REMOVED***
      this.destination.complete();
    ***REMOVED*** else ***REMOVED***
      for (let i = 0; i < len && !this.hasFirst; i++) ***REMOVED***
        let observable = observables[i];
        let subscription = subscribeToResult(this, observable, observable as any, i);

        if (this.subscriptions) ***REMOVED***
          this.subscriptions.push(subscription);
        ***REMOVED***
        this.add(subscription);
      ***REMOVED***
      this.observables = null;
    ***REMOVED***
  ***REMOVED***

  notifyNext(outerValue: T, innerValue: T,
             outerIndex: number, innerIndex: number,
             innerSub: InnerSubscriber<T, T>): void ***REMOVED***
    if (!this.hasFirst) ***REMOVED***
      this.hasFirst = true;

      for (let i = 0; i < this.subscriptions.length; i++) ***REMOVED***
        if (i !== outerIndex) ***REMOVED***
          let subscription = this.subscriptions[i];

          subscription.unsubscribe();
          this.remove(subscription);
        ***REMOVED***
      ***REMOVED***

      this.subscriptions = null;
    ***REMOVED***

    this.destination.next(innerValue);
  ***REMOVED***
***REMOVED***
