import ***REMOVED*** Subject ***REMOVED*** from '../Subject';
import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** ConnectableObservable, connectableObservableDescriptor ***REMOVED*** from '../observable/ConnectableObservable';
import ***REMOVED*** MonoTypeOperatorFunction, OperatorFunction, UnaryFunction, ObservedValueOf, ObservableInput ***REMOVED*** from '../types';

/* tslint:disable:max-line-length */
export function multicast<T>(subject: Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;
export function multicast<T, O extends ObservableInput<any>>(subject: Subject<T>, selector: (shared: Observable<T>) => O): UnaryFunction<Observable<T>, ConnectableObservable<ObservedValueOf<O>>>;
export function multicast<T>(subjectFactory: (this: Observable<T>) => Subject<T>): UnaryFunction<Observable<T>, ConnectableObservable<T>>;
export function multicast<T, O extends ObservableInput<any>>(SubjectFactory: (this: Observable<T>) => Subject<T>, selector: (shared: Observable<T>) => O): OperatorFunction<T, ObservedValueOf<O>>;
/* tslint:enable:max-line-length */

/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * ![](multicast.png)
 *
 * @param ***REMOVED***Function|Subject***REMOVED*** subjectOrSubjectFactory - Factory function to create an intermediate subject through
 * which the source sequence's elements will be multicast to the selector function
 * or Subject to push source elements into.
 * @param ***REMOVED***Function***REMOVED*** [selector] - Optional selector function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return ***REMOVED***Observable***REMOVED*** An Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */
export function multicast<T, R>(subjectOrSubjectFactory: Subject<T> | (() => Subject<T>),
                                selector?: (source: Observable<T>) => Observable<R>): OperatorFunction<T, R> ***REMOVED***
  return function multicastOperatorFunction(source: Observable<T>): Observable<R> ***REMOVED***
    let subjectFactory: () => Subject<T>;
    if (typeof subjectOrSubjectFactory === 'function') ***REMOVED***
      subjectFactory = <() => Subject<T>>subjectOrSubjectFactory;
    ***REMOVED*** else ***REMOVED***
      subjectFactory = function subjectFactory() ***REMOVED***
        return <Subject<T>>subjectOrSubjectFactory;
      ***REMOVED***;
    ***REMOVED***

    if (typeof selector === 'function') ***REMOVED***
      return source.lift(new MulticastOperator(subjectFactory, selector));
    ***REMOVED***

    const connectable: any = Object.create(source, connectableObservableDescriptor);
    connectable.source = source;
    connectable.subjectFactory = subjectFactory;

    return <ConnectableObservable<R>> connectable;
  ***REMOVED***;
***REMOVED***

export class MulticastOperator<T, R> implements Operator<T, R> ***REMOVED***
  constructor(private subjectFactory: () => Subject<T>,
              private selector: (source: Observable<T>) => Observable<R>) ***REMOVED***
  ***REMOVED***
  call(subscriber: Subscriber<R>, source: any): any ***REMOVED***
    const ***REMOVED*** selector ***REMOVED*** = this;
    const subject = this.subjectFactory();
    const subscription = selector(subject).subscribe(subscriber);
    subscription.add(source.subscribe(subject));
    return subscription;
  ***REMOVED***
***REMOVED***
