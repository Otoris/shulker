import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** ReplaySubject ***REMOVED*** from '../ReplaySubject';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';
import ***REMOVED*** MonoTypeOperatorFunction, SchedulerLike ***REMOVED*** from '../types';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';

export interface ShareReplayConfig ***REMOVED***
  bufferSize?: number;
  windowTime?: number;
  refCount: boolean;
  scheduler?: SchedulerLike;
***REMOVED***

/**
 * Share source and replay specified number of emissions on subscription.
 *
 * This operator is a specialization of `replay` that connects to a source observable
 * and multicasts through a `ReplaySubject` constructed with the specified arguments.
 * A successfully completed source will stay cached in the `shareReplayed observable` forever,
 * but an errored source can be retried.
 *
 * ## Why use shareReplay?
 * You generally want to use `shareReplay` when you have side-effects or taxing computations
 * that you do not wish to be executed amongst multiple subscribers.
 * It may also be valuable in situations where you know you will have late subscribers to
 * a stream that need access to previously emitted values.
 * This ability to replay values on subscription is what differentiates ***REMOVED***@link share***REMOVED*** and `shareReplay`.
 *
 * ![](shareReplay.png)
 *
 * ## Example
 * ```ts
 * import ***REMOVED*** interval ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** shareReplay, take ***REMOVED*** from 'rxjs/operators';
 *
 * const obs$ = interval(1000);
 * const shared$ = obs$.pipe(
 *   take(4),
 *   shareReplay(3)
 * );
 * shared$.subscribe(x => console.log('source A: ', x));
 * shared$.subscribe(y => console.log('source B: ', y));
 *
 * ```
 *
 * @see ***REMOVED***@link publish***REMOVED***
 * @see ***REMOVED***@link share***REMOVED***
 * @see ***REMOVED***@link publishReplay***REMOVED***
 *
 * @param ***REMOVED***Number***REMOVED*** [bufferSize=Number.POSITIVE_INFINITY] Maximum element count of the replay buffer.
 * @param ***REMOVED***Number***REMOVED*** [windowTime=Number.POSITIVE_INFINITY] Maximum time length of the replay buffer in milliseconds.
 * @param ***REMOVED***Scheduler***REMOVED*** [scheduler] Scheduler where connected observers within the selector function
 * will be invoked on.
 * @return ***REMOVED***Observable***REMOVED*** An observable sequence that contains the elements of a sequence produced
 * by multicasting the source sequence within a selector function.
 * @method shareReplay
 * @owner Observable
 */
export function shareReplay<T>(config: ShareReplayConfig): MonoTypeOperatorFunction<T>;
export function shareReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;
export function shareReplay<T>(
  configOrBufferSize?: ShareReplayConfig | number,
  windowTime?: number,
  scheduler?: SchedulerLike
): MonoTypeOperatorFunction<T> ***REMOVED***
  let config: ShareReplayConfig;
  if (configOrBufferSize && typeof configOrBufferSize === 'object') ***REMOVED***
    config = configOrBufferSize as ShareReplayConfig;
  ***REMOVED*** else ***REMOVED***
    config = ***REMOVED***
      bufferSize: configOrBufferSize as number | undefined,
      windowTime,
      refCount: false,
      scheduler
    ***REMOVED***;
  ***REMOVED***
  return (source: Observable<T>) => source.lift(shareReplayOperator(config));
***REMOVED***

function shareReplayOperator<T>(***REMOVED***
  bufferSize = Number.POSITIVE_INFINITY,
  windowTime = Number.POSITIVE_INFINITY,
  refCount: useRefCount,
  scheduler
***REMOVED***: ShareReplayConfig) ***REMOVED***
  let subject: ReplaySubject<T> | undefined;
  let refCount = 0;
  let subscription: Subscription | undefined;
  let hasError = false;
  let isComplete = false;

  return function shareReplayOperation(this: Subscriber<T>, source: Observable<T>) ***REMOVED***
    refCount++;
    if (!subject || hasError) ***REMOVED***
      hasError = false;
      subject = new ReplaySubject<T>(bufferSize, windowTime, scheduler);
      subscription = source.subscribe(***REMOVED***
        next(value) ***REMOVED*** subject.next(value); ***REMOVED***,
        error(err) ***REMOVED***
          hasError = true;
          subject.error(err);
        ***REMOVED***,
        complete() ***REMOVED***
          isComplete = true;
          subscription = undefined;
          subject.complete();
        ***REMOVED***,
      ***REMOVED***);
    ***REMOVED***

    const innerSub = subject.subscribe(this);
    this.add(() => ***REMOVED***
      refCount--;
      innerSub.unsubscribe();
      if (subscription && !isComplete && useRefCount && refCount === 0) ***REMOVED***
        subscription.unsubscribe();
        subscription = undefined;
        subject = undefined;
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***;
***REMOVED***
