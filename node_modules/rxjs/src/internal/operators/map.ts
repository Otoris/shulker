import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** OperatorFunction ***REMOVED*** from '../types';

/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * ![](map.png)
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * ## Example
 * Map every click to the clientX position of that click
 * ```ts
 * import ***REMOVED*** fromEvent ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** map ***REMOVED*** from 'rxjs/operators';
 *
 * const clicks = fromEvent(document, 'click');
 * const positions = clicks.pipe(map(ev => ev.clientX));
 * positions.subscribe(x => console.log(x));
 * ```
 *
 * @see ***REMOVED***@link mapTo***REMOVED***
 * @see ***REMOVED***@link pluck***REMOVED***
 *
 * @param ***REMOVED***function(value: T, index: number): R***REMOVED*** project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param ***REMOVED***any***REMOVED*** [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return ***REMOVED***Observable<R>***REMOVED*** An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
export function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> ***REMOVED***
  return function mapOperation(source: Observable<T>): Observable<R> ***REMOVED***
    if (typeof project !== 'function') ***REMOVED***
      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    ***REMOVED***
    return source.lift(new MapOperator(project, thisArg));
  ***REMOVED***;
***REMOVED***

export class MapOperator<T, R> implements Operator<T, R> ***REMOVED***
  constructor(private project: (value: T, index: number) => R, private thisArg: any) ***REMOVED***
  ***REMOVED***

  call(subscriber: Subscriber<R>, source: any): any ***REMOVED***
    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class MapSubscriber<T, R> extends Subscriber<T> ***REMOVED***
  count: number = 0;
  private thisArg: any;

  constructor(destination: Subscriber<R>,
              private project: (value: T, index: number) => R,
              thisArg: any) ***REMOVED***
    super(destination);
    this.thisArg = thisArg || this;
  ***REMOVED***

  // NOTE: This looks unoptimized, but it's actually purposefully NOT
  // using try/catch optimizations.
  protected _next(value: T) ***REMOVED***
    let result: R;
    try ***REMOVED***
      result = this.project.call(this.thisArg, value, this.count++);
    ***REMOVED*** catch (err) ***REMOVED***
      this.destination.error(err);
      return;
    ***REMOVED***
    this.destination.next(result);
  ***REMOVED***
***REMOVED***
