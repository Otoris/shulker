import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';
import ***REMOVED*** OuterSubscriber ***REMOVED*** from '../OuterSubscriber';
import ***REMOVED*** InnerSubscriber ***REMOVED*** from '../InnerSubscriber';
import ***REMOVED*** subscribeToResult ***REMOVED*** from '../util/subscribeToResult';
import ***REMOVED*** MonoTypeOperatorFunction, TeardownLogic ***REMOVED*** from '../types';

/* tslint:disable:max-line-length */
/** @deprecated In future versions, empty notifiers will no longer re-emit the source value on the output observable. */
export function delayWhen<T>(delayDurationSelector: (value: T, index: number) => Observable<never>, subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T>;
export function delayWhen<T>(delayDurationSelector: (value: T, index: number) => Observable<any>, subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T>;
/* tslint:disable:max-line-length */

/**
 * Delays the emission of items from the source Observable by a given time span
 * determined by the emissions of another Observable.
 *
 * <span class="informal">It's like ***REMOVED***@link delay***REMOVED***, but the time span of the
 * delay duration is determined by a second Observable.</span>
 *
 * ![](delayWhen.png)
 *
 * `delayWhen` time shifts each emitted value from the source Observable by a
 * time span determined by another Observable. When the source emits a value,
 * the `delayDurationSelector` function is called with the source value as
 * argument, and should return an Observable, called the "duration" Observable.
 * The source value is emitted on the output Observable only when the duration
 * Observable emits a value or completes.
 * The completion of the notifier triggering the emission of the source value
 * is deprecated behavior and will be removed in future versions.
 *
 * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
 * is an Observable. When `subscriptionDelay` emits its first value or
 * completes, the source Observable is subscribed to and starts behaving like
 * described in the previous paragraph. If `subscriptionDelay` is not provided,
 * `delayWhen` will subscribe to the source Observable as soon as the output
 * Observable is subscribed.
 *
 * ## Example
 * Delay each click by a random amount of time, between 0 and 5 seconds
 * ```ts
 * import ***REMOVED*** fromEvent, interval ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** delayWhen ***REMOVED*** from 'rxjs/operators';
 *
 * const clicks = fromEvent(document, 'click');
 * const delayedClicks = clicks.pipe(
 *   delayWhen(event => interval(Math.random() * 5000)),
 * );
 * delayedClicks.subscribe(x => console.log(x));
 * ```
 *
 * @see ***REMOVED***@link delay***REMOVED***
 * @see ***REMOVED***@link throttle***REMOVED***
 * @see ***REMOVED***@link throttleTime***REMOVED***
 * @see ***REMOVED***@link debounce***REMOVED***
 * @see ***REMOVED***@link debounceTime***REMOVED***
 * @see ***REMOVED***@link sample***REMOVED***
 * @see ***REMOVED***@link sampleTime***REMOVED***
 * @see ***REMOVED***@link audit***REMOVED***
 * @see ***REMOVED***@link auditTime***REMOVED***
 *
 * @param ***REMOVED***function(value: T, index: number): Observable***REMOVED*** delayDurationSelector A function that
 * returns an Observable for each value emitted by the source Observable, which
 * is then used to delay the emission of that item on the output Observable
 * until the Observable returned from this function emits a value.
 * @param ***REMOVED***Observable***REMOVED*** subscriptionDelay An Observable that triggers the
 * subscription to the source Observable once it emits any value.
 * @return ***REMOVED***Observable***REMOVED*** An Observable that delays the emissions of the source
 * Observable by an amount of time specified by the Observable returned by
 * `delayDurationSelector`.
 * @method delayWhen
 * @owner Observable
 */
export function delayWhen<T>(delayDurationSelector: (value: T, index: number) => Observable<any>,
                             subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T> ***REMOVED***
  if (subscriptionDelay) ***REMOVED***
    return (source: Observable<T>) =>
      new SubscriptionDelayObservable(source, subscriptionDelay)
        .lift(new DelayWhenOperator(delayDurationSelector));
  ***REMOVED***
  return (source: Observable<T>) => source.lift(new DelayWhenOperator(delayDurationSelector));
***REMOVED***

class DelayWhenOperator<T> implements Operator<T, T> ***REMOVED***
  constructor(private delayDurationSelector: (value: T, index: number) => Observable<any>) ***REMOVED***
  ***REMOVED***

  call(subscriber: Subscriber<T>, source: any): TeardownLogic ***REMOVED***
    return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class DelayWhenSubscriber<T, R> extends OuterSubscriber<T, R> ***REMOVED***
  private completed: boolean = false;
  private delayNotifierSubscriptions: Array<Subscription> = [];
  private index: number = 0;

  constructor(destination: Subscriber<T>,
              private delayDurationSelector: (value: T, index: number) => Observable<any>) ***REMOVED***
    super(destination);
  ***REMOVED***

  notifyNext(outerValue: T, innerValue: any,
             outerIndex: number, innerIndex: number,
             innerSub: InnerSubscriber<T, R>): void ***REMOVED***
    this.destination.next(outerValue);
    this.removeSubscription(innerSub);
    this.tryComplete();
  ***REMOVED***

  notifyError(error: any, innerSub: InnerSubscriber<T, R>): void ***REMOVED***
    this._error(error);
  ***REMOVED***

  notifyComplete(innerSub: InnerSubscriber<T, R>): void ***REMOVED***
    const value = this.removeSubscription(innerSub);
    if (value) ***REMOVED***
      this.destination.next(value);
    ***REMOVED***
    this.tryComplete();
  ***REMOVED***

  protected _next(value: T): void ***REMOVED***
    const index = this.index++;
    try ***REMOVED***
      const delayNotifier = this.delayDurationSelector(value, index);
      if (delayNotifier) ***REMOVED***
        this.tryDelay(delayNotifier, value);
      ***REMOVED***
    ***REMOVED*** catch (err) ***REMOVED***
      this.destination.error(err);
    ***REMOVED***
  ***REMOVED***

  protected _complete(): void ***REMOVED***
    this.completed = true;
    this.tryComplete();
    this.unsubscribe();
  ***REMOVED***

  private removeSubscription(subscription: InnerSubscriber<T, R>): T ***REMOVED***
    subscription.unsubscribe();

    const subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
    if (subscriptionIdx !== -1) ***REMOVED***
      this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
    ***REMOVED***

    return subscription.outerValue;
  ***REMOVED***

  private tryDelay(delayNotifier: Observable<any>, value: T): void ***REMOVED***
    const notifierSubscription = subscribeToResult(this, delayNotifier, value);

    if (notifierSubscription && !notifierSubscription.closed) ***REMOVED***
      const destination = this.destination as Subscription;
      destination.add(notifierSubscription);
      this.delayNotifierSubscriptions.push(notifierSubscription);
    ***REMOVED***
  ***REMOVED***

  private tryComplete(): void ***REMOVED***
    if (this.completed && this.delayNotifierSubscriptions.length === 0) ***REMOVED***
      this.destination.complete();
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class SubscriptionDelayObservable<T> extends Observable<T> ***REMOVED***
  constructor(public source: Observable<T>, private subscriptionDelay: Observable<any>) ***REMOVED***
    super();
  ***REMOVED***

  /** @deprecated This is an internal implementation detail, do not use. */
  _subscribe(subscriber: Subscriber<T>) ***REMOVED***
    this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class SubscriptionDelaySubscriber<T> extends Subscriber<T> ***REMOVED***
  private sourceSubscribed: boolean = false;

  constructor(private parent: Subscriber<T>, private source: Observable<T>) ***REMOVED***
    super();
  ***REMOVED***

  protected _next(unused: any) ***REMOVED***
    this.subscribeToSource();
  ***REMOVED***

  protected _error(err: any) ***REMOVED***
    this.unsubscribe();
    this.parent.error(err);
  ***REMOVED***

  protected _complete() ***REMOVED***
    this.unsubscribe();
    this.subscribeToSource();
  ***REMOVED***

  private subscribeToSource(): void ***REMOVED***
    if (!this.sourceSubscribed) ***REMOVED***
      this.sourceSubscribed = true;
      this.unsubscribe();
      this.source.subscribe(this.parent);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
