import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';

import ***REMOVED*** OuterSubscriber ***REMOVED*** from '../OuterSubscriber';
import ***REMOVED*** InnerSubscriber ***REMOVED*** from '../InnerSubscriber';
import ***REMOVED*** subscribeToResult ***REMOVED*** from '../util/subscribeToResult';
import ***REMOVED*** ObservableInput, OperatorFunction, ObservedValueOf ***REMOVED*** from '../types';

/* tslint:disable:max-line-length */
export function catchError<T, O extends ObservableInput<any>>(selector: (err: any, caught: Observable<T>) => O): OperatorFunction<T, T | ObservedValueOf<O>>;
/* tslint:enable:max-line-length */

/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * ![](catch.png)
 *
 * ## Examples
 * Continues with a different Observable when there's an error
 *
 * ```ts
 * import ***REMOVED*** of ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** map, catchError ***REMOVED*** from 'rxjs/operators';
 *
 * of(1, 2, 3, 4, 5).pipe(
 *     map(n => ***REMOVED***
 *   	   if (n === 4) ***REMOVED***
 * 	       throw 'four!';
 *       ***REMOVED***
 *	     return n;
 *     ***REMOVED***),
 *     catchError(err => of('I', 'II', 'III', 'IV', 'V')),
 *   )
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 * ```
 *
 * Retries the caught source Observable again in case of error, similar to retry() operator
 *
 * ```ts
 * import ***REMOVED*** of ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** map, catchError, take ***REMOVED*** from 'rxjs/operators';
 *
 * of(1, 2, 3, 4, 5).pipe(
 *     map(n => ***REMOVED***
 *   	   if (n === 4) ***REMOVED***
 *   	     throw 'four!';
 *       ***REMOVED***
 * 	     return n;
 *     ***REMOVED***),
 *     catchError((err, caught) => caught),
 *     take(30),
 *   )
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 * ```
 *
 * Throws a new error when the source Observable throws an error
 *
 * ```ts
 * import ***REMOVED*** of ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** map, catchError ***REMOVED*** from 'rxjs/operators';
 *
 * of(1, 2, 3, 4, 5).pipe(
 *     map(n => ***REMOVED***
 *       if (n === 4) ***REMOVED***
 *         throw 'four!';
 *       ***REMOVED***
 *       return n;
 *     ***REMOVED***),
 *     catchError(err => ***REMOVED***
 *       throw 'error in source. Details: ' + err;
 *     ***REMOVED***),
 *   )
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 * ```
 *
 *  @param ***REMOVED***function***REMOVED*** selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return ***REMOVED***Observable***REMOVED*** An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @name catchError
 */
export function catchError<T, O extends ObservableInput<any>>(
  selector: (err: any, caught: Observable<T>) => O
): OperatorFunction<T, T | ObservedValueOf<O>> ***REMOVED***
  return function catchErrorOperatorFunction(source: Observable<T>): Observable<T | ObservedValueOf<O>> ***REMOVED***
    const operator = new CatchOperator(selector);
    const caught = source.lift(operator);
    return (operator.caught = caught as Observable<T>);
  ***REMOVED***;
***REMOVED***

class CatchOperator<T, R> implements Operator<T, T | R> ***REMOVED***
  caught: Observable<T>;

  constructor(private selector: (err: any, caught: Observable<T>) => ObservableInput<T | R>) ***REMOVED***
  ***REMOVED***

  call(subscriber: Subscriber<R>, source: any): any ***REMOVED***
    return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class CatchSubscriber<T, R> extends OuterSubscriber<T, T | R> ***REMOVED***
  constructor(destination: Subscriber<any>,
              private selector: (err: any, caught: Observable<T>) => ObservableInput<T | R>,
              private caught: Observable<T>) ***REMOVED***
    super(destination);
  ***REMOVED***

  // NOTE: overriding `error` instead of `_error` because we don't want
  // to have this flag this subscriber as `isStopped`. We can mimic the
  // behavior of the RetrySubscriber (from the `retry` operator), where
  // we unsubscribe from our source chain, reset our Subscriber flags,
  // then subscribe to the selector result.
  error(err: any) ***REMOVED***
    if (!this.isStopped) ***REMOVED***
      let result: any;
      try ***REMOVED***
        result = this.selector(err, this.caught);
      ***REMOVED*** catch (err2) ***REMOVED***
        super.error(err2);
        return;
      ***REMOVED***
      this._unsubscribeAndRecycle();
      const innerSubscriber = new InnerSubscriber(this, undefined, undefined);
      this.add(innerSubscriber);
      const innerSubscription = subscribeToResult(this, result, undefined, undefined, innerSubscriber);
      // The returned subscription will usually be the subscriber that was
      // passed. However, interop subscribers will be wrapped and for
      // unsubscriptions to chain correctly, the wrapper needs to be added, too.
      if (innerSubscription !== innerSubscriber) ***REMOVED***
        this.add(innerSubscription);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
