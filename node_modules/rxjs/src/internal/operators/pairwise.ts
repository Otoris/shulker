import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** OperatorFunction ***REMOVED*** from '../types';

/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * ![](pairwise.png)
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * ## Example
 * On every click (starting from the second), emit the relative distance to the previous click
 * ```ts
 * import ***REMOVED*** fromEvent ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** pairwise, map ***REMOVED*** from 'rxjs/operators';
 *
 * const clicks = fromEvent(document, 'click');
 * const pairs = clicks.pipe(pairwise());
 * const distance = pairs.pipe(
 *   map(pair => ***REMOVED***
 *     const x0 = pair[0].clientX;
 *     const y0 = pair[0].clientY;
 *     const x1 = pair[1].clientX;
 *     const y1 = pair[1].clientY;
 *     return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 *   ***REMOVED***),
 * );
 * distance.subscribe(x => console.log(x));
 * ```
 *
 * @see ***REMOVED***@link buffer***REMOVED***
 * @see ***REMOVED***@link bufferCount***REMOVED***
 *
 * @return ***REMOVED***Observable<Array<T>>***REMOVED*** An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
export function pairwise<T>(): OperatorFunction<T, [T, T]> ***REMOVED***
  return (source: Observable<T>) => source.lift(new PairwiseOperator());
***REMOVED***

class PairwiseOperator<T> implements Operator<T, [T, T]> ***REMOVED***
  call(subscriber: Subscriber<[T, T]>, source: any): any ***REMOVED***
    return source.subscribe(new PairwiseSubscriber(subscriber));
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class PairwiseSubscriber<T> extends Subscriber<T> ***REMOVED***
  private prev: T;
  private hasPrev: boolean = false;

  constructor(destination: Subscriber<[T, T]>) ***REMOVED***
    super(destination);
  ***REMOVED***

  _next(value: T): void ***REMOVED***
    let pair: [T, T] | undefined;

    if (this.hasPrev) ***REMOVED***
      pair = [this.prev, value];
    ***REMOVED*** else ***REMOVED***
      this.hasPrev = true;
    ***REMOVED***

    this.prev = value;

    if (pair) ***REMOVED***
      this.destination.next(pair);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
