import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subject ***REMOVED*** from '../Subject';
import ***REMOVED*** OperatorFunction ***REMOVED*** from '../types';

/* tslint:disable:max-line-length */
export function groupBy<T, K>(keySelector: (value: T) => K): OperatorFunction<T, GroupedObservable<K, T>>;
export function groupBy<T, K>(keySelector: (value: T) => K, elementSelector: void, durationSelector: (grouped: GroupedObservable<K, T>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, T>>;
export function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>): OperatorFunction<T, GroupedObservable<K, R>>;
export function groupBy<T, K, R>(keySelector: (value: T) => K, elementSelector?: (value: T) => R, durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>, subjectSelector?: () => Subject<R>): OperatorFunction<T, GroupedObservable<K, R>>;
/* tslint:enable:max-line-length */

/**
 * Groups the items emitted by an Observable according to a specified criterion,
 * and emits these grouped items as `GroupedObservables`, one
 * ***REMOVED***@link GroupedObservable***REMOVED*** per group.
 *
 * ![](groupBy.png)
 *
 * When the Observable emits an item, a key is computed for this item with the keySelector function.
 *
 * If a ***REMOVED***@link GroupedObservable***REMOVED*** for this key exists, this ***REMOVED***@link GroupedObservable***REMOVED*** emits. Elsewhere, a new
 * ***REMOVED***@link GroupedObservable***REMOVED*** for this key is created and emits.
 *
 * A ***REMOVED***@link GroupedObservable***REMOVED*** represents values belonging to the same group represented by a common key. The common
 * key is available as the key field of a ***REMOVED***@link GroupedObservable***REMOVED*** instance.
 *
 * The elements emitted by ***REMOVED***@link GroupedObservable***REMOVED***s are by default the items emitted by the Observable, or elements
 * returned by the elementSelector function.
 *
 * ## Examples
 *
 * ### Group objects by id and return as array
 *
 * ```ts
 * import ***REMOVED*** of ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** mergeMap, groupBy, reduce ***REMOVED*** from 'rxjs/operators';
 *
 * of(
 *   ***REMOVED***id: 1, name: 'JavaScript'***REMOVED***,
 *   ***REMOVED***id: 2, name: 'Parcel'***REMOVED***,
 *   ***REMOVED***id: 2, name: 'webpack'***REMOVED***,
 *   ***REMOVED***id: 1, name: 'TypeScript'***REMOVED***,
 *   ***REMOVED***id: 3, name: 'TSLint'***REMOVED***
 * ).pipe(
 *   groupBy(p => p.id),
 *   mergeMap((group$) => group$.pipe(reduce((acc, cur) => [...acc, cur], []))),
 * )
 * .subscribe(p => console.log(p));
 *
 * // displays:
 * // [ ***REMOVED*** id: 1, name: 'JavaScript'***REMOVED***,
 * //   ***REMOVED*** id: 1, name: 'TypeScript'***REMOVED*** ]
 * //
 * // [ ***REMOVED*** id: 2, name: 'Parcel'***REMOVED***,
 * //   ***REMOVED*** id: 2, name: 'webpack'***REMOVED*** ]
 * //
 * // [ ***REMOVED*** id: 3, name: 'TSLint'***REMOVED*** ]
 * ```
 *
 * ### Pivot data on the id field
 *
 * ```ts
 * import ***REMOVED*** of ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** groupBy, map, mergeMap, reduce ***REMOVED*** from 'rxjs/operators';
 *
 * of(
 *   ***REMOVED*** id: 1, name: 'JavaScript' ***REMOVED***,
 *   ***REMOVED*** id: 2, name: 'Parcel' ***REMOVED***,
 *   ***REMOVED*** id: 2, name: 'webpack' ***REMOVED***,
 *   ***REMOVED*** id: 1, name: 'TypeScript' ***REMOVED***,
 *   ***REMOVED*** id: 3, name: 'TSLint' ***REMOVED***
 * )
 *   .pipe(
 *     groupBy(p => p.id, p => p.name),
 *     mergeMap(group$ =>
 *       group$.pipe(reduce((acc, cur) => [...acc, cur], [`$***REMOVED***group$.key***REMOVED***`]))
 *     ),
 *     map(arr => (***REMOVED*** id: parseInt(arr[0], 10), values: arr.slice(1) ***REMOVED***))
 *  )
 *  .subscribe(p => console.log(p));
 *
 * // displays:
 * // ***REMOVED*** id: 1, values: [ 'JavaScript', 'TypeScript' ] ***REMOVED***
 * // ***REMOVED*** id: 2, values: [ 'Parcel', 'webpack' ] ***REMOVED***
 * // ***REMOVED*** id: 3, values: [ 'TSLint' ] ***REMOVED***
 * ```
 *
 * @param ***REMOVED***function(value: T): K***REMOVED*** keySelector A function that extracts the key
 * for each item.
 * @param ***REMOVED***function(value: T): R***REMOVED*** [elementSelector] A function that extracts the
 * return element for each item.
 * @param ***REMOVED***function(grouped: GroupedObservable<K,R>): Observable<any>***REMOVED*** [durationSelector]
 * A function that returns an Observable to determine how long each group should
 * exist.
 * @return ***REMOVED***Observable<GroupedObservable<K,R>>***REMOVED*** An Observable that emits
 * GroupedObservables, each of which corresponds to a unique key value and each
 * of which emits those items from the source Observable that share that key
 * value.
 * @method groupBy
 * @owner Observable
 */
export function groupBy<T, K, R>(keySelector: (value: T) => K,
                                 elementSelector?: ((value: T) => R) | void,
                                 durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,
                                 subjectSelector?: () => Subject<R>): OperatorFunction<T, GroupedObservable<K, R>> ***REMOVED***
  return (source: Observable<T>) =>
    source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
***REMOVED***

export interface RefCountSubscription ***REMOVED***
  count: number;
  unsubscribe: () => void;
  closed: boolean;
  attemptedToUnsubscribe: boolean;
***REMOVED***

class GroupByOperator<T, K, R> implements Operator<T, GroupedObservable<K, R>> ***REMOVED***
  constructor(private keySelector: (value: T) => K,
              private elementSelector?: ((value: T) => R) | void,
              private durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,
              private subjectSelector?: () => Subject<R>) ***REMOVED***
  ***REMOVED***

  call(subscriber: Subscriber<GroupedObservable<K, R>>, source: any): any ***REMOVED***
    return source.subscribe(new GroupBySubscriber(
      subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector
    ));
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class GroupBySubscriber<T, K, R> extends Subscriber<T> implements RefCountSubscription ***REMOVED***
  private groups: Map<K, Subject<T | R>> = null;
  public attemptedToUnsubscribe: boolean = false;
  public count: number = 0;

  constructor(destination: Subscriber<GroupedObservable<K, R>>,
              private keySelector: (value: T) => K,
              private elementSelector?: ((value: T) => R) | void,
              private durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,
              private subjectSelector?: () => Subject<R>) ***REMOVED***
    super(destination);
  ***REMOVED***

  protected _next(value: T): void ***REMOVED***
    let key: K;
    try ***REMOVED***
      key = this.keySelector(value);
    ***REMOVED*** catch (err) ***REMOVED***
      this.error(err);
      return;
    ***REMOVED***

    this._group(value, key);
  ***REMOVED***

  private _group(value: T, key: K) ***REMOVED***
    let groups = this.groups;

    if (!groups) ***REMOVED***
      groups = this.groups = new Map<K, Subject<T | R>>();
    ***REMOVED***

    let group = groups.get(key);

    let element: R;
    if (this.elementSelector) ***REMOVED***
      try ***REMOVED***
        element = this.elementSelector(value);
      ***REMOVED*** catch (err) ***REMOVED***
        this.error(err);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      element = <any>value;
    ***REMOVED***

    if (!group) ***REMOVED***
      group = (this.subjectSelector ? this.subjectSelector() : new Subject<R>()) as Subject<T | R>;
      groups.set(key, group);
      const groupedObservable = new GroupedObservable(key, group, this);
      this.destination.next(groupedObservable);
      if (this.durationSelector) ***REMOVED***
        let duration: any;
        try ***REMOVED***
          duration = this.durationSelector(new GroupedObservable<K, R>(key, <Subject<R>>group));
        ***REMOVED*** catch (err) ***REMOVED***
          this.error(err);
          return;
        ***REMOVED***
        this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
      ***REMOVED***
    ***REMOVED***

    if (!group.closed) ***REMOVED***
      group.next(element);
    ***REMOVED***
  ***REMOVED***

  protected _error(err: any): void ***REMOVED***
    const groups = this.groups;
    if (groups) ***REMOVED***
      groups.forEach((group, key) => ***REMOVED***
        group.error(err);
      ***REMOVED***);

      groups.clear();
    ***REMOVED***
    this.destination.error(err);
  ***REMOVED***

  protected _complete(): void ***REMOVED***
    const groups = this.groups;
    if (groups) ***REMOVED***
      groups.forEach((group, key) => ***REMOVED***
        group.complete();
      ***REMOVED***);

      groups.clear();
    ***REMOVED***
    this.destination.complete();
  ***REMOVED***

  removeGroup(key: K): void ***REMOVED***
    this.groups.delete(key);
  ***REMOVED***

  unsubscribe() ***REMOVED***
    if (!this.closed) ***REMOVED***
      this.attemptedToUnsubscribe = true;
      if (this.count === 0) ***REMOVED***
        super.unsubscribe();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class GroupDurationSubscriber<K, T> extends Subscriber<T> ***REMOVED***
  constructor(private key: K,
              private group: Subject<T>,
              private parent: GroupBySubscriber<any, K, T | any>) ***REMOVED***
    super(group);
  ***REMOVED***

  protected _next(value: T): void ***REMOVED***
    this.complete();
  ***REMOVED***

  /** @deprecated This is an internal implementation detail, do not use. */
  _unsubscribe() ***REMOVED***
    const ***REMOVED*** parent, key ***REMOVED*** = this;
    this.key = this.parent = null;
    if (parent) ***REMOVED***
      parent.removeGroup(key);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * An Observable representing values belonging to the same group represented by
 * a common key. The values emitted by a GroupedObservable come from the source
 * Observable. The common key is available as the field `key` on a
 * GroupedObservable instance.
 *
 * @class GroupedObservable<K, T>
 */
export class GroupedObservable<K, T> extends Observable<T> ***REMOVED***
  /** @deprecated Do not construct this type. Internal use only */
  constructor(public key: K,
              private groupSubject: Subject<T>,
              private refCountSubscription?: RefCountSubscription) ***REMOVED***
    super();
  ***REMOVED***

  /** @deprecated This is an internal implementation detail, do not use. */
  _subscribe(subscriber: Subscriber<T>) ***REMOVED***
    const subscription = new Subscription();
    const ***REMOVED*** refCountSubscription, groupSubject ***REMOVED*** = this;
    if (refCountSubscription && !refCountSubscription.closed) ***REMOVED***
      subscription.add(new InnerRefCountSubscription(refCountSubscription));
    ***REMOVED***
    subscription.add(groupSubject.subscribe(subscriber));
    return subscription;
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class InnerRefCountSubscription extends Subscription ***REMOVED***
  constructor(private parent: RefCountSubscription) ***REMOVED***
    super();
    parent.count++;
  ***REMOVED***

  unsubscribe() ***REMOVED***
    const parent = this.parent;
    if (!parent.closed && !this.closed) ***REMOVED***
      super.unsubscribe();
      parent.count -= 1;
      if (parent.count === 0 && parent.attemptedToUnsubscribe) ***REMOVED***
        parent.unsubscribe();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
