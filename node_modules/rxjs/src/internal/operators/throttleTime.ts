import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';
import ***REMOVED*** async ***REMOVED*** from '../scheduler/async';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** ThrottleConfig, defaultThrottleConfig ***REMOVED*** from './throttle';
import ***REMOVED*** MonoTypeOperatorFunction, SchedulerLike, TeardownLogic ***REMOVED*** from '../types';

/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for `duration` milliseconds, then repeats this process.
 *
 * <span class="informal">Lets a value pass, then ignores source values for the
 * next `duration` milliseconds.</span>
 *
 * ![](throttleTime.png)
 *
 * `throttleTime` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled. After `duration` milliseconds (or the time unit determined
 * internally by the optional `scheduler`) has passed, the timer is disabled,
 * and this process repeats for the next source value. Optionally takes a
 * ***REMOVED***@link SchedulerLike***REMOVED*** for managing timers.
 *
 * ## Examples
 *
 * #### Limit click rate
 *
 * Emit clicks at a rate of at most one click per second
 * ```ts
 * import ***REMOVED*** fromEvent ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** throttleTime ***REMOVED*** from 'rxjs/operators';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(throttleTime(1000));
 * result.subscribe(x => console.log(x));
 * ```
 *
 * #### Double Click
 *
 * The following example only emits clicks which happen within a subsequent
 * delay of 400ms of the previous click. This for example can emulate a double
 * click. It makes use of the `trailing` parameter of the throttle configuration.
 *
 * ```ts
 * import ***REMOVED*** fromEvent, asyncScheduler ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** throttleTime, withLatestFrom ***REMOVED*** from 'rxjs/operators';
 *
 * // defaultThottleConfig = ***REMOVED*** leading: true, trailing: false ***REMOVED***
 * const throttleConfig = ***REMOVED***
 *   leading: false,
 *   trailing: true
 * ***REMOVED***
 *
 * const click = fromEvent(document, 'click');
 * const doubleClick = click.pipe(
 *   throttleTime(400, asyncScheduler, throttleConfig)
 * );
 *
 * doubleClick.subscribe((throttleValue: Event) => ***REMOVED***
 *   console.log(`Double-clicked! Timestamp: $***REMOVED***throttleValue.timeStamp***REMOVED***`);
 * ***REMOVED***);
 * ```
 *
 * If you enable the `leading` parameter in this example, the output would be the primary click and
 * the double click, but restricts additional clicks within 400ms.
 *
 * @see ***REMOVED***@link auditTime***REMOVED***
 * @see ***REMOVED***@link debounceTime***REMOVED***
 * @see ***REMOVED***@link delay***REMOVED***
 * @see ***REMOVED***@link sampleTime***REMOVED***
 * @see ***REMOVED***@link throttle***REMOVED***
 *
 * @param ***REMOVED***number***REMOVED*** duration Time to wait before emitting another value after
 * emitting the last value, measured in milliseconds or the time unit determined
 * internally by the optional `scheduler`.
 * @param ***REMOVED***SchedulerLike***REMOVED*** [scheduler=async] The ***REMOVED***@link SchedulerLike***REMOVED*** to use for
 * managing the timers that handle the throttling.
 * @param ***REMOVED***Object***REMOVED*** config a configuration object to define `leading` and
 * `trailing` behavior. Defaults to `***REMOVED*** leading: true, trailing: false ***REMOVED***`.
 * @return ***REMOVED***Observable<T>***REMOVED*** An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttleTime
 * @owner Observable
 */
export function throttleTime<T>(duration: number,
                                scheduler: SchedulerLike = async,
                                config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T> ***REMOVED***
  return (source: Observable<T>) => source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));
***REMOVED***

class ThrottleTimeOperator<T> implements Operator<T, T> ***REMOVED***
  constructor(private duration: number,
              private scheduler: SchedulerLike,
              private leading: boolean,
              private trailing: boolean) ***REMOVED***
  ***REMOVED***

  call(subscriber: Subscriber<T>, source: any): TeardownLogic ***REMOVED***
    return source.subscribe(
      new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing)
    );
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class ThrottleTimeSubscriber<T> extends Subscriber<T> ***REMOVED***
  private throttled: Subscription;
  private _hasTrailingValue: boolean = false;
  private _trailingValue: T = null;

  constructor(destination: Subscriber<T>,
              private duration: number,
              private scheduler: SchedulerLike,
              private leading: boolean,
              private trailing: boolean) ***REMOVED***
    super(destination);
  ***REMOVED***

  protected _next(value: T) ***REMOVED***
    if (this.throttled) ***REMOVED***
      if (this.trailing) ***REMOVED***
        this._trailingValue = value;
        this._hasTrailingValue = true;
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      this.add(this.throttled = this.scheduler.schedule<DispatchArg<T>>(dispatchNext, this.duration, ***REMOVED*** subscriber: this ***REMOVED***));
      if (this.leading) ***REMOVED***
        this.destination.next(value);
      ***REMOVED*** else if (this.trailing) ***REMOVED***
        this._trailingValue = value;
        this._hasTrailingValue = true;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  protected _complete() ***REMOVED***
    if (this._hasTrailingValue) ***REMOVED***
      this.destination.next(this._trailingValue);
      this.destination.complete();
    ***REMOVED*** else ***REMOVED***
      this.destination.complete();
    ***REMOVED***
  ***REMOVED***

  clearThrottle() ***REMOVED***
    const throttled = this.throttled;
    if (throttled) ***REMOVED***
      if (this.trailing && this._hasTrailingValue) ***REMOVED***
        this.destination.next(this._trailingValue);
        this._trailingValue = null;
        this._hasTrailingValue = false;
      ***REMOVED***
      throttled.unsubscribe();
      this.remove(throttled);
      this.throttled = null;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

interface DispatchArg<T> ***REMOVED***
  subscriber: ThrottleTimeSubscriber<T>;
***REMOVED***

function dispatchNext<T>(arg: DispatchArg<T>) ***REMOVED***
  const ***REMOVED*** subscriber ***REMOVED*** = arg;
  subscriber.clearThrottle();
***REMOVED***
