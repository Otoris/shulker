import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** EmptyError ***REMOVED*** from '../util/EmptyError';

import ***REMOVED*** Observer, MonoTypeOperatorFunction, TeardownLogic ***REMOVED*** from '../types';

/**
 * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
 * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
 * items, notify of an IllegalArgumentException or NoSuchElementException respectively. If the source Observable
 * emits items but none match the specified predicate then `undefined` is emitted.
 *
 * <span class="informal">Like ***REMOVED***@link first***REMOVED***, but emit with error notification if there is more than one value.</span>
 * ![](single.png)
 *
 * ## Example
 * emits 'error'
 * ```ts
 * import ***REMOVED*** range ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** single ***REMOVED*** from 'rxjs/operators';
 *
 * const numbers = range(1,5).pipe(single());
 * numbers.subscribe(x => console.log('never get called'), e => console.log('error'));
 * // result
 * // 'error'
 * ```
 *
 * emits 'undefined'
 * ```ts
 * import ***REMOVED*** range ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** single ***REMOVED*** from 'rxjs/operators';
 *
 * const numbers = range(1,5).pipe(single(x => x === 10));
 * numbers.subscribe(x => console.log(x));
 * // result
 * // 'undefined'
 * ```
 *
 * @see ***REMOVED***@link first***REMOVED***
 * @see ***REMOVED***@link find***REMOVED***
 * @see ***REMOVED***@link findIndex***REMOVED***
 * @see ***REMOVED***@link elementAt***REMOVED***
 *
 * @throws ***REMOVED***EmptyError***REMOVED*** Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param ***REMOVED***Function***REMOVED*** predicate - A predicate function to evaluate items emitted by the source Observable.
 * @return ***REMOVED***Observable<T>***REMOVED*** An Observable that emits the single item emitted by the source Observable that matches
 * the predicate or `undefined` when no items match.
 *
 * @method single
 * @owner Observable
 */
export function single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T> ***REMOVED***
  return (source: Observable<T>) => source.lift(new SingleOperator(predicate, source));
***REMOVED***

class SingleOperator<T> implements Operator<T, T> ***REMOVED***
  constructor(private predicate?: (value: T, index: number, source: Observable<T>) => boolean,
              private source?: Observable<T>) ***REMOVED***
  ***REMOVED***

  call(subscriber: Subscriber<T>, source: any): TeardownLogic ***REMOVED***
    return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class SingleSubscriber<T> extends Subscriber<T> ***REMOVED***
  private seenValue: boolean = false;
  private singleValue: T;
  private index: number = 0;

  constructor(destination: Observer<T>,
              private predicate?: (value: T, index: number, source: Observable<T>) => boolean,
              private source?: Observable<T>) ***REMOVED***
    super(destination);
  ***REMOVED***

  private applySingleValue(value: T): void ***REMOVED***
    if (this.seenValue) ***REMOVED***
      this.destination.error('Sequence contains more than one element');
    ***REMOVED*** else ***REMOVED***
      this.seenValue = true;
      this.singleValue = value;
    ***REMOVED***
  ***REMOVED***

  protected _next(value: T): void ***REMOVED***
    const index = this.index++;

    if (this.predicate) ***REMOVED***
      this.tryNext(value, index);
    ***REMOVED*** else ***REMOVED***
      this.applySingleValue(value);
    ***REMOVED***
  ***REMOVED***

  private tryNext(value: T, index: number): void ***REMOVED***
    try ***REMOVED***
      if (this.predicate(value, index, this.source)) ***REMOVED***
        this.applySingleValue(value);
      ***REMOVED***
    ***REMOVED*** catch (err) ***REMOVED***
      this.destination.error(err);
    ***REMOVED***
  ***REMOVED***

  protected _complete(): void ***REMOVED***
    const destination = this.destination;

    if (this.index > 0) ***REMOVED***
      destination.next(this.seenValue ? this.singleValue : undefined);
      destination.complete();
    ***REMOVED*** else ***REMOVED***
      destination.error(new EmptyError);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
