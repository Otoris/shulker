import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** Subject ***REMOVED*** from '../Subject';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';
import ***REMOVED*** OuterSubscriber ***REMOVED*** from '../OuterSubscriber';
import ***REMOVED*** InnerSubscriber ***REMOVED*** from '../InnerSubscriber';
import ***REMOVED*** subscribeToResult ***REMOVED*** from '../util/subscribeToResult';
import ***REMOVED*** OperatorFunction ***REMOVED*** from '../types';

/**
 * Branch out the source Observable values as a nested Observable starting from
 * an emission from `openings` and ending when the output of `closingSelector`
 * emits.
 *
 * <span class="informal">It's like ***REMOVED***@link bufferToggle***REMOVED***, but emits a nested
 * Observable instead of an array.</span>
 *
 * ![](windowToggle.png)
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows that contain those items
 * emitted by the source Observable between the time when the `openings`
 * Observable emits an item and when the Observable returned by
 * `closingSelector` emits an item.
 *
 * ## Example
 * Every other second, emit the click events from the next 500ms
 * ```ts
 * import ***REMOVED*** fromEvent, interval, EMPTY ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** windowToggle, mergeAll ***REMOVED*** from 'rxjs/operators';
 *
 * const clicks = fromEvent(document, 'click');
 * const openings = interval(1000);
 * const result = clicks.pipe(
 *   windowToggle(openings, i => i % 2 ? interval(500) : EMPTY),
 *   mergeAll()
 * );
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see ***REMOVED***@link window***REMOVED***
 * @see ***REMOVED***@link windowCount***REMOVED***
 * @see ***REMOVED***@link windowTime***REMOVED***
 * @see ***REMOVED***@link windowWhen***REMOVED***
 * @see ***REMOVED***@link bufferToggle***REMOVED***
 *
 * @param ***REMOVED***Observable<O>***REMOVED*** openings An observable of notifications to start new
 * windows.
 * @param ***REMOVED***function(value: O): Observable***REMOVED*** closingSelector A function that takes
 * the value emitted by the `openings` observable and returns an Observable,
 * which, when it emits (either `next` or `complete`), signals that the
 * associated window should complete.
 * @return ***REMOVED***Observable<Observable<T>>***REMOVED*** An observable of windows, which in turn
 * are Observables.
 * @method windowToggle
 * @owner Observable
 */
export function windowToggle<T, O>(openings: Observable<O>,
                                   closingSelector: (openValue: O) => Observable<any>): OperatorFunction<T, Observable<T>> ***REMOVED***
  return (source: Observable<T>) => source.lift(new WindowToggleOperator<T, O>(openings, closingSelector));
***REMOVED***

class WindowToggleOperator<T, O> implements Operator<T, Observable<T>> ***REMOVED***

  constructor(private openings: Observable<O>,
              private closingSelector: (openValue: O) => Observable<any>) ***REMOVED***
  ***REMOVED***

  call(subscriber: Subscriber<Observable<T>>, source: any): any ***REMOVED***
    return source.subscribe(new WindowToggleSubscriber(
      subscriber, this.openings, this.closingSelector
    ));
  ***REMOVED***
***REMOVED***

interface WindowContext<T> ***REMOVED***
  window: Subject<T>;
  subscription: Subscription;
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class WindowToggleSubscriber<T, O> extends OuterSubscriber<T, any> ***REMOVED***
  private contexts: WindowContext<T>[] = [];
  private openSubscription: Subscription;

  constructor(destination: Subscriber<Observable<T>>,
              private openings: Observable<O>,
              private closingSelector: (openValue: O) => Observable<any>) ***REMOVED***
    super(destination);
    this.add(this.openSubscription = subscribeToResult(this, openings, openings as any));
  ***REMOVED***

  protected _next(value: T) ***REMOVED***
    const ***REMOVED*** contexts ***REMOVED*** = this;
    if (contexts) ***REMOVED***
      const len = contexts.length;
      for (let i = 0; i < len; i++) ***REMOVED***
        contexts[i].window.next(value);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  protected _error(err: any) ***REMOVED***

    const ***REMOVED*** contexts ***REMOVED*** = this;
    this.contexts = null;

    if (contexts) ***REMOVED***
      const len = contexts.length;
      let index = -1;

      while (++index < len) ***REMOVED***
        const context = contexts[index];
        context.window.error(err);
        context.subscription.unsubscribe();
      ***REMOVED***
    ***REMOVED***

    super._error(err);
  ***REMOVED***

  protected _complete() ***REMOVED***
    const ***REMOVED*** contexts ***REMOVED*** = this;
    this.contexts = null;
    if (contexts) ***REMOVED***
      const len = contexts.length;
      let index = -1;
      while (++index < len) ***REMOVED***
        const context = contexts[index];
        context.window.complete();
        context.subscription.unsubscribe();
      ***REMOVED***
    ***REMOVED***
    super._complete();
  ***REMOVED***

  /** @deprecated This is an internal implementation detail, do not use. */
  _unsubscribe() ***REMOVED***
    const ***REMOVED*** contexts ***REMOVED*** = this;
    this.contexts = null;
    if (contexts) ***REMOVED***
      const len = contexts.length;
      let index = -1;
      while (++index < len) ***REMOVED***
        const context = contexts[index];
        context.window.unsubscribe();
        context.subscription.unsubscribe();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  notifyNext(outerValue: any, innerValue: any,
             outerIndex: number, innerIndex: number,
             innerSub: InnerSubscriber<T, any>): void ***REMOVED***

    if (outerValue === this.openings) ***REMOVED***
      let closingNotifier;
      try ***REMOVED***
        const ***REMOVED*** closingSelector ***REMOVED*** = this;
        closingNotifier = closingSelector(innerValue);
      ***REMOVED*** catch (e) ***REMOVED***
        return this.error(e);
      ***REMOVED***

      const window = new Subject<T>();
      const subscription = new Subscription();
      const context = ***REMOVED*** window, subscription ***REMOVED***;
      this.contexts.push(context);
      const innerSubscription = subscribeToResult(this, closingNotifier, context as any);

      if (innerSubscription.closed) ***REMOVED***
        this.closeWindow(this.contexts.length - 1);
      ***REMOVED*** else ***REMOVED***
        (<any>innerSubscription).context = context;
        subscription.add(innerSubscription);
      ***REMOVED***

      this.destination.next(window);
    ***REMOVED*** else ***REMOVED***
      this.closeWindow(this.contexts.indexOf(outerValue));
    ***REMOVED***
  ***REMOVED***

  notifyError(err: any): void ***REMOVED***
    this.error(err);
  ***REMOVED***

  notifyComplete(inner: Subscription): void ***REMOVED***
    if (inner !== this.openSubscription) ***REMOVED***
      this.closeWindow(this.contexts.indexOf((<any> inner).context));
    ***REMOVED***
  ***REMOVED***

  private closeWindow(index: number): void ***REMOVED***
    if (index === -1) ***REMOVED***
      return;
    ***REMOVED***

    const ***REMOVED*** contexts ***REMOVED*** = this;
    const context = contexts[index];
    const ***REMOVED*** window, subscription ***REMOVED*** = context;
    contexts.splice(index, 1);
    window.complete();
    subscription.unsubscribe();
  ***REMOVED***
***REMOVED***
