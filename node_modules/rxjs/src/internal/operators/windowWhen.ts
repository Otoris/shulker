import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** Subject ***REMOVED*** from '../Subject';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';
import ***REMOVED*** OuterSubscriber ***REMOVED*** from '../OuterSubscriber';
import ***REMOVED*** InnerSubscriber ***REMOVED*** from '../InnerSubscriber';
import ***REMOVED*** subscribeToResult ***REMOVED*** from '../util/subscribeToResult';
import ***REMOVED*** OperatorFunction ***REMOVED*** from '../types';

/**
 * Branch out the source Observable values as a nested Observable using a
 * factory function of closing Observables to determine when to start a new
 * window.
 *
 * <span class="informal">It's like ***REMOVED***@link bufferWhen***REMOVED***, but emits a nested
 * Observable instead of an array.</span>
 *
 * ![](windowWhen.png)
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping windows.
 * It emits the current window and opens a new one whenever the Observable
 * produced by the specified `closingSelector` function emits an item. The first
 * window is opened immediately when subscribing to the output Observable.
 *
 * ## Example
 * Emit only the first two clicks events in every window of [1-5] random seconds
 * ```ts
 * import ***REMOVED*** fromEvent, interval ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** windowWhen, map, mergeAll, take ***REMOVED*** from 'rxjs/operators';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(
 *   windowWhen(() => interval(1000 + Math.random() * 4000)),
 *   map(win => win.pipe(take(2))),     // each window has at most 2 emissions
 *   mergeAll()                         // flatten the Observable-of-Observables
 * );
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see ***REMOVED***@link window***REMOVED***
 * @see ***REMOVED***@link windowCount***REMOVED***
 * @see ***REMOVED***@link windowTime***REMOVED***
 * @see ***REMOVED***@link windowToggle***REMOVED***
 * @see ***REMOVED***@link bufferWhen***REMOVED***
 *
 * @param ***REMOVED***function(): Observable***REMOVED*** closingSelector A function that takes no
 * arguments and returns an Observable that signals (on either `next` or
 * `complete`) when to close the previous window and start a new one.
 * @return ***REMOVED***Observable<Observable<T>>***REMOVED*** An observable of windows, which in turn
 * are Observables.
 * @method windowWhen
 * @owner Observable
 */
export function windowWhen<T>(closingSelector: () => Observable<any>): OperatorFunction<T, Observable<T>> ***REMOVED***
  return function windowWhenOperatorFunction(source: Observable<T>) ***REMOVED***
    return source.lift(new WindowOperator<T>(closingSelector));
  ***REMOVED***;
***REMOVED***

class WindowOperator<T> implements Operator<T, Observable<T>> ***REMOVED***
  constructor(private closingSelector: () => Observable<any>) ***REMOVED***
  ***REMOVED***

  call(subscriber: Subscriber<Observable<T>>, source: any): any ***REMOVED***
    return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class WindowSubscriber<T> extends OuterSubscriber<T, any> ***REMOVED***
  private window: Subject<T>;
  private closingNotification: Subscription;

  constructor(protected destination: Subscriber<Observable<T>>,
              private closingSelector: () => Observable<any>) ***REMOVED***
    super(destination);
    this.openWindow();
  ***REMOVED***

  notifyNext(outerValue: T, innerValue: any,
             outerIndex: number, innerIndex: number,
             innerSub: InnerSubscriber<T, any>): void ***REMOVED***
    this.openWindow(innerSub);
  ***REMOVED***

  notifyError(error: any, innerSub: InnerSubscriber<T, any>): void ***REMOVED***
    this._error(error);
  ***REMOVED***

  notifyComplete(innerSub: InnerSubscriber<T, any>): void ***REMOVED***
    this.openWindow(innerSub);
  ***REMOVED***

  protected _next(value: T): void ***REMOVED***
    this.window.next(value);
  ***REMOVED***

  protected _error(err: any): void ***REMOVED***
    this.window.error(err);
    this.destination.error(err);
    this.unsubscribeClosingNotification();
  ***REMOVED***

  protected _complete(): void ***REMOVED***
    this.window.complete();
    this.destination.complete();
    this.unsubscribeClosingNotification();
  ***REMOVED***

  private unsubscribeClosingNotification(): void ***REMOVED***
    if (this.closingNotification) ***REMOVED***
      this.closingNotification.unsubscribe();
    ***REMOVED***
  ***REMOVED***

  private openWindow(innerSub: InnerSubscriber<T, any> = null): void ***REMOVED***
    if (innerSub) ***REMOVED***
      this.remove(innerSub);
      innerSub.unsubscribe();
    ***REMOVED***

    const prevWindow = this.window;
    if (prevWindow) ***REMOVED***
      prevWindow.complete();
    ***REMOVED***

    const window = this.window = new Subject<T>();
    this.destination.next(window);

    let closingNotifier;
    try ***REMOVED***
      const ***REMOVED*** closingSelector ***REMOVED*** = this;
      closingNotifier = closingSelector();
    ***REMOVED*** catch (e) ***REMOVED***
      this.destination.error(e);
      this.window.error(e);
      return;
    ***REMOVED***
    this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
  ***REMOVED***
***REMOVED***
