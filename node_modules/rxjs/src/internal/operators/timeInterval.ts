
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** async ***REMOVED*** from '../scheduler/async';
import ***REMOVED*** SchedulerLike, OperatorFunction ***REMOVED*** from '../types';
import ***REMOVED*** scan ***REMOVED*** from './scan';
import ***REMOVED*** defer ***REMOVED*** from '../observable/defer';
import ***REMOVED*** map ***REMOVED*** from './map';

/**
 *
 * Emits an object containing the current value, and the time that has
 * passed between emitting the current value and the previous value, which is
 * calculated by using the provided `scheduler`'s `now()` method to retrieve
 * the current time at each emission, then calculating the difference. The `scheduler`
 * defaults to ***REMOVED***@link asyncScheduler***REMOVED***, so by default, the `interval` will be in
 * milliseconds.
 *
 * <span class="informal">Convert an Observable that emits items into one that
 * emits indications of the amount of time elapsed between those emissions.</span>
 *
 * ![](timeinterval.png)
 *
 * ## Examples
 * Emit inteval between current value with the last value
 *
 * ```ts
 * const seconds = interval(1000);
 *
 * seconds.pipe(timeInterval())
 * .subscribe(
 *     value => console.log(value),
 *     err => console.log(err),
 * );
 *
 * seconds.pipe(timeout(900))
 * .subscribe(
 *     value => console.log(value),
 *     err => console.log(err),
 * );
 *
 * // NOTE: The values will never be this precise,
 * // intervals created with `interval` or `setInterval`
 * // are non-deterministic.
 *
 * // ***REMOVED***value: 0, interval: 1000***REMOVED***
 * // ***REMOVED***value: 1, interval: 1000***REMOVED***
 * // ***REMOVED***value: 2, interval: 1000***REMOVED***
 * ```
 *
 * @param ***REMOVED***SchedulerLike***REMOVED*** [scheduler] Scheduler used to get the current time.
 * @return ***REMOVED***Observable<***REMOVED*** interval: number, value: T ***REMOVED***>***REMOVED*** Observable that emit infomation about value and interval
 * @method timeInterval
 */
export function timeInterval<T>(scheduler: SchedulerLike = async): OperatorFunction<T, TimeInterval<T>> ***REMOVED***
  return (source: Observable<T>) => defer(() => ***REMOVED***
    return source.pipe(
      // TODO(benlesh): correct these typings.
      scan(
        (***REMOVED*** current ***REMOVED***, value) => (***REMOVED*** value, current: scheduler.now(), last: current ***REMOVED***),
        ***REMOVED*** current: scheduler.now(), value: undefined,  last: undefined ***REMOVED***
      ) as any,
      map<any, TimeInterval<T>>((***REMOVED*** current, last, value ***REMOVED***) => new TimeInterval(value, current - last)),
    );
  ***REMOVED***);
***REMOVED***

// TODO(benlesh): make this an interface, export the interface, but not the implemented class,
// there's no reason users should be manually creating this type.

/**
 * @deprecated exposed API, use as interface only.
 */
export class TimeInterval<T> ***REMOVED***
  constructor(public value: T, public interval: number) ***REMOVED******REMOVED***
***REMOVED***
