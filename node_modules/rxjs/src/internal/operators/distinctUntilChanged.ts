import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** MonoTypeOperatorFunction, TeardownLogic ***REMOVED*** from '../types';

/* tslint:disable:max-line-length */
export function distinctUntilChanged<T>(compare?: (x: T, y: T) => boolean): MonoTypeOperatorFunction<T>;
export function distinctUntilChanged<T, K>(compare: (x: K, y: K) => boolean, keySelector: (x: T) => K): MonoTypeOperatorFunction<T>;
/* tslint:enable:max-line-length */

/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * ## Example
 * A simple example with numbers
 * ```ts
 * import ***REMOVED*** of ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** distinctUntilChanged ***REMOVED*** from 'rxjs/operators';
 *
 * of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4).pipe(
 *     distinctUntilChanged(),
 *   )
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 * ```
 *
 * An example using a compare function
 * ```typescript
 * import ***REMOVED*** of ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** distinctUntilChanged ***REMOVED*** from 'rxjs/operators';
 *
 * interface Person ***REMOVED***
 *    age: number,
 *    name: string
 * ***REMOVED***
 *
 * of<Person>(
 *     ***REMOVED*** age: 4, name: 'Foo'***REMOVED***,
 *     ***REMOVED*** age: 7, name: 'Bar'***REMOVED***,
 *     ***REMOVED*** age: 5, name: 'Foo'***REMOVED***,
 *     ***REMOVED*** age: 6, name: 'Foo'***REMOVED***,
 *   ).pipe(
 *     distinctUntilChanged((p: Person, q: Person) => p.name === q.name),
 *   )
 *   .subscribe(x => console.log(x));
 *
 * // displays:
 * // ***REMOVED*** age: 4, name: 'Foo' ***REMOVED***
 * // ***REMOVED*** age: 7, name: 'Bar' ***REMOVED***
 * // ***REMOVED*** age: 5, name: 'Foo' ***REMOVED***
 * ```
 *
 * @see ***REMOVED***@link distinct***REMOVED***
 * @see ***REMOVED***@link distinctUntilKeyChanged***REMOVED***
 *
 * @param ***REMOVED***function***REMOVED*** [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return ***REMOVED***Observable***REMOVED*** An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
export function distinctUntilChanged<T, K>(compare?: (x: K, y: K) => boolean, keySelector?: (x: T) => K): MonoTypeOperatorFunction<T> ***REMOVED***
  return (source: Observable<T>) => source.lift(new DistinctUntilChangedOperator<T, K>(compare, keySelector));
***REMOVED***

class DistinctUntilChangedOperator<T, K> implements Operator<T, T> ***REMOVED***
  constructor(private compare: (x: K, y: K) => boolean,
              private keySelector: (x: T) => K) ***REMOVED***
  ***REMOVED***

  call(subscriber: Subscriber<T>, source: any): TeardownLogic ***REMOVED***
    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class DistinctUntilChangedSubscriber<T, K> extends Subscriber<T> ***REMOVED***
  private key: K;
  private hasKey: boolean = false;

  constructor(destination: Subscriber<T>,
              compare: (x: K, y: K) => boolean,
              private keySelector: (x: T) => K) ***REMOVED***
    super(destination);
    if (typeof compare === 'function') ***REMOVED***
      this.compare = compare;
    ***REMOVED***
  ***REMOVED***

  private compare(x: any, y: any): boolean ***REMOVED***
    return x === y;
  ***REMOVED***

  protected _next(value: T): void ***REMOVED***
    let key: any;
    try ***REMOVED***
      const ***REMOVED*** keySelector ***REMOVED*** = this;
      key = keySelector ? keySelector(value) : value;
    ***REMOVED*** catch (err) ***REMOVED***
      return this.destination.error(err);
    ***REMOVED***
    let result = false;
    if (this.hasKey) ***REMOVED***
      try ***REMOVED***
        const ***REMOVED*** compare ***REMOVED*** = this;
        result = compare(this.key, key);
      ***REMOVED*** catch (err) ***REMOVED***
        return this.destination.error(err);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      this.hasKey = true;
    ***REMOVED***
    if (!result) ***REMOVED***
      this.key = key;
      this.destination.next(value);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
