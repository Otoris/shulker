import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** ArgumentOutOfRangeError ***REMOVED*** from '../util/ArgumentOutOfRangeError';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** MonoTypeOperatorFunction, TeardownLogic ***REMOVED*** from '../types';

/**
 * Skip the last `count` values emitted by the source Observable.
 *
 * ![](skipLast.png)
 *
 * `skipLast` returns an Observable that accumulates a queue with a length
 * enough to store the first `count` values. As more values are received,
 * values are taken from the front of the queue and produced on the result
 * sequence. This causes values to be delayed.
 *
 * ## Example
 * Skip the last 2 values of an Observable with many values
 * ```ts
 * import ***REMOVED*** range ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** skipLast ***REMOVED*** from 'rxjs/operators';
 *
 * const many = range(1, 5);
 * const skipLastTwo = many.pipe(skipLast(2));
 * skipLastTwo.subscribe(x => console.log(x));
 *
 * // Results in:
 * // 1 2 3
 * ```
 *
 * @see ***REMOVED***@link skip***REMOVED***
 * @see ***REMOVED***@link skipUntil***REMOVED***
 * @see ***REMOVED***@link skipWhile***REMOVED***
 * @see ***REMOVED***@link take***REMOVED***
 *
 * @throws ***REMOVED***ArgumentOutOfRangeError***REMOVED*** When using `skipLast(i)`, it throws
 * ArgumentOutOrRangeError if `i < 0`.
 *
 * @param ***REMOVED***number***REMOVED*** count Number of elements to skip from the end of the source Observable.
 * @returns ***REMOVED***Observable<T>***REMOVED*** An Observable that skips the last count values
 * emitted by the source Observable.
 * @method skipLast
 * @owner Observable
 */
export function skipLast<T>(count: number): MonoTypeOperatorFunction<T> ***REMOVED***
  return (source: Observable<T>) => source.lift(new SkipLastOperator(count));
***REMOVED***

class SkipLastOperator<T> implements Operator<T, T> ***REMOVED***
  constructor(private _skipCount: number) ***REMOVED***
    if (this._skipCount < 0) ***REMOVED***
      throw new ArgumentOutOfRangeError;
    ***REMOVED***
  ***REMOVED***

  call(subscriber: Subscriber<T>, source: any): TeardownLogic ***REMOVED***
    if (this._skipCount === 0) ***REMOVED***
      // If we don't want to skip any values then just subscribe
      // to Subscriber without any further logic.
      return source.subscribe(new Subscriber(subscriber));
    ***REMOVED*** else ***REMOVED***
      return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class SkipLastSubscriber<T> extends Subscriber<T> ***REMOVED***
  private _ring: T[];
  private _count: number = 0;

  constructor(destination: Subscriber<T>, private _skipCount: number) ***REMOVED***
    super(destination);
    this._ring = new Array<T>(_skipCount);
  ***REMOVED***

  protected _next(value: T): void ***REMOVED***
    const skipCount = this._skipCount;
    const count = this._count++;

    if (count < skipCount) ***REMOVED***
      this._ring[count] = value;
    ***REMOVED*** else ***REMOVED***
      const currentIndex = count % skipCount;
      const ring = this._ring;
      const oldValue = ring[currentIndex];

      ring[currentIndex] = value;
      this.destination.next(oldValue);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
