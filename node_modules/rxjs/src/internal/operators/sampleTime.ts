import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** async ***REMOVED*** from '../scheduler/async';
import ***REMOVED*** MonoTypeOperatorFunction, SchedulerAction, SchedulerLike, TeardownLogic ***REMOVED*** from '../types';

/**
 * Emits the most recently emitted value from the source Observable within
 * periodic time intervals.
 *
 * <span class="informal">Samples the source Observable at periodic time
 * intervals, emitting what it samples.</span>
 *
 * ![](sampleTime.png)
 *
 * `sampleTime` periodically looks at the source Observable and emits whichever
 * value it has most recently emitted since the previous sampling, unless the
 * source has not emitted anything since the previous sampling. The sampling
 * happens periodically in time every `period` milliseconds (or the time unit
 * defined by the optional `scheduler` argument). The sampling starts as soon as
 * the output Observable is subscribed.
 *
 * ## Example
 * Every second, emit the most recent click at most once
 * ```ts
 * import ***REMOVED*** fromEvent ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** sampleTime ***REMOVED*** from 'rxjs/operators';
 *
 * const clicks = fromEvent(document, 'click');
 * const result = clicks.pipe(sampleTime(1000));
 * result.subscribe(x => console.log(x));
 * ```
 *
 * @see ***REMOVED***@link auditTime***REMOVED***
 * @see ***REMOVED***@link debounceTime***REMOVED***
 * @see ***REMOVED***@link delay***REMOVED***
 * @see ***REMOVED***@link sample***REMOVED***
 * @see ***REMOVED***@link throttleTime***REMOVED***
 *
 * @param ***REMOVED***number***REMOVED*** period The sampling period expressed in milliseconds or the
 * time unit determined internally by the optional `scheduler`.
 * @param ***REMOVED***SchedulerLike***REMOVED*** [scheduler=async] The ***REMOVED***@link SchedulerLike***REMOVED*** to use for
 * managing the timers that handle the sampling.
 * @return ***REMOVED***Observable<T>***REMOVED*** An Observable that emits the results of sampling the
 * values emitted by the source Observable at the specified time interval.
 * @method sampleTime
 * @owner Observable
 */
export function sampleTime<T>(period: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T> ***REMOVED***
  return (source: Observable<T>) => source.lift(new SampleTimeOperator(period, scheduler));
***REMOVED***

class SampleTimeOperator<T> implements Operator<T, T> ***REMOVED***
  constructor(private period: number,
              private scheduler: SchedulerLike) ***REMOVED***
  ***REMOVED***

  call(subscriber: Subscriber<T>, source: any): TeardownLogic ***REMOVED***
    return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class SampleTimeSubscriber<T> extends Subscriber<T> ***REMOVED***
  lastValue: T;
  hasValue: boolean = false;

  constructor(destination: Subscriber<T>,
              private period: number,
              private scheduler: SchedulerLike) ***REMOVED***
    super(destination);
    this.add(scheduler.schedule(dispatchNotification, period, ***REMOVED*** subscriber: this, period ***REMOVED***));
  ***REMOVED***

  protected _next(value: T) ***REMOVED***
    this.lastValue = value;
    this.hasValue = true;
  ***REMOVED***

  notifyNext() ***REMOVED***
    if (this.hasValue) ***REMOVED***
      this.hasValue = false;
      this.destination.next(this.lastValue);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function dispatchNotification<T>(this: SchedulerAction<any>, state: any) ***REMOVED***
  let ***REMOVED*** subscriber, period ***REMOVED*** = state;
  subscriber.notifyNext();
  this.schedule(state, period);
***REMOVED***
