import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** empty ***REMOVED*** from '../observable/empty';
import ***REMOVED*** MonoTypeOperatorFunction, TeardownLogic ***REMOVED*** from '../types';

/**
 * Returns an Observable that will resubscribe to the source stream when the source stream completes, at most count times.
 *
 * <span class="informal">Repeats all values emitted on the source. It's like ***REMOVED***@link retry***REMOVED***, but for non error cases.</span>
 *
 * ![](repeat.png)
 *
 * Similar to ***REMOVED***@link retry***REMOVED***, this operator repeats the stream of items emitted by the source for non error cases.
 * Repeat can be useful for creating observables that are meant to have some repeated pattern or rhythm.
 *
 * Note: `repeat(0)` returns an empty observable and `repeat()` will repeat forever
 *
 * ## Example
 * Repeat a message stream
 * ```ts
 * import ***REMOVED*** of ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** repeat, delay ***REMOVED*** from 'rxjs/operators';
 *
 * const source = of('Repeat message');
 * const example = source.pipe(repeat(3));
 * example.subscribe(x => console.log(x));
 *
 * // Results
 * // Repeat message
 * // Repeat message
 * // Repeat message
 * ```
 *
 * Repeat 3 values, 2 times
 * ```ts
 * import ***REMOVED*** interval ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** repeat, take ***REMOVED*** from 'rxjs/operators';
 *
 * const source = interval(1000);
 * const example = source.pipe(take(3), repeat(2));
 * example.subscribe(x => console.log(x));
 *
 * // Results every second
 * // 0
 * // 1
 * // 2
 * // 0
 * // 1
 * // 2
 * ```
 *
 * @see ***REMOVED***@link repeatWhen***REMOVED***
 * @see ***REMOVED***@link retry***REMOVED***
 *
 * @param ***REMOVED***number***REMOVED*** [count] The number of times the source Observable items are repeated, a count of 0 will yield
 * an empty Observable.
 * @return ***REMOVED***Observable***REMOVED*** An Observable that will resubscribe to the source stream when the source stream completes
 * , at most count times.
 * @method repeat
 * @owner Observable
 */
export function repeat<T>(count: number = -1): MonoTypeOperatorFunction<T> ***REMOVED***
  return (source: Observable<T>) => ***REMOVED***
    if (count === 0) ***REMOVED***
      return empty();
    ***REMOVED*** else if (count < 0) ***REMOVED***
      return source.lift(new RepeatOperator(-1, source));
    ***REMOVED*** else ***REMOVED***
      return source.lift(new RepeatOperator(count - 1, source));
    ***REMOVED***
  ***REMOVED***;
***REMOVED***

class RepeatOperator<T> implements Operator<T, T> ***REMOVED***
  constructor(private count: number,
              private source: Observable<T>) ***REMOVED***
  ***REMOVED***
  call(subscriber: Subscriber<T>, source: any): TeardownLogic ***REMOVED***
    return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class RepeatSubscriber<T> extends Subscriber<T> ***REMOVED***
  constructor(destination: Subscriber<any>,
              private count: number,
              private source: Observable<T>) ***REMOVED***
    super(destination);
  ***REMOVED***
  complete() ***REMOVED***
    if (!this.isStopped) ***REMOVED***
      const ***REMOVED*** source, count ***REMOVED*** = this;
      if (count === 0) ***REMOVED***
        return super.complete();
      ***REMOVED*** else if (count > -1) ***REMOVED***
        this.count = count - 1;
      ***REMOVED***
      source.subscribe(this._unsubscribeAndRecycle());
    ***REMOVED***
  ***REMOVED***
***REMOVED***
