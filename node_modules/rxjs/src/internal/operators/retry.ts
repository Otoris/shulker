import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';

import ***REMOVED*** MonoTypeOperatorFunction, TeardownLogic ***REMOVED*** from '../types';

/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given
 * as a number parameter) rather than propagating the `error` call.
 *
 * ![](retry.png)
 *
 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
 * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
 * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
 * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
 *
 * ## Example
 * ```ts
 * import ***REMOVED*** interval, of, throwError ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** mergeMap, retry ***REMOVED*** from 'rxjs/operators';
 *
 * const source = interval(1000);
 * const example = source.pipe(
 *   mergeMap(val => ***REMOVED***
 *     if(val > 5)***REMOVED***
 *       return throwError('Error!');
 *     ***REMOVED***
 *     return of(val);
 *   ***REMOVED***),
 *   //retry 2 times on error
 *   retry(2)
 * );
 *
 * const subscribe = example.subscribe(***REMOVED***
 *   next: val => console.log(val),
 *   error: val => console.log(`$***REMOVED***val***REMOVED***: Retried 2 times then quit!`)
 * ***REMOVED***);
 *
 * // Output:
 * // 0..1..2..3..4..5..
 * // 0..1..2..3..4..5..
 * // 0..1..2..3..4..5..
 * // "Error!: Retried 2 times then quit!"
 * ```
 *
 * @param ***REMOVED***number***REMOVED*** count - Number of retry attempts before failing.
 * @return ***REMOVED***Observable***REMOVED*** The source Observable modified with the retry logic.
 * @method retry
 * @owner Observable
 */
export function retry<T>(count: number = -1): MonoTypeOperatorFunction<T> ***REMOVED***
  return (source: Observable<T>) => source.lift(new RetryOperator(count, source));
***REMOVED***

class RetryOperator<T> implements Operator<T, T> ***REMOVED***
  constructor(private count: number,
              private source: Observable<T>) ***REMOVED***
  ***REMOVED***

  call(subscriber: Subscriber<T>, source: any): TeardownLogic ***REMOVED***
    return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class RetrySubscriber<T> extends Subscriber<T> ***REMOVED***
  constructor(destination: Subscriber<any>,
              private count: number,
              private source: Observable<T>) ***REMOVED***
    super(destination);
  ***REMOVED***
  error(err: any) ***REMOVED***
    if (!this.isStopped) ***REMOVED***
      const ***REMOVED*** source, count ***REMOVED*** = this;
      if (count === 0) ***REMOVED***
        return super.error(err);
      ***REMOVED*** else if (count > -1) ***REMOVED***
        this.count = count - 1;
      ***REMOVED***
      source.subscribe(this._unsubscribeAndRecycle());
    ***REMOVED***
  ***REMOVED***
***REMOVED***
