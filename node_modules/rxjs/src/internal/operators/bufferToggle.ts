import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';
import ***REMOVED*** subscribeToResult ***REMOVED*** from '../util/subscribeToResult';
import ***REMOVED*** OuterSubscriber ***REMOVED*** from '../OuterSubscriber';
import ***REMOVED*** InnerSubscriber ***REMOVED*** from '../InnerSubscriber';
import ***REMOVED*** OperatorFunction, SubscribableOrPromise ***REMOVED*** from '../types';

/**
 * Buffers the source Observable values starting from an emission from
 * `openings` and ending when the output of `closingSelector` emits.
 *
 * <span class="informal">Collects values from the past as an array. Starts
 * collecting only when `opening` emits, and calls the `closingSelector`
 * function to get an Observable that tells when to close the buffer.</span>
 *
 * ![](bufferToggle.png)
 *
 * Buffers values from the source by opening the buffer via signals from an
 * Observable provided to `openings`, and closing and sending the buffers when
 * a Subscribable or Promise returned by the `closingSelector` function emits.
 *
 * ## Example
 *
 * Every other second, emit the click events from the next 500ms
 *
 * ```ts
 * import ***REMOVED*** fromEvent, interval, EMPTY ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** bufferToggle ***REMOVED*** from 'rxjs/operators';
 *
 * const clicks = fromEvent(document, 'click');
 * const openings = interval(1000);
 * const buffered = clicks.pipe(bufferToggle(openings, i =>
 *   i % 2 ? interval(500) : EMPTY
 * ));
 * buffered.subscribe(x => console.log(x));
 * ```
 *
 * @see ***REMOVED***@link buffer***REMOVED***
 * @see ***REMOVED***@link bufferCount***REMOVED***
 * @see ***REMOVED***@link bufferTime***REMOVED***
 * @see ***REMOVED***@link bufferWhen***REMOVED***
 * @see ***REMOVED***@link windowToggle***REMOVED***
 *
 * @param ***REMOVED***SubscribableOrPromise<O>***REMOVED*** openings A Subscribable or Promise of notifications to start new
 * buffers.
 * @param ***REMOVED***function(value: O): SubscribableOrPromise***REMOVED*** closingSelector A function that takes
 * the value emitted by the `openings` observable and returns a Subscribable or Promise,
 * which, when it emits, signals that the associated buffer should be emitted
 * and cleared.
 * @return ***REMOVED***Observable<T[]>***REMOVED*** An observable of arrays of buffered values.
 * @method bufferToggle
 * @owner Observable
 */
export function bufferToggle<T, O>(
  openings: SubscribableOrPromise<O>,
  closingSelector: (value: O) => SubscribableOrPromise<any>
): OperatorFunction<T, T[]> ***REMOVED***
  return function bufferToggleOperatorFunction(source: Observable<T>) ***REMOVED***
    return source.lift(new BufferToggleOperator<T, O>(openings, closingSelector));
  ***REMOVED***;
***REMOVED***

class BufferToggleOperator<T, O> implements Operator<T, T[]> ***REMOVED***

  constructor(private openings: SubscribableOrPromise<O>,
              private closingSelector: (value: O) => SubscribableOrPromise<any>) ***REMOVED***
  ***REMOVED***

  call(subscriber: Subscriber<T[]>, source: any): any ***REMOVED***
    return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
  ***REMOVED***
***REMOVED***

interface BufferContext<T> ***REMOVED***
  buffer: T[];
  subscription: Subscription;
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
class BufferToggleSubscriber<T, O> extends OuterSubscriber<T, O> ***REMOVED***
  private contexts: Array<BufferContext<T>> = [];

  constructor(destination: Subscriber<T[]>,
              private openings: SubscribableOrPromise<O>,
              private closingSelector: (value: O) => SubscribableOrPromise<any> | void) ***REMOVED***
    super(destination);
    this.add(subscribeToResult(this, openings));
  ***REMOVED***

  protected _next(value: T): void ***REMOVED***
    const contexts = this.contexts;
    const len = contexts.length;
    for (let i = 0; i < len; i++) ***REMOVED***
      contexts[i].buffer.push(value);
    ***REMOVED***
  ***REMOVED***

  protected _error(err: any): void ***REMOVED***
    const contexts = this.contexts;
    while (contexts.length > 0) ***REMOVED***
      const context = contexts.shift();
      context.subscription.unsubscribe();
      context.buffer = null;
      context.subscription = null;
    ***REMOVED***
    this.contexts = null;
    super._error(err);
  ***REMOVED***

  protected _complete(): void ***REMOVED***
    const contexts = this.contexts;
    while (contexts.length > 0) ***REMOVED***
      const context = contexts.shift();
      this.destination.next(context.buffer);
      context.subscription.unsubscribe();
      context.buffer = null;
      context.subscription = null;
    ***REMOVED***
    this.contexts = null;
    super._complete();
  ***REMOVED***

  notifyNext(outerValue: any, innerValue: O,
             outerIndex: number, innerIndex: number,
             innerSub: InnerSubscriber<T, O>): void ***REMOVED***
    outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
  ***REMOVED***

  notifyComplete(innerSub: InnerSubscriber<T, O>): void ***REMOVED***
    this.closeBuffer((<any> innerSub).context);
  ***REMOVED***

  private openBuffer(value: O): void ***REMOVED***
    try ***REMOVED***
      const closingSelector = this.closingSelector;
      const closingNotifier = closingSelector.call(this, value);
      if (closingNotifier) ***REMOVED***
        this.trySubscribe(closingNotifier);
      ***REMOVED***
    ***REMOVED*** catch (err) ***REMOVED***
      this._error(err);
    ***REMOVED***
  ***REMOVED***

  private closeBuffer(context: BufferContext<T>): void ***REMOVED***
    const contexts = this.contexts;

    if (contexts && context) ***REMOVED***
      const ***REMOVED*** buffer, subscription ***REMOVED*** = context;
      this.destination.next(buffer);
      contexts.splice(contexts.indexOf(context), 1);
      this.remove(subscription);
      subscription.unsubscribe();
    ***REMOVED***
  ***REMOVED***

  private trySubscribe(closingNotifier: any): void ***REMOVED***
    const contexts = this.contexts;

    const buffer: Array<T> = [];
    const subscription = new Subscription();
    const context = ***REMOVED*** buffer, subscription ***REMOVED***;
    contexts.push(context);

    const innerSubscription = subscribeToResult(this, closingNotifier, <any>context);

    if (!innerSubscription || innerSubscription.closed) ***REMOVED***
      this.closeBuffer(context);
    ***REMOVED*** else ***REMOVED***
      (<any> innerSubscription).context = context;

      this.add(innerSubscription);
      subscription.add(innerSubscription);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
