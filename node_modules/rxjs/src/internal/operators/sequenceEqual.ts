import ***REMOVED*** Operator ***REMOVED*** from '../Operator';
import ***REMOVED*** Observable ***REMOVED*** from '../Observable';
import ***REMOVED*** Subscriber ***REMOVED*** from '../Subscriber';
import ***REMOVED*** Subscription ***REMOVED*** from '../Subscription';

import ***REMOVED*** Observer, OperatorFunction ***REMOVED*** from '../types';

/**
 * Compares all values of two observables in sequence using an optional comparator function
 * and returns an observable of a single boolean value representing whether or not the two sequences
 * are equal.
 *
 * <span class="informal">Checks to see of all values emitted by both observables are equal, in order.</span>
 *
 * ![](sequenceEqual.png)
 *
 * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either
 * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom
 * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the
 * observables completes, the operator will wait for the other observable to complete; If the other
 * observable emits before completing, the returned observable will emit `false` and complete. If one observable never
 * completes or emits after the other complets, the returned observable will never complete.
 *
 * ## Example
 * figure out if the Konami code matches
 * ```ts
 * import ***REMOVED*** from, fromEvent ***REMOVED*** from 'rxjs';
 * import ***REMOVED*** sequenceEqual, bufferCount, mergeMap, map ***REMOVED*** from 'rxjs/operators';
 *
 * const codes = from([
 *   'ArrowUp',
 *   'ArrowUp',
 *   'ArrowDown',
 *   'ArrowDown',
 *   'ArrowLeft',
 *   'ArrowRight',
 *   'ArrowLeft',
 *   'ArrowRight',
 *   'KeyB',
 *   'KeyA',
 *   'Enter', // no start key, clearly.
 * ]);
 *
 * const keys = fromEvent(document, 'keyup').pipe(map(e => e.code));
 * const matches = keys.pipe(
 *   bufferCount(11, 1),
 *   mergeMap(
 *     last11 => from(last11).pipe(sequenceEqual(codes)),
 *   ),
 * );
 * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
 * ```
 *
 * @see ***REMOVED***@link combineLatest***REMOVED***
 * @see ***REMOVED***@link zip***REMOVED***
 * @see ***REMOVED***@link withLatestFrom***REMOVED***
 *
 * @param ***REMOVED***Observable***REMOVED*** compareTo The observable sequence to compare the source sequence to.
 * @param ***REMOVED***function***REMOVED*** [comparator] An optional function to compare each value pair
 * @return ***REMOVED***Observable***REMOVED*** An Observable of a single boolean value representing whether or not
 * the values emitted by both observables were equal in sequence.
 * @method sequenceEqual
 * @owner Observable
 */
export function sequenceEqual<T>(compareTo: Observable<T>,
                                 comparator?: (a: T, b: T) => boolean): OperatorFunction<T, boolean> ***REMOVED***
  return (source: Observable<T>) => source.lift(new SequenceEqualOperator(compareTo, comparator));
***REMOVED***

export class SequenceEqualOperator<T> implements Operator<T, boolean> ***REMOVED***
  constructor(private compareTo: Observable<T>,
              private comparator: (a: T, b: T) => boolean) ***REMOVED***
  ***REMOVED***

  call(subscriber: Subscriber<boolean>, source: any): any ***REMOVED***
    return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
  ***REMOVED***
***REMOVED***

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends ***REMOVED***Ignored***REMOVED***
 */
export class SequenceEqualSubscriber<T, R> extends Subscriber<T> ***REMOVED***
  private _a: T[] = [];
  private _b: T[] = [];
  private _oneComplete = false;

  constructor(destination: Observer<R>,
              private compareTo: Observable<T>,
              private comparator: (a: T, b: T) => boolean) ***REMOVED***
    super(destination);
    (this.destination as Subscription).add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));
  ***REMOVED***

  protected _next(value: T): void ***REMOVED***
    if (this._oneComplete && this._b.length === 0) ***REMOVED***
      this.emit(false);
    ***REMOVED*** else ***REMOVED***
      this._a.push(value);
      this.checkValues();
    ***REMOVED***
  ***REMOVED***

  public _complete(): void ***REMOVED***
    if (this._oneComplete) ***REMOVED***
      this.emit(this._a.length === 0 && this._b.length === 0);
    ***REMOVED*** else ***REMOVED***
      this._oneComplete = true;
    ***REMOVED***
    this.unsubscribe();
  ***REMOVED***

  checkValues() ***REMOVED***
    const ***REMOVED*** _a, _b, comparator ***REMOVED*** = this;
    while (_a.length > 0 && _b.length > 0) ***REMOVED***
      let a = _a.shift();
      let b = _b.shift();
      let areEqual = false;
      try ***REMOVED***
        areEqual = comparator ? comparator(a, b) : a === b;
      ***REMOVED*** catch (e) ***REMOVED***
        this.destination.error(e);
      ***REMOVED***
      if (!areEqual) ***REMOVED***
        this.emit(false);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  emit(value: boolean) ***REMOVED***
    const ***REMOVED*** destination ***REMOVED*** = this;
    destination.next(value);
    destination.complete();
  ***REMOVED***

  nextB(value: T) ***REMOVED***
    if (this._oneComplete && this._a.length === 0) ***REMOVED***
      this.emit(false);
    ***REMOVED*** else ***REMOVED***
      this._b.push(value);
      this.checkValues();
    ***REMOVED***
  ***REMOVED***

  completeB() ***REMOVED***
    if (this._oneComplete) ***REMOVED***
      this.emit(this._a.length === 0 && this._b.length === 0);
    ***REMOVED*** else ***REMOVED***
      this._oneComplete = true;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

class SequenceEqualCompareToSubscriber<T, R> extends Subscriber<T> ***REMOVED***
  constructor(destination: Observer<R>, private parent: SequenceEqualSubscriber<T, R>) ***REMOVED***
    super(destination);
  ***REMOVED***

  protected _next(value: T): void ***REMOVED***
    this.parent.nextB(value);
  ***REMOVED***

  protected _error(err: any): void ***REMOVED***
    this.parent.error(err);
    this.unsubscribe();
  ***REMOVED***

  protected _complete(): void ***REMOVED***
    this.parent.completeB();
    this.unsubscribe();
  ***REMOVED***
***REMOVED***
