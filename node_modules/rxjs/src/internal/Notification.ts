import ***REMOVED*** PartialObserver ***REMOVED*** from './types';
import ***REMOVED*** Observable ***REMOVED*** from './Observable';
import ***REMOVED*** empty ***REMOVED*** from './observable/empty';
import ***REMOVED*** of ***REMOVED*** from './observable/of';
import ***REMOVED*** throwError ***REMOVED*** from './observable/throwError';
import ***REMOVED*** deprecate ***REMOVED*** from 'util';

// TODO: When this enum is removed, replace it with a type alias. See #4556.
/**
 * @deprecated NotificationKind is deprecated as const enums are not compatible with isolated modules. Use a string literal instead.
 */
export enum NotificationKind ***REMOVED***
  NEXT = 'N',
  ERROR = 'E',
  COMPLETE = 'C',
***REMOVED***

/**
 * Represents a push-based event or value that an ***REMOVED***@link Observable***REMOVED*** can emit.
 * This class is particularly useful for operators that manage notifications,
 * like ***REMOVED***@link materialize***REMOVED***, ***REMOVED***@link dematerialize***REMOVED***, ***REMOVED***@link observeOn***REMOVED***, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see ***REMOVED***@link materialize***REMOVED***
 * @see ***REMOVED***@link dematerialize***REMOVED***
 * @see ***REMOVED***@link observeOn***REMOVED***
 *
 * @class Notification<T>
 */
export class Notification<T> ***REMOVED***
  hasValue: boolean;

  constructor(public kind: 'N' | 'E' | 'C', public value?: T, public error?: any) ***REMOVED***
    this.hasValue = kind === 'N';
  ***REMOVED***

  /**
   * Delivers to the given `observer` the value wrapped by this Notification.
   * @param ***REMOVED***Observer***REMOVED*** observer
   * @return
   */
  observe(observer: PartialObserver<T>): any ***REMOVED***
    switch (this.kind) ***REMOVED***
      case 'N':
        return observer.next && observer.next(this.value);
      case 'E':
        return observer.error && observer.error(this.error);
      case 'C':
        return observer.complete && observer.complete();
    ***REMOVED***
  ***REMOVED***

  /**
   * Given some ***REMOVED***@link Observer***REMOVED*** callbacks, deliver the value represented by the
   * current Notification to the correctly corresponding callback.
   * @param ***REMOVED***function(value: T): void***REMOVED*** next An Observer `next` callback.
   * @param ***REMOVED***function(err: any): void***REMOVED*** [error] An Observer `error` callback.
   * @param ***REMOVED***function(): void***REMOVED*** [complete] An Observer `complete` callback.
   * @return ***REMOVED***any***REMOVED***
   */
  do(next: (value: T) => void, error?: (err: any) => void, complete?: () => void): any ***REMOVED***
    const kind = this.kind;
    switch (kind) ***REMOVED***
      case 'N':
        return next && next(this.value);
      case 'E':
        return error && error(this.error);
      case 'C':
        return complete && complete();
    ***REMOVED***
  ***REMOVED***

  /**
   * Takes an Observer or its individual callback functions, and calls `observe`
   * or `do` methods accordingly.
   * @param ***REMOVED***Observer|function(value: T): void***REMOVED*** nextOrObserver An Observer or
   * the `next` callback.
   * @param ***REMOVED***function(err: any): void***REMOVED*** [error] An Observer `error` callback.
   * @param ***REMOVED***function(): void***REMOVED*** [complete] An Observer `complete` callback.
   * @return ***REMOVED***any***REMOVED***
   */
  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) ***REMOVED***
    if (nextOrObserver && typeof (<PartialObserver<T>>nextOrObserver).next === 'function') ***REMOVED***
      return this.observe(<PartialObserver<T>>nextOrObserver);
    ***REMOVED*** else ***REMOVED***
      return this.do(<(value: T) => void>nextOrObserver, error, complete);
    ***REMOVED***
  ***REMOVED***

  /**
   * Returns a simple Observable that just delivers the notification represented
   * by this Notification instance.
   * @return ***REMOVED***any***REMOVED***
   */
  toObservable(): Observable<T> ***REMOVED***
    const kind = this.kind;
    switch (kind) ***REMOVED***
      case 'N':
        return of(this.value);
      case 'E':
        return throwError(this.error);
      case 'C':
        return empty();
    ***REMOVED***
    throw new Error('unexpected notification kind value');
  ***REMOVED***

  private static completeNotification: Notification<any> = new Notification('C');
  private static undefinedValueNotification: Notification<any> = new Notification('N', undefined);

  /**
   * A shortcut to create a Notification instance of the type `next` from a
   * given value.
   * @param ***REMOVED***T***REMOVED*** value The `next` value.
   * @return ***REMOVED***Notification<T>***REMOVED*** The "next" Notification representing the
   * argument.
   * @nocollapse
   */
  static createNext<T>(value: T): Notification<T> ***REMOVED***
    if (typeof value !== 'undefined') ***REMOVED***
      return new Notification('N', value);
    ***REMOVED***
    return Notification.undefinedValueNotification;
  ***REMOVED***

  /**
   * A shortcut to create a Notification instance of the type `error` from a
   * given error.
   * @param ***REMOVED***any***REMOVED*** [err] The `error` error.
   * @return ***REMOVED***Notification<T>***REMOVED*** The "error" Notification representing the
   * argument.
   * @nocollapse
   */
  static createError<T>(err?: any): Notification<T> ***REMOVED***
    return new Notification('E', undefined, err);
  ***REMOVED***

  /**
   * A shortcut to create a Notification instance of the type `complete`.
   * @return ***REMOVED***Notification<any>***REMOVED*** The valueless "complete" Notification.
   * @nocollapse
   */
  static createComplete(): Notification<any> ***REMOVED***
    return Notification.completeNotification;
  ***REMOVED***
***REMOVED***
