"use strict";
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = function (d, b) ***REMOVED***
        extendStatics = Object.setPrototypeOf ||
            (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
            function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
        return extendStatics(d, b);
    ***REMOVED***
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var Subject_1 = require("./Subject");
var queue_1 = require("./scheduler/queue");
var Subscription_1 = require("./Subscription");
var observeOn_1 = require("./operators/observeOn");
var ObjectUnsubscribedError_1 = require("./util/ObjectUnsubscribedError");
var SubjectSubscription_1 = require("./SubjectSubscription");
var ReplaySubject = (function (_super) ***REMOVED***
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) ***REMOVED***
        if (bufferSize === void 0) ***REMOVED*** bufferSize = Number.POSITIVE_INFINITY; ***REMOVED***
        if (windowTime === void 0) ***REMOVED*** windowTime = Number.POSITIVE_INFINITY; ***REMOVED***
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) ***REMOVED***
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        ***REMOVED***
        else ***REMOVED***
            _this.next = _this.nextTimeWindow;
        ***REMOVED***
        return _this;
    ***REMOVED***
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) ***REMOVED***
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) ***REMOVED***
            _events.shift();
        ***REMOVED***
        _super.prototype.next.call(this, value);
    ***REMOVED***;
    ReplaySubject.prototype.nextTimeWindow = function (value) ***REMOVED***
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    ***REMOVED***;
    ReplaySubject.prototype._subscribe = function (subscriber) ***REMOVED***
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) ***REMOVED***
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        ***REMOVED***
        else if (this.isStopped || this.hasError) ***REMOVED***
            subscription = Subscription_1.Subscription.EMPTY;
        ***REMOVED***
        else ***REMOVED***
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        ***REMOVED***
        if (scheduler) ***REMOVED***
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        ***REMOVED***
        if (_infiniteTimeWindow) ***REMOVED***
            for (var i = 0; i < len && !subscriber.closed; i++) ***REMOVED***
                subscriber.next(_events[i]);
            ***REMOVED***
        ***REMOVED***
        else ***REMOVED***
            for (var i = 0; i < len && !subscriber.closed; i++) ***REMOVED***
                subscriber.next(_events[i].value);
            ***REMOVED***
        ***REMOVED***
        if (this.hasError) ***REMOVED***
            subscriber.error(this.thrownError);
        ***REMOVED***
        else if (this.isStopped) ***REMOVED***
            subscriber.complete();
        ***REMOVED***
        return subscription;
    ***REMOVED***;
    ReplaySubject.prototype._getNow = function () ***REMOVED***
        return (this.scheduler || queue_1.queue).now();
    ***REMOVED***;
    ReplaySubject.prototype._trimBufferThenGetEvents = function () ***REMOVED***
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) ***REMOVED***
            if ((now - _events[spliceCount].time) < _windowTime) ***REMOVED***
                break;
            ***REMOVED***
            spliceCount++;
        ***REMOVED***
        if (eventsCount > _bufferSize) ***REMOVED***
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        ***REMOVED***
        if (spliceCount > 0) ***REMOVED***
            _events.splice(0, spliceCount);
        ***REMOVED***
        return _events;
    ***REMOVED***;
    return ReplaySubject;
***REMOVED***(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () ***REMOVED***
    function ReplayEvent(time, value) ***REMOVED***
        this.time = time;
        this.value = value;
    ***REMOVED***
    return ReplayEvent;
***REMOVED***());
//# sourceMappingURL=ReplaySubject.js.map