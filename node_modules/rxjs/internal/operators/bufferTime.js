"use strict";
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = function (d, b) ***REMOVED***
        extendStatics = Object.setPrototypeOf ||
            (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
            function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
        return extendStatics(d, b);
    ***REMOVED***
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var async_1 = require("../scheduler/async");
var Subscriber_1 = require("../Subscriber");
var isScheduler_1 = require("../util/isScheduler");
function bufferTime(bufferTimeSpan) ***REMOVED***
    var length = arguments.length;
    var scheduler = async_1.async;
    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) ***REMOVED***
        scheduler = arguments[arguments.length - 1];
        length--;
    ***REMOVED***
    var bufferCreationInterval = null;
    if (length >= 2) ***REMOVED***
        bufferCreationInterval = arguments[1];
    ***REMOVED***
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) ***REMOVED***
        maxBufferSize = arguments[2];
    ***REMOVED***
    return function bufferTimeOperatorFunction(source) ***REMOVED***
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    ***REMOVED***;
***REMOVED***
exports.bufferTime = bufferTime;
var BufferTimeOperator = (function () ***REMOVED***
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) ***REMOVED***
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    ***REMOVED***
    BufferTimeOperator.prototype.call = function (subscriber, source) ***REMOVED***
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    ***REMOVED***;
    return BufferTimeOperator;
***REMOVED***());
var Context = (function () ***REMOVED***
    function Context() ***REMOVED***
        this.buffer = [];
    ***REMOVED***
    return Context;
***REMOVED***());
var BufferTimeSubscriber = (function (_super) ***REMOVED***
    __extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) ***REMOVED***
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) ***REMOVED***
            var timeSpanOnlyState = ***REMOVED*** subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan ***REMOVED***;
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        ***REMOVED***
        else ***REMOVED***
            var closeState = ***REMOVED*** subscriber: _this, context: context ***REMOVED***;
            var creationState = ***REMOVED*** bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler ***REMOVED***;
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        ***REMOVED***
        return _this;
    ***REMOVED***
    BufferTimeSubscriber.prototype._next = function (value) ***REMOVED***
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) ***REMOVED***
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) ***REMOVED***
                filledBufferContext = context_1;
            ***REMOVED***
        ***REMOVED***
        if (filledBufferContext) ***REMOVED***
            this.onBufferFull(filledBufferContext);
        ***REMOVED***
    ***REMOVED***;
    BufferTimeSubscriber.prototype._error = function (err) ***REMOVED***
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    ***REMOVED***;
    BufferTimeSubscriber.prototype._complete = function () ***REMOVED***
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) ***REMOVED***
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        ***REMOVED***
        _super.prototype._complete.call(this);
    ***REMOVED***;
    BufferTimeSubscriber.prototype._unsubscribe = function () ***REMOVED***
        this.contexts = null;
    ***REMOVED***;
    BufferTimeSubscriber.prototype.onBufferFull = function (context) ***REMOVED***
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) ***REMOVED***
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = ***REMOVED*** subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan ***REMOVED***;
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        ***REMOVED***
    ***REMOVED***;
    BufferTimeSubscriber.prototype.openContext = function () ***REMOVED***
        var context = new Context();
        this.contexts.push(context);
        return context;
    ***REMOVED***;
    BufferTimeSubscriber.prototype.closeContext = function (context) ***REMOVED***
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) ***REMOVED***
            contexts.splice(contexts.indexOf(context), 1);
        ***REMOVED***
    ***REMOVED***;
    return BufferTimeSubscriber;
***REMOVED***(Subscriber_1.Subscriber));
function dispatchBufferTimeSpanOnly(state) ***REMOVED***
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) ***REMOVED***
        subscriber.closeContext(prevContext);
    ***REMOVED***
    if (!subscriber.closed) ***REMOVED***
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    ***REMOVED***
***REMOVED***
function dispatchBufferCreation(state) ***REMOVED***
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) ***REMOVED***
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, ***REMOVED*** subscriber: subscriber, context: context ***REMOVED***));
        action.schedule(state, bufferCreationInterval);
    ***REMOVED***
***REMOVED***
function dispatchBufferClose(arg) ***REMOVED***
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
***REMOVED***
//# sourceMappingURL=bufferTime.js.map