"use strict";
var __extends = (this && this.__extends) || (function () ***REMOVED***
    var extendStatics = function (d, b) ***REMOVED***
        extendStatics = Object.setPrototypeOf ||
            (***REMOVED*** __proto__: [] ***REMOVED*** instanceof Array && function (d, b) ***REMOVED*** d.__proto__ = b; ***REMOVED***) ||
            function (d, b) ***REMOVED*** for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; ***REMOVED***;
        return extendStatics(d, b);
    ***REMOVED***
    return function (d, b) ***REMOVED***
        extendStatics(d, b);
        function __() ***REMOVED*** this.constructor = d; ***REMOVED***
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    ***REMOVED***;
***REMOVED***)();
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
var Observable_1 = require("../Observable");
var Notification_1 = require("../Notification");
var ColdObservable_1 = require("./ColdObservable");
var HotObservable_1 = require("./HotObservable");
var SubscriptionLog_1 = require("./SubscriptionLog");
var VirtualTimeScheduler_1 = require("../scheduler/VirtualTimeScheduler");
var AsyncScheduler_1 = require("../scheduler/AsyncScheduler");
var defaultMaxFrame = 750;
var TestScheduler = (function (_super) ***REMOVED***
    __extends(TestScheduler, _super);
    function TestScheduler(assertDeepEqual) ***REMOVED***
        var _this = _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame) || this;
        _this.assertDeepEqual = assertDeepEqual;
        _this.hotObservables = [];
        _this.coldObservables = [];
        _this.flushTests = [];
        _this.runMode = false;
        return _this;
    ***REMOVED***
    TestScheduler.prototype.createTime = function (marbles) ***REMOVED***
        var indexOf = marbles.indexOf('|');
        if (indexOf === -1) ***REMOVED***
            throw new Error('marble diagram for time should have a completion marker "|"');
        ***REMOVED***
        return indexOf * TestScheduler.frameTimeFactor;
    ***REMOVED***;
    TestScheduler.prototype.createColdObservable = function (marbles, values, error) ***REMOVED***
        if (marbles.indexOf('^') !== -1) ***REMOVED***
            throw new Error('cold observable cannot have subscription offset "^"');
        ***REMOVED***
        if (marbles.indexOf('!') !== -1) ***REMOVED***
            throw new Error('cold observable cannot have unsubscription marker "!"');
        ***REMOVED***
        var messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);
        var cold = new ColdObservable_1.ColdObservable(messages, this);
        this.coldObservables.push(cold);
        return cold;
    ***REMOVED***;
    TestScheduler.prototype.createHotObservable = function (marbles, values, error) ***REMOVED***
        if (marbles.indexOf('!') !== -1) ***REMOVED***
            throw new Error('hot observable cannot have unsubscription marker "!"');
        ***REMOVED***
        var messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);
        var subject = new HotObservable_1.HotObservable(messages, this);
        this.hotObservables.push(subject);
        return subject;
    ***REMOVED***;
    TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) ***REMOVED***
        var _this = this;
        var messages = [];
        observable.subscribe(function (value) ***REMOVED***
            messages.push(***REMOVED*** frame: _this.frame - outerFrame, notification: Notification_1.Notification.createNext(value) ***REMOVED***);
        ***REMOVED***, function (err) ***REMOVED***
            messages.push(***REMOVED*** frame: _this.frame - outerFrame, notification: Notification_1.Notification.createError(err) ***REMOVED***);
        ***REMOVED***, function () ***REMOVED***
            messages.push(***REMOVED*** frame: _this.frame - outerFrame, notification: Notification_1.Notification.createComplete() ***REMOVED***);
        ***REMOVED***);
        return messages;
    ***REMOVED***;
    TestScheduler.prototype.expectObservable = function (observable, subscriptionMarbles) ***REMOVED***
        var _this = this;
        if (subscriptionMarbles === void 0) ***REMOVED*** subscriptionMarbles = null; ***REMOVED***
        var actual = [];
        var flushTest = ***REMOVED*** actual: actual, ready: false ***REMOVED***;
        var subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);
        var subscriptionFrame = subscriptionParsed.subscribedFrame === Number.POSITIVE_INFINITY ?
            0 : subscriptionParsed.subscribedFrame;
        var unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;
        var subscription;
        this.schedule(function () ***REMOVED***
            subscription = observable.subscribe(function (x) ***REMOVED***
                var value = x;
                if (x instanceof Observable_1.Observable) ***REMOVED***
                    value = _this.materializeInnerObservable(value, _this.frame);
                ***REMOVED***
                actual.push(***REMOVED*** frame: _this.frame, notification: Notification_1.Notification.createNext(value) ***REMOVED***);
            ***REMOVED***, function (err) ***REMOVED***
                actual.push(***REMOVED*** frame: _this.frame, notification: Notification_1.Notification.createError(err) ***REMOVED***);
            ***REMOVED***, function () ***REMOVED***
                actual.push(***REMOVED*** frame: _this.frame, notification: Notification_1.Notification.createComplete() ***REMOVED***);
            ***REMOVED***);
        ***REMOVED***, subscriptionFrame);
        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) ***REMOVED***
            this.schedule(function () ***REMOVED*** return subscription.unsubscribe(); ***REMOVED***, unsubscriptionFrame);
        ***REMOVED***
        this.flushTests.push(flushTest);
        var runMode = this.runMode;
        return ***REMOVED***
            toBe: function (marbles, values, errorValue) ***REMOVED***
                flushTest.ready = true;
                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***;
    TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) ***REMOVED***
        var flushTest = ***REMOVED*** actual: actualSubscriptionLogs, ready: false ***REMOVED***;
        this.flushTests.push(flushTest);
        var runMode = this.runMode;
        return ***REMOVED***
            toBe: function (marbles) ***REMOVED***
                var marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;
                flushTest.ready = true;
                flushTest.expected = marblesArray.map(function (marbles) ***REMOVED***
                    return TestScheduler.parseMarblesAsSubscriptions(marbles, runMode);
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***;
    TestScheduler.prototype.flush = function () ***REMOVED***
        var _this = this;
        var hotObservables = this.hotObservables;
        while (hotObservables.length > 0) ***REMOVED***
            hotObservables.shift().setup();
        ***REMOVED***
        _super.prototype.flush.call(this);
        this.flushTests = this.flushTests.filter(function (test) ***REMOVED***
            if (test.ready) ***REMOVED***
                _this.assertDeepEqual(test.actual, test.expected);
                return false;
            ***REMOVED***
            return true;
        ***REMOVED***);
    ***REMOVED***;
    TestScheduler.parseMarblesAsSubscriptions = function (marbles, runMode) ***REMOVED***
        var _this = this;
        if (runMode === void 0) ***REMOVED*** runMode = false; ***REMOVED***
        if (typeof marbles !== 'string') ***REMOVED***
            return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);
        ***REMOVED***
        var len = marbles.length;
        var groupStart = -1;
        var subscriptionFrame = Number.POSITIVE_INFINITY;
        var unsubscriptionFrame = Number.POSITIVE_INFINITY;
        var frame = 0;
        var _loop_1 = function (i) ***REMOVED***
            var nextFrame = frame;
            var advanceFrameBy = function (count) ***REMOVED***
                nextFrame += count * _this.frameTimeFactor;
            ***REMOVED***;
            var c = marbles[i];
            switch (c) ***REMOVED***
                case ' ':
                    if (!runMode) ***REMOVED***
                        advanceFrameBy(1);
                    ***REMOVED***
                    break;
                case '-':
                    advanceFrameBy(1);
                    break;
                case '(':
                    groupStart = frame;
                    advanceFrameBy(1);
                    break;
                case ')':
                    groupStart = -1;
                    advanceFrameBy(1);
                    break;
                case '^':
                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) ***REMOVED***
                        throw new Error('found a second subscription point \'^\' in a ' +
                            'subscription marble diagram. There can only be one.');
                    ***REMOVED***
                    subscriptionFrame = groupStart > -1 ? groupStart : frame;
                    advanceFrameBy(1);
                    break;
                case '!':
                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) ***REMOVED***
                        throw new Error('found a second subscription point \'^\' in a ' +
                            'subscription marble diagram. There can only be one.');
                    ***REMOVED***
                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
                    break;
                default:
                    if (runMode && c.match(/^[0-9]$/)) ***REMOVED***
                        if (i === 0 || marbles[i - 1] === ' ') ***REMOVED***
                            var buffer = marbles.slice(i);
                            var match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
                            if (match) ***REMOVED***
                                i += match[0].length - 1;
                                var duration = parseFloat(match[1]);
                                var unit = match[2];
                                var durationInMs = void 0;
                                switch (unit) ***REMOVED***
                                    case 'ms':
                                        durationInMs = duration;
                                        break;
                                    case 's':
                                        durationInMs = duration * 1000;
                                        break;
                                    case 'm':
                                        durationInMs = duration * 1000 * 60;
                                        break;
                                    default:
                                        break;
                                ***REMOVED***
                                advanceFrameBy(durationInMs / this_1.frameTimeFactor);
                                break;
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***
                    throw new Error('there can only be \'^\' and \'!\' markers in a ' +
                        'subscription marble diagram. Found instead \'' + c + '\'.');
            ***REMOVED***
            frame = nextFrame;
            out_i_1 = i;
        ***REMOVED***;
        var this_1 = this, out_i_1;
        for (var i = 0; i < len; i++) ***REMOVED***
            _loop_1(i);
            i = out_i_1;
        ***REMOVED***
        if (unsubscriptionFrame < 0) ***REMOVED***
            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);
        ***REMOVED***
        else ***REMOVED***
            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);
        ***REMOVED***
    ***REMOVED***;
    TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables, runMode) ***REMOVED***
        var _this = this;
        if (materializeInnerObservables === void 0) ***REMOVED*** materializeInnerObservables = false; ***REMOVED***
        if (runMode === void 0) ***REMOVED*** runMode = false; ***REMOVED***
        if (marbles.indexOf('!') !== -1) ***REMOVED***
            throw new Error('conventional marble diagrams cannot have the ' +
                'unsubscription marker "!"');
        ***REMOVED***
        var len = marbles.length;
        var testMessages = [];
        var subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');
        var frame = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);
        var getValue = typeof values !== 'object' ?
            function (x) ***REMOVED*** return x; ***REMOVED*** :
            function (x) ***REMOVED***
                if (materializeInnerObservables && values[x] instanceof ColdObservable_1.ColdObservable) ***REMOVED***
                    return values[x].messages;
                ***REMOVED***
                return values[x];
            ***REMOVED***;
        var groupStart = -1;
        var _loop_2 = function (i) ***REMOVED***
            var nextFrame = frame;
            var advanceFrameBy = function (count) ***REMOVED***
                nextFrame += count * _this.frameTimeFactor;
            ***REMOVED***;
            var notification = void 0;
            var c = marbles[i];
            switch (c) ***REMOVED***
                case ' ':
                    if (!runMode) ***REMOVED***
                        advanceFrameBy(1);
                    ***REMOVED***
                    break;
                case '-':
                    advanceFrameBy(1);
                    break;
                case '(':
                    groupStart = frame;
                    advanceFrameBy(1);
                    break;
                case ')':
                    groupStart = -1;
                    advanceFrameBy(1);
                    break;
                case '|':
                    notification = Notification_1.Notification.createComplete();
                    advanceFrameBy(1);
                    break;
                case '^':
                    advanceFrameBy(1);
                    break;
                case '#':
                    notification = Notification_1.Notification.createError(errorValue || 'error');
                    advanceFrameBy(1);
                    break;
                default:
                    if (runMode && c.match(/^[0-9]$/)) ***REMOVED***
                        if (i === 0 || marbles[i - 1] === ' ') ***REMOVED***
                            var buffer = marbles.slice(i);
                            var match = buffer.match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);
                            if (match) ***REMOVED***
                                i += match[0].length - 1;
                                var duration = parseFloat(match[1]);
                                var unit = match[2];
                                var durationInMs = void 0;
                                switch (unit) ***REMOVED***
                                    case 'ms':
                                        durationInMs = duration;
                                        break;
                                    case 's':
                                        durationInMs = duration * 1000;
                                        break;
                                    case 'm':
                                        durationInMs = duration * 1000 * 60;
                                        break;
                                    default:
                                        break;
                                ***REMOVED***
                                advanceFrameBy(durationInMs / this_2.frameTimeFactor);
                                break;
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***
                    notification = Notification_1.Notification.createNext(getValue(c));
                    advanceFrameBy(1);
                    break;
            ***REMOVED***
            if (notification) ***REMOVED***
                testMessages.push(***REMOVED*** frame: groupStart > -1 ? groupStart : frame, notification: notification ***REMOVED***);
            ***REMOVED***
            frame = nextFrame;
            out_i_2 = i;
        ***REMOVED***;
        var this_2 = this, out_i_2;
        for (var i = 0; i < len; i++) ***REMOVED***
            _loop_2(i);
            i = out_i_2;
        ***REMOVED***
        return testMessages;
    ***REMOVED***;
    TestScheduler.prototype.run = function (callback) ***REMOVED***
        var prevFrameTimeFactor = TestScheduler.frameTimeFactor;
        var prevMaxFrames = this.maxFrames;
        TestScheduler.frameTimeFactor = 1;
        this.maxFrames = Number.POSITIVE_INFINITY;
        this.runMode = true;
        AsyncScheduler_1.AsyncScheduler.delegate = this;
        var helpers = ***REMOVED***
            cold: this.createColdObservable.bind(this),
            hot: this.createHotObservable.bind(this),
            flush: this.flush.bind(this),
            expectObservable: this.expectObservable.bind(this),
            expectSubscriptions: this.expectSubscriptions.bind(this),
        ***REMOVED***;
        try ***REMOVED***
            var ret = callback(helpers);
            this.flush();
            return ret;
        ***REMOVED***
        finally ***REMOVED***
            TestScheduler.frameTimeFactor = prevFrameTimeFactor;
            this.maxFrames = prevMaxFrames;
            this.runMode = false;
            AsyncScheduler_1.AsyncScheduler.delegate = undefined;
        ***REMOVED***
    ***REMOVED***;
    return TestScheduler;
***REMOVED***(VirtualTimeScheduler_1.VirtualTimeScheduler));
exports.TestScheduler = TestScheduler;
//# sourceMappingURL=TestScheduler.js.map