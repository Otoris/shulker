/**
 * Data structure that makes it easy to interact with a bitfield.
 */
class BitField ***REMOVED***
  /**
   * @param ***REMOVED***BitFieldResolvable***REMOVED*** [bits=0] Bits(s) to read from
   */
  constructor(bits) ***REMOVED***
    /**
     * Bitfield of the packed bits
     * @type ***REMOVED***number***REMOVED***
     */
    this.bitfield = this.constructor.resolve(bits);
  ***REMOVED***

  /**
   * Checks whether the bitfield has a bit, or any of multiple bits.
   * @param ***REMOVED***BitFieldResolvable***REMOVED*** bit Bit(s) to check for
   * @returns ***REMOVED***boolean***REMOVED***
   */
  any(bit) ***REMOVED***
    return (this.bitfield & this.constructor.resolve(bit)) !== 0;
  ***REMOVED***

  /**
   * Checks if this bitfield equals another
   * @param ***REMOVED***BitFieldResolvable***REMOVED*** bit Bit(s) to check for
   * @returns ***REMOVED***boolean***REMOVED***
   */
  equals(bit) ***REMOVED***
    return this.bitfield === this.constructor.resolve(bit);
  ***REMOVED***

  /**
   * Checks whether the bitfield has a bit, or multiple bits.
   * @param ***REMOVED***BitFieldResolvable***REMOVED*** bit Bit(s) to check for
   * @returns ***REMOVED***boolean***REMOVED***
   */
  has(bit) ***REMOVED***
    if (Array.isArray(bit)) return bit.every(p => this.has(p));
    bit = this.constructor.resolve(bit);
    return (this.bitfield & bit) === bit;
  ***REMOVED***

  /**
   * Gets all given bits that are missing from the bitfield.
   * @param ***REMOVED***BitFieldResolvable***REMOVED*** bits Bits(s) to check for
   * @param ***REMOVED***...****REMOVED*** hasParams Additional parameters for the has method, if any
   * @returns ***REMOVED***string[]***REMOVED***
   */
  missing(bits, ...hasParams) ***REMOVED***
    if (!Array.isArray(bits)) bits = new this.constructor(bits).toArray(false);
    return bits.filter(p => !this.has(p, ...hasParams));
  ***REMOVED***

  /**
   * Freezes these bits, making them immutable.
   * @returns ***REMOVED***Readonly<BitField>***REMOVED*** These bits
   */
  freeze() ***REMOVED***
    return Object.freeze(this);
  ***REMOVED***

  /**
   * Adds bits to these ones.
   * @param ***REMOVED***...BitFieldResolvable***REMOVED*** [bits] Bits to add
   * @returns ***REMOVED***BitField***REMOVED*** These bits or new BitField if the instance is frozen.
   */
  add(...bits) ***REMOVED***
    let total = 0;
    for (const bit of bits) ***REMOVED***
      total |= this.constructor.resolve(bit);
    ***REMOVED***
    if (Object.isFrozen(this)) return new this.constructor(this.bitfield | total);
    this.bitfield |= total;
    return this;
  ***REMOVED***

  /**
   * Removes bits from these.
   * @param ***REMOVED***...BitFieldResolvable***REMOVED*** [bits] Bits to remove
   * @returns ***REMOVED***BitField***REMOVED*** These bits or new BitField if the instance is frozen.
   */
  remove(...bits) ***REMOVED***
    let total = 0;
    for (const bit of bits) ***REMOVED***
      total |= this.constructor.resolve(bit);
    ***REMOVED***
    if (Object.isFrozen(this)) return new this.constructor(this.bitfield & ~total);
    this.bitfield &= ~total;
    return this;
  ***REMOVED***

  /**
   * Gets an object mapping field names to a ***REMOVED***@link boolean***REMOVED*** indicating whether the
   * bit is available.
   * @param ***REMOVED***...****REMOVED*** hasParams Additional parameters for the has method, if any
   * @returns ***REMOVED***Object***REMOVED***
   */
  serialize(...hasParams) ***REMOVED***
    const serialized = ***REMOVED******REMOVED***;
    for (const flag of Object.keys(this.constructor.FLAGS)) ***REMOVED***
      serialized[flag] = this.has(this.constructor.FLAGS[flag], ...hasParams);
    ***REMOVED***
    return serialized;
  ***REMOVED***

  /**
   * Gets an ***REMOVED***@link Array***REMOVED*** of bitfield names based on the bits available.
   * @param ***REMOVED***...****REMOVED*** hasParams Additional parameters for the has method, if any
   * @returns ***REMOVED***string[]***REMOVED***
   */
  toArray(...hasParams) ***REMOVED***
    return Object.keys(this.constructor.FLAGS).filter(bit => this.has(bit, ...hasParams));
  ***REMOVED***

  toJSON() ***REMOVED***
    return this.bitfield;
  ***REMOVED***

  valueOf() ***REMOVED***
    return this.bitfield;
  ***REMOVED***

  *[Symbol.iterator]() ***REMOVED***
    yield* this.toArray();
  ***REMOVED***

  /**
   * Data that can be resolved to give a bitfield. This can be:
   * * A string (see ***REMOVED***@link BitField.FLAGS***REMOVED***)
   * * A bit number
   * * An instance of BitField
   * * An Array of BitFieldResolvable
   * @typedef ***REMOVED***string|number|BitField|BitFieldResolvable[]***REMOVED*** BitFieldResolvable
   */

  /**
   * Resolves bitfields to their numeric form.
   * @param ***REMOVED***BitFieldResolvable***REMOVED*** [bit=0] - bit(s) to resolve
   * @returns ***REMOVED***number***REMOVED***
   */
  static resolve(bit = 0) ***REMOVED***
    if (typeof bit === 'number' && bit >= 0) return bit;
    if (bit instanceof BitField) return bit.bitfield;
    if (Array.isArray(bit)) return bit.map(p => this.resolve(p)).reduce((prev, p) => prev | p, 0);
    if (typeof bit === 'string' && typeof this.FLAGS[bit] !== 'undefined') return this.FLAGS[bit];
    throw new RangeError('Invalid bitfield flag or number.');
  ***REMOVED***
***REMOVED***

/**
 * Numeric bitfield flags.
 * <info>Defined in extension classes</info>
 * @type ***REMOVED***Object***REMOVED***
 * @abstract
 */
BitField.FLAGS = ***REMOVED******REMOVED***;

module.exports = BitField;
