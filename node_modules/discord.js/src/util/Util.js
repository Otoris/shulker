const snekfetch = require('snekfetch');
const Constants = require('./Constants');
const ConstantsHttp = Constants.DefaultOptions.http;

/**
 * Contains various general-purpose utility methods. These functions are also available on the base `Discord` object.
 */
class Util ***REMOVED***
  constructor() ***REMOVED***
    throw new Error(`The $***REMOVED***this.constructor.name***REMOVED*** class may not be instantiated.`);
  ***REMOVED***

  /**
   * Splits a string into multiple chunks at a designated character that do not exceed a specific length.
   * @param ***REMOVED***string***REMOVED*** text Content to split
   * @param ***REMOVED***SplitOptions***REMOVED*** [options] Options controlling the behaviour of the split
   * @returns ***REMOVED***string|string[]***REMOVED***
   */
  static splitMessage(text, ***REMOVED*** maxLength = 1950, char = '\n', prepend = '', append = '' ***REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
    if (text.length <= maxLength) return text;
    const splitText = text.split(char);
    if (splitText.some(chunk => chunk.length > maxLength)) ***REMOVED***
      throw new Error('Message exceeds the max length and contains no split characters.');
    ***REMOVED***
    const messages = [''];
    let msg = 0;
    for (let i = 0; i < splitText.length; i++) ***REMOVED***
      if (messages[msg].length + splitText[i].length + 1 > maxLength) ***REMOVED***
        messages[msg] += append;
        messages.push(prepend);
        msg++;
      ***REMOVED***
      messages[msg] += (messages[msg].length > 0 && messages[msg] !== prepend ? char : '') + splitText[i];
    ***REMOVED***
    return messages;
  ***REMOVED***

  /**
   * Data that can be resolved to give a string. This can be:
   * * A string
   * * An array (joined with a new line delimiter to give a string)
   * * Any value
   * @typedef ***REMOVED***string|Array|****REMOVED*** StringResolvable
   */

  /**
   * Resolves a StringResolvable to a string.
   * @param ***REMOVED***StringResolvable***REMOVED*** data The string resolvable to resolve
   * @returns ***REMOVED***string***REMOVED***
   */
  static resolveString(data) ***REMOVED***
    if (typeof data === 'string') return data;
    if (Array.isArray(data)) return data.join('\n');
    return String(data);
  ***REMOVED***

  /**
   * Escapes any Discord-flavour markdown in a string.
   * @param ***REMOVED***string***REMOVED*** text Content to escape
   * @param ***REMOVED***boolean***REMOVED*** [onlyCodeBlock=false] Whether to only escape codeblocks (takes priority)
   * @param ***REMOVED***boolean***REMOVED*** [onlyInlineCode=false] Whether to only escape inline code
   * @returns ***REMOVED***string***REMOVED***
   */
  static escapeMarkdown(text, onlyCodeBlock = false, onlyInlineCode = false) ***REMOVED***
    if (onlyCodeBlock) return text.replace(/```/g, '`\u200b``');
    if (onlyInlineCode) return text.replace(/\\(`|\\)/g, '$1').replace(/(`|\\)/g, '\\$1');
    return text.replace(/\\(\*|_|`|~|\\)/g, '$1').replace(/(\*|_|`|~|\\)/g, '\\$1');
  ***REMOVED***

  /**
   * Gets the recommended shard count from Discord.
   * @param ***REMOVED***string***REMOVED*** token Discord auth token
   * @param ***REMOVED***number***REMOVED*** [guildsPerShard=1000] Number of guilds per shard
   * @returns ***REMOVED***Promise<number>***REMOVED*** The recommended number of shards
   */
  static fetchRecommendedShards(token, guildsPerShard = 1000) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      if (!token) throw new Error('A token must be provided.');
      snekfetch.get(`$***REMOVED***ConstantsHttp.host***REMOVED***/api/v$***REMOVED***ConstantsHttp.version***REMOVED***$***REMOVED***Constants.Endpoints.gateway.bot***REMOVED***`)
        .set('Authorization', `Bot $***REMOVED***token.replace(/^Bot\s*/i, '')***REMOVED***`)
        .end((err, res) => ***REMOVED***
          if (err) reject(err);
          resolve(res.body.shards * (1000 / guildsPerShard));
        ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Parses emoji info out of a string. The string must be one of:
   * * A UTF-8 emoji (no ID)
   * * A URL-encoded UTF-8 emoji (no ID)
   * * A Discord custom emoji (`<:name:id>` or `<a:name:id>`)
   * @param ***REMOVED***string***REMOVED*** text Emoji string to parse
   * @returns ***REMOVED***?Object***REMOVED*** Object with `animated`, `name`, and `id` properties
   * @private
   */
  static parseEmoji(text) ***REMOVED***
    if (text.includes('%')) text = decodeURIComponent(text);
    if (!text.includes(':')) return ***REMOVED*** animated: false, name: text, id: null ***REMOVED***;
    const m = text.match(/<?(a:)?(\w***REMOVED***2,32***REMOVED***):(\d***REMOVED***17,19***REMOVED***)>?/);
    if (!m) return null;
    return ***REMOVED*** animated: Boolean(m[1]), name: m[2], id: m[3] ***REMOVED***;
  ***REMOVED***

  /**
   * Checks whether two arrays are equal or have the same elements.
   * @param ***REMOVED***Array<*>***REMOVED*** a The first array.
   * @param ***REMOVED***Array<*>***REMOVED*** b The second array.
   * @returns ***REMOVED***boolean***REMOVED*** Whether the arrays are equal.
   * @private
   */
  static arraysEqual(a, b) ***REMOVED***
    if (a === b) return true;
    if (a.length !== b.length) return false;

    const setA = new Set(a);
    const setB = new Set(b);

    return a.every(e => setB.has(e)) && b.every(e => setA.has(e));
  ***REMOVED***

  /**
   * Shallow-copies an object with its class/prototype intact.
   * @param ***REMOVED***Object***REMOVED*** obj Object to clone
   * @returns ***REMOVED***Object***REMOVED***
   * @private
   */
  static cloneObject(obj) ***REMOVED***
    return Object.assign(Object.create(obj), obj);
  ***REMOVED***

  /**
   * Sets default properties on an object that aren't already specified.
   * @param ***REMOVED***Object***REMOVED*** def Default properties
   * @param ***REMOVED***Object***REMOVED*** given Object to assign defaults to
   * @returns ***REMOVED***Object***REMOVED***
   * @private
   */
  static mergeDefault(def, given) ***REMOVED***
    if (!given) return def;
    for (const key in def) ***REMOVED***
      if (!***REMOVED******REMOVED***.hasOwnProperty.call(given, key)) ***REMOVED***
        given[key] = def[key];
      ***REMOVED*** else if (given[key] === Object(given[key])) ***REMOVED***
        given[key] = this.mergeDefault(def[key], given[key]);
      ***REMOVED***
    ***REMOVED***

    return given;
  ***REMOVED***

  /**
   * Converts an ArrayBuffer or string to a Buffer.
   * @param ***REMOVED***ArrayBuffer|string***REMOVED*** ab ArrayBuffer to convert
   * @returns ***REMOVED***Buffer***REMOVED***
   * @private
   */
  static convertToBuffer(ab) ***REMOVED***
    if (typeof ab === 'string') ab = this.str2ab(ab);
    return Buffer.from(ab);
  ***REMOVED***

  /**
   * Converts a string to an ArrayBuffer.
   * @param ***REMOVED***string***REMOVED*** str String to convert
   * @returns ***REMOVED***ArrayBuffer***REMOVED***
   * @private
   */
  static str2ab(str) ***REMOVED***
    const buffer = new ArrayBuffer(str.length * 2);
    const view = new Uint16Array(buffer);
    for (var i = 0, strLen = str.length; i < strLen; i++) view[i] = str.charCodeAt(i);
    return buffer;
  ***REMOVED***

  /**
   * Makes an Error from a plain info object.
   * @param ***REMOVED***Object***REMOVED*** obj Error info
   * @param ***REMOVED***string***REMOVED*** obj.name Error type
   * @param ***REMOVED***string***REMOVED*** obj.message Message for the error
   * @param ***REMOVED***string***REMOVED*** obj.stack Stack for the error
   * @returns ***REMOVED***Error***REMOVED***
   * @private
   */
  static makeError(obj) ***REMOVED***
    const err = new Error(obj.message);
    err.name = obj.name;
    err.stack = obj.stack;
    return err;
  ***REMOVED***

  /**
   * Makes a plain error info object from an Error.
   * @param ***REMOVED***Error***REMOVED*** err Error to get info from
   * @returns ***REMOVED***Object***REMOVED***
   * @private
   */
  static makePlainError(err) ***REMOVED***
    const obj = ***REMOVED******REMOVED***;
    obj.name = err.name;
    obj.message = err.message;
    obj.stack = err.stack;
    return obj;
  ***REMOVED***

  /**
   * Moves an element in an array *in place*.
   * @param ***REMOVED***Array<*>***REMOVED*** array Array to modify
   * @param ***REMOVED*******REMOVED*** element Element to move
   * @param ***REMOVED***number***REMOVED*** newIndex Index or offset to move the element to
   * @param ***REMOVED***boolean***REMOVED*** [offset=false] Move the element by an offset amount rather than to a set index
   * @returns ***REMOVED***number***REMOVED***
   * @private
   */
  static moveElementInArray(array, element, newIndex, offset = false) ***REMOVED***
    const index = array.indexOf(element);
    newIndex = (offset ? index : 0) + newIndex;
    if (newIndex > -1 && newIndex < array.length) ***REMOVED***
      const removedElement = array.splice(index, 1)[0];
      array.splice(newIndex, 0, removedElement);
    ***REMOVED***
    return array.indexOf(element);
  ***REMOVED***

  /**
   * Creates a Promise that resolves after a specified duration.
   * @param ***REMOVED***number***REMOVED*** ms How long to wait before resolving (in milliseconds)
   * @returns ***REMOVED***Promise<void>***REMOVED***
   * @private
   */
  static delayFor(ms) ***REMOVED***
    return new Promise(resolve => ***REMOVED***
      setTimeout(resolve, ms);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

module.exports = Util;
