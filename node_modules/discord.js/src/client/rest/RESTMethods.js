const querystring = require('querystring');
const long = require('long');
const Permissions = require('../../util/Permissions');
const Constants = require('../../util/Constants');
const Endpoints = Constants.Endpoints;
const Collection = require('../../util/Collection');
const Util = require('../../util/Util');
const resolvePermissions = require('../../structures/shared/resolvePermissions');

const RichEmbed = require('../../structures/RichEmbed');
const User = require('../../structures/User');
const GuildMember = require('../../structures/GuildMember');
const Message = require('../../structures/Message');
const Role = require('../../structures/Role');
const Invite = require('../../structures/Invite');
const Webhook = require('../../structures/Webhook');
const UserProfile = require('../../structures/UserProfile');
const OAuth2Application = require('../../structures/OAuth2Application');
const Channel = require('../../structures/Channel');
const GroupDMChannel = require('../../structures/GroupDMChannel');
const Guild = require('../../structures/Guild');
const VoiceRegion = require('../../structures/VoiceRegion');
const GuildAuditLogs = require('../../structures/GuildAuditLogs');

const MessageFlags = require('../../util/MessageFlags');

class RESTMethods ***REMOVED***
  constructor(restManager) ***REMOVED***
    this.rest = restManager;
    this.client = restManager.client;
    this._ackToken = null;
  ***REMOVED***

  login(token = this.client.token) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      if (!token || typeof token !== 'string') throw new Error(Constants.Errors.INVALID_TOKEN);
      token = token.replace(/^Bot\s*/i, '');
      this.client.manager.connectToWebSocket(token, resolve, reject);
    ***REMOVED***).catch(e => ***REMOVED***
      this.client.destroy();
      return Promise.reject(e);
    ***REMOVED***);
  ***REMOVED***

  logout() ***REMOVED***
    return this.rest.makeRequest('post', Endpoints.logout, true, ***REMOVED******REMOVED***);
  ***REMOVED***

  getGateway(bot = false) ***REMOVED***
    return this.rest.makeRequest('get', bot ? Endpoints.gateway.bot : Endpoints.gateway, true);
  ***REMOVED***

  fetchVoiceRegions(guildID) ***REMOVED***
    let endpoint;
    if (guildID) endpoint = Endpoints.Guild(guildID).voiceRegions;
    else endpoint = Endpoints.voiceRegions;
    return this.rest.makeRequest('get', endpoint, true).then(res => ***REMOVED***
      const regions = new Collection();
      for (const region of res) regions.set(region.id, new VoiceRegion(region));
      return regions;
    ***REMOVED***);
  ***REMOVED***

  fetchEmbed(guildID) ***REMOVED***
    return this.rest.makeRequest('get', Endpoints.Guild(guildID).embed, true).then(data => (***REMOVED***
      enabled: data.enabled,
      channel: data.channel_id ? this.client.channels.get(data.channel_id) : null,
    ***REMOVED***));
  ***REMOVED***

  sendMessage(channel, content, ***REMOVED*** tts, nonce, embed, disableEveryone, split, code, reply ***REMOVED*** = ***REMOVED******REMOVED***, files = null) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED*** // eslint-disable-line complexity
      if (typeof content !== 'undefined') content = this.client.resolver.resolveString(content);

      // The nonce has to be a uint64 :<
      if (typeof nonce !== 'undefined') ***REMOVED***
        nonce = parseInt(nonce);
        if (isNaN(nonce) || nonce < 0) throw new RangeError('Message nonce must fit in an unsigned 64-bit integer.');
      ***REMOVED***

      if (content) ***REMOVED***
        if (split && typeof split !== 'object') split = ***REMOVED******REMOVED***;

        // Wrap everything in a code block
        if (typeof code !== 'undefined' && (typeof code !== 'boolean' || code === true)) ***REMOVED***
          content = Util.escapeMarkdown(this.client.resolver.resolveString(content), true);
          content = `\`\`\`$***REMOVED***typeof code !== 'boolean' ? code || '' : ''***REMOVED***\n$***REMOVED***content***REMOVED***\n\`\`\``;
          if (split) ***REMOVED***
            split.prepend = `\`\`\`$***REMOVED***typeof code !== 'boolean' ? code || '' : ''***REMOVED***\n`;
            split.append = '\n```';
          ***REMOVED***
        ***REMOVED***

        // Add zero-width spaces to @everyone/@here
        if (disableEveryone || (typeof disableEveryone === 'undefined' && this.client.options.disableEveryone)) ***REMOVED***
          content = content.replace(/@(everyone|here)/g, '@\u200b$1');
        ***REMOVED***

        // Add the reply prefix
        if (reply && !(channel instanceof User || channel instanceof GuildMember) && channel.type !== 'dm') ***REMOVED***
          const id = this.client.resolver.resolveUserID(reply);
          const mention = `<@$***REMOVED***reply instanceof GuildMember && reply.nickname ? '!' : ''***REMOVED***$***REMOVED***id***REMOVED***>`;
          content = `$***REMOVED***mention***REMOVED***$***REMOVED***content ? `, $***REMOVED***content***REMOVED***` : ''***REMOVED***`;
          if (split) split.prepend = `$***REMOVED***mention***REMOVED***, $***REMOVED***split.prepend || ''***REMOVED***`;
        ***REMOVED***

        // Split the content
        if (split) content = Util.splitMessage(content, split);
      ***REMOVED*** else if (reply && !(channel instanceof User || channel instanceof GuildMember) && channel.type !== 'dm') ***REMOVED***
        const id = this.client.resolver.resolveUserID(reply);
        content = `<@$***REMOVED***reply instanceof GuildMember && reply.nickname ? '!' : ''***REMOVED***$***REMOVED***id***REMOVED***>`;
      ***REMOVED***

      const send = chan => ***REMOVED***
        if (content instanceof Array) ***REMOVED***
          const messages = [];
          (function sendChunk(list, index) ***REMOVED***
            const options = index === list.length - 1 ? ***REMOVED*** tts, embed, files ***REMOVED*** : ***REMOVED*** tts ***REMOVED***;
            chan.send(list[index], options).then(message => ***REMOVED***
              messages.push(message);
              if (index >= list.length - 1) return resolve(messages);
              return sendChunk(list, ++index);
            ***REMOVED***).catch(reject);
          ***REMOVED***(content, 0));
        ***REMOVED*** else ***REMOVED***
          this.rest.makeRequest('post', Endpoints.Channel(chan).messages, true, ***REMOVED***
            content, tts, nonce, embed,
          ***REMOVED***, files).then(data => resolve(this.client.actions.MessageCreate.handle(data).message), reject);
        ***REMOVED***
      ***REMOVED***;

      if (channel instanceof User || channel instanceof GuildMember) this.createDM(channel).then(send, reject);
      else send(channel);
    ***REMOVED***);
  ***REMOVED***

  updateMessage(message, content, ***REMOVED*** flags, embed, code, reply ***REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
    if (typeof content !== 'undefined') content = this.client.resolver.resolveString(content);

    if (typeof flags !== 'undefined') flags = MessageFlags.resolve(flags);

    // Wrap everything in a code block
    if (typeof code !== 'undefined' && (typeof code !== 'boolean' || code === true)) ***REMOVED***
      content = Util.escapeMarkdown(this.client.resolver.resolveString(content), true);
      content = `\`\`\`$***REMOVED***typeof code !== 'boolean' ? code || '' : ''***REMOVED***\n$***REMOVED***content***REMOVED***\n\`\`\``;
    ***REMOVED***

    // Add the reply prefix
    if (reply && message.channel.type !== 'dm') ***REMOVED***
      const id = this.client.resolver.resolveUserID(reply);
      const mention = `<@$***REMOVED***reply instanceof GuildMember && reply.nickname ? '!' : ''***REMOVED***$***REMOVED***id***REMOVED***>`;
      content = `$***REMOVED***mention***REMOVED***$***REMOVED***content ? `, $***REMOVED***content***REMOVED***` : ''***REMOVED***`;
    ***REMOVED***

    if (embed instanceof RichEmbed) embed = embed.toJSON();

    return this.rest.makeRequest('patch', Endpoints.Message(message), true, ***REMOVED***
      content, embed, flags,
    ***REMOVED***).then(data => this.client.actions.MessageUpdate.handle(data).updated);
  ***REMOVED***

  deleteMessage(message) ***REMOVED***
    return this.rest.makeRequest('delete', Endpoints.Message(message), true)
      .then(() =>
        this.client.actions.MessageDelete.handle(***REMOVED***
          id: message.id,
          channel_id: message.channel.id,
        ***REMOVED***).message
      );
  ***REMOVED***

  ackMessage(message) ***REMOVED***
    return this.rest.makeRequest('post', Endpoints.Message(message).ack, true, ***REMOVED*** token: this._ackToken ***REMOVED***).then(res => ***REMOVED***
      if (res.token) this._ackToken = res.token;
      return message;
    ***REMOVED***);
  ***REMOVED***

  ackTextChannel(channel) ***REMOVED***
    return this.rest.makeRequest('post', Endpoints.Channel(channel).Message(channel.lastMessageID).ack, true, ***REMOVED***
      token: this._ackToken,
    ***REMOVED***).then(res => ***REMOVED***
      if (res.token) this._ackToken = res.token;
      return channel;
    ***REMOVED***);
  ***REMOVED***

  ackGuild(guild) ***REMOVED***
    return this.rest.makeRequest('post', Endpoints.Guild(guild).ack, true).then(() => guild);
  ***REMOVED***

  bulkDeleteMessages(channel, messages) ***REMOVED***
    return this.rest.makeRequest('post', Endpoints.Channel(channel).messages.bulkDelete, true, ***REMOVED***
      messages: messages,
    ***REMOVED***).then(() =>
      this.client.actions.MessageDeleteBulk.handle(***REMOVED***
        channel_id: channel.id,
        ids: messages,
      ***REMOVED***).messages
    );
  ***REMOVED***

  search(target, options) ***REMOVED***
    if (typeof options === 'string') options = ***REMOVED*** content: options ***REMOVED***;
    if (options.before) ***REMOVED***
      if (!(options.before instanceof Date)) options.before = new Date(options.before);
      options.maxID = long.fromNumber(options.before.getTime() - 14200704e5).shiftLeft(22).toString();
    ***REMOVED***
    if (options.after) ***REMOVED***
      if (!(options.after instanceof Date)) options.after = new Date(options.after);
      options.minID = long.fromNumber(options.after.getTime() - 14200704e5).shiftLeft(22).toString();
    ***REMOVED***
    if (options.during) ***REMOVED***
      if (!(options.during instanceof Date)) options.during = new Date(options.during);
      const t = options.during.getTime() - 14200704e5;
      options.minID = long.fromNumber(t).shiftLeft(22).toString();
      options.maxID = long.fromNumber(t + 86400000).shiftLeft(22).toString();
    ***REMOVED***
    if (options.channel) options.channel = this.client.resolver.resolveChannelID(options.channel);
    if (options.author) options.author = this.client.resolver.resolveUserID(options.author);
    if (options.mentions) options.mentions = this.client.resolver.resolveUserID(options.options.mentions);
    options = ***REMOVED***
      content: options.content,
      max_id: options.maxID,
      min_id: options.minID,
      has: options.has,
      channel_id: options.channel,
      author_id: options.author,
      author_type: options.authorType,
      context_size: options.contextSize,
      sort_by: options.sortBy,
      sort_order: options.sortOrder,
      limit: options.limit,
      offset: options.offset,
      mentions: options.mentions,
      mentions_everyone: options.mentionsEveryone,
      link_hostname: options.linkHostname,
      embed_provider: options.embedProvider,
      embed_type: options.embedType,
      attachment_filename: options.attachmentFilename,
      attachment_extension: options.attachmentExtension,
      include_nsfw: options.nsfw,
    ***REMOVED***;

    for (const key of Object.keys(options)) if (options[key] === undefined) delete options[key];
    const queryString = (querystring.stringify(options).match(/[^=&?]+=[^=&?]+/g) || []).join('&');

    let endpoint;
    if (target instanceof Channel) ***REMOVED***
      endpoint = Endpoints.Channel(target).search;
    ***REMOVED*** else if (target instanceof Guild) ***REMOVED***
      endpoint = Endpoints.Guild(target).search;
    ***REMOVED*** else ***REMOVED***
      throw new TypeError('Target must be a TextChannel, DMChannel, GroupDMChannel, or Guild.');
    ***REMOVED***
    return this.rest.makeRequest('get', `$***REMOVED***endpoint***REMOVED***?$***REMOVED***queryString***REMOVED***`, true).then(body => ***REMOVED***
      const messages = body.messages.map(x =>
        x.map(m => new Message(this.client.channels.get(m.channel_id), m, this.client))
      );
      return ***REMOVED***
        totalResults: body.total_results,
        messages,
      ***REMOVED***;
    ***REMOVED***);
  ***REMOVED***

  createChannel(guild, name, options) ***REMOVED***
    const ***REMOVED***
      type,
      topic,
      nsfw,
      bitrate,
      userLimit,
      parent,
      permissionOverwrites,
      position,
      rateLimitPerUser,
      reason,
    ***REMOVED*** = options;
    return this.rest.makeRequest('post', Endpoints.Guild(guild).channels, true, ***REMOVED***
      name,
      topic,
      type: type ? Constants.ChannelTypes[type.toUpperCase()] : Constants.ChannelTypes.TEXT,
      nsfw,
      bitrate,
      user_limit: userLimit,
      parent_id: parent instanceof Channel ? parent.id : parent,
      permission_overwrites: resolvePermissions.call(this, permissionOverwrites, guild),
      position,
      rate_limit_per_user: rateLimitPerUser,
    ***REMOVED***,
    undefined,
    reason).then(data => this.client.actions.ChannelCreate.handle(data).channel);
  ***REMOVED***

  createDM(recipient) ***REMOVED***
    const dmChannel = this.getExistingDM(recipient);
    if (dmChannel) return Promise.resolve(dmChannel);
    return this.rest.makeRequest('post', Endpoints.User(this.client.user).channels, true, ***REMOVED***
      recipient_id: recipient.id,
    ***REMOVED***).then(data => this.client.actions.ChannelCreate.handle(data).channel);
  ***REMOVED***

  createGroupDM(options) ***REMOVED***
    const data = this.client.user.bot ?
      ***REMOVED*** access_tokens: options.accessTokens, nicks: options.nicks ***REMOVED*** :
      ***REMOVED*** recipients: options.recipients ***REMOVED***;
    return this.rest.makeRequest('post', Endpoints.User('@me').channels, true, data)
      .then(res => new GroupDMChannel(this.client, res));
  ***REMOVED***

  addUserToGroupDM(channel, options) ***REMOVED***
    const data = this.client.user.bot ?
      ***REMOVED*** nick: options.nick, access_token: options.accessToken ***REMOVED*** :
      ***REMOVED*** recipient: options.id ***REMOVED***;
    return this.rest.makeRequest('put', Endpoints.Channel(channel).Recipient(options.id), true, data)
      .then(() => channel);
  ***REMOVED***

  removeUserFromGroupDM(channel, userId) ***REMOVED***
    return this.rest.makeRequest('delete', Endpoints.Channel(channel).Recipient(userId), true)
      .then(() => channel);
  ***REMOVED***

  updateGroupDMChannel(channel, _data) ***REMOVED***
    const data = ***REMOVED******REMOVED***;
    data.name = _data.name;
    data.icon = _data.icon;
    return this.rest.makeRequest('patch', Endpoints.Channel(channel), true, data).then(() => channel);
  ***REMOVED***

  getExistingDM(recipient) ***REMOVED***
    return this.client.channels.find(channel =>
      channel.recipient && channel.recipient.id === recipient.id
    );
  ***REMOVED***

  deleteChannel(channel, reason) ***REMOVED***
    if (channel instanceof User || channel instanceof GuildMember) channel = this.getExistingDM(channel);
    if (!channel) return Promise.reject(new Error('No channel to delete.'));
    return this.rest.makeRequest('delete', Endpoints.Channel(channel), true, undefined, undefined, reason)
      .then(data => ***REMOVED***
        data.id = channel.id;
        return this.client.actions.ChannelDelete.handle(data).channel;
      ***REMOVED***);
  ***REMOVED***

  updateChannel(channel, _data, reason) ***REMOVED***
    const data = ***REMOVED******REMOVED***;
    data.name = (_data.name || channel.name).trim();
    data.topic = typeof _data.topic === 'undefined' ? channel.topic : _data.topic;
    data.nsfw = typeof _data.nsfw === 'undefined' ? channel.nsfw : _data.nsfw;
    data.position = _data.position || channel.position;
    data.bitrate = _data.bitrate || (channel.bitrate ? channel.bitrate * 1000 : undefined);
    data.user_limit = typeof _data.userLimit !== 'undefined' ? _data.userLimit : channel.userLimit;
    data.parent_id = _data.parent instanceof Channel ? _data.parent.id : _data.parent;
    data.permission_overwrites = _data.permissionOverwrites ?
      resolvePermissions.call(this, _data.permissionOverwrites, channel.guild) : undefined;
    data.rate_limit_per_user = typeof _data.rateLimitPerUser !== 'undefined' ?
      _data.rateLimitPerUser : channel.rateLimitPerUser;
    return this.rest.makeRequest('patch', Endpoints.Channel(channel), true, data, undefined, reason).then(newData =>
      this.client.actions.ChannelUpdate.handle(newData).updated
    );
  ***REMOVED***

  leaveGuild(guild) ***REMOVED***
    if (guild.ownerID === this.client.user.id) return Promise.reject(new Error('Guild is owned by the client.'));
    return this.rest.makeRequest('delete', Endpoints.User('@me').Guild(guild.id), true).then(() =>
      this.client.actions.GuildDelete.handle(***REMOVED*** id: guild.id ***REMOVED***).guild
    );
  ***REMOVED***

  createGuild(options) ***REMOVED***
    options.icon = this.client.resolver.resolveBase64(options.icon) || null;
    options.region = options.region || 'us-central';
    return new Promise((resolve, reject) => ***REMOVED***
      this.rest.makeRequest('post', Endpoints.guilds, true, options).then(data => ***REMOVED***
        if (this.client.guilds.has(data.id)) return resolve(this.client.guilds.get(data.id));

        const handleGuild = guild => ***REMOVED***
          if (guild.id === data.id) ***REMOVED***
            this.client.removeListener(Constants.Events.GUILD_CREATE, handleGuild);
            this.client.clearTimeout(timeout);
            resolve(guild);
          ***REMOVED***
        ***REMOVED***;
        this.client.on(Constants.Events.GUILD_CREATE, handleGuild);

        const timeout = this.client.setTimeout(() => ***REMOVED***
          this.client.removeListener(Constants.Events.GUILD_CREATE, handleGuild);
          reject(new Error('Took too long to receive guild data.'));
        ***REMOVED***, 10000);
        return undefined;
      ***REMOVED***, reject);
    ***REMOVED***);
  ***REMOVED***

  // Untested but probably will work
  deleteGuild(guild) ***REMOVED***
    return this.rest.makeRequest('delete', Endpoints.Guild(guild), true).then(() =>
      this.client.actions.GuildDelete.handle(***REMOVED*** id: guild.id ***REMOVED***).guild
    );
  ***REMOVED***

  getUser(userID, cache) ***REMOVED***
    return this.rest.makeRequest('get', Endpoints.User(userID), true).then(data => ***REMOVED***
      if (cache) return this.client.actions.UserGet.handle(data).user;
      else return new User(this.client, data);
    ***REMOVED***);
  ***REMOVED***

  updateCurrentUser(_data, password) ***REMOVED***
    const user = this.client.user;
    const data = ***REMOVED******REMOVED***;
    data.username = _data.username || user.username;
    data.avatar = typeof _data.avatar === 'undefined' ? user.avatar : this.client.resolver.resolveBase64(_data.avatar);
    if (!user.bot) ***REMOVED***
      data.email = _data.email || user.email;
      data.password = password;
      if (_data.new_password) data.new_password = _data.newPassword;
    ***REMOVED***
    return this.rest.makeRequest('patch', Endpoints.User('@me'), true, data).then(newData =>
      this.client.actions.UserUpdate.handle(newData).updated
    );
  ***REMOVED***

  updateGuild(guild, data, reason) ***REMOVED***
    return this.rest.makeRequest('patch', Endpoints.Guild(guild), true, data, undefined, reason).then(newData =>
      this.client.actions.GuildUpdate.handle(newData).updated
    );
  ***REMOVED***

  kickGuildMember(guild, member, reason) ***REMOVED***
    return this.rest.makeRequest(
      'delete', Endpoints.Guild(guild).Member(member), true,
      undefined, undefined, reason)
      .then(() => member);
  ***REMOVED***

  createGuildRole(guild, data, reason) ***REMOVED***
    if (data.color) data.color = this.client.resolver.resolveColor(data.color);
    if (data.permissions) data.permissions = Permissions.resolve(data.permissions);
    return this.rest.makeRequest('post', Endpoints.Guild(guild).roles, true, data, undefined, reason).then(r => ***REMOVED***
      const ***REMOVED*** role ***REMOVED*** = this.client.actions.GuildRoleCreate.handle(***REMOVED***
        guild_id: guild.id,
        role: r,
      ***REMOVED***);
      if (data.position) return role.setPosition(data.position, reason);
      return role;
    ***REMOVED***);
  ***REMOVED***

  deleteGuildRole(role, reason) ***REMOVED***
    return this.rest.makeRequest(
      'delete', Endpoints.Guild(role.guild).Role(role.id), true,
      undefined, undefined, reason)
      .then(() =>
        this.client.actions.GuildRoleDelete.handle(***REMOVED***
          guild_id: role.guild.id,
          role_id: role.id,
        ***REMOVED***).role
      );
  ***REMOVED***

  setChannelOverwrite(channel, payload) ***REMOVED***
    return this.rest.makeRequest('put', `$***REMOVED***Endpoints.Channel(channel).permissions***REMOVED***/$***REMOVED***payload.id***REMOVED***`, true, payload);
  ***REMOVED***

  deletePermissionOverwrites(overwrite, reason) ***REMOVED***
    return this.rest.makeRequest(
      'delete', `$***REMOVED***Endpoints.Channel(overwrite.channel).permissions***REMOVED***/$***REMOVED***overwrite.id***REMOVED***`,
      true, undefined, undefined, reason
    ).then(() => overwrite);
  ***REMOVED***

  getChannelMessages(channel, payload = ***REMOVED******REMOVED***) ***REMOVED***
    const params = [];
    if (payload.limit) params.push(`limit=$***REMOVED***payload.limit***REMOVED***`);
    if (payload.around) params.push(`around=$***REMOVED***payload.around***REMOVED***`);
    else if (payload.before) params.push(`before=$***REMOVED***payload.before***REMOVED***`);
    else if (payload.after) params.push(`after=$***REMOVED***payload.after***REMOVED***`);

    let endpoint = Endpoints.Channel(channel).messages;
    if (params.length > 0) endpoint += `?$***REMOVED***params.join('&')***REMOVED***`;
    return this.rest.makeRequest('get', endpoint, true);
  ***REMOVED***

  getChannelMessage(channel, messageID) ***REMOVED***
    const msg = channel.messages.get(messageID);
    if (msg) return Promise.resolve(msg);
    return this.rest.makeRequest('get', Endpoints.Channel(channel).Message(messageID), true);
  ***REMOVED***

  putGuildMember(guild, userID, options) ***REMOVED***
    options.access_token = options.accessToken;
    if (options.roles) ***REMOVED***
      const roles = options.roles;
      if (roles instanceof Collection || (roles instanceof Array && roles[0] instanceof Role)) ***REMOVED***
        options.roles = roles.map(role => role.id);
      ***REMOVED***
    ***REMOVED***
    return this.rest.makeRequest('put', Endpoints.Guild(guild).Member(userID), true, options)
      .then(data => this.client.actions.GuildMemberGet.handle(guild, data).member);
  ***REMOVED***

  getGuild(guild) ***REMOVED***
    return this.rest.makeRequest('get', Endpoints.Guild(guild), true);
  ***REMOVED***

  getGuildMember(guild, userID, cache) ***REMOVED***
    return this.rest.makeRequest('get', Endpoints.Guild(guild).Member(userID), true).then(data => ***REMOVED***
      if (cache) return this.client.actions.GuildMemberGet.handle(guild, data).member;
      else return new GuildMember(guild, data);
    ***REMOVED***);
  ***REMOVED***

  updateGuildMember(member, data, reason) ***REMOVED***
    if (data.channel) ***REMOVED***
      const channel = this.client.resolver.resolveChannel(data.channel);
      if (!channel || channel.guild.id !== member.guild.id || channel.type !== 'voice') ***REMOVED***
        return Promise.reject(new Error('Could not resolve channel to a guild voice channel.'));
      ***REMOVED***
      data.channel_id = channel.id;
      data.channel = undefined;
    ***REMOVED*** else if (data.channel === null) ***REMOVED***
      data.channel_id = null;
      data.channel = undefined;
    ***REMOVED***
    if (data.roles) data.roles = [...new Set(data.roles.map(role => role instanceof Role ? role.id : role))];

    let endpoint = Endpoints.Member(member);
    // Fix your endpoints, discord ;-;
    if (member.id === this.client.user.id) ***REMOVED***
      const keys = Object.keys(data);
      if (keys.length === 1 && keys[0] === 'nick') ***REMOVED***
        endpoint = Endpoints.Member(member).nickname;
      ***REMOVED***
    ***REMOVED***

    return this.rest.makeRequest('patch', endpoint, true, data, undefined, reason).then(newData =>
      member.guild._updateMember(member, newData).mem
    );
  ***REMOVED***

  addMemberRole(member, role, reason) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      if (member._roles.includes(role.id)) return resolve(member);

      const listener = (oldMember, newMember) => ***REMOVED***
        if (newMember.id === member.id && !oldMember._roles.includes(role.id) && newMember._roles.includes(role.id)) ***REMOVED***
          this.client.removeListener(Constants.Events.GUILD_MEMBER_UPDATE, listener);
          resolve(newMember);
        ***REMOVED***
      ***REMOVED***;

      this.client.on(Constants.Events.GUILD_MEMBER_UPDATE, listener);
      const timeout = this.client.setTimeout(() => ***REMOVED***
        this.client.removeListener(Constants.Events.GUILD_MEMBER_UPDATE, listener);
        reject(new Error('Adding the role timed out.'));
      ***REMOVED***, 10e3);

      return this.rest.makeRequest('put', Endpoints.Member(member).Role(role.id), true, undefined, undefined, reason)
        .catch(err => ***REMOVED***
          this.client.removeListener(Constants.Events.GUILD_MEMBER_UPDATE, listener);
          this.client.clearTimeout(timeout);
          reject(err);
        ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  removeMemberRole(member, role, reason) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      if (!member._roles.includes(role.id)) return resolve(member);

      const listener = (oldMember, newMember) => ***REMOVED***
        if (newMember.id === member.id && oldMember._roles.includes(role.id) && !newMember._roles.includes(role.id)) ***REMOVED***
          this.client.removeListener(Constants.Events.GUILD_MEMBER_UPDATE, listener);
          resolve(newMember);
        ***REMOVED***
      ***REMOVED***;

      this.client.on(Constants.Events.GUILD_MEMBER_UPDATE, listener);
      const timeout = this.client.setTimeout(() => ***REMOVED***
        this.client.removeListener(Constants.Events.GUILD_MEMBER_UPDATE, listener);
        reject(new Error('Removing the role timed out.'));
      ***REMOVED***, 10e3);

      return this.rest.makeRequest('delete', Endpoints.Member(member).Role(role.id), true, undefined, undefined, reason)
        .catch(err => ***REMOVED***
          this.client.removeListener(Constants.Events.GUILD_MEMBER_UPDATE, listener);
          this.client.clearTimeout(timeout);
          reject(err);
        ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  sendTyping(channelID) ***REMOVED***
    return this.rest.makeRequest('post', Endpoints.Channel(channelID).typing, true);
  ***REMOVED***

  banGuildMember(guild, member, options) ***REMOVED***
    const id = this.client.resolver.resolveUserID(member);
    if (!id) return Promise.reject(new Error('Couldn\'t resolve the user ID to ban.'));

    const url = `$***REMOVED***Endpoints.Guild(guild).bans***REMOVED***/$***REMOVED***id***REMOVED***?$***REMOVED***querystring.stringify(options)***REMOVED***`;
    return this.rest.makeRequest('put', url, true).then(() => ***REMOVED***
      if (member instanceof GuildMember) return member;
      const user = this.client.resolver.resolveUser(id);
      if (user) ***REMOVED***
        member = this.client.resolver.resolveGuildMember(guild, user);
        return member || user;
      ***REMOVED***
      return id;
    ***REMOVED***);
  ***REMOVED***

  unbanGuildMember(guild, member, reason) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      const id = this.client.resolver.resolveUserID(member);
      if (!id) throw new Error('Couldn\'t resolve the user ID to unban.');

      const listener = (eGuild, eUser) => ***REMOVED***
        if (eGuild.id === guild.id && eUser.id === id) ***REMOVED***
          this.client.removeListener(Constants.Events.GUILD_BAN_REMOVE, listener);
          this.client.clearTimeout(timeout);
          resolve(eUser);
        ***REMOVED***
      ***REMOVED***;
      this.client.on(Constants.Events.GUILD_BAN_REMOVE, listener);

      const timeout = this.client.setTimeout(() => ***REMOVED***
        this.client.removeListener(Constants.Events.GUILD_BAN_REMOVE, listener);
        reject(new Error('Took too long to receive the ban remove event.'));
      ***REMOVED***, 10000);

      this.rest.makeRequest('delete', `$***REMOVED***Endpoints.Guild(guild).bans***REMOVED***/$***REMOVED***id***REMOVED***`, true, undefined, undefined, reason)
        .catch(err => ***REMOVED***
          this.client.removeListener(Constants.Events.GUILD_BAN_REMOVE, listener);
          this.client.clearTimeout(timeout);
          reject(err);
        ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  getGuildBan(guild, user) ***REMOVED***
    const id = this.client.resolver.resolveUserID(user);
    return this.rest.makeRequest('get', `$***REMOVED***Endpoints.Guild(guild).bans***REMOVED***/$***REMOVED***id***REMOVED***`, true).then(ban => (***REMOVED***
      reason: ban.reason,
      user: this.client.dataManager.newUser(ban.user),
    ***REMOVED***));
  ***REMOVED***

  getGuildBans(guild) ***REMOVED***
    return this.rest.makeRequest('get', Endpoints.Guild(guild).bans, true).then(bans =>
      bans.reduce((collection, ban) => ***REMOVED***
        collection.set(ban.user.id, ***REMOVED***
          reason: ban.reason,
          user: this.client.dataManager.newUser(ban.user),
        ***REMOVED***);
        return collection;
      ***REMOVED***, new Collection())
    );
  ***REMOVED***

  updateGuildRole(role, _data, reason) ***REMOVED***
    const data = ***REMOVED******REMOVED***;
    data.name = _data.name || role.name;
    data.position = typeof _data.position !== 'undefined' ? _data.position : role.position;
    data.color = _data.color === null ? null : this.client.resolver.resolveColor(_data.color || role.color);
    data.hoist = typeof _data.hoist !== 'undefined' ? _data.hoist : role.hoist;
    data.mentionable = typeof _data.mentionable !== 'undefined' ? _data.mentionable : role.mentionable;

    if (typeof _data.permissions !== 'undefined') data.permissions = Permissions.resolve(_data.permissions);
    else data.permissions = role.permissions;

    return this.rest.makeRequest('patch', Endpoints.Guild(role.guild).Role(role.id), true, data, undefined, reason)
      .then(_role =>
        this.client.actions.GuildRoleUpdate.handle(***REMOVED***
          role: _role,
          guild_id: role.guild.id,
        ***REMOVED***).updated
      );
  ***REMOVED***

  pinMessage(message) ***REMOVED***
    return this.rest.makeRequest('put', Endpoints.Channel(message.channel).Pin(message.id), true)
      .then(() => message);
  ***REMOVED***

  unpinMessage(message) ***REMOVED***
    return this.rest.makeRequest('delete', Endpoints.Channel(message.channel).Pin(message.id), true)
      .then(() => message);
  ***REMOVED***

  getChannelPinnedMessages(channel) ***REMOVED***
    return this.rest.makeRequest('get', Endpoints.Channel(channel).pins, true);
  ***REMOVED***

  createChannelInvite(channel, options, reason) ***REMOVED***
    const payload = ***REMOVED******REMOVED***;
    payload.temporary = options.temporary;
    payload.max_age = options.maxAge;
    payload.max_uses = options.maxUses;
    payload.unique = options.unique;
    return this.rest.makeRequest('post', Endpoints.Channel(channel).invites, true, payload, undefined, reason)
      .then(invite => new Invite(this.client, invite));
  ***REMOVED***

  deleteInvite(invite, reason) ***REMOVED***
    return this.rest.makeRequest('delete', Endpoints.Invite(invite.code), true, undefined, undefined, reason)
      .then(() => invite);
  ***REMOVED***

  getInvite(code) ***REMOVED***
    return this.rest.makeRequest('get', Endpoints.Invite(code), true).then(invite =>
      new Invite(this.client, invite)
    );
  ***REMOVED***

  getGuildInvites(guild) ***REMOVED***
    return this.rest.makeRequest('get', Endpoints.Guild(guild).invites, true).then(inviteItems => ***REMOVED***
      const invites = new Collection();
      for (const inviteItem of inviteItems) ***REMOVED***
        const invite = new Invite(this.client, inviteItem);
        invites.set(invite.code, invite);
      ***REMOVED***
      return invites;
    ***REMOVED***);
  ***REMOVED***

  getGuildVanityCode(guild) ***REMOVED***
    return this.rest.makeRequest('get', Endpoints.Guild(guild).vanityURL, true)
      .then(res => res.code);
  ***REMOVED***

  pruneGuildMembers(guild, days, dry, reason) ***REMOVED***
    return this.rest.makeRequest(dry ?
      'get' :
      'post',
    `$***REMOVED***Endpoints.Guild(guild).prune***REMOVED***?days=$***REMOVED***days***REMOVED***`, true, undefined, undefined, reason)
      .then(data => data.pruned);
  ***REMOVED***

  createEmoji(guild, image, name, roles, reason) ***REMOVED***
    const data = ***REMOVED*** image, name ***REMOVED***;
    if (roles) data.roles = roles.map(r => r.id ? r.id : r);
    return this.rest.makeRequest('post', Endpoints.Guild(guild).emojis, true, data, undefined, reason)
      .then(emoji => this.client.actions.GuildEmojiCreate.handle(guild, emoji).emoji);
  ***REMOVED***

  updateEmoji(emoji, _data, reason) ***REMOVED***
    const data = ***REMOVED******REMOVED***;
    if (_data.name) data.name = _data.name;
    if (_data.roles) data.roles = _data.roles.map(r => r.id ? r.id : r);
    return this.rest.makeRequest('patch', Endpoints.Guild(emoji.guild).Emoji(emoji.id), true, data, undefined, reason)
      .then(newEmoji => this.client.actions.GuildEmojiUpdate.handle(emoji, newEmoji).emoji);
  ***REMOVED***

  deleteEmoji(emoji, reason) ***REMOVED***
    return this.rest.makeRequest('delete', Endpoints.Guild(emoji.guild).Emoji(emoji.id), true, undefined, reason)
      .then(() => this.client.actions.GuildEmojiDelete.handle(emoji).emoji);
  ***REMOVED***

  getGuildAuditLogs(guild, options = ***REMOVED******REMOVED***) ***REMOVED***
    if (options.before && options.before instanceof GuildAuditLogs.Entry) options.before = options.before.id;
    if (options.after && options.after instanceof GuildAuditLogs.Entry) options.after = options.after.id;
    if (typeof options.type === 'string') options.type = GuildAuditLogs.Actions[options.type];

    const queryString = (querystring.stringify(***REMOVED***
      before: options.before,
      after: options.after,
      limit: options.limit,
      user_id: this.client.resolver.resolveUserID(options.user),
      action_type: options.type,
    ***REMOVED***).match(/[^=&?]+=[^=&?]+/g) || []).join('&');

    return this.rest.makeRequest('get', `$***REMOVED***Endpoints.Guild(guild).auditLogs***REMOVED***?$***REMOVED***queryString***REMOVED***`, true)
      .then(data => GuildAuditLogs.build(guild, data));
  ***REMOVED***

  getWebhook(id, token) ***REMOVED***
    return this.rest.makeRequest('get', Endpoints.Webhook(id, token), !token).then(data =>
      new Webhook(this.client, data)
    );
  ***REMOVED***

  getGuildWebhooks(guild) ***REMOVED***
    return this.rest.makeRequest('get', Endpoints.Guild(guild).webhooks, true).then(data => ***REMOVED***
      const hooks = new Collection();
      for (const hook of data) hooks.set(hook.id, new Webhook(this.client, hook));
      return hooks;
    ***REMOVED***);
  ***REMOVED***

  getChannelWebhooks(channel) ***REMOVED***
    return this.rest.makeRequest('get', Endpoints.Channel(channel).webhooks, true).then(data => ***REMOVED***
      const hooks = new Collection();
      for (const hook of data) hooks.set(hook.id, new Webhook(this.client, hook));
      return hooks;
    ***REMOVED***);
  ***REMOVED***

  createWebhook(channel, name, avatar, reason) ***REMOVED***
    return this.rest.makeRequest('post', Endpoints.Channel(channel).webhooks, true, ***REMOVED*** name, avatar ***REMOVED***, undefined, reason)
      .then(data => new Webhook(this.client, data));
  ***REMOVED***

  editWebhook(webhook, options, reason) ***REMOVED***
    let endpoint;
    let auth;

    // Changing the channel of a webhook or specifying a reason requires a bot token
    if (options.channel_id || reason) ***REMOVED***
      endpoint = Endpoints.Webhook(webhook.id);
      auth = true;
    ***REMOVED*** else ***REMOVED***
      endpoint = Endpoints.Webhook(webhook.id, webhook.token);
      auth = false;
    ***REMOVED***

    return this.rest.makeRequest('patch', endpoint, auth, options, undefined, reason).then(data => ***REMOVED***
      webhook.name = data.name;
      webhook.avatar = data.avatar;
      webhook.channelID = data.channel_id;
      return webhook;
    ***REMOVED***);
  ***REMOVED***

  deleteWebhook(webhook, reason) ***REMOVED***
    return this.rest.makeRequest(
      'delete', Endpoints.Webhook(webhook.id, webhook.token),
      false, undefined, undefined, reason);
  ***REMOVED***

  sendWebhookMessage(webhook, content, ***REMOVED*** avatarURL, tts, embeds, username ***REMOVED*** = ***REMOVED******REMOVED***, files = null) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      username = username || webhook.name;

      if (content instanceof Array) ***REMOVED***
        const messages = [];
        (function sendChunk(list, index) ***REMOVED***
          const options = index === list.length - 1 ? ***REMOVED*** tts, embeds, files ***REMOVED*** : ***REMOVED*** tts ***REMOVED***;
          webhook.send(list[index], options).then(message => ***REMOVED***
            messages.push(message);
            if (index >= list.length - 1) return resolve(messages);
            return sendChunk(list, ++index);
          ***REMOVED***).catch(reject);
        ***REMOVED***(content, 0));
      ***REMOVED*** else ***REMOVED***
        this.rest.makeRequest('post', `$***REMOVED***Endpoints.Webhook(webhook.id, webhook.token)***REMOVED***?wait=true`, false, ***REMOVED***
          username,
          avatar_url: avatarURL,
          content,
          tts,
          embeds,
        ***REMOVED***, files).then(data => ***REMOVED***
          if (!this.client.channels) resolve(data);
          else resolve(this.client.actions.MessageCreate.handle(data).message);
        ***REMOVED***, reject);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  sendSlackWebhookMessage(webhook, body) ***REMOVED***
    return this.rest.makeRequest(
      'post', `$***REMOVED***Endpoints.Webhook(webhook.id, webhook.token)***REMOVED***/slack?wait=true`, false, body
    );
  ***REMOVED***

  fetchUserProfile(user) ***REMOVED***
    return this.rest.makeRequest('get', Endpoints.User(user).profile, true).then(data =>
      new UserProfile(user, data)
    );
  ***REMOVED***

  fetchMentions(options) ***REMOVED***
    if (options.guild instanceof Guild) options.guild = options.guild.id;
    Util.mergeDefault(***REMOVED*** limit: 25, roles: true, everyone: true, guild: null ***REMOVED***, options);

    return this.rest.makeRequest(
      'get', Endpoints.User('@me').Mentions(options.limit, options.roles, options.everyone, options.guild), true
    ).then(data => data.map(m => new Message(this.client.channels.get(m.channel_id), m, this.client)));
  ***REMOVED***

  addFriend(user) ***REMOVED***
    return this.rest.makeRequest('post', Endpoints.User('@me'), true, ***REMOVED***
      username: user.username,
      discriminator: user.discriminator,
    ***REMOVED***).then(() => user);
  ***REMOVED***

  removeFriend(user) ***REMOVED***
    return this.rest.makeRequest('delete', Endpoints.User('@me').Relationship(user.id), true)
      .then(() => user);
  ***REMOVED***

  blockUser(user) ***REMOVED***
    return this.rest.makeRequest('put', Endpoints.User('@me').Relationship(user.id), true, ***REMOVED*** type: 2 ***REMOVED***)
      .then(() => user);
  ***REMOVED***

  unblockUser(user) ***REMOVED***
    return this.rest.makeRequest('delete', Endpoints.User('@me').Relationship(user.id), true)
      .then(() => user);
  ***REMOVED***

  updateEmbed(guildID, embed, reason) ***REMOVED***
    return this.rest.makeRequest('patch', Endpoints.Guild(guildID).embed, true, ***REMOVED***
      enabled: embed.enabled,
      channel_id: this.client.resolver.resolveChannelID(embed.channel),
    ***REMOVED***, undefined, reason);
  ***REMOVED***

  setRolePositions(guildID, roles) ***REMOVED***
    return this.rest.makeRequest('patch', Endpoints.Guild(guildID).roles, true, roles).then(() =>
      this.client.actions.GuildRolesPositionUpdate.handle(***REMOVED***
        guild_id: guildID,
        roles,
      ***REMOVED***).guild
    );
  ***REMOVED***

  setChannelPositions(guildID, channels) ***REMOVED***
    return this.rest.makeRequest('patch', Endpoints.Guild(guildID).channels, true, channels).then(() =>
      this.client.actions.GuildChannelsPositionUpdate.handle(***REMOVED***
        guild_id: guildID,
        channels,
      ***REMOVED***).guild
    );
  ***REMOVED***

  addMessageReaction(message, emoji) ***REMOVED***
    return this.rest.makeRequest(
      'put', Endpoints.Message(message).Reaction(emoji).User('@me'), true
    ).then(() =>
      message._addReaction(Util.parseEmoji(emoji), message.client.user)
    );
  ***REMOVED***

  removeMessageReaction(message, emoji, userID) ***REMOVED***
    const endpoint = Endpoints.Message(message).Reaction(emoji).User(userID === this.client.user.id ? '@me' : userID);
    return this.rest.makeRequest('delete', endpoint, true).then(() =>
      this.client.actions.MessageReactionRemove.handle(***REMOVED***
        user_id: userID,
        message_id: message.id,
        emoji: Util.parseEmoji(emoji),
        channel_id: message.channel.id,
      ***REMOVED***).reaction
    );
  ***REMOVED***

  removeMessageReactionEmoji(message, emoji) ***REMOVED***
    const endpoint = Endpoints.Message(message).Reaction(emoji);
    return this.rest.makeRequest('delete', endpoint, true).then(() =>
      this.client.actions.MessageReactionRemoveEmoji.handle(***REMOVED***
        message_id: message.id,
        emoji: Util.parseEmoji(emoji),
        channel_id: message.channel.id,
      ***REMOVED***).reaction
    );
  ***REMOVED***

  removeMessageReactions(message) ***REMOVED***
    return this.rest.makeRequest('delete', Endpoints.Message(message).reactions, true)
      .then(() => message);
  ***REMOVED***

  getMessageReactionUsers(message, emoji, options) ***REMOVED***
    const queryString = (querystring.stringify(options).match(/[^=&?]+=[^=&?]+/g) || []).join('&');

    return this.rest.makeRequest('get', `$***REMOVED***Endpoints.Message(message).Reaction(emoji)***REMOVED***?$***REMOVED***queryString***REMOVED***`, true);
  ***REMOVED***

  getApplication(id) ***REMOVED***
    return this.rest.makeRequest('get', Endpoints.OAUTH2.Application(id), true).then(app =>
      new OAuth2Application(this.client, app)
    );
  ***REMOVED***

  resetApplication(id) ***REMOVED***
    return this.rest.makeRequest('post', Endpoints.OAUTH2.Application(id).resetToken, true)
      .then(() => this.rest.makeRequest('post', Endpoints.OAUTH2.Application(id).resetSecret, true))
      .then(app => new OAuth2Application(this.client, app));
  ***REMOVED***

  setNote(user, note) ***REMOVED***
    return this.rest.makeRequest('put', Endpoints.User(user).note, true, ***REMOVED*** note ***REMOVED***).then(() => user);
  ***REMOVED***

  acceptInvite(code) ***REMOVED***
    if (code.id) code = code.id;
    return new Promise((resolve, reject) =>
      this.rest.makeRequest('post', Endpoints.Invite(code), true).then(res => ***REMOVED***
        const handler = guild => ***REMOVED***
          if (guild.id === res.id) ***REMOVED***
            resolve(guild);
            this.client.removeListener(Constants.Events.GUILD_CREATE, handler);
          ***REMOVED***
        ***REMOVED***;
        this.client.on(Constants.Events.GUILD_CREATE, handler);
        this.client.setTimeout(() => ***REMOVED***
          this.client.removeListener(Constants.Events.GUILD_CREATE, handler);
          reject(new Error('Accepting invite timed out'));
        ***REMOVED***, 120e3);
      ***REMOVED***)
    );
  ***REMOVED***

  patchUserSettings(data) ***REMOVED***
    return this.rest.makeRequest('patch', Constants.Endpoints.User('@me').settings, true, data);
  ***REMOVED***

  patchClientUserGuildSettings(guildID, data) ***REMOVED***
    return this.rest.makeRequest('patch', Constants.Endpoints.User('@me').Guild(guildID).settings, true, data);
  ***REMOVED***

  getIntegrations(guild) ***REMOVED***
    return this.rest.makeRequest(
      'get',
      Constants.Endpoints.Guild(guild.id).integrations,
      true
    );
  ***REMOVED***

  createIntegration(guild, data, reason) ***REMOVED***
    return this.rest.makeRequest(
      'post',
      Constants.Endpoints.Guild(guild.id).integrations,
      true,
      data,
      undefined,
      reason
    );
  ***REMOVED***

  syncIntegration(integration) ***REMOVED***
    return this.rest.makeRequest(
      'post',
      Constants.Endpoints.Guild(integration.guild.id).Integration(integration.id),
      true
    );
  ***REMOVED***

  editIntegration(integration, data, reason) ***REMOVED***
    return this.rest.makeRequest(
      'patch',
      Constants.Endpoints.Guild(integration.guild.id).Integration(integration.id),
      true,
      data,
      undefined,
      reason
    );
  ***REMOVED***

  deleteIntegration(integration, reason) ***REMOVED***
    return this.rest.makeRequest(
      'delete',
      Constants.Endpoints.Guild(integration.guild.id).Integration(integration.id),
      true,
      undefined,
      undefined,
      reason
    );
  ***REMOVED***
***REMOVED***

module.exports = RESTMethods;
