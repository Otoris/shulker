const RequestHandler = require('./RequestHandler');
const DiscordAPIError = require('../DiscordAPIError');
const ***REMOVED*** Events: ***REMOVED*** RATE_LIMIT ***REMOVED*** ***REMOVED*** = require('../../../util/Constants');

/**
 * Handles API Requests sequentially, i.e. we wait until the current request is finished before moving onto
 * the next. This plays a _lot_ nicer in terms of avoiding 429's when there is more than one session of the account,
 * but it can be slower.
 * @extends ***REMOVED***RequestHandler***REMOVED***
 * @private
 */
class SequentialRequestHandler extends RequestHandler ***REMOVED***
  /**
   * @param ***REMOVED***RESTManager***REMOVED*** restManager The REST manager to use
   * @param ***REMOVED***string***REMOVED*** endpoint The endpoint to handle
   */
  constructor(restManager, endpoint) ***REMOVED***
    super(restManager, endpoint);

    /**
     * The client that instantiated this handler
     * @type ***REMOVED***Client***REMOVED***
     */
    this.client = restManager.client;

    /**
     * The endpoint that this handler is handling
     * @type ***REMOVED***string***REMOVED***
     */
    this.endpoint = endpoint;

    /**
     * The time difference between Discord's Dates and the local computer's Dates. A positive number means the local
     * computer's time is ahead of Discord's
     * @type ***REMOVED***number***REMOVED***
     */
    this.timeDifference = 0;

    /**
     * Whether the queue is being processed or not
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.busy = false;
  ***REMOVED***

  push(request) ***REMOVED***
    super.push(request);
    this.handle();
  ***REMOVED***

  /**
   * Performs a request then resolves a promise to indicate its readiness for a new request.
   * @param ***REMOVED***APIRequest***REMOVED*** item The item to execute
   * @returns ***REMOVED***Promise<?Object|Error>***REMOVED***
   */
  execute(item) ***REMOVED***
    this.busy = true;
    return new Promise(resolve => ***REMOVED***
      item.request.gen().end((err, res) => ***REMOVED***
        if (res && res.headers) ***REMOVED***
          this.requestLimit = Number(res.headers['x-ratelimit-limit']);
          this.requestResetTime = Number(res.headers['x-ratelimit-reset']) * 1000;
          this.requestRemaining = Number(res.headers['x-ratelimit-remaining']);
          this.timeDifference = Date.now() - new Date(res.headers.date).getTime();
        ***REMOVED***
        if (err) ***REMOVED***
          if (err.status === 429) ***REMOVED***
            this.queue.unshift(item);
            this.client.setTimeout(() => ***REMOVED***
              this.globalLimit = false;
              resolve();
            ***REMOVED***, Number(res.headers['retry-after']) + this.client.options.restTimeOffset);
            if (res.headers['x-ratelimit-global']) this.globalLimit = true;
          ***REMOVED*** else if (err.status >= 500 && err.status < 600) ***REMOVED***
            if (item.retries === this.client.options.retryLimit) ***REMOVED***
              item.reject(err);
              resolve();
            ***REMOVED*** else ***REMOVED***
              item.retries++;
              this.queue.unshift(item);
              this.client.setTimeout(resolve, 1e3 + this.client.options.restTimeOffset);
            ***REMOVED***
          ***REMOVED*** else ***REMOVED***
            item.reject(err.status >= 400 && err.status < 500 ?
              new DiscordAPIError(res.request.path, res.body, res.request.method) : err);
            resolve(err);
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          this.globalLimit = false;
          const data = res && res.body ? res.body : ***REMOVED******REMOVED***;
          item.resolve(data);
          if (this.requestRemaining === 0) ***REMOVED***
            if (this.client.listenerCount(RATE_LIMIT)) ***REMOVED***
              /**
               * Emitted when the client hits a rate limit while making a request
               * @event Client#rateLimit
               * @param ***REMOVED***Object***REMOVED*** rateLimitInfo Object containing the rate limit info
               * @param ***REMOVED***number***REMOVED*** rateLimitInfo.limit Number of requests that can be made to this endpoint
               * @param ***REMOVED***number***REMOVED*** rateLimitInfo.timeDifference Delta-T in ms between your system and Discord servers
               * @param ***REMOVED***string***REMOVED*** rateLimitInfo.path Path used for request that triggered this event
               * @param ***REMOVED***string***REMOVED*** rateLimitInfo.method HTTP method used for request that triggered this event
               */
              this.client.emit(RATE_LIMIT, ***REMOVED***
                limit: this.requestLimit,
                timeDifference: this.timeDifference,
                path: item.request.path,
                method: item.request.method,
              ***REMOVED***);
            ***REMOVED***
            this.client.setTimeout(
              () => resolve(data),
              this.requestResetTime - Date.now() + this.timeDifference + this.client.options.restTimeOffset
            );
          ***REMOVED*** else ***REMOVED***
            resolve(data);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  handle() ***REMOVED***
    super.handle();
    if (this.busy || this.remaining === 0 || this.queue.length === 0 || this.globalLimit) return;
    this.execute(this.queue.shift()).then(() => ***REMOVED***
      this.busy = false;
      this.handle();
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

module.exports = SequentialRequestHandler;
