const Action = require('./Action');
const Constants = require('../../util/Constants');

class GuildDeleteAction extends Action ***REMOVED***
  constructor(client) ***REMOVED***
    super(client);
    this.deleted = new Map();
  ***REMOVED***

  handle(data) ***REMOVED***
    const client = this.client;

    let guild = client.guilds.get(data.id);
    if (guild) ***REMOVED***
      for (const channel of guild.channels.values()) ***REMOVED***
        if (channel.type === 'text') channel.stopTyping(true);
      ***REMOVED***

      if (guild.available && data.unavailable) ***REMOVED***
        // Guild is unavailable
        guild.available = false;
        client.emit(Constants.Events.GUILD_UNAVAILABLE, guild);

        // Stops the GuildDelete packet thinking a guild was actually deleted,
        // handles emitting of event itself
        return ***REMOVED***
          guild: null,
        ***REMOVED***;
      ***REMOVED***

      for (const channel of guild.channels.values()) this.client.channels.delete(channel.id);
      if (guild.voiceConnection) guild.voiceConnection.disconnect();

      // Delete guild
      client.guilds.delete(guild.id);
      this.deleted.set(guild.id, guild);
      this.scheduleForDeletion(guild.id);
    ***REMOVED*** else ***REMOVED***
      guild = this.deleted.get(data.id) || null;
    ***REMOVED***
    if (guild) guild.deleted = true;

    return ***REMOVED*** guild ***REMOVED***;
  ***REMOVED***

  scheduleForDeletion(id) ***REMOVED***
    this.client.setTimeout(() => this.deleted.delete(id), this.client.options.restWsBridgeTimeout);
  ***REMOVED***
***REMOVED***

/**
 * Emitted whenever a guild becomes unavailable, likely due to a server outage.
 * @event Client#guildUnavailable
 * @param ***REMOVED***Guild***REMOVED*** guild The guild that has become unavailable
 */

module.exports = GuildDeleteAction;
