const Constants = require('../../util/Constants');
const SecretKey = require('./util/SecretKey');
const EventEmitter = require('events').EventEmitter;

let WebSocket;
try ***REMOVED***
  WebSocket = require('@discordjs/uws');
***REMOVED*** catch (err) ***REMOVED***
  WebSocket = require('ws');
***REMOVED***

/**
 * Represents a Voice Connection's WebSocket.
 * @extends ***REMOVED***EventEmitter***REMOVED***
 * @private
 */
class VoiceWebSocket extends EventEmitter ***REMOVED***
  constructor(voiceConnection) ***REMOVED***
    super();

    /**
     * The client of this voice WebSocket
     * @type ***REMOVED***Client***REMOVED***
     */
    this.client = voiceConnection.voiceManager.client;

    /**
     * The Voice Connection that this WebSocket serves
     * @type ***REMOVED***VoiceConnection***REMOVED***
     */
    this.voiceConnection = voiceConnection;

    /**
     * How many connection attempts have been made
     * @type ***REMOVED***number***REMOVED***
     */
    this.attempts = 0;

    this.connect();
    this.dead = false;
    this.voiceConnection.on('closing', this.shutdown.bind(this));
  ***REMOVED***

  shutdown() ***REMOVED***
    this.dead = true;
    this.reset();
  ***REMOVED***

  /**
   * Resets the current WebSocket.
   */
  reset() ***REMOVED***
    if (this.ws) ***REMOVED***
      if (this.ws.readyState !== WebSocket.CLOSED) this.ws.close();
      this.ws = null;
    ***REMOVED***
    this.clearHeartbeat();
  ***REMOVED***

  /**
   * Starts connecting to the Voice WebSocket Server.
   */
  connect() ***REMOVED***
    if (this.dead) return;
    if (this.ws) this.reset();
    if (this.attempts >= 5) ***REMOVED***
      this.emit('debug', new Error(`Too many connection attempts ($***REMOVED***this.attempts***REMOVED***).`));
      return;
    ***REMOVED***

    this.attempts++;

    /**
     * The actual WebSocket used to connect to the Voice WebSocket Server.
     * @type ***REMOVED***WebSocket***REMOVED***
     */
    this.ws = new WebSocket(`wss://$***REMOVED***this.voiceConnection.authentication.endpoint***REMOVED***`);
    this.ws.onopen = this.onOpen.bind(this);
    this.ws.onmessage = this.onMessage.bind(this);
    this.ws.onclose = this.onClose.bind(this);
    this.ws.onerror = this.onError.bind(this);
  ***REMOVED***

  /**
   * Sends data to the WebSocket if it is open.
   * @param ***REMOVED***string***REMOVED*** data The data to send to the WebSocket
   * @returns ***REMOVED***Promise<string>***REMOVED***
   */
  send(data) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      if (!this.ws || this.ws.readyState !== WebSocket.OPEN) ***REMOVED***
        throw new Error(`Voice websocket not open to send $***REMOVED***data***REMOVED***.`);
      ***REMOVED***
      this.ws.send(data, null, error => ***REMOVED***
        if (error) reject(error); else resolve(data);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  /**
   * JSON.stringify's a packet and then sends it to the WebSocket Server.
   * @param ***REMOVED***Object***REMOVED*** packet The packet to send
   * @returns ***REMOVED***Promise<string>***REMOVED***
   */
  sendPacket(packet) ***REMOVED***
    try ***REMOVED***
      packet = JSON.stringify(packet);
    ***REMOVED*** catch (error) ***REMOVED***
      return Promise.reject(error);
    ***REMOVED***
    return this.send(packet);
  ***REMOVED***

  /**
   * Called whenever the WebSocket opens.
   */
  onOpen() ***REMOVED***
    this.sendPacket(***REMOVED***
      op: Constants.OPCodes.DISPATCH,
      d: ***REMOVED***
        server_id: this.voiceConnection.channel.guild.id,
        user_id: this.client.user.id,
        token: this.voiceConnection.authentication.token,
        session_id: this.voiceConnection.authentication.sessionID,
      ***REMOVED***,
    ***REMOVED***).catch(() => ***REMOVED***
      this.emit('error', new Error('Tried to send join packet, but the WebSocket is not open.'));
    ***REMOVED***);
  ***REMOVED***

  /**
   * Called whenever a message is received from the WebSocket.
   * @param ***REMOVED***MessageEvent***REMOVED*** event The message event that was received
   * @returns ***REMOVED***void***REMOVED***
   */
  onMessage(event) ***REMOVED***
    try ***REMOVED***
      return this.onPacket(JSON.parse(event.data));
    ***REMOVED*** catch (error) ***REMOVED***
      return this.onError(error);
    ***REMOVED***
  ***REMOVED***

  /**
   * Called whenever the connection to the WebSocket server is lost.
   */
  onClose() ***REMOVED***
    if (!this.dead) this.client.setTimeout(this.connect.bind(this), this.attempts * 1000);
  ***REMOVED***

  /**
   * Called whenever an error occurs with the WebSocket.
   * @param ***REMOVED***Error***REMOVED*** error The error that occurred
   */
  onError(error) ***REMOVED***
    this.emit('error', error);
  ***REMOVED***

  /**
   * Called whenever a valid packet is received from the WebSocket.
   * @param ***REMOVED***Object***REMOVED*** packet The received packet
   */
  onPacket(packet) ***REMOVED***
    switch (packet.op) ***REMOVED***
      case Constants.VoiceOPCodes.READY:
        this.setHeartbeat(packet.d.heartbeat_interval);
        /**
         * Emitted once the voice WebSocket receives the ready packet.
         * @param ***REMOVED***Object***REMOVED*** packet The received packet
         * @event VoiceWebSocket#ready
         */
        this.emit('ready', packet.d);
        break;
      case Constants.VoiceOPCodes.SESSION_DESCRIPTION:
        /**
         * Emitted once the Voice Websocket receives a description of this voice session.
         * @param ***REMOVED***string***REMOVED*** encryptionMode The type of encryption being used
         * @param ***REMOVED***SecretKey***REMOVED*** secretKey The secret key used for encryption
         * @event VoiceWebSocket#sessionDescription
         */
        this.emit('sessionDescription', packet.d.mode, new SecretKey(packet.d.secret_key));
        break;
      case Constants.VoiceOPCodes.SPEAKING:
        /**
         * Emitted whenever a speaking packet is received.
         * @param ***REMOVED***Object***REMOVED*** data
         * @event VoiceWebSocket#startSpeaking
         */
        this.emit('startSpeaking', packet.d);
        break;
      default:
        /**
         * Emitted when an unhandled packet is received.
         * @param ***REMOVED***Object***REMOVED*** packet
         * @event VoiceWebSocket#unknownPacket
         */
        this.emit('unknownPacket', packet);
        break;
    ***REMOVED***
  ***REMOVED***

  /**
   * Sets an interval at which to send a heartbeat packet to the WebSocket.
   * @param ***REMOVED***number***REMOVED*** interval The interval at which to send a heartbeat packet
   */
  setHeartbeat(interval) ***REMOVED***
    if (!interval || isNaN(interval)) ***REMOVED***
      this.onError(new Error('Tried to set voice heartbeat but no valid interval was specified.'));
      return;
    ***REMOVED***
    if (this.heartbeatInterval) ***REMOVED***
      /**
       * Emitted whenver the voice WebSocket encounters a non-fatal error.
       * @param ***REMOVED***string***REMOVED*** warn The warning
       * @event VoiceWebSocket#warn
       */
      this.emit('warn', 'A voice heartbeat interval is being overwritten');
      clearInterval(this.heartbeatInterval);
    ***REMOVED***
    this.heartbeatInterval = this.client.setInterval(this.sendHeartbeat.bind(this), interval);
  ***REMOVED***

  /**
   * Clears a heartbeat interval, if one exists.
   */
  clearHeartbeat() ***REMOVED***
    if (!this.heartbeatInterval) ***REMOVED***
      this.emit('warn', 'Tried to clear a heartbeat interval that does not exist');
      return;
    ***REMOVED***
    clearInterval(this.heartbeatInterval);
    this.heartbeatInterval = null;
  ***REMOVED***

  /**
   * Sends a heartbeat packet.
   */
  sendHeartbeat() ***REMOVED***
    this.sendPacket(***REMOVED*** op: Constants.VoiceOPCodes.HEARTBEAT, d: null ***REMOVED***).catch(() => ***REMOVED***
      this.emit('warn', 'Tried to send heartbeat, but connection is not open');
      this.clearHeartbeat();
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

module.exports = VoiceWebSocket;
