const VolumeInterface = require('./util/VolumeInterface');
const Prism = require('prism-media');
const OpusEncoders = require('./opus/OpusEngineList');
const Collection = require('../../util/Collection');

const ffmpegArguments = [
  '-analyzeduration', '0',
  '-loglevel', '0',
  '-f', 's16le',
  '-ar', '48000',
  '-ac', '2',
];

/**
 * A voice broadcast can be played across multiple voice connections for improved shared-stream efficiency.
 *
 * Example usage:
 * ```js
 * const broadcast = client.createVoiceBroadcast();
 * broadcast.playFile('./music.mp3');
 * // Play "music.mp3" in all voice connections that the client is in
 * for (const connection of client.voiceConnections.values()) ***REMOVED***
 *   connection.playBroadcast(broadcast);
 * ***REMOVED***
 * ```
 * @implements ***REMOVED***VolumeInterface***REMOVED***
 */
class VoiceBroadcast extends VolumeInterface ***REMOVED***
  constructor(client) ***REMOVED***
    super();
    /**
     * The client that created the broadcast
     * @type ***REMOVED***Client***REMOVED***
     */
    this.client = client;
    this._dispatchers = new Collection();
    this._encoders = new Collection();
    /**
     * The audio transcoder that this broadcast uses
     * @type ***REMOVED***Prism***REMOVED***
     */
    this.prism = new Prism();
    /**
     * The current audio transcoder that is being used
     * @type ***REMOVED***Object***REMOVED***
     */
    this.currentTranscoder = null;
    this.tickInterval = null;
    this._volume = 1;
  ***REMOVED***

  /**
   * An array of subscribed dispatchers
   * @type ***REMOVED***StreamDispatcher[]***REMOVED***
   * @readonly
   */
  get dispatchers() ***REMOVED***
    let d = [];
    for (const container of this._dispatchers.values()) ***REMOVED***
      d = d.concat(Array.from(container.values()));
    ***REMOVED***
    return d;
  ***REMOVED***

  get _playableStream() ***REMOVED***
    const currentTranscoder = this.currentTranscoder;
    if (!currentTranscoder) return null;
    const transcoder = currentTranscoder.transcoder;
    const options = currentTranscoder.options;
    return (transcoder && transcoder.output) || options.stream;
  ***REMOVED***

  unregisterDispatcher(dispatcher, old) ***REMOVED***
    const volume = old || dispatcher.volume;

    /**
     * Emitted whenever a stream dispatcher unsubscribes from the broadcast.
     * @event VoiceBroadcast#unsubscribe
     * @param ***REMOVED***StreamDispatcher***REMOVED*** dispatcher The unsubscribed dispatcher
     */
    this.emit('unsubscribe', dispatcher);
    for (const container of this._dispatchers.values()) ***REMOVED***
      container.delete(dispatcher);

      if (!container.size) ***REMOVED***
        this._encoders.get(volume).destroy();
        this._dispatchers.delete(volume);
        this._encoders.delete(volume);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  registerDispatcher(dispatcher) ***REMOVED***
    if (!this._dispatchers.has(dispatcher.volume)) ***REMOVED***
      this._dispatchers.set(dispatcher.volume, new Set());
      this._encoders.set(dispatcher.volume, OpusEncoders.fetch());
    ***REMOVED***
    const container = this._dispatchers.get(dispatcher.volume);
    if (!container.has(dispatcher)) ***REMOVED***
      container.add(dispatcher);
      dispatcher.once('end', () => this.unregisterDispatcher(dispatcher));
      dispatcher.on('volumeChange', (o, n) => ***REMOVED***
        this.unregisterDispatcher(dispatcher, o);
        if (!this._dispatchers.has(n)) ***REMOVED***
          this._dispatchers.set(n, new Set());
          this._encoders.set(n, OpusEncoders.fetch());
        ***REMOVED***
        this._dispatchers.get(n).add(dispatcher);
      ***REMOVED***);
      /**
       * Emitted whenever a stream dispatcher subscribes to the broadcast.
       * @event VoiceBroadcast#subscribe
       * @param ***REMOVED***StreamDispatcher***REMOVED*** dispatcher The subscribed dispatcher
       */
      this.emit('subscribe', dispatcher);
    ***REMOVED***
  ***REMOVED***

  killCurrentTranscoder() ***REMOVED***
    if (this.currentTranscoder) ***REMOVED***
      if (this.currentTranscoder.transcoder) this.currentTranscoder.transcoder.kill();
      this.currentTranscoder = null;
      this.emit('end');
    ***REMOVED***
  ***REMOVED***

  /**
   * Plays any audio stream across the broadcast.
   * @param ***REMOVED***ReadableStream***REMOVED*** stream The audio stream to play
   * @param ***REMOVED***StreamOptions***REMOVED*** [options] Options for playing the stream
   * @returns ***REMOVED***VoiceBroadcast***REMOVED***
   * @example
   * // Play streams using ytdl-core
   * const ytdl = require('ytdl-core');
   * const streamOptions = ***REMOVED*** seek: 0, volume: 1 ***REMOVED***;
   * const broadcast = client.createVoiceBroadcast();
   *
   * voiceChannel.join()
   *   .then(connection => ***REMOVED***
   *     const stream = ytdl('https://www.youtube.com/watch?v=XAWgeLF9EVQ', ***REMOVED*** filter : 'audioonly' ***REMOVED***);
   *     broadcast.playStream(stream);
   *     const dispatcher = connection.playBroadcast(broadcast);
   *   ***REMOVED***)
   *   .catch(console.error);
   */
  playStream(stream, options = ***REMOVED******REMOVED***) ***REMOVED***
    this.setVolume(options.volume || 1);
    return this._playTranscodable(stream, options);
  ***REMOVED***

  /**
   * Play the given file in the voice connection.
   * @param ***REMOVED***string***REMOVED*** file The absolute path to the file
   * @param ***REMOVED***StreamOptions***REMOVED*** [options] Options for playing the stream
   * @returns ***REMOVED***StreamDispatcher***REMOVED***
   * @example
   * // Play files natively
   * const broadcast = client.createVoiceBroadcast();
   *
   * voiceChannel.join()
   *   .then(connection => ***REMOVED***
   *     broadcast.playFile('C:/Users/Discord/Desktop/music.mp3');
   *     const dispatcher = connection.playBroadcast(broadcast);
   *   ***REMOVED***)
   *   .catch(console.error);
   */
  playFile(file, options = ***REMOVED******REMOVED***) ***REMOVED***
    this.setVolume(options.volume || 1);
    return this._playTranscodable(`file:$***REMOVED***file***REMOVED***`, options);
  ***REMOVED***

  _playTranscodable(media, options) ***REMOVED***
    this.killCurrentTranscoder();
    const transcoder = this.prism.transcode(***REMOVED***
      type: 'ffmpeg',
      media,
      ffmpegArguments: ffmpegArguments.concat(['-ss', String(options.seek || 0)]),
    ***REMOVED***);
    /**
     * Emitted whenever an error occurs.
     * @event VoiceBroadcast#error
     * @param ***REMOVED***Error***REMOVED*** error The error that occurred
     */
    transcoder.once('error', e => ***REMOVED***
      if (this.listenerCount('error') > 0) this.emit('error', e);
      /**
       * Emitted whenever the VoiceBroadcast has any warnings.
       * @event VoiceBroadcast#warn
       * @param ***REMOVED***string|Error***REMOVED*** warning The warning that was raised
       */
      else this.emit('warn', e);
    ***REMOVED***);
    /**
     * Emitted once the broadcast (the audio stream) ends.
     * @event VoiceBroadcast#end
     */
    transcoder.once('end', () => this.killCurrentTranscoder());
    this.currentTranscoder = ***REMOVED***
      transcoder,
      options,
    ***REMOVED***;
    transcoder.output.once('readable', () => this._startPlaying());
    return this;
  ***REMOVED***

  /**
   * Plays a stream of 16-bit signed stereo PCM.
   * @param ***REMOVED***ReadableStream***REMOVED*** stream The audio stream to play
   * @param ***REMOVED***StreamOptions***REMOVED*** [options] Options for playing the stream
   * @returns ***REMOVED***VoiceBroadcast***REMOVED***
   */
  playConvertedStream(stream, options = ***REMOVED******REMOVED***) ***REMOVED***
    this.killCurrentTranscoder();
    this.setVolume(options.volume || 1);
    this.currentTranscoder = ***REMOVED*** options: ***REMOVED*** stream ***REMOVED*** ***REMOVED***;
    stream.once('readable', () => this._startPlaying());
    return this;
  ***REMOVED***

  /**
   * Plays an Opus encoded stream.
   * <warn>Note that inline volume is not compatible with this method.</warn>
   * @param ***REMOVED***ReadableStream***REMOVED*** stream The Opus audio stream to play
   * @param ***REMOVED***StreamOptions***REMOVED*** [options] Options for playing the stream
   * @returns ***REMOVED***StreamDispatcher***REMOVED***
   */
  playOpusStream(stream) ***REMOVED***
    this.currentTranscoder = ***REMOVED*** options: ***REMOVED*** stream ***REMOVED***, opus: true ***REMOVED***;
    stream.once('readable', () => this._startPlaying());
    return this;
  ***REMOVED***

  /**
   * Play an arbitrary input that can be [handled by ffmpeg](https://ffmpeg.org/ffmpeg-protocols.html#Description)
   * @param ***REMOVED***string***REMOVED*** input The arbitrary input
   * @param ***REMOVED***StreamOptions***REMOVED*** [options] Options for playing the stream
   * @returns ***REMOVED***VoiceBroadcast***REMOVED***
   */
  playArbitraryInput(input, options = ***REMOVED******REMOVED***) ***REMOVED***
    this.setVolume(options.volume || 1);
    options.input = input;
    return this._playTranscodable(input, options);
  ***REMOVED***

  /**
   * Pauses the entire broadcast - all dispatchers also pause.
   */
  pause() ***REMOVED***
    this.paused = true;
    for (const container of this._dispatchers.values()) ***REMOVED***
      for (const dispatcher of container.values()) ***REMOVED***
        dispatcher.pause();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  /**
   * Resumes the entire broadcast - all dispatchers also resume.
   */
  resume() ***REMOVED***
    this.paused = false;
    for (const container of this._dispatchers.values()) ***REMOVED***
      for (const dispatcher of container.values()) ***REMOVED***
        dispatcher.resume();
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  _startPlaying() ***REMOVED***
    if (this.tickInterval) clearInterval(this.tickInterval);
    // Old code?
    // this.tickInterval = this.client.setInterval(this.tick.bind(this), 20);
    this._startTime = Date.now();
    this._count = 0;
    this._pausedTime = 0;
    this._missed = 0;
    this.tick();
  ***REMOVED***

  tick() ***REMOVED***
    if (!this._playableStream) return;
    if (this.paused) ***REMOVED***
      this._pausedTime += 20;
      setTimeout(() => this.tick(), 20);
      return;
    ***REMOVED***

    const opus = this.currentTranscoder.opus;
    const buffer = this.readStreamBuffer();

    if (!buffer) ***REMOVED***
      this._missed++;
      if (this._missed < 5) ***REMOVED***
        this._pausedTime += 200;
        setTimeout(() => this.tick(), 200);
      ***REMOVED*** else ***REMOVED***
        this.killCurrentTranscoder();
      ***REMOVED***
      return;
    ***REMOVED***

    this._missed = 0;

    let packetMatrix = ***REMOVED******REMOVED***;

    const getOpusPacket = volume => ***REMOVED***
      if (packetMatrix[volume]) return packetMatrix[volume];

      const opusEncoder = this._encoders.get(volume);
      const opusPacket = opusEncoder.encode(this.applyVolume(buffer, this._volume * volume));
      packetMatrix[volume] = opusPacket;
      return opusPacket;
    ***REMOVED***;

    for (const dispatcher of this.dispatchers) ***REMOVED***
      if (opus) ***REMOVED***
        dispatcher.processPacket(buffer);
        continue;
      ***REMOVED***

      const volume = dispatcher.volume;
      dispatcher.processPacket(getOpusPacket(volume));
    ***REMOVED***

    const next = 20 + (this._startTime + this._pausedTime + (this._count * 20) - Date.now());
    this._count++;
    setTimeout(() => this.tick(), next);
  ***REMOVED***

  readStreamBuffer() ***REMOVED***
    const opus = this.currentTranscoder.opus;
    const bufferLength = (opus ? 80 : 1920) * 2;
    let buffer = this._playableStream.read(bufferLength);
    if (opus) return buffer;
    if (!buffer) return null;

    if (buffer.length !== bufferLength) ***REMOVED***
      const newBuffer = Buffer.alloc(bufferLength).fill(0);
      buffer.copy(newBuffer);
      buffer = newBuffer;
    ***REMOVED***

    return buffer;
  ***REMOVED***

  /**
   * Stop the current stream from playing without unsubscribing dispatchers.
   */
  end() ***REMOVED***
    this.killCurrentTranscoder();
  ***REMOVED***

  /**
   * End the current broadcast, all subscribed dispatchers will also end.
   */
  destroy() ***REMOVED***
    this.end();
    for (const container of this._dispatchers.values()) ***REMOVED***
      for (const dispatcher of container.values()) ***REMOVED***
        dispatcher.destroy('end', 'broadcast ended');
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

module.exports = VoiceBroadcast;
