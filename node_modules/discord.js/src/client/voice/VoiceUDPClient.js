const udp = require('dgram');
const Constants = require('../../util/Constants');
const EventEmitter = require('events').EventEmitter;

/**
 * Represents a UDP client for a Voice Connection.
 * @extends ***REMOVED***EventEmitter***REMOVED***
 * @private
 */
class VoiceConnectionUDPClient extends EventEmitter ***REMOVED***
  constructor(voiceConnection) ***REMOVED***
    super();

    /**
     * The voice connection that this UDP client serves
     * @type ***REMOVED***VoiceConnection***REMOVED***
     */
    this.voiceConnection = voiceConnection;

    /**
     * The UDP socket
     * @type ***REMOVED***?Socket***REMOVED***
     */
    this.socket = null;

    /**
     * The address of the Discord voice server
     * @type ***REMOVED***?string***REMOVED***
     */
    this.discordAddress = null;

    /**
     * The local IP address
     * @type ***REMOVED***?string***REMOVED***
     */
    this.localAddress = null;

    /**
     * The local port
     * @type ***REMOVED***?string***REMOVED***
     */
    this.localPort = null;

    this.voiceConnection.on('closing', this.shutdown.bind(this));
  ***REMOVED***

  shutdown() ***REMOVED***
    if (this.socket) ***REMOVED***
      this.socket.removeAllListeners('message');
      try ***REMOVED***
        this.socket.close();
      ***REMOVED*** finally ***REMOVED***
        this.socket = null;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  /**
   * The port of the Discord voice server
   * @type ***REMOVED***number***REMOVED***
   * @readonly
   */
  get discordPort() ***REMOVED***
    return this.voiceConnection.authentication.port;
  ***REMOVED***

  /**
   * Send a packet to the UDP client.
   * @param ***REMOVED***Object***REMOVED*** packet The packet to send
   * @returns ***REMOVED***Promise<Object>***REMOVED***
   */
  send(packet) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      if (!this.socket) throw new Error('Tried to send a UDP packet, but there is no socket available.');
      if (!this.discordAddress || !this.discordPort) throw new Error('Malformed UDP address or port.');
      this.socket.send(packet, 0, packet.length, this.discordPort, this.discordAddress, error => ***REMOVED***
        if (error) reject(error); else resolve(packet);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  createUDPSocket(address) ***REMOVED***
    this.discordAddress = address;
    const socket = this.socket = udp.createSocket('udp4');

    socket.once('message', message => ***REMOVED***
      const packet = parseLocalPacket(message);
      if (packet.error) ***REMOVED***
        this.emit('error', packet.error);
        return;
      ***REMOVED***

      this.localAddress = packet.address;
      this.localPort = packet.port;

      this.voiceConnection.sockets.ws.sendPacket(***REMOVED***
        op: Constants.VoiceOPCodes.SELECT_PROTOCOL,
        d: ***REMOVED***
          protocol: 'udp',
          data: ***REMOVED***
            address: packet.address,
            port: packet.port,
            mode: 'xsalsa20_poly1305',
          ***REMOVED***,
        ***REMOVED***,
      ***REMOVED***);
    ***REMOVED***);

    const blankMessage = Buffer.alloc(70);
    blankMessage.writeUIntBE(this.voiceConnection.authentication.ssrc, 0, 4);
    this.send(blankMessage);
  ***REMOVED***
***REMOVED***

function parseLocalPacket(message) ***REMOVED***
  try ***REMOVED***
    const packet = Buffer.from(message);
    let address = '';
    for (let i = 4; i < packet.indexOf(0, i); i++) address += String.fromCharCode(packet[i]);
    const port = parseInt(packet.readUIntLE(packet.length - 2, 2).toString(10), 10);
    return ***REMOVED*** address, port ***REMOVED***;
  ***REMOVED*** catch (error) ***REMOVED***
    return ***REMOVED*** error ***REMOVED***;
  ***REMOVED***
***REMOVED***

module.exports = VoiceConnectionUDPClient;
