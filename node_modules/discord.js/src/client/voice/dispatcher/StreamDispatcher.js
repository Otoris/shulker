const VolumeInterface = require('../util/VolumeInterface');
const VoiceBroadcast = require('../VoiceBroadcast');
const Constants = require('../../../util/Constants');

const secretbox = require('../util/Secretbox');

const nonce = Buffer.alloc(24);
nonce.fill(0);

/**
 * The class that sends voice packet data to the voice connection.
 * ```js
 * // Obtained using:
 * voiceChannel.join().then(connection => ***REMOVED***
 *   // You can play a file or a stream here:
 *   const dispatcher = connection.playFile('./file.mp3');
 * ***REMOVED***);
 * ```
 * @implements ***REMOVED***VolumeInterface***REMOVED***
 */
class StreamDispatcher extends VolumeInterface ***REMOVED***
  constructor(player, stream, streamOptions) ***REMOVED***
    super(streamOptions);
    /**
     * The Audio Player that controls this dispatcher
     * @type ***REMOVED***AudioPlayer***REMOVED***
     */
    this.player = player;
    /**
     * The stream that the dispatcher plays
     * @type ***REMOVED***ReadableStream|VoiceBroadcast***REMOVED***
     */
    this.stream = stream;
    if (!(this.stream instanceof VoiceBroadcast)) this.startStreaming();
    this.streamOptions = streamOptions;

    const data = this.streamingData;
    data.length = 20;
    data.missed = 0;

    /**
     * Whether playing is paused
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.paused = false;
    /**
     * Whether this dispatcher has been destroyed
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.destroyed = false;

    this._opus = streamOptions.opus;
  ***REMOVED***

  /**
   * How many passes the dispatcher should take when sending packets to reduce packet loss. Values over 5
   * aren't recommended, as it means you are using 5x more bandwidth. You _can_ edit this at runtime
   * @type ***REMOVED***number***REMOVED***
   * @readonly
   */
  get passes() ***REMOVED***
    return this.streamOptions.passes || 1;
  ***REMOVED***

  set passes(n) ***REMOVED***
    this.streamOptions.passes = n;
  ***REMOVED***

  get streamingData() ***REMOVED***
    return this.player.streamingData;
  ***REMOVED***

  /**
   * How long the stream dispatcher has been "speaking" for
   * @type ***REMOVED***number***REMOVED***
   * @readonly
   */
  get time() ***REMOVED***
    return this.streamingData.count * (this.streamingData.length || 0);
  ***REMOVED***

  /**
   * The total time, taking into account pauses and skips, that the dispatcher has been streaming for
   * @type ***REMOVED***number***REMOVED***
   * @readonly
   */
  get totalStreamTime() ***REMOVED***
    return this.time + this.streamingData.pausedTime;
  ***REMOVED***

  /**
   * Stops sending voice packets to the voice connection (stream may still progress however).
   */
  pause() ***REMOVED*** this.setPaused(true); ***REMOVED***

  /**
   * Resumes sending voice packets to the voice connection (may be further on in the stream than when paused).
   */
  resume() ***REMOVED*** this.setPaused(false); ***REMOVED***


  /**
   * Stops the current stream permanently and emits an `end` event.
   * @param ***REMOVED***string***REMOVED*** [reason='user'] An optional reason for stopping the dispatcher
   */
  end(reason = 'user') ***REMOVED***
    this.destroy('end', reason);
  ***REMOVED***

  setSpeaking(value) ***REMOVED***
    if (this.speaking === value) return;
    if (this.player.voiceConnection.status !== Constants.VoiceStatus.CONNECTED) return;
    this.speaking = value;
    /**
     * Emitted when the dispatcher starts/stops speaking.
     * @event StreamDispatcher#speaking
     * @param ***REMOVED***boolean***REMOVED*** value Whether or not the dispatcher is speaking
     */
    this.emit('speaking', value);
  ***REMOVED***


  /**
   * Set the bitrate of the current Opus encoder.
   * @param ***REMOVED***number***REMOVED*** bitrate New bitrate, in kbps
   * If set to 'auto', the voice channel's bitrate will be used
   */
  setBitrate(bitrate) ***REMOVED***
    this.player.setBitrate(bitrate);
  ***REMOVED***

  sendBuffer(buffer, sequence, timestamp, opusPacket) ***REMOVED***
    opusPacket = opusPacket || this.player.opusEncoder.encode(buffer);
    const packet = this.createPacket(sequence, timestamp, opusPacket);
    this.sendPacket(packet);
  ***REMOVED***

  sendPacket(packet) ***REMOVED***
    let repeats = this.passes;
    /**
     * Emitted whenever the dispatcher has debug information.
     * @event StreamDispatcher#debug
     * @param ***REMOVED***string***REMOVED*** info The debug info
     */
    this.setSpeaking(true);
    while (repeats-- && this.player.voiceConnection.sockets.udp) ***REMOVED***
      this.player.voiceConnection.sockets.udp.send(packet)
        .catch(e => ***REMOVED***
          this.setSpeaking(false);
          this.emit('debug', `Failed to send a packet $***REMOVED***e***REMOVED***`);
        ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  createPacket(sequence, timestamp, buffer) ***REMOVED***
    const packetBuffer = Buffer.alloc(buffer.length + 28);
    packetBuffer.fill(0);
    packetBuffer[0] = 0x80;
    packetBuffer[1] = 0x78;

    packetBuffer.writeUIntBE(sequence, 2, 2);
    packetBuffer.writeUIntBE(timestamp, 4, 4);
    packetBuffer.writeUIntBE(this.player.voiceConnection.authentication.ssrc, 8, 4);

    packetBuffer.copy(nonce, 0, 0, 12);
    buffer = secretbox.methods.close(buffer, nonce, this.player.voiceConnection.authentication.secretKey.key);
    for (let i = 0; i < buffer.length; i++) packetBuffer[i + 12] = buffer[i];

    return packetBuffer;
  ***REMOVED***

  processPacket(packet) ***REMOVED***
    try ***REMOVED***
      if (this.destroyed || !this.player.voiceConnection.authentication.secretKey) ***REMOVED***
        this.setSpeaking(false);
        return;
      ***REMOVED***

      const data = this.streamingData;

      if (this.paused) ***REMOVED***
        this.setSpeaking(false);
        data.pausedTime = data.length * 10;
        return;
      ***REMOVED***

      if (!packet) ***REMOVED***
        data.missed++;
        data.pausedTime += data.length * 10;
        return;
      ***REMOVED***

      this.started();
      this.missed = 0;

      this.stepStreamingData();
      this.sendBuffer(null, data.sequence, data.timestamp, packet);
    ***REMOVED*** catch (e) ***REMOVED***
      this.destroy('error', e);
    ***REMOVED***
  ***REMOVED***

  process() ***REMOVED***
    try ***REMOVED***
      if (this.destroyed) ***REMOVED***
        this.setSpeaking(false);
        return;
      ***REMOVED***

      const data = this.streamingData;

      if (data.missed >= 5) ***REMOVED***
        this.destroy('end', 'Stream is not generating quickly enough.');
        return;
      ***REMOVED***

      if (this.paused) ***REMOVED***
        this.setSpeaking(false);
        // Old code?
        // data.timestamp = data.timestamp + 4294967295 ? data.timestamp + 960 : 0;
        data.pausedTime += data.length * 10;
        this.player.voiceConnection.voiceManager.client.setTimeout(() => this.process(), data.length * 10);
        return;
      ***REMOVED***

      this.started();

      const buffer = this.readStreamBuffer();
      if (!buffer) ***REMOVED***
        data.missed++;
        data.pausedTime += data.length * 10;
        this.player.voiceConnection.voiceManager.client.setTimeout(() => this.process(), data.length * 10);
        return;
      ***REMOVED***

      data.missed = 0;

      this.stepStreamingData();

      if (this._opus) ***REMOVED***
        this.sendBuffer(null, data.sequence, data.timestamp, buffer);
      ***REMOVED*** else ***REMOVED***
        this.sendBuffer(buffer, data.sequence, data.timestamp);
      ***REMOVED***

      const nextTime = data.length + (data.startTime + data.pausedTime + (data.count * data.length) - Date.now());
      this.player.voiceConnection.voiceManager.client.setTimeout(() => this.process(), nextTime);
    ***REMOVED*** catch (e) ***REMOVED***
      this.destroy('error', e);
    ***REMOVED***
  ***REMOVED***

  readStreamBuffer() ***REMOVED***
    const data = this.streamingData;
    const bufferLength = (this._opus ? 80 : 1920) * data.channels;
    let buffer = this.stream.read(bufferLength);
    if (this._opus) return buffer;
    if (!buffer) return null;

    if (buffer.length !== bufferLength) ***REMOVED***
      const newBuffer = Buffer.alloc(bufferLength).fill(0);
      buffer.copy(newBuffer);
      buffer = newBuffer;
    ***REMOVED***

    buffer = this.applyVolume(buffer);
    return buffer;
  ***REMOVED***

  started() ***REMOVED***
    const data = this.streamingData;

    if (!data.startTime) ***REMOVED***
      /**
       * Emitted once the dispatcher starts streaming.
       * @event StreamDispatcher#start
       */
      this.emit('start');
      data.startTime = Date.now();
    ***REMOVED***
  ***REMOVED***

  stepStreamingData() ***REMOVED***
    const data = this.streamingData;
    data.count++;
    data.sequence = data.sequence < 65535 ? data.sequence + 1 : 0;
    data.timestamp = (data.timestamp + 960) < 4294967295 ? data.timestamp + 960 : 0;
  ***REMOVED***

  destroy(type, reason) ***REMOVED***
    if (this.destroyed) return;
    this.destroyed = true;
    this.setSpeaking(false);
    this.emit(type, reason);
    /**
     * Emitted once the dispatcher ends.
     * @param ***REMOVED***string***REMOVED*** [reason] The reason the dispatcher ended
     * @event StreamDispatcher#end
     */
    if (type !== 'end') this.emit('end', `destroyed due to $***REMOVED***type***REMOVED*** - $***REMOVED***reason***REMOVED***`);
  ***REMOVED***

  startStreaming() ***REMOVED***
    if (!this.stream) ***REMOVED***
      /**
       * Emitted if the dispatcher encounters an error.
       * @event StreamDispatcher#error
       * @param ***REMOVED***string***REMOVED*** error The error message
       */
      this.emit('error', 'No stream');
      return;
    ***REMOVED***

    this.stream.on('end', err => this.destroy('end', err || 'stream'));
    this.stream.on('error', err => this.destroy('error', err));

    const data = this.streamingData;
    data.length = 20;
    data.missed = 0;

    this.stream.once('readable', () => ***REMOVED***
      data.startTime = null;
      data.count = 0;
      this.process();
    ***REMOVED***);
  ***REMOVED***

  setPaused(paused) ***REMOVED*** this.setSpeaking(!(this.paused = paused)); ***REMOVED***
***REMOVED***

module.exports = StreamDispatcher;
