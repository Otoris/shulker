const VoiceWebSocket = require('./VoiceWebSocket');
const VoiceUDP = require('./VoiceUDPClient');
const Util = require('../../util/Util');
const Constants = require('../../util/Constants');
const AudioPlayer = require('./player/AudioPlayer');
const VoiceReceiver = require('./receiver/VoiceReceiver');
const SingleSilence = require('./util/SingleSilence');
const EventEmitter = require('events').EventEmitter;
const Prism = require('prism-media');

// The delay between packets when a user is considered to have stopped speaking
// https://github.com/discordjs/discord.js/issues/3524#issuecomment-540373200
const DISCORD_SPEAKING_DELAY = 250;

/**
 * Represents a connection to a guild's voice server.
 * ```js
 * // Obtained using:
 * voiceChannel.join()
 *   .then(connection => ***REMOVED***
 *
 *   ***REMOVED***);
 * ```
 * @extends ***REMOVED***EventEmitter***REMOVED***
 */
class VoiceConnection extends EventEmitter ***REMOVED***
  constructor(voiceManager, channel) ***REMOVED***
    super();

    /**
     * The voice manager that instantiated this connection
     * @type ***REMOVED***ClientVoiceManager***REMOVED***
     */
    this.voiceManager = voiceManager;

    /**
     * The client that instantiated this connection
     * @type ***REMOVED***Client***REMOVED***
     */
    this.client = voiceManager.client;

    /**
     * @external Prism
     * @see ***REMOVED***@link https://github.com/hydrabolt/prism-media***REMOVED***
     */

    /**
     * The audio transcoder for this connection
     * @type ***REMOVED***Prism***REMOVED***
     */
    this.prism = new Prism();

    /**
     * The voice channel this connection is currently serving
     * @type ***REMOVED***VoiceChannel***REMOVED***
     */
    this.channel = channel;

    /**
     * The current status of the voice connection
     * @type ***REMOVED***VoiceStatus***REMOVED***
     */
    this.status = Constants.VoiceStatus.AUTHENTICATING;

    /**
     * Whether we're currently transmitting audio
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.speaking = false;

    /**
     * An array of Voice Receivers that have been created for this connection
     * @type ***REMOVED***VoiceReceiver[]***REMOVED***
     */
    this.receivers = [];

    /**
     * The authentication data needed to connect to the voice server
     * @type ***REMOVED***Object***REMOVED***
     * @private
     */
    this.authentication = ***REMOVED******REMOVED***;

    /**
     * The audio player for this voice connection
     * @type ***REMOVED***AudioPlayer***REMOVED***
     */
    this.player = new AudioPlayer(this);

    this.player.on('debug', m => ***REMOVED***
      /**
       * Debug info from the connection.
       * @event VoiceConnection#debug
       * @param ***REMOVED***string***REMOVED*** message The debug message
       */
      this.emit('debug', `audio player - $***REMOVED***m***REMOVED***`);
    ***REMOVED***);

    this.player.on('error', e => ***REMOVED***
      /**
       * Warning info from the connection.
       * @event VoiceConnection#warn
       * @param ***REMOVED***string|Error***REMOVED*** warning The warning
       */
      this.emit('warn', e);
    ***REMOVED***);

    /**
     * Map SSRC to user id
     * @type ***REMOVED***Map<number, Snowflake>***REMOVED***
     * @private
     */
    this.ssrcMap = new Map();

    /**
     * Map user id to speaking timeout
     * @type ***REMOVED***Map<Snowflake, Timeout>***REMOVED***
     * @private
     */
    this.speakingTimeouts = new Map();

    /**
     * Object that wraps contains the `ws` and `udp` sockets of this voice connection
     * @type ***REMOVED***Object***REMOVED***
     * @private
     */
    this.sockets = ***REMOVED******REMOVED***;

    this.authenticate();
  ***REMOVED***

  /**
   * The current stream dispatcher (if any)
   * @type ***REMOVED***?StreamDispatcher***REMOVED***
   * @readonly
   */
  get dispatcher() ***REMOVED***
    return this.player.dispatcher;
  ***REMOVED***

  /**
   * Sets whether the voice connection should display as "speaking" or not.
   * @param ***REMOVED***boolean***REMOVED*** value Whether or not to speak
   * @private
   */
  setSpeaking(value) ***REMOVED***
    if (this.speaking === value) return;
    if (this.status !== Constants.VoiceStatus.CONNECTED) return;
    this.speaking = value;
    this.sockets.ws.sendPacket(***REMOVED***
      op: Constants.VoiceOPCodes.SPEAKING,
      d: ***REMOVED***
        speaking: true,
        delay: 0,
      ***REMOVED***,
    ***REMOVED***).catch(e => ***REMOVED***
      this.emit('debug', e);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Sends a request to the main gateway to join a voice channel.
   * @param ***REMOVED***Object***REMOVED*** [options] The options to provide
   */
  sendVoiceStateUpdate(options = ***REMOVED******REMOVED***) ***REMOVED***
    options = Util.mergeDefault(***REMOVED***
      guild_id: this.channel.guild.id,
      channel_id: this.channel.id,
      self_mute: false,
      self_deaf: false,
    ***REMOVED***, options);

    this.client.ws.send(***REMOVED***
      op: Constants.OPCodes.VOICE_STATE_UPDATE,
      d: options,
    ***REMOVED***);
  ***REMOVED***

  /**
   * Set the token and endpoint required to connect to the voice servers.
   * @param ***REMOVED***string***REMOVED*** token The voice token
   * @param ***REMOVED***string***REMOVED*** endpoint The voice endpoint
   * @returns ***REMOVED***void***REMOVED***
   */
  setTokenAndEndpoint(token, endpoint) ***REMOVED***
    if (!endpoint) ***REMOVED***
      // Signifies awaiting endpoint stage
      return;
    ***REMOVED***

    if (!token) ***REMOVED***
      this.authenticateFailed('Token not provided from voice server packet.');
      return;
    ***REMOVED***

    endpoint = endpoint.match(/([^:]*)/)[0];

    if (!endpoint) ***REMOVED***
      this.authenticateFailed('Invalid endpoint received.');
      return;
    ***REMOVED***

    if (this.status === Constants.VoiceStatus.AUTHENTICATING) ***REMOVED***
      this.authentication.token = token;
      this.authentication.endpoint = endpoint;
      this.checkAuthenticated();
    ***REMOVED*** else if (token !== this.authentication.token || endpoint !== this.authentication.endpoint) ***REMOVED***
      this.reconnect(token, endpoint);
    ***REMOVED***
  ***REMOVED***

  /**
   * Sets the Session ID for the connection.
   * @param ***REMOVED***string***REMOVED*** sessionID The voice session ID
   */
  setSessionID(sessionID) ***REMOVED***
    if (!sessionID) ***REMOVED***
      this.authenticateFailed('Session ID not supplied.');
      return;
    ***REMOVED***

    if (this.status === Constants.VoiceStatus.AUTHENTICATING) ***REMOVED***
      this.authentication.sessionID = sessionID;
      this.checkAuthenticated();
    ***REMOVED*** else if (sessionID !== this.authentication.sessionID) ***REMOVED***
      this.authentication.sessionID = sessionID;
      /**
       * Emitted when a new session ID is received.
       * @event VoiceConnection#newSession
       * @private
       */
      this.emit('newSession', sessionID);
    ***REMOVED***
  ***REMOVED***

  /**
   * Checks whether the voice connection is authenticated.
   * @private
   */
  checkAuthenticated() ***REMOVED***
    const ***REMOVED*** token, endpoint, sessionID ***REMOVED*** = this.authentication;

    if (token && endpoint && sessionID) ***REMOVED***
      this.client.clearTimeout(this.connectTimeout);
      this.status = Constants.VoiceStatus.CONNECTING;
      /**
       * Emitted when we successfully initiate a voice connection.
       * @event VoiceConnection#authenticated
       */
      this.emit('authenticated');
      this.connect();
    ***REMOVED***
  ***REMOVED***

  /**
   * Invoked when we fail to initiate a voice connection.
   * @param ***REMOVED***string***REMOVED*** reason The reason for failure
   * @private
   */
  authenticateFailed(reason) ***REMOVED***
    this.client.clearTimeout(this.connectTimeout);
    if (this.status === Constants.VoiceStatus.AUTHENTICATING) ***REMOVED***
      /**
       * Emitted when we fail to initiate a voice connection.
       * @event VoiceConnection#failed
       * @param ***REMOVED***Error***REMOVED*** error The encountered error
       */
      this.emit('failed', new Error(reason));
    ***REMOVED*** else ***REMOVED***
      /**
       * Emitted whenever the connection encounters an error.
       * @event VoiceConnection#error
       * @param ***REMOVED***Error***REMOVED*** error The encountered error
       */
      this.emit('error', new Error(reason));
    ***REMOVED***
    this.status = Constants.VoiceStatus.DISCONNECTED;
  ***REMOVED***

  /**
   * Move to a different voice channel in the same guild.
   * @param ***REMOVED***VoiceChannel***REMOVED*** channel The channel to move to
   * @private
   */
  updateChannel(channel) ***REMOVED***
    this.channel = channel;
    this.sendVoiceStateUpdate();
  ***REMOVED***

  /**
   * Attempts to authenticate to the voice server.
   * @private
   */
  authenticate() ***REMOVED***
    this.sendVoiceStateUpdate();
    this.connectTimeout = this.client.setTimeout(
      () => this.authenticateFailed(new Error('Connection not established within 15 seconds.')), 15000);
  ***REMOVED***

  /**
   * Attempts to reconnect to the voice server (typically after a region change).
   * @param ***REMOVED***string***REMOVED*** token The voice token
   * @param ***REMOVED***string***REMOVED*** endpoint The voice endpoint
   * @private
   */
  reconnect(token, endpoint) ***REMOVED***
    this.authentication.token = token;
    this.authentication.endpoint = endpoint;

    this.status = Constants.VoiceStatus.RECONNECTING;
    /**
     * Emitted when the voice connection is reconnecting (typically after a region change).
     * @event VoiceConnection#reconnecting
     */
    this.emit('reconnecting');
    this.connect();
  ***REMOVED***

  /**
   * Disconnect the voice connection, causing a disconnect and closing event to be emitted.
   */
  disconnect() ***REMOVED***
    this.emit('closing');
    this.sendVoiceStateUpdate(***REMOVED***
      channel_id: null,
    ***REMOVED***);

    this._disconnect();
  ***REMOVED***

  /**
   * Internally disconnects (doesn't send disconnect packet).
   * @private
   */
  _disconnect() ***REMOVED***
    this.player.destroy();
    this.cleanup();
    this.status = Constants.VoiceStatus.DISCONNECTED;
    /**
     * Emitted when the voice connection disconnects.
     * @event VoiceConnection#disconnect
     */
    this.emit('disconnect');
  ***REMOVED***

  /**
   * Cleans up after disconnect.
   * @private
   */
  cleanup() ***REMOVED***
    const ***REMOVED*** ws, udp ***REMOVED*** = this.sockets;

    if (ws) ***REMOVED***
      ws.removeAllListeners('error');
      ws.removeAllListeners('ready');
      ws.removeAllListeners('sessionDescription');
      ws.removeAllListeners('startSpeaking');
      ws.shutdown();
    ***REMOVED***

    if (udp) udp.removeAllListeners('error');

    this.sockets.ws = null;
    this.sockets.udp = null;
  ***REMOVED***

  /**
   * Connect the voice connection.
   * @private
   */
  connect() ***REMOVED***
    if (this.status !== Constants.VoiceStatus.RECONNECTING) ***REMOVED***
      if (this.sockets.ws) throw new Error('There is already an existing WebSocket connection.');
      if (this.sockets.udp) throw new Error('There is already an existing UDP connection.');
    ***REMOVED***

    if (this.sockets.ws) this.sockets.ws.shutdown();
    if (this.sockets.udp) this.sockets.udp.shutdown();

    this.sockets.ws = new VoiceWebSocket(this);
    this.sockets.udp = new VoiceUDP(this);

    const ***REMOVED*** ws, udp ***REMOVED*** = this.sockets;

    ws.on('error', err => this.emit('error', err));
    udp.on('error', err => this.emit('error', err));
    ws.on('ready', this.onReady.bind(this));
    ws.on('sessionDescription', this.onSessionDescription.bind(this));
    ws.on('startSpeaking', this.onStartSpeaking.bind(this));
  ***REMOVED***

  /**
   * Invoked when the voice websocket is ready.
   * @param ***REMOVED***Object***REMOVED*** data The received data
   * @private
   */
  onReady(***REMOVED*** port, ssrc, ip ***REMOVED***) ***REMOVED***
    this.authentication.port = port;
    this.authentication.ssrc = ssrc;
    this.sockets.udp.createUDPSocket(ip);
    this.sockets.udp.socket.on('message', this.onUDPMessage.bind(this));
  ***REMOVED***

  /**
   * Invoked when a session description is received.
   * @param ***REMOVED***string***REMOVED*** mode The encryption mode
   * @param ***REMOVED***string***REMOVED*** secret The secret key
   * @private
   */
  onSessionDescription(mode, secret) ***REMOVED***
    this.authentication.encryptionMode = mode;
    this.authentication.secretKey = secret;

    this.status = Constants.VoiceStatus.CONNECTED;
    const ready = () => ***REMOVED***
      /**
       * Emitted once the connection is ready, when a promise to join a voice channel resolves,
       * the connection will already be ready.
       * @event VoiceConnection#ready
       */
      this.emit('ready');
    ***REMOVED***;
    if (this.dispatcher) ***REMOVED***
      ready();
    ***REMOVED*** else ***REMOVED***
      // This serves to provide support for voice receive, sending audio is required to receive it.
      this.playOpusStream(new SingleSilence()).once('end', ready);
    ***REMOVED***
  ***REMOVED***

  /**
   * Invoked whenever a user initially starts speaking.
   * @param ***REMOVED***Object***REMOVED*** data The speaking data
   * @private
   */
  onStartSpeaking(***REMOVED*** user_id, ssrc ***REMOVED***) ***REMOVED***
    this.ssrcMap.set(+ssrc, user_id);
  ***REMOVED***

  /**
   * Invoked when a speaking event is received.
   * @param ***REMOVED***Object***REMOVED*** data The received data
   * @private
   */
  onSpeaking(***REMOVED*** user_id, speaking ***REMOVED***) ***REMOVED***
    const guild = this.channel.guild;
    const user = this.client.users.get(user_id);
    if (!speaking) ***REMOVED***
      for (const receiver of this.receivers) ***REMOVED***
        receiver.stoppedSpeaking(user);
      ***REMOVED***
    ***REMOVED***
    /**
     * Emitted whenever a user starts/stops speaking.
     * @event VoiceConnection#speaking
     * @param ***REMOVED***User***REMOVED*** user The user that has started/stopped speaking
     * @param ***REMOVED***boolean***REMOVED*** speaking Whether or not the user is speaking
     */
    if (this.status === Constants.VoiceStatus.CONNECTED) this.emit('speaking', user, speaking);
    guild._memberSpeakUpdate(user_id, speaking);
  ***REMOVED***

  /**
   * Handles synthesizing of the speaking event.
   * @param ***REMOVED***Buffer***REMOVED*** buffer Received packet from the UDP socket
   * @private
   */
  onUDPMessage(buffer) ***REMOVED***
    const ssrc = +buffer.readUInt32BE(8).toString(10);
    const user = this.client.users.get(this.ssrcMap.get(ssrc));
    if (!user) return;

    let speakingTimeout = this.speakingTimeouts.get(ssrc);
    if (typeof speakingTimeout === 'undefined') ***REMOVED***
      this.onSpeaking(***REMOVED*** user_id: user.id, ssrc, speaking: true ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      this.client.clearTimeout(speakingTimeout);
    ***REMOVED***

    speakingTimeout = this.client.setTimeout(() => ***REMOVED***
      try ***REMOVED***
        this.onSpeaking(***REMOVED*** user_id: user.id, ssrc, speaking: false ***REMOVED***);
        this.client.clearTimeout(speakingTimeout);
        this.speakingTimeouts.delete(ssrc);
      ***REMOVED*** catch (ex) ***REMOVED***
        // Connection already closed, ignore
      ***REMOVED***
    ***REMOVED***, DISCORD_SPEAKING_DELAY);
    this.speakingTimeouts.set(ssrc, speakingTimeout);
  ***REMOVED***

  /**
   * Options that can be passed to stream-playing methods:
   * @typedef ***REMOVED***Object***REMOVED*** StreamOptions
   * @property ***REMOVED***number***REMOVED*** [seek=0] The time to seek to
   * @property ***REMOVED***number***REMOVED*** [volume=1] The volume to play at
   * @property ***REMOVED***number***REMOVED*** [passes=1] How many times to send the voice packet to reduce packet loss
   * @property ***REMOVED***number|string***REMOVED*** [bitrate=48000] The bitrate (quality) of the audio.
   * If set to 'auto', the voice channel's bitrate will be used
   */

  /**
   * Play the given file in the voice connection.
   * @param ***REMOVED***string***REMOVED*** file The absolute path to the file
   * @param ***REMOVED***StreamOptions***REMOVED*** [options] Options for playing the stream
   * @returns ***REMOVED***StreamDispatcher***REMOVED***
   * @example
   * // Play files natively
   * voiceChannel.join()
   *   .then(connection => ***REMOVED***
   *     const dispatcher = connection.playFile('C:/Users/Discord/Desktop/music.mp3');
   *   ***REMOVED***)
   *   .catch(console.error);
   */
  playFile(file, options) ***REMOVED***
    return this.player.playUnknownStream(`file:$***REMOVED***file***REMOVED***`, options);
  ***REMOVED***

  /**
   * Play an arbitrary input that can be [handled by ffmpeg](https://ffmpeg.org/ffmpeg-protocols.html#Description)
   * @param ***REMOVED***string***REMOVED*** input the arbitrary input
   * @param ***REMOVED***StreamOptions***REMOVED*** [options] Options for playing the stream
   * @returns ***REMOVED***StreamDispatcher***REMOVED***
   */
  playArbitraryInput(input, options) ***REMOVED***
    return this.player.playUnknownStream(input, options);
  ***REMOVED***

  /**
   * Plays and converts an audio stream in the voice connection.
   * @param ***REMOVED***ReadableStream***REMOVED*** stream The audio stream to play
   * @param ***REMOVED***StreamOptions***REMOVED*** [options] Options for playing the stream
   * @returns ***REMOVED***StreamDispatcher***REMOVED***
   * @example
   * // Play streams using ytdl-core
   * const ytdl = require('ytdl-core');
   * const streamOptions = ***REMOVED*** seek: 0, volume: 1 ***REMOVED***;
   * voiceChannel.join()
   *   .then(connection => ***REMOVED***
   *     const stream = ytdl('https://www.youtube.com/watch?v=XAWgeLF9EVQ', ***REMOVED*** filter : 'audioonly' ***REMOVED***);
   *     const dispatcher = connection.playStream(stream, streamOptions);
   *   ***REMOVED***)
   *   .catch(console.error);
   */
  playStream(stream, options) ***REMOVED***
    return this.player.playUnknownStream(stream, options);
  ***REMOVED***

  /**
   * Plays a stream of 16-bit signed stereo PCM.
   * @param ***REMOVED***ReadableStream***REMOVED*** stream The audio stream to play
   * @param ***REMOVED***StreamOptions***REMOVED*** [options] Options for playing the stream
   * @returns ***REMOVED***StreamDispatcher***REMOVED***
   */
  playConvertedStream(stream, options) ***REMOVED***
    return this.player.playPCMStream(stream, options);
  ***REMOVED***

  /**
   * Plays an Opus encoded stream.
   * <warn>Note that inline volume is not compatible with this method.</warn>
   * @param ***REMOVED***ReadableStream***REMOVED*** stream The Opus audio stream to play
   * @param ***REMOVED***StreamOptions***REMOVED*** [options] Options for playing the stream
   * @returns ***REMOVED***StreamDispatcher***REMOVED***
   */
  playOpusStream(stream, options) ***REMOVED***
    return this.player.playOpusStream(stream, options);
  ***REMOVED***

  /**
   * Plays a voice broadcast.
   * @param ***REMOVED***VoiceBroadcast***REMOVED*** broadcast The broadcast to play
   * @param ***REMOVED***StreamOptions***REMOVED*** [options] Options for playing the stream
   * @returns ***REMOVED***StreamDispatcher***REMOVED***
   * @example
   * // Play a broadcast
   * const broadcast = client
   *   .createVoiceBroadcast()
   *   .playFile('./test.mp3');
   * const dispatcher = voiceConnection.playBroadcast(broadcast);
   */
  playBroadcast(broadcast, options) ***REMOVED***
    return this.player.playBroadcast(broadcast, options);
  ***REMOVED***

  /**
   * Creates a VoiceReceiver so you can start listening to voice data.
   * It's recommended to only create one of these.
   * @returns ***REMOVED***VoiceReceiver***REMOVED***
   */
  createReceiver() ***REMOVED***
    const receiver = new VoiceReceiver(this);
    this.receivers.push(receiver);
    return receiver;
  ***REMOVED***
***REMOVED***

module.exports = VoiceConnection;
