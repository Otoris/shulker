const EventEmitter = require('events');
const Constants = require('../util/Constants');
const Permissions = require('../util/Permissions');
const Util = require('../util/Util');
const RESTManager = require('./rest/RESTManager');
const ClientDataManager = require('./ClientDataManager');
const ClientManager = require('./ClientManager');
const ClientDataResolver = require('./ClientDataResolver');
const ClientVoiceManager = require('./voice/ClientVoiceManager');
const WebSocketManager = require('./websocket/WebSocketManager');
const ActionsManager = require('./actions/ActionsManager');
const Collection = require('../util/Collection');
const Presence = require('../structures/Presence').Presence;
const ShardClientUtil = require('../sharding/ShardClientUtil');
const VoiceBroadcast = require('./voice/VoiceBroadcast');

/**
 * The main hub for interacting with the Discord API, and the starting point for any bot.
 * @extends ***REMOVED***EventEmitter***REMOVED***
 */
class Client extends EventEmitter ***REMOVED***
  /**
   * @param ***REMOVED***ClientOptions***REMOVED*** [options] Options for the client
   */
  constructor(options = ***REMOVED******REMOVED***) ***REMOVED***
    super();

    // Obtain shard details from environment
    if (!options.shardId && 'SHARD_ID' in process.env) options.shardId = Number(process.env.SHARD_ID);
    if (!options.shardCount && 'SHARD_COUNT' in process.env) options.shardCount = Number(process.env.SHARD_COUNT);

    /**
     * The options the client was instantiated with
     * @type ***REMOVED***ClientOptions***REMOVED***
     */
    this.options = Util.mergeDefault(Constants.DefaultOptions, options);
    this._validateOptions();

    /**
     * The REST manager of the client
     * @type ***REMOVED***RESTManager***REMOVED***
     * @private
     */
    this.rest = new RESTManager(this);

    /**
     * The data manager of the client
     * @type ***REMOVED***ClientDataManager***REMOVED***
     * @private
     */
    this.dataManager = new ClientDataManager(this);

    /**
     * The manager of the client
     * @type ***REMOVED***ClientManager***REMOVED***
     * @private
     */
    this.manager = new ClientManager(this);

    /**
     * The WebSocket manager of the client
     * @type ***REMOVED***WebSocketManager***REMOVED***
     * @private
     */
    this.ws = new WebSocketManager(this);

    /**
     * The data resolver of the client
     * @type ***REMOVED***ClientDataResolver***REMOVED***
     * @private
     */
    this.resolver = new ClientDataResolver(this);

    /**
     * The action manager of the client
     * @type ***REMOVED***ActionsManager***REMOVED***
     * @private
     */
    this.actions = new ActionsManager(this);

    /**
     * The voice manager of the client (`null` in browsers)
     * @type ***REMOVED***?ClientVoiceManager***REMOVED***
     * @private
     */
    this.voice = !this.browser ? new ClientVoiceManager(this) : null;

    /**
     * The shard helpers for the client
     * (only if the process was spawned as a child, such as from a ***REMOVED***@link ShardingManager***REMOVED***)
     * @type ***REMOVED***?ShardClientUtil***REMOVED***
     */
    this.shard = process.send ? ShardClientUtil.singleton(this) : null;

    /**
     * All of the ***REMOVED***@link User***REMOVED*** objects that have been cached at any point, mapped by their IDs
     * @type ***REMOVED***Collection<Snowflake, User>***REMOVED***
     */
    this.users = new Collection();

    /**
     * All of the guilds the client is currently handling, mapped by their IDs -
     * as long as sharding isn't being used, this will be *every* guild the bot is a member of
     * @type ***REMOVED***Collection<Snowflake, Guild>***REMOVED***
     */
    this.guilds = new Collection();

    /**
     * All of the ***REMOVED***@link Channel***REMOVED***s that the client is currently handling, mapped by their IDs -
     * as long as sharding isn't being used, this will be *every* channel in *every* guild, and all DM channels
     * @type ***REMOVED***Collection<Snowflake, Channel>***REMOVED***
     */
    this.channels = new Collection();

    /**
     * Presences that have been received for the client user's friends, mapped by user IDs
     * <warn>This is only filled when using a user account.</warn>
     * @type ***REMOVED***Collection<Snowflake, Presence>***REMOVED***
     * @deprecated
     */
    this.presences = new Collection();

    Object.defineProperty(this, 'token', ***REMOVED*** writable: true ***REMOVED***);
    if (!this.token && 'CLIENT_TOKEN' in process.env) ***REMOVED***
      /**
       * Authorization token for the logged in user/bot
       * <warn>This should be kept private at all times.</warn>
       * @type ***REMOVED***?string***REMOVED***
       */
      this.token = process.env.CLIENT_TOKEN;
    ***REMOVED*** else ***REMOVED***
      this.token = null;
    ***REMOVED***

    /**
     * User that the client is logged in as
     * @type ***REMOVED***?ClientUser***REMOVED***
     */
    this.user = null;

    /**
     * Time at which the client was last regarded as being in the `READY` state
     * (each time the client disconnects and successfully reconnects, this will be overwritten)
     * @type ***REMOVED***?Date***REMOVED***
     */
    this.readyAt = null;

    /**
     * Active voice broadcasts that have been created
     * @type ***REMOVED***VoiceBroadcast[]***REMOVED***
     */
    this.broadcasts = [];

    /**
     * Previous heartbeat pings of the websocket (most recent first, limited to three elements)
     * @type ***REMOVED***number[]***REMOVED***
     */
    this.pings = [];

    /**
     * Timeouts set by ***REMOVED***@link Client#setTimeout***REMOVED*** that are still active
     * @type ***REMOVED***Set<Timeout>***REMOVED***
     * @private
     */
    this._timeouts = new Set();

    /**
     * Intervals set by ***REMOVED***@link Client#setInterval***REMOVED*** that are still active
     * @type ***REMOVED***Set<Timeout>***REMOVED***
     * @private
     */
    this._intervals = new Set();

    if (this.options.messageSweepInterval > 0) ***REMOVED***
      this.setInterval(this.sweepMessages.bind(this), this.options.messageSweepInterval * 1000);
    ***REMOVED***
  ***REMOVED***

  /**
   * Timestamp of the latest ping's start time
   * @type ***REMOVED***number***REMOVED***
   * @private
   */
  get _pingTimestamp() ***REMOVED***
    return this.ws.connection ? this.ws.connection.lastPingTimestamp : 0;
  ***REMOVED***

  /**
   * Current status of the client's connection to Discord
   * @type ***REMOVED***Status***REMOVED***
   * @readonly
   */
  get status() ***REMOVED***
    return this.ws.connection ? this.ws.connection.status : Constants.Status.IDLE;
  ***REMOVED***

  /**
   * How long it has been since the client last entered the `READY` state in milliseconds
   * @type ***REMOVED***?number***REMOVED***
   * @readonly
   */
  get uptime() ***REMOVED***
    return this.readyAt ? Date.now() - this.readyAt : null;
  ***REMOVED***

  /**
   * Average heartbeat ping of the websocket, obtained by averaging the ***REMOVED***@link Client#pings***REMOVED*** property
   * @type ***REMOVED***number***REMOVED***
   * @readonly
   */
  get ping() ***REMOVED***
    return this.pings.reduce((prev, p) => prev + p, 0) / this.pings.length;
  ***REMOVED***

  /**
   * All active voice connections that have been established, mapped by guild ID
   * @type ***REMOVED***Collection<Snowflake, VoiceConnection>***REMOVED***
   * @readonly
   */
  get voiceConnections() ***REMOVED***
    if (this.browser) return new Collection();
    return this.voice.connections;
  ***REMOVED***

  /**
   * All custom emojis that the client has access to, mapped by their IDs
   * @type ***REMOVED***Collection<Snowflake, Emoji>***REMOVED***
   * @readonly
   */
  get emojis() ***REMOVED***
    const emojis = new Collection();
    for (const guild of this.guilds.values()) ***REMOVED***
      for (const emoji of guild.emojis.values()) emojis.set(emoji.id, emoji);
    ***REMOVED***
    return emojis;
  ***REMOVED***

  /**
   * Timestamp of the time the client was last `READY` at
   * @type ***REMOVED***?number***REMOVED***
   * @readonly
   */
  get readyTimestamp() ***REMOVED***
    return this.readyAt ? this.readyAt.getTime() : null;
  ***REMOVED***

  /**
   * Whether the client is in a browser environment
   * @type ***REMOVED***boolean***REMOVED***
   * @readonly
   */
  get browser() ***REMOVED***
    return typeof window !== 'undefined';
  ***REMOVED***

  /**
   * Creates a voice broadcast.
   * @returns ***REMOVED***VoiceBroadcast***REMOVED***
   */
  createVoiceBroadcast() ***REMOVED***
    const broadcast = new VoiceBroadcast(this);
    this.broadcasts.push(broadcast);
    return broadcast;
  ***REMOVED***

  /**
   * Logs the client in, establishing a websocket connection to Discord.
   * <info>Both bot and regular user accounts are supported, but it is highly recommended to use a bot account whenever
   * possible. User accounts are subject to harsher ratelimits and other restrictions that don't apply to bot accounts.
   * Bot accounts also have access to many features that user accounts cannot utilise. Automating a user account is
   * considered a violation of Discord's ToS.</info>
   * @param ***REMOVED***string***REMOVED*** token Token of the account to log in with
   * @returns ***REMOVED***Promise<string>***REMOVED*** Token of the account used
   * @example
   * client.login('my token')
   *  .then(console.log)
   *  .catch(console.error);
   */
  login(token = this.token) ***REMOVED***
    return this.rest.methods.login(token);
  ***REMOVED***

  /**
   * Logs out, terminates the connection to Discord, and destroys the client.
   * @returns ***REMOVED***Promise***REMOVED***
   */
  destroy() ***REMOVED***
    for (const t of this._timeouts) clearTimeout(t);
    for (const i of this._intervals) clearInterval(i);
    this._timeouts.clear();
    this._intervals.clear();
    return this.manager.destroy();
  ***REMOVED***

  /**
   * Requests a sync of guild data with Discord.
   * <info>This can be done automatically every 30 seconds by enabling ***REMOVED***@link ClientOptions#sync***REMOVED***.</info>
   * <warn>This is only available when using a user account.</warn>
   * @param ***REMOVED***Guild[]|Collection<Snowflake, Guild>***REMOVED*** [guilds=this.guilds] An array or collection of guilds to sync
   * @deprecated
   */
  syncGuilds(guilds = this.guilds) ***REMOVED***
    if (this.user.bot) return;
    this.ws.send(***REMOVED***
      op: 12,
      d: guilds instanceof Collection ? guilds.keyArray() : guilds.map(g => g.id),
    ***REMOVED***);
  ***REMOVED***

  /**
   * Obtains a user from Discord, or the user cache if it's already available.
   * <warn>This is only available when using a bot account.</warn>
   * @param ***REMOVED***Snowflake***REMOVED*** id ID of the user
   * @param ***REMOVED***boolean***REMOVED*** [cache=true] Whether to cache the new user object if it isn't already
   * @returns ***REMOVED***Promise<User>***REMOVED***
   */
  fetchUser(id, cache = true) ***REMOVED***
    if (this.users.has(id)) return Promise.resolve(this.users.get(id));
    return this.rest.methods.getUser(id, cache);
  ***REMOVED***

  /**
   * Obtains an invite from Discord.
   * @param ***REMOVED***InviteResolvable***REMOVED*** invite Invite code or URL
   * @returns ***REMOVED***Promise<Invite>***REMOVED***
   * @example
   * client.fetchInvite('https://discord.gg/bRCvFy9')
   *   .then(invite => console.log(`Obtained invite with code: $***REMOVED***invite.code***REMOVED***`))
   *   .catch(console.error);
   */
  fetchInvite(invite) ***REMOVED***
    const code = this.resolver.resolveInviteCode(invite);
    return this.rest.methods.getInvite(code);
  ***REMOVED***

  /**
   * Obtains a webhook from Discord.
   * @param ***REMOVED***Snowflake***REMOVED*** id ID of the webhook
   * @param ***REMOVED***string***REMOVED*** [token] Token for the webhook
   * @returns ***REMOVED***Promise<Webhook>***REMOVED***
   * @example
   * client.fetchWebhook('id', 'token')
   *   .then(webhook => console.log(`Obtained webhook with name: $***REMOVED***webhook.name***REMOVED***`))
   *   .catch(console.error);
   */
  fetchWebhook(id, token) ***REMOVED***
    return this.rest.methods.getWebhook(id, token);
  ***REMOVED***

  /**
   * Obtains the available voice regions from Discord.
   * @returns ***REMOVED***Promise<Collection<string, VoiceRegion>>***REMOVED***
   * @example
   * client.fetchVoiceRegions()
   *   .then(regions => console.log(`Available regions are: $***REMOVED***regions.map(region => region.name).join(', ')***REMOVED***`))
   *   .catch(console.error);
   */
  fetchVoiceRegions() ***REMOVED***
    return this.rest.methods.fetchVoiceRegions();
  ***REMOVED***

  /**
   * Sweeps all text-based channels' messages and removes the ones older than the max message lifetime.
   * If the message has been edited, the time of the edit is used rather than the time of the original message.
   * @param ***REMOVED***number***REMOVED*** [lifetime=this.options.messageCacheLifetime] Messages that are older than this (in seconds)
   * will be removed from the caches. The default is based on ***REMOVED***@link ClientOptions#messageCacheLifetime***REMOVED***
   * @returns ***REMOVED***number***REMOVED*** Amount of messages that were removed from the caches,
   * or -1 if the message cache lifetime is unlimited
   */
  sweepMessages(lifetime = this.options.messageCacheLifetime) ***REMOVED***
    if (typeof lifetime !== 'number' || isNaN(lifetime)) throw new TypeError('The lifetime must be a number.');
    if (lifetime <= 0) ***REMOVED***
      this.emit('debug', 'Didn\'t sweep messages - lifetime is unlimited');
      return -1;
    ***REMOVED***

    const lifetimeMs = lifetime * 1000;
    const now = Date.now();
    let channels = 0;
    let messages = 0;

    for (const channel of this.channels.values()) ***REMOVED***
      if (!channel.messages) continue;
      channels++;

      messages += channel.messages.sweep(
        message => now - (message.editedTimestamp || message.createdTimestamp) > lifetimeMs
      );
    ***REMOVED***

    this.emit('debug', `Swept $***REMOVED***messages***REMOVED*** messages older than $***REMOVED***lifetime***REMOVED*** seconds in $***REMOVED***channels***REMOVED*** text-based channels`);
    return messages;
  ***REMOVED***

  /**
   * Obtains the OAuth Application of the bot from Discord.
   * <warn>Bots can only fetch their own profile.</warn>
   * @param ***REMOVED***Snowflake***REMOVED*** [id='@me'] ID of application to fetch
   * @returns ***REMOVED***Promise<OAuth2Application>***REMOVED***
   * @example
   * client.fetchApplication()
   *   .then(application => console.log(`Obtained application with name: $***REMOVED***application.name***REMOVED***`))
   *   .catch(console.error);
   */
  fetchApplication(id = '@me') ***REMOVED***
    if (id !== '@me') process.emitWarning('fetchApplication: use "@me" as an argument', 'DeprecationWarning');
    return this.rest.methods.getApplication(id);
  ***REMOVED***

  /**
   * Generates a link that can be used to invite the bot to a guild.
   * <warn>This is only available when using a bot account.</warn>
   * @param ***REMOVED***PermissionResolvable***REMOVED*** [permissions] Permissions to request
   * @returns ***REMOVED***Promise<string>***REMOVED***
   * @example
   * client.generateInvite(['SEND_MESSAGES', 'MANAGE_GUILD', 'MENTION_EVERYONE'])
   *   .then(link => console.log(`Generated bot invite link: $***REMOVED***link***REMOVED***`))
   *   .catch(console.error);
   */
  generateInvite(permissions) ***REMOVED***
    permissions = Permissions.resolve(permissions);
    return this.fetchApplication().then(application =>
      `https://discordapp.com/oauth2/authorize?client_id=$***REMOVED***application.id***REMOVED***&permissions=$***REMOVED***permissions***REMOVED***&scope=bot`
    );
  ***REMOVED***

  /**
   * Sets a timeout that will be automatically cancelled if the client is destroyed.
   * @param ***REMOVED***Function***REMOVED*** fn Function to execute
   * @param ***REMOVED***number***REMOVED*** delay Time to wait before executing (in milliseconds)
   * @param ***REMOVED***...****REMOVED*** args Arguments for the function
   * @returns ***REMOVED***Timeout***REMOVED***
   */
  setTimeout(fn, delay, ...args) ***REMOVED***
    const timeout = setTimeout(() => ***REMOVED***
      fn(...args);
      this._timeouts.delete(timeout);
    ***REMOVED***, delay);
    this._timeouts.add(timeout);
    return timeout;
  ***REMOVED***

  /**
   * Clears a timeout.
   * @param ***REMOVED***Timeout***REMOVED*** timeout Timeout to cancel
   */
  clearTimeout(timeout) ***REMOVED***
    clearTimeout(timeout);
    this._timeouts.delete(timeout);
  ***REMOVED***

  /**
   * Sets an interval that will be automatically cancelled if the client is destroyed.
   * @param ***REMOVED***Function***REMOVED*** fn Function to execute
   * @param ***REMOVED***number***REMOVED*** delay Time to wait before executing (in milliseconds)
   * @param ***REMOVED***...****REMOVED*** args Arguments for the function
   * @returns ***REMOVED***Timeout***REMOVED***
   */
  setInterval(fn, delay, ...args) ***REMOVED***
    const interval = setInterval(fn, delay, ...args);
    this._intervals.add(interval);
    return interval;
  ***REMOVED***

  /**
   * Clears an interval.
   * @param ***REMOVED***Timeout***REMOVED*** interval Interval to cancel
   */
  clearInterval(interval) ***REMOVED***
    clearInterval(interval);
    this._intervals.delete(interval);
  ***REMOVED***

  /**
   * Adds a ping to ***REMOVED***@link Client#pings***REMOVED***.
   * @param ***REMOVED***number***REMOVED*** startTime Starting time of the ping
   * @private
   */
  _pong(startTime) ***REMOVED***
    this.pings.unshift(Date.now() - startTime);
    if (this.pings.length > 3) this.pings.length = 3;
    this.ws.lastHeartbeatAck = true;
  ***REMOVED***

  /**
   * Adds/updates a friend's presence in ***REMOVED***@link Client#presences***REMOVED***.
   * @param ***REMOVED***Snowflake***REMOVED*** id ID of the user
   * @param ***REMOVED***Object***REMOVED*** presence Raw presence object from Discord
   * @private
   */
  _setPresence(id, presence) ***REMOVED***
    if (this.presences.has(id)) ***REMOVED***
      this.presences.get(id).update(presence);
      return;
    ***REMOVED***
    this.presences.set(id, new Presence(presence, this));
  ***REMOVED***

  /**
   * Calls ***REMOVED***@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval***REMOVED*** on a script
   * with the client as `this`.
   * @param ***REMOVED***string***REMOVED*** script Script to eval
   * @returns ***REMOVED*******REMOVED***
   * @private
   */
  _eval(script) ***REMOVED***
    return eval(script);
  ***REMOVED***

  /**
   * Validates the client options.
   * @param ***REMOVED***ClientOptions***REMOVED*** [options=this.options] Options to validate
   * @private
   */
  _validateOptions(options = this.options) ***REMOVED*** // eslint-disable-line complexity
    if (typeof options.shardCount !== 'number' || isNaN(options.shardCount)) ***REMOVED***
      throw new TypeError('The shardCount option must be a number.');
    ***REMOVED***
    if (typeof options.shardId !== 'number' || isNaN(options.shardId)) ***REMOVED***
      throw new TypeError('The shardId option must be a number.');
    ***REMOVED***
    if (options.shardCount < 0) throw new RangeError('The shardCount option must be at least 0.');
    if (options.shardId < 0) throw new RangeError('The shardId option must be at least 0.');
    if (options.shardId !== 0 && options.shardId >= options.shardCount) ***REMOVED***
      throw new RangeError('The shardId option must be less than shardCount.');
    ***REMOVED***
    if (typeof options.messageCacheMaxSize !== 'number' || isNaN(options.messageCacheMaxSize)) ***REMOVED***
      throw new TypeError('The messageCacheMaxSize option must be a number.');
    ***REMOVED***
    if (typeof options.messageCacheLifetime !== 'number' || isNaN(options.messageCacheLifetime)) ***REMOVED***
      throw new TypeError('The messageCacheLifetime option must be a number.');
    ***REMOVED***
    if (typeof options.messageSweepInterval !== 'number' || isNaN(options.messageSweepInterval)) ***REMOVED***
      throw new TypeError('The messageSweepInterval option must be a number.');
    ***REMOVED***
    if (typeof options.fetchAllMembers !== 'boolean') ***REMOVED***
      throw new TypeError('The fetchAllMembers option must be a boolean.');
    ***REMOVED***
    if (typeof options.disableEveryone !== 'boolean') ***REMOVED***
      throw new TypeError('The disableEveryone option must be a boolean.');
    ***REMOVED***
    if (typeof options.restWsBridgeTimeout !== 'number' || isNaN(options.restWsBridgeTimeout)) ***REMOVED***
      throw new TypeError('The restWsBridgeTimeout option must be a number.');
    ***REMOVED***
    if (!(options.disabledEvents instanceof Array)) throw new TypeError('The disabledEvents option must be an Array.');
    if (typeof options.retryLimit !== 'number' || isNaN(options.retryLimit)) ***REMOVED***
      throw new TypeError('The retryLimit  options must be a number.');
    ***REMOVED***
  ***REMOVED***
***REMOVED***

module.exports = Client;

/**
 * Emitted for general warnings.
 * @event Client#warn
 * @param ***REMOVED***string***REMOVED*** info The warning
 */

/**
 * Emitted for general debugging information.
 * @event Client#debug
 * @param ***REMOVED***string***REMOVED*** info The debug information
 */
