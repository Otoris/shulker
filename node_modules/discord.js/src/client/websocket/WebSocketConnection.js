const browser = typeof window !== 'undefined';
const EventEmitter = require('events');
const Constants = require('../../util/Constants');
const zlib = require('zlib');
const PacketManager = require('./packets/WebSocketPacketManager');
const erlpack = (function findErlpack() ***REMOVED***
  try ***REMOVED***
    const e = require('erlpack');
    if (!e.pack) return null;
    return e;
  ***REMOVED*** catch (e) ***REMOVED***
    return null;
  ***REMOVED***
***REMOVED***());

const WebSocket = (function findWebSocket() ***REMOVED***
  if (browser) return window.WebSocket; // eslint-disable-line no-undef
  try ***REMOVED***
    const uws = require('@discordjs/uws');
    process.emitWarning('uws support is being removed in the next version of discord.js',
      'DeprecationWarning', findWebSocket);
    return uws;
  ***REMOVED*** catch (e) ***REMOVED***
    return require('ws');
  ***REMOVED***
***REMOVED***());

/**
 * Abstracts a WebSocket connection with decoding/encoding for the Discord gateway.
 * @private
 */
class WebSocketConnection extends EventEmitter ***REMOVED***
  /**
   * @param ***REMOVED***WebSocketManager***REMOVED*** manager The WebSocket manager
   * @param ***REMOVED***string***REMOVED*** gateway The WebSocket gateway to connect to
   */
  constructor(manager, gateway) ***REMOVED***
    super();
    /**
     * The WebSocket Manager of this connection
     * @type ***REMOVED***WebSocketManager***REMOVED***
     */
    this.manager = manager;

    /**
     * The client this belongs to
     * @type ***REMOVED***Client***REMOVED***
     */
    this.client = manager.client;

    /**
     * The WebSocket connection itself
     * @type ***REMOVED***WebSocket***REMOVED***
     */
    this.ws = null;

    /**
     * The current sequence of the WebSocket
     * @type ***REMOVED***number***REMOVED***
     */
    this.sequence = -1;

    /**
     * The current status of the client
     * @type ***REMOVED***Status***REMOVED***
     */
    this.status = Constants.Status.IDLE;

    /**
     * The Packet Manager of the connection
     * @type ***REMOVED***WebSocketPacketManager***REMOVED***
     */
    this.packetManager = new PacketManager(this);

    /**
     * The last time a ping was sent (a timestamp)
     * @type ***REMOVED***number***REMOVED***
     */
    this.lastPingTimestamp = 0;

    /**
     * Contains the rate limit queue and metadata
     * @type ***REMOVED***Object***REMOVED***
     */
    this.ratelimit = ***REMOVED***
      queue: [],
      remaining: 120,
      total: 120,
      time: 60e3,
      resetTimer: null,
    ***REMOVED***;
    this.connect(gateway);

    /**
     * Events that are disabled (will not be processed)
     * @type ***REMOVED***Object***REMOVED***
     */
    this.disabledEvents = ***REMOVED******REMOVED***;

    /**
     * The sequence on WebSocket close
     * @type ***REMOVED***number***REMOVED***
     */
    this.closeSequence = 0;

    /**
     * Whether or not the WebSocket is expecting to be closed
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.expectingClose = false;
    for (const event of this.client.options.disabledEvents) this.disabledEvents[event] = true;
  ***REMOVED***

  /**
   * Causes the client to be marked as ready and emits the ready event.
   * @returns ***REMOVED***void***REMOVED***
   */
  triggerReady() ***REMOVED***
    if (this.status === Constants.Status.READY) ***REMOVED***
      this.debug('Tried to mark self as ready, but already ready');
      return;
    ***REMOVED***
    /**
     * Emitted when the client becomes ready to start working.
     * @event Client#ready
     */
    this.status = Constants.Status.READY;
    this.client.emit(Constants.Events.READY);
    this.packetManager.handleQueue();
  ***REMOVED***

  /**
   * Checks whether the client is ready to be marked as ready.
   * @returns ***REMOVED***void***REMOVED***
   */
  checkIfReady() ***REMOVED***
    if (this.status === Constants.Status.READY || this.status === Constants.Status.NEARLY) return false;
    let unavailableGuilds = 0;
    for (const guild of this.client.guilds.values()) ***REMOVED***
      if (!guild.available) unavailableGuilds++;
    ***REMOVED***
    if (unavailableGuilds === 0) ***REMOVED***
      this.status = Constants.Status.NEARLY;
      if (!this.client.options.fetchAllMembers) return this.triggerReady();
      // Fetch all members before marking self as ready
      const promises = this.client.guilds.map(g => g.fetchMembers());
      Promise.all(promises)
        .then(() => this.triggerReady())
        .catch(e => ***REMOVED***
          this.debug(`Failed to fetch all members before ready! $***REMOVED***e***REMOVED***`);
          this.triggerReady();
        ***REMOVED***);
    ***REMOVED***
    return true;
  ***REMOVED***

  // Util
  /**
   * Emits a debug message.
   * @param ***REMOVED***string***REMOVED*** message Debug message
   * @returns ***REMOVED***void***REMOVED***
   */
  debug(message) ***REMOVED***
    if (message instanceof Error) message = message.stack;
    return this.manager.debug(`[connection] $***REMOVED***message***REMOVED***`);
  ***REMOVED***

  /**
   * Attempts to serialise data from the WebSocket.
   * @param ***REMOVED***string|Object***REMOVED*** data Data to unpack
   * @returns ***REMOVED***Object***REMOVED***
   */
  unpack(data) ***REMOVED***
    if (data instanceof ArrayBuffer) data = Buffer.from(new Uint8Array(data));

    if (erlpack && typeof data !== 'string') return erlpack.unpack(data);
    else if (data instanceof Buffer) data = zlib.inflateSync(data).toString();

    return JSON.parse(data);
  ***REMOVED***

  /**
   * Packs an object ready to be sent.
   * @param ***REMOVED***Object***REMOVED*** data Data to pack
   * @returns ***REMOVED***string|Buffer***REMOVED***
   */
  pack(data) ***REMOVED***
    return erlpack ? erlpack.pack(data) : JSON.stringify(data);
  ***REMOVED***

  /**
   * Processes the current WebSocket queue.
   */
  processQueue() ***REMOVED***
    if (this.ratelimit.remaining === 0) return;
    if (this.ratelimit.queue.length === 0) return;
    if (this.ratelimit.remaining === this.ratelimit.total) ***REMOVED***
      this.ratelimit.resetTimer = this.client.setTimeout(() => ***REMOVED***
        this.ratelimit.remaining = this.ratelimit.total;
        this.processQueue();
      ***REMOVED***, this.ratelimit.time);
    ***REMOVED***
    while (this.ratelimit.remaining > 0) ***REMOVED***
      const item = this.ratelimit.queue.shift();
      if (!item) return;
      this._send(item);
      this.ratelimit.remaining--;
    ***REMOVED***
  ***REMOVED***

  /**
   * Sends data, bypassing the queue.
   * @param ***REMOVED***Object***REMOVED*** data Packet to send
   * @returns ***REMOVED***void***REMOVED***
   */
  _send(data) ***REMOVED***
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) ***REMOVED***
      this.debug(`Tried to send packet $***REMOVED***JSON.stringify(data)***REMOVED*** but no WebSocket is available!`);
      return;
    ***REMOVED***
    this.ws.send(this.pack(data));
  ***REMOVED***

  /**
   * Adds data to the queue to be sent.
   * @param ***REMOVED***Object***REMOVED*** data Packet to send
   * @returns ***REMOVED***void***REMOVED***
   */
  send(data) ***REMOVED***
    if (!this.ws || this.ws.readyState !== WebSocket.OPEN) ***REMOVED***
      this.debug(`Tried to send packet $***REMOVED***JSON.stringify(data)***REMOVED*** but no WebSocket is available!`);
      return;
    ***REMOVED***
    this.ratelimit.queue.push(data);
    this.processQueue();
  ***REMOVED***

  /**
   * Creates a connection to a gateway.
   * @param ***REMOVED***string***REMOVED*** gateway The gateway to connect to
   * @param ***REMOVED***number***REMOVED*** [after=0] How long to wait before connecting
   * @param ***REMOVED***boolean***REMOVED*** [force=false] Whether or not to force a new connection even if one already exists
   * @returns ***REMOVED***boolean***REMOVED***
   */
  connect(gateway = this.gateway, after = 0, force = false) ***REMOVED***
    if (after) return this.client.setTimeout(() => this.connect(gateway, 0, force), after); // eslint-disable-line
    if (this.ws && !force) ***REMOVED***
      this.debug('WebSocket connection already exists');
      return false;
    ***REMOVED*** else if (typeof gateway !== 'string') ***REMOVED***
      this.debug(`Tried to connect to an invalid gateway: $***REMOVED***gateway***REMOVED***`);
      return false;
    ***REMOVED***
    this.expectingClose = false;
    this.gateway = gateway;
    this.debug(`Connecting to $***REMOVED***gateway***REMOVED***`);
    const ws = this.ws = new WebSocket(gateway);
    if (browser) ws.binaryType = 'arraybuffer';
    ws.onmessage = this.onMessage.bind(this);
    ws.onopen = this.onOpen.bind(this);
    ws.onerror = this.onError.bind(this);
    ws.onclose = this.onClose.bind(this);
    this.status = Constants.Status.CONNECTING;
    return true;
  ***REMOVED***

  /**
   * Destroys the connection.
   * @returns ***REMOVED***boolean***REMOVED***
   */
  destroy() ***REMOVED***
    const ws = this.ws;
    if (!ws) ***REMOVED***
      this.debug('Attempted to destroy WebSocket but no connection exists!');
      return false;
    ***REMOVED***
    this.heartbeat(-1);
    this.expectingClose = true;
    ws.close(1000);
    this.packetManager.handleQueue();
    this.ws = null;
    this.status = Constants.Status.DISCONNECTED;
    this.ratelimit.remaining = this.ratelimit.total;
    return true;
  ***REMOVED***

  /**
   * Called whenever a message is received.
   * @param ***REMOVED***Event***REMOVED*** event Event received
   * @returns ***REMOVED***boolean***REMOVED***
   */
  onMessage(event) ***REMOVED***
    let data;
    try ***REMOVED***
      data = this.unpack(event.data);
    ***REMOVED*** catch (err) ***REMOVED***
      this.emit('debug', err);
    ***REMOVED***
    return this.onPacket(data);
  ***REMOVED***

  /**
   * Sets the current sequence of the connection.
   * @param ***REMOVED***number***REMOVED*** s New sequence
   */
  setSequence(s) ***REMOVED***
    this.sequence = s > this.sequence ? s : this.sequence;
  ***REMOVED***

  /**
   * Called whenever a packet is received.
   * @param ***REMOVED***Object***REMOVED*** packet Received packet
   * @returns ***REMOVED***boolean***REMOVED***
   */
  onPacket(packet) ***REMOVED***
    if (!packet) ***REMOVED***
      this.debug('Received null packet');
      return false;
    ***REMOVED***
    this.client.emit('raw', packet);
    switch (packet.op) ***REMOVED***
      case Constants.OPCodes.HELLO:
        return this.heartbeat(packet.d.heartbeat_interval);
      case Constants.OPCodes.RECONNECT:
        return this.reconnect();
      case Constants.OPCodes.INVALID_SESSION:
        if (!packet.d) this.sessionID = null;
        this.sequence = -1;
        this.debug('Session invalidated -- will identify with a new session');
        return this.identify(packet.d ? 2500 : 0);
      case Constants.OPCodes.HEARTBEAT_ACK:
        return this.ackHeartbeat();
      case Constants.OPCodes.HEARTBEAT:
        return this.heartbeat();
      default:
        return this.packetManager.handle(packet);
    ***REMOVED***
  ***REMOVED***

  /**
   * Called whenever a connection is opened to the gateway.
   * @param ***REMOVED***Event***REMOVED*** event Received open event
   */
  onOpen(event) ***REMOVED***
    if (event && event.target && event.target.url) this.gateway = event.target.url;
    this.debug(`Connected to gateway $***REMOVED***this.gateway***REMOVED***`);
    this.identify();
  ***REMOVED***

  /**
   * Causes a reconnection to the gateway.
   */
  reconnect() ***REMOVED***
    this.debug('Attemping to reconnect in 5500ms...');
    /**
     * Emitted whenever the client tries to reconnect to the WebSocket.
     * @event Client#reconnecting
     */
    this.client.emit(Constants.Events.RECONNECTING);
    this.connect(this.gateway, 5500, true);
  ***REMOVED***

  /**
   * Called whenever an error occurs with the WebSocket.
   * @param ***REMOVED***Error***REMOVED*** error The error that occurred
   */
  onError(error) ***REMOVED***
    if (error && error.message === 'uWs client connection error') ***REMOVED***
      this.reconnect();
      return;
    ***REMOVED***
    /**
     * Emitted whenever the client's WebSocket encounters a connection error.
     * @event Client#error
     * @param ***REMOVED***Error***REMOVED*** error The encountered error
     */
    this.client.emit(Constants.Events.ERROR, error);
  ***REMOVED***

  /**
   * @external CloseEvent
   * @see ***REMOVED***@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent***REMOVED***
   */

  /**
   * Called whenever a connection to the gateway is closed.
   * @param ***REMOVED***CloseEvent***REMOVED*** event Close event that was received
   */
  onClose(event) ***REMOVED***
    this.debug(`$***REMOVED***this.expectingClose ? 'Client' : 'Server'***REMOVED*** closed the WebSocket connection: $***REMOVED***event.code***REMOVED***`);
    this.closeSequence = this.sequence;
    // Reset the state before trying to fix anything
    this.emit('close', event);
    this.heartbeat(-1);
    // Should we reconnect?
    if (event.code === 1000 ? this.expectingClose : Constants.WSCodes[event.code]) ***REMOVED***
      this.expectingClose = false;
      /**
       * Emitted when the client's WebSocket disconnects and will no longer attempt to reconnect.
       * @event Client#disconnect
       * @param ***REMOVED***CloseEvent***REMOVED*** event The WebSocket close event
       */
      this.client.emit(Constants.Events.DISCONNECT, event);
      this.debug(Constants.WSCodes[event.code]);
      this.destroy();
      return;
    ***REMOVED***
    this.expectingClose = false;
    this.reconnect();
  ***REMOVED***

  // Heartbeat
  /**
   * Acknowledges a heartbeat.
   */
  ackHeartbeat() ***REMOVED***
    this.debug(`Heartbeat acknowledged, latency of $***REMOVED***Date.now() - this.lastPingTimestamp***REMOVED***ms`);
    this.client._pong(this.lastPingTimestamp);
  ***REMOVED***

  /**
   * Sends a heartbeat or sets an interval for sending heartbeats.
   * @param ***REMOVED***number***REMOVED*** [time] If -1, clears the interval, any other number sets an interval
   * If no value is given, a heartbeat will be sent instantly
   */
  heartbeat(time) ***REMOVED***
    if (!isNaN(time)) ***REMOVED***
      if (time === -1) ***REMOVED***
        this.debug('Clearing heartbeat interval');
        this.client.clearInterval(this.heartbeatInterval);
        this.heartbeatInterval = null;
      ***REMOVED*** else ***REMOVED***
        this.debug(`Setting a heartbeat interval for $***REMOVED***time***REMOVED***ms`);
        this.heartbeatInterval = this.client.setInterval(() => this.heartbeat(), time);
      ***REMOVED***
      return;
    ***REMOVED***
    this.debug('Sending a heartbeat');
    this.lastPingTimestamp = Date.now();
    this.send(***REMOVED***
      op: Constants.OPCodes.HEARTBEAT,
      d: this.sequence,
    ***REMOVED***);
  ***REMOVED***

  // Identification
  /**
   * Identifies the client on a connection.
   * @param ***REMOVED***number***REMOVED*** [after] How long to wait before identifying
   * @returns ***REMOVED***void***REMOVED***
   */
  identify(after) ***REMOVED***
    if (after) return this.client.setTimeout(this.identify.bind(this), after);
    return this.sessionID ? this.identifyResume() : this.identifyNew();
  ***REMOVED***

  /**
   * Identifies as a new connection on the gateway.
   * @returns ***REMOVED***void***REMOVED***
   */
  identifyNew() ***REMOVED***
    if (!this.client.token) ***REMOVED***
      this.debug('No token available to identify a new session with');
      return;
    ***REMOVED***
    // Clone the generic payload and assign the token
    const d = Object.assign(***REMOVED*** token: this.client.token ***REMOVED***, this.client.options.ws);

    // Sharding stuff
    const ***REMOVED*** shardId, shardCount ***REMOVED*** = this.client.options;
    if (shardCount > 0) d.shard = [Number(shardId), Number(shardCount)];

    // Send the payload
    this.debug('Identifying as a new session');
    this.send(***REMOVED*** op: Constants.OPCodes.IDENTIFY, d ***REMOVED***);
  ***REMOVED***

  /**
   * Resumes a session on the gateway.
   * @returns ***REMOVED***void***REMOVED***
   */
  identifyResume() ***REMOVED***
    if (!this.sessionID) ***REMOVED***
      this.debug('Warning: wanted to resume but session ID not available; identifying as a new session instead');
      return this.identifyNew();
    ***REMOVED***
    this.debug(`Attempting to resume session $***REMOVED***this.sessionID***REMOVED***`);

    const d = ***REMOVED***
      token: this.client.token,
      session_id: this.sessionID,
      seq: this.sequence,
    ***REMOVED***;

    return this.send(***REMOVED***
      op: Constants.OPCodes.RESUME,
      d,
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

/**
 * Encoding the WebSocket connections will use.
 * @type ***REMOVED***string***REMOVED***
 */
WebSocketConnection.ENCODING = erlpack ? 'etf' : 'json';
WebSocketConnection.WebSocket = WebSocket;

module.exports = WebSocketConnection;
