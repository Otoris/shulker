const childProcess = require('child_process');
const EventEmitter = require('events');
const path = require('path');
const Util = require('../util/Util');

/**
 * Represents a Shard spawned by the ShardingManager.
 */
class Shard extends EventEmitter ***REMOVED***
  /**
   * @param ***REMOVED***ShardingManager***REMOVED*** manager The sharding manager
   * @param ***REMOVED***number***REMOVED*** id The ID of this shard
   * @param ***REMOVED***Array***REMOVED*** [args=[]] Command line arguments to pass to the script
   */
  constructor(manager, id, args = []) ***REMOVED***
    super();
    /**
     * Manager that created the shard
     * @type ***REMOVED***ShardingManager***REMOVED***
     */
    this.manager = manager;

    /**
     * ID of the shard
     * @type ***REMOVED***number***REMOVED***
     */
    this.id = id;

    /**
     * The environment variables for the shard
     * @type ***REMOVED***Object***REMOVED***
     */
    this.env = Object.assign(***REMOVED******REMOVED***, process.env, ***REMOVED***
      SHARD_ID: this.id,
      SHARD_COUNT: this.manager.totalShards,
      CLIENT_TOKEN: this.manager.token,
    ***REMOVED***);

    /**
     * Whether the shard's ***REMOVED***@link Client***REMOVED*** is ready
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.ready = false;

    this._evals = new Map();
    this._fetches = new Map();

    /**
     * Listener function for the ***REMOVED***@link ChildProcess***REMOVED***' `exit` event
     * @type ***REMOVED***Function***REMOVED***
     * @private
     */
    this._exitListener = this._handleExit.bind(this, undefined);

    /**
     * Process of the shard
     * @type ***REMOVED***ChildProcess***REMOVED***
     */
    this.process = null;

    this.spawn(args);
  ***REMOVED***

  /**
   * Forks a child process for the shard.
   * <warn>You should not need to call this manually.</warn>
   * @param ***REMOVED***Array***REMOVED*** [args=this.manager.args] Command line arguments to pass to the script
   * @param ***REMOVED***Array***REMOVED*** [execArgv=this.manager.execArgv] Command line arguments to pass to the process executable
   * @returns ***REMOVED***ChildProcess***REMOVED***
   */
  spawn(args = this.manager.args, execArgv = this.manager.execArgv) ***REMOVED***
    this.process = childProcess.fork(path.resolve(this.manager.file), args, ***REMOVED***
      env: this.env, execArgv,
    ***REMOVED***)
      .on('exit', this._exitListener)
      .on('message', this._handleMessage.bind(this));

    /**
     * Emitted upon the creation of the shard's child process.
     * @event Shard#spawn
     * @param ***REMOVED***ChildProcess***REMOVED*** process Child process that was created
     */
    this.emit('spawn', this.process);

    return new Promise((resolve, reject) => ***REMOVED***
      this.once('ready', resolve);
      this.once('disconnect', () => reject(new Error(`Shard $***REMOVED***this.id***REMOVED***'s Client disconnected before becoming ready.`)));
      this.once('death', () => reject(new Error(`Shard $***REMOVED***this.id***REMOVED***'s process exited before its Client became ready.`)));
      setTimeout(() => reject(new Error(`Shard $***REMOVED***this.id***REMOVED***'s Client took too long to become ready.`)), 30000);
    ***REMOVED***).then(() => this.process);
  ***REMOVED***

  /**
   * Immediately kills the shard's process and does not restart it.
   */
  kill() ***REMOVED***
    this.process.removeListener('exit', this._exitListener);
    this.process.kill();
    this._handleExit(false);
  ***REMOVED***

  /**
   * Kills and restarts the shard's process.
   * @param ***REMOVED***number***REMOVED*** [delay=500] How long to wait between killing the process and restarting it (in milliseconds)
   * @returns ***REMOVED***Promise<ChildProcess>***REMOVED***
   */
  respawn(delay = 500) ***REMOVED***
    this.kill();
    if (delay > 0) return Util.delayFor(delay).then(() => this.spawn());
    return this.spawn();
  ***REMOVED***

  /**
   * Sends a message to the shard's process.
   * @param ***REMOVED*******REMOVED*** message Message to send to the shard
   * @returns ***REMOVED***Promise<Shard>***REMOVED***
   */
  send(message) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      this.process.send(message, err => ***REMOVED***
        if (err) reject(err); else resolve(this);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Fetches a client property value of the shard.
   * @param ***REMOVED***string***REMOVED*** prop Name of the client property to get, using periods for nesting
   * @returns ***REMOVED***Promise<*>***REMOVED***
   * @example
   * shard.fetchClientValue('guilds.size')
   *   .then(count => console.log(`$***REMOVED***count***REMOVED*** guilds in shard $***REMOVED***shard.id***REMOVED***`))
   *   .catch(console.error);
   */
  fetchClientValue(prop) ***REMOVED***
    if (this._fetches.has(prop)) return this._fetches.get(prop);

    const promise = new Promise((resolve, reject) => ***REMOVED***
      const listener = message => ***REMOVED***
        if (!message || message._fetchProp !== prop) return;
        this.process.removeListener('message', listener);
        this._fetches.delete(prop);
        resolve(message._result);
      ***REMOVED***;
      this.process.on('message', listener);

      this.send(***REMOVED*** _fetchProp: prop ***REMOVED***).catch(err => ***REMOVED***
        this.process.removeListener('message', listener);
        this._fetches.delete(prop);
        reject(err);
      ***REMOVED***);
    ***REMOVED***);

    this._fetches.set(prop, promise);
    return promise;
  ***REMOVED***

  /**
   * Evaluates a script on the shard, in the context of the client.
   * @param ***REMOVED***string***REMOVED*** script JavaScript to run on the shard
   * @returns ***REMOVED***Promise<*>***REMOVED*** Result of the script execution
   */
  eval(script) ***REMOVED***
    if (this._evals.has(script)) return this._evals.get(script);

    const promise = new Promise((resolve, reject) => ***REMOVED***
      const listener = message => ***REMOVED***
        if (!message || message._eval !== script) return;
        this.process.removeListener('message', listener);
        this._evals.delete(script);
        if (!message._error) resolve(message._result); else reject(Util.makeError(message._error));
      ***REMOVED***;
      this.process.on('message', listener);

      this.send(***REMOVED*** _eval: script ***REMOVED***).catch(err => ***REMOVED***
        this.process.removeListener('message', listener);
        this._evals.delete(script);
        reject(err);
      ***REMOVED***);
    ***REMOVED***);

    this._evals.set(script, promise);
    return promise;
  ***REMOVED***

  /**
   * Handles an IPC message.
   * @param ***REMOVED*******REMOVED*** message Message received
   * @private
   */
  _handleMessage(message) ***REMOVED***
    if (message) ***REMOVED***
      // Shard is ready
      if (message._ready) ***REMOVED***
        this.ready = true;
        /**
         * Emitted upon the shard's ***REMOVED***@link Client#ready***REMOVED*** event.
         * @event Shard#ready
         */
        this.emit('ready');
        return;
      ***REMOVED***

      // Shard has disconnected
      if (message._disconnect) ***REMOVED***
        this.ready = false;
        /**
         * Emitted upon the shard's ***REMOVED***@link Client#disconnect***REMOVED*** event.
         * @event Shard#disconnect
         */
        this.emit('disconnect');
        return;
      ***REMOVED***

      // Shard is attempting to reconnect
      if (message._reconnecting) ***REMOVED***
        this.ready = false;
        /**
         * Emitted upon the shard's ***REMOVED***@link Client#reconnecting***REMOVED*** event.
         * @event Shard#reconnecting
         */
        this.emit('reconnecting');
        return;
      ***REMOVED***

      // Shard is requesting a property fetch
      if (message._sFetchProp) ***REMOVED***
        this.manager.fetchClientValues(message._sFetchProp).then(
          results => this.send(***REMOVED*** _sFetchProp: message._sFetchProp, _result: results ***REMOVED***),
          err => this.send(***REMOVED*** _sFetchProp: message._sFetchProp, _error: Util.makePlainError(err) ***REMOVED***)
        );
        return;
      ***REMOVED***

      // Shard is requesting an eval broadcast
      if (message._sEval) ***REMOVED***
        this.manager.broadcastEval(message._sEval).then(
          results => this.send(***REMOVED*** _sEval: message._sEval, _result: results ***REMOVED***),
          err => this.send(***REMOVED*** _sEval: message._sEval, _error: Util.makePlainError(err) ***REMOVED***)
        );
        return;
      ***REMOVED***
    ***REMOVED***

    /**
     * Emitted upon recieving a message from a shard.
     * @event ShardingManager#message
     * @param ***REMOVED***Shard***REMOVED*** shard Shard that sent the message
     * @param ***REMOVED*******REMOVED*** message Message that was received
     */
    this.manager.emit('message', this, message);

    /**
     * Emitted upon recieving a message from the child process.
     * @event Shard#message
     * @param ***REMOVED*******REMOVED*** message Message that was received
     */
    this.emit('message', message);
  ***REMOVED***

  /**
   * Handles the shard's process exiting.
   * @param ***REMOVED***boolean***REMOVED*** [respawn=this.manager.respawn] Whether to spawn the shard again
   * @private
   */
  _handleExit(respawn = this.manager.respawn) ***REMOVED***
    /**
     * Emitted upon the shard's child process exiting.
     * @event Shard#death
     * @param ***REMOVED***ChildProcess***REMOVED*** process Child process that exited
     */
    this.emit('death', this.process);

    this.process = null;
    this._evals.clear();
    this._fetches.clear();

    if (respawn) this.manager.createShard(this.id);
  ***REMOVED***
***REMOVED***

module.exports = Shard;
