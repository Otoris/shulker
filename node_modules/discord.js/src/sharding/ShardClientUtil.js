const Util = require('../util/Util');

/**
 * Helper class for sharded clients spawned as a child process, such as from a ShardingManager.
 */
class ShardClientUtil ***REMOVED***
  /**
   * @param ***REMOVED***Client***REMOVED*** client The client of the current shard
   */
  constructor(client) ***REMOVED***
    this.client = client;
    process.on('message', this._handleMessage.bind(this));
    client.on('ready', () => ***REMOVED*** process.send(***REMOVED*** _ready: true ***REMOVED***); ***REMOVED***);
    client.on('disconnect', () => ***REMOVED*** process.send(***REMOVED*** _disconnect: true ***REMOVED***); ***REMOVED***);
    client.on('reconnecting', () => ***REMOVED*** process.send(***REMOVED*** _reconnecting: true ***REMOVED***); ***REMOVED***);
  ***REMOVED***

  /**
   * ID of this shard
   * @type ***REMOVED***number***REMOVED***
   * @readonly
   */
  get id() ***REMOVED***
    return this.client.options.shardId;
  ***REMOVED***

  /**
   * Total number of shards
   * @type ***REMOVED***number***REMOVED***
   * @readonly
   */
  get count() ***REMOVED***
    return this.client.options.shardCount;
  ***REMOVED***

  /**
   * Sends a message to the master process.
   * @param ***REMOVED*******REMOVED*** message Message to send
   * @returns ***REMOVED***Promise<void>***REMOVED***
   */
  send(message) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      process.send(message, err => ***REMOVED***
        if (err) reject(err); else resolve();
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Fetches a client property value of each shard.
   * @param ***REMOVED***string***REMOVED*** prop Name of the client property to get, using periods for nesting
   * @returns ***REMOVED***Promise<Array>***REMOVED***
   * @example
   * client.shard.fetchClientValues('guilds.size')
   *   .then(results => ***REMOVED***
   *     console.log(`$***REMOVED***results.reduce((prev, val) => prev + val, 0)***REMOVED*** total guilds`);
   *   ***REMOVED***)
   *   .catch(console.error);
   */
  fetchClientValues(prop) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      const listener = message => ***REMOVED***
        if (!message || message._sFetchProp !== prop) return;
        process.removeListener('message', listener);
        if (!message._error) resolve(message._result); else reject(Util.makeError(message._error));
      ***REMOVED***;
      process.on('message', listener);

      this.send(***REMOVED*** _sFetchProp: prop ***REMOVED***).catch(err => ***REMOVED***
        process.removeListener('message', listener);
        reject(err);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Evaluates a script on all shards, in the context of the Clients.
   * @param ***REMOVED***string***REMOVED*** script JavaScript to run on each shard
   * @returns ***REMOVED***Promise<Array>***REMOVED*** Results of the script execution
   */
  broadcastEval(script) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      const listener = message => ***REMOVED***
        if (!message || message._sEval !== script) return;
        process.removeListener('message', listener);
        if (!message._error) resolve(message._result); else reject(Util.makeError(message._error));
      ***REMOVED***;
      process.on('message', listener);

      this.send(***REMOVED*** _sEval: script ***REMOVED***).catch(err => ***REMOVED***
        process.removeListener('message', listener);
        reject(err);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Handles an IPC message.
   * @param ***REMOVED*******REMOVED*** message Message received
   * @private
   */
  _handleMessage(message) ***REMOVED***
    if (!message) return;
    if (message._fetchProp) ***REMOVED***
      const props = message._fetchProp.split('.');
      let value = this.client;
      for (const prop of props) value = value[prop];
      this._respond('fetchProp', ***REMOVED*** _fetchProp: message._fetchProp, _result: value ***REMOVED***);
    ***REMOVED*** else if (message._eval) ***REMOVED***
      try ***REMOVED***
        this._respond('eval', ***REMOVED*** _eval: message._eval, _result: this.client._eval(message._eval) ***REMOVED***);
      ***REMOVED*** catch (err) ***REMOVED***
        this._respond('eval', ***REMOVED*** _eval: message._eval, _error: Util.makePlainError(err) ***REMOVED***);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  /**
   * Sends a message to the master process, emitting an error from the client upon failure.
   * @param ***REMOVED***string***REMOVED*** type Type of response to send
   * @param ***REMOVED*******REMOVED*** message Message to send
   * @private
   */
  _respond(type, message) ***REMOVED***
    this.send(message).catch(err => ***REMOVED***
      err.message = `Error when sending $***REMOVED***type***REMOVED*** response to master process: $***REMOVED***err.message***REMOVED***`;
      this.client.emit('error', err);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Creates/gets the singleton of this class.
   * @param ***REMOVED***Client***REMOVED*** client The client to use
   * @returns ***REMOVED***ShardClientUtil***REMOVED***
   */
  static singleton(client) ***REMOVED***
    if (!this._singleton) ***REMOVED***
      this._singleton = new this(client);
    ***REMOVED*** else ***REMOVED***
      client.emit('warn', 'Multiple clients created in child process; only the first will handle sharding helpers.');
    ***REMOVED***
    return this._singleton;
  ***REMOVED***
***REMOVED***

module.exports = ShardClientUtil;
