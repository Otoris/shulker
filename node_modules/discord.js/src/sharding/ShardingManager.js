const path = require('path');
const fs = require('fs');
const EventEmitter = require('events').EventEmitter;
const Shard = require('./Shard');
const Collection = require('../util/Collection');
const Util = require('../util/Util');

/**
 * This is a utility class that can be used to help you spawn shards of your client. Each shard is completely separate
 * from the other. The Shard Manager takes a path to a file and spawns it under the specified amount of shards safely.
 * If you do not select an amount of shards, the manager will automatically decide the best amount.
 * @extends ***REMOVED***EventEmitter***REMOVED***
 */
class ShardingManager extends EventEmitter ***REMOVED***
  /**
   * @param ***REMOVED***string***REMOVED*** file Path to your shard script file
   * @param ***REMOVED***Object***REMOVED*** [options] Options for the sharding manager
   * @param ***REMOVED***number|string***REMOVED*** [options.totalShards='auto'] Number of shards to spawn, or "auto"
   * @param ***REMOVED***boolean***REMOVED*** [options.respawn=true] Whether shards should automatically respawn upon exiting
   * @param ***REMOVED***string[]***REMOVED*** [options.shardArgs=[]] Arguments to pass to the shard script when spawning
   * @param ***REMOVED***string***REMOVED*** [options.token] Token to use for automatic shard count and passing to shards
   */
  constructor(file, options = ***REMOVED******REMOVED***) ***REMOVED***
    super();
    options = Util.mergeDefault(***REMOVED***
      totalShards: 'auto',
      respawn: true,
      shardArgs: [],
      token: null,
    ***REMOVED***, options);

    /**
     * Path to the shard script file
     * @type ***REMOVED***string***REMOVED***
     */
    this.file = file;
    if (!file) throw new Error('File must be specified.');
    if (!path.isAbsolute(file)) this.file = path.resolve(process.cwd(), file);
    const stats = fs.statSync(this.file);
    if (!stats.isFile()) throw new Error('File path does not point to a file.');

    /**
     * Amount of shards that this manager is going to spawn
     * @type ***REMOVED***number|string***REMOVED***
     */
    this.totalShards = options.totalShards;
    if (this.totalShards !== 'auto') ***REMOVED***
      if (typeof this.totalShards !== 'number' || isNaN(this.totalShards)) ***REMOVED***
        throw new TypeError('Amount of shards must be a number.');
      ***REMOVED***
      if (this.totalShards < 1) throw new RangeError('Amount of shards must be at least 1.');
      if (this.totalShards !== Math.floor(this.totalShards)) ***REMOVED***
        throw new RangeError('Amount of shards must be an integer.');
      ***REMOVED***
    ***REMOVED***

    /**
     * Whether shards should automatically respawn upon exiting
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.respawn = options.respawn;

    /**
     * An array of arguments to pass to shards
     * @type ***REMOVED***string[]***REMOVED***
     */
    this.shardArgs = options.shardArgs;

    /**
     * Arguments for the shard's process executable
     * @type ***REMOVED***?string[]***REMOVED***
     */
    this.execArgv = options.execArgv;

    /**
     * Token to use for obtaining the automatic shard count, and passing to shards
     * @type ***REMOVED***?string***REMOVED***
     */
    this.token = options.token ? options.token.replace(/^Bot\s*/i, '') : null;

    /**
     * A collection of shards that this manager has spawned
     * @type ***REMOVED***Collection<number, Shard>***REMOVED***
     */
    this.shards = new Collection();
  ***REMOVED***

  /**
   * Spawns a single shard.
   * @param ***REMOVED***number***REMOVED*** id The ID of the shard to spawn. **This is usually not necessary**
   * @returns ***REMOVED***Promise<Shard>***REMOVED***
   */
  createShard(id = this.shards.size) ***REMOVED***
    const shard = new Shard(this, id, this.shardArgs);
    this.shards.set(id, shard);
    /**
     * Emitted upon launching a shard.
     * @event ShardingManager#launch
     * @param ***REMOVED***Shard***REMOVED*** shard Shard that was launched
     */
    this.emit('launch', shard);
    return Promise.resolve(shard);
  ***REMOVED***

  /**
   * Spawns multiple shards.
   * @param ***REMOVED***number***REMOVED*** [amount=this.totalShards] Number of shards to spawn
   * @param ***REMOVED***number***REMOVED*** [delay=7500] How long to wait in between spawning each shard (in milliseconds)
   * @returns ***REMOVED***Promise<Collection<number, Shard>>***REMOVED***
   */
  spawn(amount = this.totalShards, delay = 7500) ***REMOVED***
    if (amount === 'auto') ***REMOVED***
      return Util.fetchRecommendedShards(this.token).then(count => ***REMOVED***
        this.totalShards = count;
        return this._spawn(count, delay);
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      if (typeof amount !== 'number' || isNaN(amount)) throw new TypeError('Amount of shards must be a number.');
      if (amount < 1) throw new RangeError('Amount of shards must be at least 1.');
      if (amount !== Math.floor(amount)) throw new TypeError('Amount of shards must be an integer.');
      return this._spawn(amount, delay);
    ***REMOVED***
  ***REMOVED***

  /**
   * Actually spawns shards, unlike that poser above >:(
   * @param ***REMOVED***number***REMOVED*** amount Number of shards to spawn
   * @param ***REMOVED***number***REMOVED*** delay How long to wait in between spawning each shard (in milliseconds)
   * @returns ***REMOVED***Promise<Collection<number, Shard>>***REMOVED***
   * @private
   */
  _spawn(amount, delay) ***REMOVED***
    return new Promise(resolve => ***REMOVED***
      if (this.shards.size >= amount) throw new Error(`Already spawned $***REMOVED***this.shards.size***REMOVED*** shards.`);
      this.totalShards = amount;

      this.createShard();
      if (this.shards.size >= this.totalShards) ***REMOVED***
        resolve(this.shards);
        return;
      ***REMOVED***

      if (delay <= 0) ***REMOVED***
        while (this.shards.size < this.totalShards) this.createShard();
        resolve(this.shards);
      ***REMOVED*** else ***REMOVED***
        const interval = setInterval(() => ***REMOVED***
          this.createShard();
          if (this.shards.size >= this.totalShards) ***REMOVED***
            clearInterval(interval);
            resolve(this.shards);
          ***REMOVED***
        ***REMOVED***, delay);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  /**
   * Send a message to all shards.
   * @param ***REMOVED*******REMOVED*** message Message to be sent to the shards
   * @returns ***REMOVED***Promise<Shard[]>***REMOVED***
   */
  broadcast(message) ***REMOVED***
    const promises = [];
    for (const shard of this.shards.values()) promises.push(shard.send(message));
    return Promise.all(promises);
  ***REMOVED***

  /**
   * Evaluates a script on all shards, in the context of the Clients.
   * @param ***REMOVED***string***REMOVED*** script JavaScript to run on each shard
   * @returns ***REMOVED***Promise<Array>***REMOVED*** Results of the script execution
   */
  broadcastEval(script) ***REMOVED***
    const promises = [];
    for (const shard of this.shards.values()) promises.push(shard.eval(script));
    return Promise.all(promises);
  ***REMOVED***

  /**
   * Fetches a client property value of each shard.
   * @param ***REMOVED***string***REMOVED*** prop Name of the client property to get, using periods for nesting
   * @returns ***REMOVED***Promise<Array>***REMOVED***
   * @example
   * manager.fetchClientValues('guilds.size')
   *   .then(results => ***REMOVED***
   *     console.log(`$***REMOVED***results.reduce((prev, val) => prev + val, 0)***REMOVED*** total guilds`);
   *   ***REMOVED***)
   *   .catch(console.error);
   */
  fetchClientValues(prop) ***REMOVED***
    if (this.shards.size === 0) return Promise.reject(new Error('No shards have been spawned.'));
    if (this.shards.size !== this.totalShards) return Promise.reject(new Error('Still spawning shards.'));
    const promises = [];
    for (const shard of this.shards.values()) promises.push(shard.fetchClientValue(prop));
    return Promise.all(promises);
  ***REMOVED***

  /**
   * Kills all running shards and respawns them.
   * @param ***REMOVED***number***REMOVED*** [shardDelay=5000] How long to wait between shards (in milliseconds)
   * @param ***REMOVED***number***REMOVED*** [respawnDelay=500] How long to wait between killing a shard's process and restarting it
   * (in milliseconds)
   * @param ***REMOVED***boolean***REMOVED*** [waitForReady=true] Whether to wait for a shard to become ready before continuing to another
   * @param ***REMOVED***number***REMOVED*** [currentShardIndex=0] The shard index to start respawning at
   * @returns ***REMOVED***Promise<Collection<number, Shard>>***REMOVED***
   */
  respawnAll(shardDelay = 5000, respawnDelay = 500, waitForReady = true, currentShardIndex = 0) ***REMOVED***
    let s = 0;
    const shard = this.shards.get(currentShardIndex);
    const promises = [shard.respawn(respawnDelay, waitForReady)];
    if (++s < this.shards.size && shardDelay > 0) promises.push(Util.delayFor(shardDelay));
    return Promise.all(promises).then(() => ***REMOVED***
      if (++currentShardIndex === this.shards.size) return this.shards;
      return this.respawnAll(shardDelay, respawnDelay, waitForReady, currentShardIndex);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

module.exports = ShardingManager;
