const path = require('path');
const Message = require('../Message');
const MessageCollector = require('../MessageCollector');
const Collection = require('../../util/Collection');
const Attachment = require('../../structures/Attachment');
const RichEmbed = require('../../structures/RichEmbed');
const Snowflake = require('../../util/Snowflake');
const util = require('util');

/**
 * Interface for classes that have text-channel-like features.
 * @interface
 */
class TextBasedChannel ***REMOVED***
  constructor() ***REMOVED***
    /**
     * A collection containing the messages sent to this channel
     * @type ***REMOVED***Collection<Snowflake, Message>***REMOVED***
     */
    this.messages = new Collection();

    /**
     * The ID of the last message in the channel, if one was sent
     * @type ***REMOVED***?Snowflake***REMOVED***
     */
    this.lastMessageID = null;

    /**
     * The Message object of the last message in the channel, if one was sent
     * @type ***REMOVED***?Message***REMOVED***
     */
    this.lastMessage = null;

    /**
     * The timestamp when the last pinned message was pinned, if there was one
     * @type ***REMOVED***?number***REMOVED***
     */
    this.lastPinTimestamp = null;
  ***REMOVED***

  /**
   * Options provided when sending or editing a message.
   * @typedef ***REMOVED***Object***REMOVED*** MessageOptions
   * @property ***REMOVED***boolean***REMOVED*** [tts=false] Whether or not the message should be spoken aloud
   * @property ***REMOVED***string***REMOVED*** [nonce=''] The nonce for the message
   * @property ***REMOVED***RichEmbed|Object***REMOVED*** [embed] An embed for the message
   * (see [here](https://discordapp.com/developers/docs/resources/channel#embed-object) for more details)
   * @property ***REMOVED***boolean***REMOVED*** [disableEveryone=this.client.options.disableEveryone] Whether or not @everyone and @here
   * should be replaced with plain-text
   * @property ***REMOVED***FileOptions|BufferResolvable|Attachment***REMOVED*** [file] A file to send with the message **(deprecated)**
   * @property ***REMOVED***FileOptions[]|BufferResolvable[]|Attachment[]***REMOVED*** [files] Files to send with the message
   * @property ***REMOVED***string|boolean***REMOVED*** [code] Language for optional codeblock formatting to apply
   * @property ***REMOVED***boolean|SplitOptions***REMOVED*** [split=false] Whether or not the message should be split into multiple messages if
   * it exceeds the character limit. If an object is provided, these are the options for splitting the message
   * @property ***REMOVED***UserResolvable***REMOVED*** [reply] User to reply to (prefixes the message with a mention, except in DMs)
   */

  /**
   * @typedef ***REMOVED***Object***REMOVED*** FileOptions
   * @property ***REMOVED***BufferResolvable***REMOVED*** attachment File to attach
   * @property ***REMOVED***string***REMOVED*** [name='file.jpg'] Filename of the attachment
   */

  /**
   * Options for splitting a message.
   * @typedef ***REMOVED***Object***REMOVED*** SplitOptions
   * @property ***REMOVED***number***REMOVED*** [maxLength=1950] Maximum character length per message piece
   * @property ***REMOVED***string***REMOVED*** [char='\n'] Character to split the message with
   * @property ***REMOVED***string***REMOVED*** [prepend=''] Text to prepend to every piece except the first
   * @property ***REMOVED***string***REMOVED*** [append=''] Text to append to every piece except the last
   */

  /**
   * Send a message to this channel.
   * @param ***REMOVED***StringResolvable***REMOVED*** [content] Text for the message
   * @param ***REMOVED***MessageOptions|Attachment|RichEmbed***REMOVED*** [options] Options for the message,
   * can also be just a RichEmbed or Attachment
   * @returns ***REMOVED***Promise<Message|Message[]>***REMOVED***
   * @example
   * // Send a basic message
   * channel.send('hello!')
   *   .then(message => console.log(`Sent message: $***REMOVED***message.content***REMOVED***`))
   *   .catch(console.error);
   * @example
   * // Send a remote file
   * channel.send(***REMOVED***
   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']
   * ***REMOVED***)
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Send a local file
   * channel.send(***REMOVED***
   *   files: [***REMOVED***
   *     attachment: 'entire/path/to/file.jpg',
   *     name: 'file.jpg'
   *   ***REMOVED***]
   * ***REMOVED***)
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Send an embed with a local image inside
   * channel.send('This is an embed', ***REMOVED***
   *   embed: ***REMOVED***
   *     thumbnail: ***REMOVED***
   *          url: 'attachment://file.jpg'
   *       ***REMOVED***
   *    ***REMOVED***,
   *    files: [***REMOVED***
   *       attachment: 'entire/path/to/file.jpg',
   *       name: 'file.jpg'
   *    ***REMOVED***]
   * ***REMOVED***)
   *   .then(console.log)
   *   .catch(console.error);
   */
  // eslint-disable-next-line complexity
  send(content, options) ***REMOVED***
    if (!options && typeof content === 'object' && !(content instanceof Array)) ***REMOVED***
      options = content;
      content = '';
    ***REMOVED*** else if (!options) ***REMOVED***
      options = ***REMOVED******REMOVED***;
    ***REMOVED***

    const ***REMOVED*** reply ***REMOVED*** = options;
    if (options instanceof Attachment) options = ***REMOVED*** files: [options.file] ***REMOVED***;
    if (options instanceof RichEmbed) ***REMOVED***
      if (options.reply) options.reply = undefined;
      options = ***REMOVED*** embed: options ***REMOVED***;
    ***REMOVED***
    options.reply = reply;

    if (options.embed) ***REMOVED***
      if (options.embed.file) ***REMOVED***
        if (options.files) options.files.push(options.embed.file);
        else options.files = [options.embed.file];
      ***REMOVED***
      if (options.embed.files) ***REMOVED***
        if (options.files) options.files = options.files.concat(options.embed.files);
        else options.files = options.embed.files;
      ***REMOVED***
    ***REMOVED***

    if (options.file) ***REMOVED***
      if (options.files) options.files.push(options.file);
      else options.files = [options.file];
    ***REMOVED***

    if (options.embed) options.embed = new RichEmbed(options.embed).toJSON();

    if (options.files) ***REMOVED***
      for (let i = 0; i < options.files.length; i++) ***REMOVED***
        let file = options.files[i];
        if (!file || typeof file === 'string' || Buffer.isBuffer(file)) file = ***REMOVED*** attachment: file ***REMOVED***;
        if (!file.name) ***REMOVED***
          if (typeof file.attachment === 'string') ***REMOVED***
            file.name = path.basename(file.attachment);
          ***REMOVED*** else if (file.attachment && file.attachment.path) ***REMOVED***
            file.name = path.basename(file.attachment.path);
          ***REMOVED*** else if (file instanceof Attachment) ***REMOVED***
            file = ***REMOVED*** attachment: file.file, name: path.basename(file.file) || 'file.jpg' ***REMOVED***;
          ***REMOVED*** else ***REMOVED***
            file.name = 'file.jpg';
          ***REMOVED***
        ***REMOVED*** else if (file instanceof Attachment) ***REMOVED***
          file = file.file;
        ***REMOVED***
        options.files[i] = file;
      ***REMOVED***

      return Promise.all(options.files.map(file =>
        this.client.resolver.resolveFile(file.attachment).then(resource => ***REMOVED***
          file.file = resource;
          return file;
        ***REMOVED***)
      )).then(files => this.client.rest.methods.sendMessage(this, content, options, files));
    ***REMOVED***

    return this.client.rest.methods.sendMessage(this, content, options);
  ***REMOVED***

  /**
   * Gets a single message from this channel, regardless of it being cached or not.
   * @param ***REMOVED***Snowflake***REMOVED*** messageID ID of the message to get
   * @returns ***REMOVED***Promise<Message>***REMOVED***
   * @example
   * // Get message
   * channel.fetchMessage('99539446449315840')
   *   .then(message => console.log(message.content))
   *   .catch(console.error);
   */
  fetchMessage(messageID) ***REMOVED***
    if (!this.client.user.bot) ***REMOVED***
      return this.fetchMessages(***REMOVED*** limit: 1, around: messageID ***REMOVED***).then(messages => ***REMOVED***
        const msg = messages.get(messageID);
        if (!msg) throw new Error('Message not found.');
        return msg;
      ***REMOVED***);
    ***REMOVED***
    return this.client.rest.methods.getChannelMessage(this, messageID).then(data => ***REMOVED***
      const msg = data instanceof Message ? data : new Message(this, data, this.client);
      this._cacheMessage(msg);
      return msg;
    ***REMOVED***);
  ***REMOVED***

  /**
   * The parameters to pass in when requesting previous messages from a channel. `around`, `before` and
   * `after` are mutually exclusive. All the parameters are optional.
   * @typedef ***REMOVED***Object***REMOVED*** ChannelLogsQueryOptions
   * @property ***REMOVED***number***REMOVED*** [limit=50] Number of messages to acquire
   * @property ***REMOVED***Snowflake***REMOVED*** [before] ID of a message to get the messages that were posted before it
   * @property ***REMOVED***Snowflake***REMOVED*** [after] ID of a message to get the messages that were posted after it
   * @property ***REMOVED***Snowflake***REMOVED*** [around] ID of a message to get the messages that were posted around it
   */

  /**
   * Gets the past messages sent in this channel. Resolves with a collection mapping message ID's to Message objects.
   * <info>The returned Collection does not contain reaction users of the messages if they were not cached.
   * Those need to be fetched separately in such a case.</info>
   * @param ***REMOVED***ChannelLogsQueryOptions***REMOVED*** [options=***REMOVED******REMOVED***] Query parameters to pass in
   * @returns ***REMOVED***Promise<Collection<Snowflake, Message>>***REMOVED***
   * @example
   * // Get messages
   * channel.fetchMessages(***REMOVED*** limit: 10 ***REMOVED***)
   *   .then(messages => console.log(`Received $***REMOVED***messages.size***REMOVED*** messages`))
   *   .catch(console.error);
   * @example
   * // Get messages and filter by user ID
   * channel.fetchMessages()
   *   .then(messages => console.log(`$***REMOVED***messages.filter(m => m.author.id === '84484653687267328').size***REMOVED*** messages`))
   *   .catch(console.error);
   */
  fetchMessages(options = ***REMOVED******REMOVED***) ***REMOVED***
    return this.client.rest.methods.getChannelMessages(this, options).then(data => ***REMOVED***
      const messages = new Collection();
      for (const message of data) ***REMOVED***
        const msg = new Message(this, message, this.client);
        messages.set(message.id, msg);
        this._cacheMessage(msg);
      ***REMOVED***
      return messages;
    ***REMOVED***);
  ***REMOVED***

  /**
   * Fetches the pinned messages of this channel and returns a collection of them.
   * <info>The returned Collection does not contain any reaction data of the messages.
   * Those need to be fetched separately.</info>
   * @returns ***REMOVED***Promise<Collection<Snowflake, Message>>***REMOVED***
   * @example
   * // Get pinned messages
   * channel.fetchPinnedMessages()
   *   .then(messages => console.log(`Received $***REMOVED***messages.size***REMOVED*** messages`))
   *   .catch(console.error);
   */
  fetchPinnedMessages() ***REMOVED***
    return this.client.rest.methods.getChannelPinnedMessages(this).then(data => ***REMOVED***
      const messages = new Collection();
      for (const message of data) ***REMOVED***
        const msg = new Message(this, message, this.client);
        messages.set(message.id, msg);
        this._cacheMessage(msg);
      ***REMOVED***
      return messages;
    ***REMOVED***);
  ***REMOVED***

  /**
   * @typedef ***REMOVED***Object***REMOVED*** MessageSearchOptions
   * @property ***REMOVED***string***REMOVED*** [content] Message content
   * @property ***REMOVED***Snowflake***REMOVED*** [maxID] Maximum ID for the filter
   * @property ***REMOVED***Snowflake***REMOVED*** [minID] Minimum ID for the filter
   * @property ***REMOVED***string***REMOVED*** [has] One of `link`, `embed`, `file`, `video`, `image`, or `sound`,
   * or add `-` to negate (e.g. `-file`)
   * @property ***REMOVED***ChannelResolvable***REMOVED*** [channel] Channel to limit search to (only for guild search endpoint)
   * @property ***REMOVED***UserResolvable***REMOVED*** [author] Author to limit search
   * @property ***REMOVED***string***REMOVED*** [authorType] One of `user`, `bot`, `webhook`, or add `-` to negate (e.g. `-webhook`)
   * @property ***REMOVED***string***REMOVED*** [sortBy='recent'] `recent` or `relevant`
   * @property ***REMOVED***string***REMOVED*** [sortOrder='desc'] `asc` or `desc`
   * @property ***REMOVED***number***REMOVED*** [contextSize=2] How many messages to get around the matched message (0 to 2)
   * @property ***REMOVED***number***REMOVED*** [limit=25] Maximum number of results to get (1 to 25)
   * @property ***REMOVED***number***REMOVED*** [offset=0] Offset the "pages" of results (since you can only see 25 at a time)
   * @property ***REMOVED***UserResolvable***REMOVED*** [mentions] Mentioned user filter
   * @property ***REMOVED***boolean***REMOVED*** [mentionsEveryone] If everyone is mentioned
   * @property ***REMOVED***string***REMOVED*** [linkHostname] Filter links by hostname
   * @property ***REMOVED***string***REMOVED*** [embedProvider] The name of an embed provider
   * @property ***REMOVED***string***REMOVED*** [embedType] one of `image`, `video`, `url`, `rich`
   * @property ***REMOVED***string***REMOVED*** [attachmentFilename] The name of an attachment
   * @property ***REMOVED***string***REMOVED*** [attachmentExtension] The extension of an attachment
   * @property ***REMOVED***Date***REMOVED*** [before] Date to find messages before
   * @property ***REMOVED***Date***REMOVED*** [after] Date to find messages before
   * @property ***REMOVED***Date***REMOVED*** [during] Date to find messages during (range of date to date + 24 hours)
   * @property ***REMOVED***boolean***REMOVED*** [nsfw=false] Include results from NSFW channels
   */

  /**
   * @typedef ***REMOVED***Object***REMOVED*** MessageSearchResult
   * @property ***REMOVED***number***REMOVED*** totalResults Total result count
   * @property ***REMOVED***Message[][]***REMOVED*** messages Array of message results
   * The message which has triggered the result will have the `hit` property set to `true`
   */

  /**
   * Performs a search within the channel.
   * <warn>This is only available when using a user account.</warn>
   * @param ***REMOVED***MessageSearchOptions***REMOVED*** [options=***REMOVED******REMOVED***] Options to pass to the search
   * @returns ***REMOVED***Promise<MessageSearchResult>***REMOVED***
   * @deprecated
   * @example
   * channel.search(***REMOVED***
   *   content: 'discord.js',
   *   before: '2016-11-17'
   * ***REMOVED***).then(res => ***REMOVED***
   *   const hit = res.messages[0].find(m => m.hit).content;
   *   console.log(`I found: **$***REMOVED***hit***REMOVED*****, total results: $***REMOVED***res.totalResults***REMOVED***`);
   * ***REMOVED***).catch(console.error);
   */
  search(options = ***REMOVED******REMOVED***) ***REMOVED***
    return this.client.rest.methods.search(this, options);
  ***REMOVED***

  /**
   * Starts a typing indicator in the channel.
   * @param ***REMOVED***number***REMOVED*** [count] The number of times startTyping should be considered to have been called
   * @example
   * // Start typing in a channel
   * channel.startTyping();
   */
  startTyping(count) ***REMOVED***
    if (typeof count !== 'undefined' && count < 1) throw new RangeError('Count must be at least 1.');
    if (this.client.user._typing.has(this.id)) ***REMOVED***
      const entry = this.client.user._typing.get(this.id);
      entry.count = count || entry.count + 1;
      return;
    ***REMOVED***

    const entry = ***REMOVED***
      count: count || 1,
      interval: this.client.setInterval(() => ***REMOVED***
        this.client.rest.methods.sendTyping(this.id).catch(() => ***REMOVED***
          this.client.clearInterval(entry.interval);
          this.client.user._typing.delete(this.id);
        ***REMOVED***);
      ***REMOVED***, 9000),
    ***REMOVED***;
    this.client.rest.methods.sendTyping(this.id).catch(() => ***REMOVED***
      this.client.clearInterval(entry.interval);
      this.client.user._typing.delete(this.id);
    ***REMOVED***);
    this.client.user._typing.set(this.id, entry);
  ***REMOVED***

  /**
   * Stops the typing indicator in the channel.
   * The indicator will only stop if this is called as many times as startTyping().
   * <info>It can take a few seconds for the client user to stop typing.</info>
   * @param ***REMOVED***boolean***REMOVED*** [force=false] Whether or not to reset the call count and force the indicator to stop
   * @example
   * // Reduce the typing count by one and stop typing if it reached 0
   * channel.stopTyping();
   * @example
   * // Force typing to fully stop in a channel
   * channel.stopTyping(true);
   */
  stopTyping(force = false) ***REMOVED***
    if (this.client.user._typing.has(this.id)) ***REMOVED***
      const entry = this.client.user._typing.get(this.id);
      entry.count--;
      if (entry.count <= 0 || force) ***REMOVED***
        this.client.clearInterval(entry.interval);
        this.client.user._typing.delete(this.id);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  /**
   * Whether or not the typing indicator is being shown in the channel
   * @type ***REMOVED***boolean***REMOVED***
   * @readonly
   */
  get typing() ***REMOVED***
    return this.client.user._typing.has(this.id);
  ***REMOVED***

  /**
   * Number of times `startTyping` has been called
   * @type ***REMOVED***number***REMOVED***
   * @readonly
   */
  get typingCount() ***REMOVED***
    if (this.client.user._typing.has(this.id)) return this.client.user._typing.get(this.id).count;
    return 0;
  ***REMOVED***

  /**
   * The Message object of the last message in the channel, if one was sent
   * @type ***REMOVED***?Message***REMOVED***
   * @readonly
   */
  get lastMessage() ***REMOVED***
    return this.messages.get(this.lastMessageID) || null;
  ***REMOVED***

  /**
   * The date when the last pinned message was pinned, if there was one
   * @type ***REMOVED***?Date***REMOVED***
   * @readonly
   */
  get lastPinAt() ***REMOVED***
    return this.lastPinTimestamp ? new Date(this.lastPinTimestamp) : null;
  ***REMOVED***

  /**
   * Creates a Message Collector
   * @param ***REMOVED***CollectorFilter***REMOVED*** filter The filter to create the collector with
   * @param ***REMOVED***MessageCollectorOptions***REMOVED*** [options=***REMOVED******REMOVED***] The options to pass to the collector
   * @returns ***REMOVED***MessageCollector***REMOVED***
   * @deprecated
   */
  createCollector(filter, options) ***REMOVED***
    return this.createMessageCollector(filter, options);
  ***REMOVED***

  /**
   * Creates a Message Collector.
   * @param ***REMOVED***CollectorFilter***REMOVED*** filter The filter to create the collector with
   * @param ***REMOVED***MessageCollectorOptions***REMOVED*** [options=***REMOVED******REMOVED***] The options to pass to the collector
   * @returns ***REMOVED***MessageCollector***REMOVED***
   * @example
   * // Create a message collector
   * const filter = m => m.content.includes('discord');
   * const collector = channel.createMessageCollector(filter, ***REMOVED*** time: 15000 ***REMOVED***);
   * collector.on('collect', m => console.log(`Collected $***REMOVED***m.content***REMOVED***`));
   * collector.on('end', collected => console.log(`Collected $***REMOVED***collected.size***REMOVED*** items`));
   */
  createMessageCollector(filter, options = ***REMOVED******REMOVED***) ***REMOVED***
    return new MessageCollector(this, filter, options);
  ***REMOVED***

  /**
   * An object containing the same properties as CollectorOptions, but a few more:
   * @typedef ***REMOVED***MessageCollectorOptions***REMOVED*** AwaitMessagesOptions
   * @property ***REMOVED***string[]***REMOVED*** [errors] Stop/end reasons that cause the promise to reject
   */

  /**
   * Similar to createCollector but in promise form. Resolves with a collection of messages that pass the specified
   * filter.
   * @param ***REMOVED***CollectorFilter***REMOVED*** filter The filter function to use
   * @param ***REMOVED***AwaitMessagesOptions***REMOVED*** [options=***REMOVED******REMOVED***] Optional options to pass to the internal collector
   * @returns ***REMOVED***Promise<Collection<Snowflake, Message>>***REMOVED***
   * @example
   * // Await !vote messages
   * const filter = m => m.content.startsWith('!vote');
   * // Errors: ['time'] treats ending because of the time limit as an error
   * channel.awaitMessages(filter, ***REMOVED*** max: 4, time: 60000, errors: ['time'] ***REMOVED***)
   *   .then(collected => console.log(collected.size))
   *   .catch(collected => console.log(`After a minute, only $***REMOVED***collected.size***REMOVED*** out of 4 voted.`));
   */
  awaitMessages(filter, options = ***REMOVED******REMOVED***) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      const collector = this.createCollector(filter, options);
      collector.once('end', (collection, reason) => ***REMOVED***
        if (options.errors && options.errors.includes(reason)) ***REMOVED***
          reject(collection);
        ***REMOVED*** else ***REMOVED***
          resolve(collection);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Bulk delete given messages that are newer than two weeks.
   * <warn>This is only available when using a bot account.</warn>
   * @param ***REMOVED***Collection<Snowflake, Message>|Message[]|Snowflake[]|number***REMOVED*** messages
   * Messages or number of messages to delete
   * @param ***REMOVED***boolean***REMOVED*** [filterOld=false] Filter messages to remove those which are older than two weeks automatically
   * @returns ***REMOVED***Promise<Collection<Snowflake, Message>>***REMOVED*** Deleted messages
   * @example
   * // Bulk delete messages
   * channel.bulkDelete(5)
   *   .then(messages => console.log(`Bulk deleted $***REMOVED***messages.size***REMOVED*** messages`))
   *   .catch(console.error);
   */
  bulkDelete(messages, filterOld = false) ***REMOVED***
    if (messages instanceof Array || messages instanceof Collection) ***REMOVED***
      let messageIDs = messages instanceof Collection ? messages.keyArray() : messages.map(m => m.id || m);
      if (filterOld) ***REMOVED***
        messageIDs = messageIDs.filter(id => Date.now() - Snowflake.deconstruct(id).date.getTime() < 1209600000);
      ***REMOVED***
      if (messageIDs.length === 0) return Promise.resolve(new Collection());
      if (messageIDs.length === 1) ***REMOVED***
        return this.fetchMessage(messageIDs[0]).then(m => m.delete()).then(m => new Collection([[m.id, m]]));
      ***REMOVED***
      return this.client.rest.methods.bulkDeleteMessages(this, messageIDs);
    ***REMOVED***
    if (!isNaN(messages)) return this.fetchMessages(***REMOVED*** limit: messages ***REMOVED***).then(msgs => this.bulkDelete(msgs, filterOld));
    throw new TypeError('The messages must be an Array, Collection, or number.');
  ***REMOVED***

  /**
   * Marks all messages in this channel as read.
   * <warn>This is only available when using a user account.</warn>
   * @returns ***REMOVED***Promise<TextChannel|GroupDMChannel|DMChannel>***REMOVED***
   * @deprecated
   */
  acknowledge() ***REMOVED***
    if (!this.lastMessageID) return Promise.resolve(this);
    return this.client.rest.methods.ackTextChannel(this);
  ***REMOVED***

  _cacheMessage(message) ***REMOVED***
    const maxSize = this.client.options.messageCacheMaxSize;
    if (maxSize === 0) return null;
    if (this.messages.size >= maxSize && maxSize > 0) this.messages.delete(this.messages.firstKey());
    this.messages.set(message.id, message);
    return message;
  ***REMOVED***
***REMOVED***

/** @lends TextBasedChannel.prototype */
const Deprecated = ***REMOVED***
  /**
   * Send a message to this channel.
   * @param ***REMOVED***StringResolvable***REMOVED*** [content] Text for the message
   * @param ***REMOVED***MessageOptions***REMOVED*** [options=***REMOVED******REMOVED***] Options for the message
   * @returns ***REMOVED***Promise<Message|Message[]>***REMOVED***
   * @deprecated
   * @example
   * // Send a message
   * channel.sendMessage('hello!')
   *  .then(message => console.log(`Sent message: $***REMOVED***message.content***REMOVED***`))
   *  .catch(console.error);
   */
  sendMessage(content, options) ***REMOVED***
    return this.send(content, options);
  ***REMOVED***,

  /**
   * Send an embed to this channel.
   * @param ***REMOVED***RichEmbed|Object***REMOVED*** embed Embed for the message
   * @param ***REMOVED***string***REMOVED*** [content] Text for the message
   * @param ***REMOVED***MessageOptions***REMOVED*** [options] Options for the message
   * @returns ***REMOVED***Promise<Message>***REMOVED***
   * @deprecated
   */
  sendEmbed(embed, content, options) ***REMOVED***
    if (!options && typeof content === 'object' && !(content instanceof Array)) ***REMOVED***
      options = content;
      content = '';
    ***REMOVED*** else if (!options) ***REMOVED***
      options = ***REMOVED******REMOVED***;
    ***REMOVED***
    return this.send(content, Object.assign(options, ***REMOVED*** embed ***REMOVED***));
  ***REMOVED***,

  /**
   * Send files to this channel.
   * @param ***REMOVED***FileOptions[]|string[]***REMOVED*** files Files to send with the message
   * @param ***REMOVED***StringResolvable***REMOVED*** [content] Text for the message
   * @param ***REMOVED***MessageOptions***REMOVED*** [options] Options for the message
   * @returns ***REMOVED***Promise<Message>***REMOVED***
   * @deprecated
   */
  sendFiles(files, content, options = ***REMOVED******REMOVED***) ***REMOVED***
    return this.send(content, Object.assign(options, ***REMOVED*** files ***REMOVED***));
  ***REMOVED***,

  /**
   * Send a file to this channel.
   * @param ***REMOVED***BufferResolvable***REMOVED*** attachment File to send
   * @param ***REMOVED***string***REMOVED*** [name='file.jpg'] Name and extension of the file
   * @param ***REMOVED***StringResolvable***REMOVED*** [content] Text for the message
   * @param ***REMOVED***MessageOptions***REMOVED*** [options] Options for the message
   * @returns ***REMOVED***Promise<Message>***REMOVED***
   * @deprecated
   */
  sendFile(attachment, name, content, options = ***REMOVED******REMOVED***) ***REMOVED***
    return this.send(***REMOVED*** files: [***REMOVED*** attachment, name ***REMOVED***], content, options ***REMOVED***);
  ***REMOVED***,

  /**
   * Send a code block to this channel.
   * @param ***REMOVED***string***REMOVED*** lang Language for the code block
   * @param ***REMOVED***StringResolvable***REMOVED*** content Content of the code block
   * @param ***REMOVED***MessageOptions***REMOVED*** [options] Options for the message
   * @returns ***REMOVED***Promise<Message|Message[]>***REMOVED***
   * @deprecated
   */
  sendCode(lang, content, options = ***REMOVED******REMOVED***) ***REMOVED***
    return this.send(content, Object.assign(options, ***REMOVED*** code: lang ***REMOVED***));
  ***REMOVED***,
***REMOVED***;

for (const key of Object.keys(Deprecated)) ***REMOVED***
  TextBasedChannel.prototype[key] = util.deprecate(Deprecated[key], `TextChannel#$***REMOVED***key***REMOVED***: use TextChannel#send instead`);
***REMOVED***

exports.applyToClass = (structure, full = false, ignore = []) => ***REMOVED***
  const props = ['send', 'sendMessage', 'sendEmbed', 'sendFile', 'sendFiles', 'sendCode'];
  if (full) ***REMOVED***
    props.push(
      '_cacheMessage',
      'acknowledge',
      'fetchMessages',
      'fetchMessage',
      'search',
      'lastMessage',
      'lastPinAt',
      'bulkDelete',
      'startTyping',
      'stopTyping',
      'typing',
      'typingCount',
      'fetchPinnedMessages',
      'createCollector',
      'createMessageCollector',
      'awaitMessages'
    );
  ***REMOVED***
  for (const prop of props) ***REMOVED***
    if (ignore.includes(prop)) continue;
    Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop));
  ***REMOVED***
***REMOVED***;

TextBasedChannel.prototype.acknowledge = util.deprecate(
  TextBasedChannel.prototype.acknowledge, 'TextBasedChannel#acknowledge: userbot methods will be removed'
);

TextBasedChannel.prototype.search =
  util.deprecate(TextBasedChannel.prototype.search, 'TextBasedChannel#search: userbot methods will be removed');
