const Collection = require('../../util/Collection');
const EventEmitter = require('events').EventEmitter;

/**
 * Filter to be applied to the collector.
 * @typedef ***REMOVED***Function***REMOVED*** CollectorFilter
 * @param ***REMOVED***...****REMOVED*** args Any arguments received by the listener
 * @param ***REMOVED***Collection***REMOVED*** collection The items collected by this collector
 * @returns ***REMOVED***boolean***REMOVED***
 */

/**
 * Options to be applied to the collector.
 * @typedef ***REMOVED***Object***REMOVED*** CollectorOptions
 * @property ***REMOVED***number***REMOVED*** [time] How long to run the collector for
 * @property ***REMOVED***number***REMOVED*** [idle] How long to stop the collector after inactivity in milliseconds
 */

/**
 * Abstract class for defining a new Collector.
 * @abstract
 */
class Collector extends EventEmitter ***REMOVED***
  constructor(client, filter, options = ***REMOVED******REMOVED***) ***REMOVED***
    super();

    /**
     * The client
     * @name Collector#client
     * @type ***REMOVED***Client***REMOVED***
     * @readonly
     */
    Object.defineProperty(this, 'client', ***REMOVED*** value: client ***REMOVED***);

    /**
     * The filter applied to this collector
     * @type ***REMOVED***CollectorFilter***REMOVED***
     */
    this.filter = filter;

    /**
     * The options of this collector
     * @type ***REMOVED***CollectorOptions***REMOVED***
     */
    this.options = options;

    /**
     * The items collected by this collector
     * @type ***REMOVED***Collection***REMOVED***
     */
    this.collected = new Collection();

    /**
     * Whether this collector has finished collecting
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.ended = false;

    /**
     * Timeout for cleanup
     * @type ***REMOVED***?Timeout***REMOVED***
     * @private
     */
    this._timeout = null;

    /**
     * Timeout for cleanup due to inactivity
     * @type ***REMOVED***?Timeout***REMOVED***
     * @private
     */
    this._idletimeout = null;

    /**
     * Call this to handle an event as a collectable element
     * Accepts any event data as parameters
     * @type ***REMOVED***Function***REMOVED***
     * @private
     */
    this.listener = this._handle.bind(this);
    if (options.time) this._timeout = this.client.setTimeout(() => this.stop('time'), options.time);
    if (options.idle) this._idletimeout = this.client.setTimeout(() => this.stop('idle'), options.idle);
  ***REMOVED***

  /**
   * @param ***REMOVED***...****REMOVED*** args The arguments emitted by the listener
   * @emits Collector#collect
   * @private
   */
  _handle(...args) ***REMOVED***
    const collect = this.handle(...args);
    if (collect && this.filter(...args, this.collected)) ***REMOVED***
      this.collected.set(collect.key, collect.value);

      /**
       * Emitted whenever an element is collected.
       * @event Collector#collect
       * @param ***REMOVED*******REMOVED*** element The element that got collected
       * @param ***REMOVED***Collector***REMOVED*** collector The collector
       */
      this.emit('collect', collect.value, this);

      /**
       * Emitted whenever an element is collected.
       * @event Collector#fullCollect
       * @param ***REMOVED***...****REMOVED*** args The arguments emitted by the listener
       * @private
       */
      this.emit('fullCollect', ...args, this);

      if (this._idletimeout) ***REMOVED***
        this.client.clearTimeout(this._idletimeout);
        this._idletimeout = this.client.setTimeout(() => this.stop('idle'), this.options.idle);
      ***REMOVED***
    ***REMOVED***

    const post = this.postCheck(...args);
    if (post) this.stop(post);
  ***REMOVED***

  /**
   * Return a promise that resolves with the next collected element;
   * rejects with collected elements if the collector finishes without receiving a next element
   * @type ***REMOVED***Promise***REMOVED***
   * @readonly
   */
  get next() ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      if (this.ended) ***REMOVED***
        reject(this.collected);
        return;
      ***REMOVED***

      const cleanup = () => ***REMOVED***
        this.removeListener('collect', onCollect);
        this.removeListener('end', onEnd);
      ***REMOVED***;

      const onCollect = item => ***REMOVED***
        cleanup();
        resolve(item);
      ***REMOVED***;

      const onEnd = () => ***REMOVED***
        cleanup();
        reject(this.collected); // eslint-disable-line prefer-promise-reject-errors
      ***REMOVED***;

      this.on('collect', onCollect);
      this.on('end', onEnd);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Stop this collector and emit the `end` event.
   * @param ***REMOVED***string***REMOVED*** [reason='user'] The reason this collector is ending
   * @emits Collector#end
   */
  stop(reason = 'user') ***REMOVED***
    if (this.ended) return;

    if (this._timeout) ***REMOVED***
      this.client.clearTimeout(this._timeout);
      this._timeout = null;
    ***REMOVED***
    if (this._idletimeout) ***REMOVED***
      this.client.clearTimeout(this._idletimeout);
      this._idletimeout = null;
    ***REMOVED***
    this.ended = true;
    this.cleanup();

    /**
     * Emitted when the collector is finished collecting.
     * @event Collector#end
     * @param ***REMOVED***Collection***REMOVED*** collected The elements collected by the collector
     * @param ***REMOVED***string***REMOVED*** reason The reason the collector ended
     */
    this.emit('end', this.collected, reason);
  ***REMOVED***

  /* eslint-disable no-empty-function, valid-jsdoc */
  /**
   * Handles incoming events from the `listener` function. Returns null if the event should not be collected,
   * or returns an object describing the data that should be stored.
   * @see Collector#listener
   * @param ***REMOVED***...****REMOVED*** args Any args the event listener emits
   * @returns ***REMOVED***?***REMOVED***key: string, value***REMOVED******REMOVED*** Data to insert into collection, if any
   * @abstract
   */
  handle() ***REMOVED******REMOVED***

  /**
   * This method runs after collection to see if the collector should finish.
   * @param ***REMOVED***...****REMOVED*** args Any args the event listener emits
   * @returns ***REMOVED***?string***REMOVED*** Reason to end the collector, if any
   * @abstract
   */
  postCheck() ***REMOVED******REMOVED***

  /**
   * Called when the collector is ending.
   * @abstract
   */
  cleanup() ***REMOVED******REMOVED***
  /* eslint-enable no-empty-function, valid-jsdoc */
***REMOVED***

module.exports = Collector;
