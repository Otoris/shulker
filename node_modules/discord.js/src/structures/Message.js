const Mentions = require('./MessageMentions');
const Attachment = require('./MessageAttachment');
const Embed = require('./MessageEmbed');
const RichEmbed = require('./RichEmbed');
const MessageReaction = require('./MessageReaction');
const ReactionCollector = require('./ReactionCollector');
const Util = require('../util/Util');
const Collection = require('../util/Collection');
const Constants = require('../util/Constants');
const Permissions = require('../util/Permissions');
const MessageFlags = require('../util/MessageFlags');
let GuildMember;

/**
 * Represents a message on Discord.
 */
class Message ***REMOVED***
  constructor(channel, data, client) ***REMOVED***
    /**
     * The client that instantiated the Message
     * @name Message#client
     * @type ***REMOVED***Client***REMOVED***
     * @readonly
     */
    Object.defineProperty(this, 'client', ***REMOVED*** value: client ***REMOVED***);

    /**
     * The channel that the message was sent in
     * @type ***REMOVED***TextChannel|DMChannel|GroupDMChannel***REMOVED***
     */
    this.channel = channel;

    /**
     * Whether this message has been deleted
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.deleted = false;

    if (data) this.setup(data);
  ***REMOVED***

  setup(data) ***REMOVED*** // eslint-disable-line complexity
    /**
     * The ID of the message
     * @type ***REMOVED***Snowflake***REMOVED***
     */
    this.id = data.id;

    /**
     * The type of the message
     * @type ***REMOVED***MessageType***REMOVED***
     */
    this.type = Constants.MessageTypes[data.type];

    /**
     * The content of the message
     * @type ***REMOVED***string***REMOVED***
     */
    this.content = data.content;

    /**
     * The author of the message
     * @type ***REMOVED***User***REMOVED***
     */
    this.author = this.client.dataManager.newUser(data.author, !data.webhook_id);

    /**
     * Whether or not this message is pinned
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.pinned = data.pinned;

    /**
     * Whether or not the message was Text-To-Speech
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.tts = data.tts;

    /**
     * A random number or string used for checking message delivery
     * <warn>This is only received after the message was sent successfully, and
     * lost if re-fetched</warn>
     * @type ***REMOVED***?string***REMOVED***
     */
    this.nonce = data.nonce;

    /**
     * Whether or not this message was sent by Discord, not actually a user (e.g. pin notifications)
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.system = data.type !== 0;

    /**
     * A list of embeds in the message - e.g. YouTube Player
     * @type ***REMOVED***MessageEmbed[]***REMOVED***
     */
    this.embeds = data.embeds.map(e => new Embed(this, e));

    /**
     * A collection of attachments in the message - e.g. Pictures - mapped by their ID
     * @type ***REMOVED***Collection<Snowflake, MessageAttachment>***REMOVED***
     */
    this.attachments = new Collection();
    for (const attachment of data.attachments) this.attachments.set(attachment.id, new Attachment(this, attachment));

    /**
     * The timestamp the message was sent at
     * @type ***REMOVED***number***REMOVED***
     */
    this.createdTimestamp = new Date(data.timestamp).getTime();

    /**
     * The timestamp the message was last edited at (if applicable)
     * @type ***REMOVED***?number***REMOVED***
     */
    this.editedTimestamp = data.edited_timestamp ? new Date(data.edited_timestamp).getTime() : null;

    /**
     * A collection of reactions to this message, mapped by the reaction ID
     * @type ***REMOVED***Collection<Snowflake, MessageReaction>***REMOVED***
     */
    this.reactions = new Collection();
    if (data.reactions && data.reactions.length > 0) ***REMOVED***
      for (const reaction of data.reactions) ***REMOVED***
        const id = reaction.emoji.id ? `$***REMOVED***reaction.emoji.name***REMOVED***:$***REMOVED***reaction.emoji.id***REMOVED***` : reaction.emoji.name;
        this.reactions.set(id, new MessageReaction(this, reaction.emoji, reaction.count, reaction.me));
      ***REMOVED***
    ***REMOVED***

    /**
     * All valid mentions that the message contains
     * @type ***REMOVED***MessageMentions***REMOVED***
     */
    this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels);

    /**
     * ID of the webhook that sent the message, if applicable
     * @type ***REMOVED***?Snowflake***REMOVED***
     */
    this.webhookID = data.webhook_id || null;

    /**
     * Whether this message is a hit in a search
     * @type ***REMOVED***?boolean***REMOVED***
     */
    this.hit = typeof data.hit === 'boolean' ? data.hit : null;

    /**
     * Flags that are applied to the message
     * @type ***REMOVED***Readonly<MessageFlags>***REMOVED***
     */
    this.flags = new MessageFlags(data.flags).freeze();

    /**
     * Reference data sent in a crossposted message.
     * @typedef ***REMOVED***Object***REMOVED*** MessageReference
     * @property ***REMOVED***string***REMOVED*** channelID ID of the channel the message was crossposted from
     * @property ***REMOVED***?string***REMOVED*** guildID ID of the guild the message was crossposted from
     * @property ***REMOVED***?string***REMOVED*** messageID ID of the message that was crossposted
     */

    /**
     * Message reference data
     * @type ***REMOVED***?MessageReference***REMOVED***
     */
    this.reference = data.message_reference ? ***REMOVED***
      channelID: data.message_reference.channel_id,
      guildID: data.message_reference.guild_id,
      messageID: data.message_reference.message_id,
    ***REMOVED*** : null;

    /**
     * The previous versions of the message, sorted with the most recent first
     * @type ***REMOVED***Message[]***REMOVED***
     * @private
     */
    this._edits = [];

    if (data.member && this.guild && this.author && !this.guild.members.has(this.author.id)) ***REMOVED***
      this.guild._addMember(Object.assign(data.member, ***REMOVED*** user: this.author ***REMOVED***), false);
    ***REMOVED***

    /**
     * Represents the author of the message as a guild member
     * Only available if the message comes from a guild where the author is still a member
     * @type ***REMOVED***?GuildMember***REMOVED***
     */
    this.member = this.guild ? this.guild.member(this.author) || null : null;
  ***REMOVED***

  /**
   * Updates the message.
   * @param ***REMOVED***Object***REMOVED*** data Raw Discord message update data
   * @private
   */
  patch(data) ***REMOVED***
    const clone = Util.cloneObject(this);
    this._edits.unshift(clone);

    if ('edited_timestamp' in data) this.editedTimestamp = new Date(data.edited_timestamp).getTime();
    if ('content' in data) this.content = data.content;
    if ('pinned' in data) this.pinned = data.pinned;
    if ('tts' in data) this.tts = data.tts;
    if ('embeds' in data) this.embeds = data.embeds.map(e => new Embed(this, e));
    else this.embeds = this.embeds.slice();

    if ('attachments' in data) ***REMOVED***
      this.attachments = new Collection();
      for (const attachment of data.attachments) this.attachments.set(attachment.id, new Attachment(this, attachment));
    ***REMOVED*** else ***REMOVED***
      this.attachments = new Collection(this.attachments);
    ***REMOVED***

    this.mentions = new Mentions(
      this,
      'mentions' in data ? data.mentions : this.mentions.users,
      'mentions_roles' in data ? data.mentions_roles : this.mentions.roles,
      'mention_everyone' in data ? data.mention_everyone : this.mentions.everyone,
      'mention_channels' in data ? data.mention_channels : this.mentions.crosspostedChannels
    );

    this.flags = new MessageFlags('flags' in data ? data.flags : 0).freeze();
  ***REMOVED***

  /**
   * The time the message was sent
   * @type ***REMOVED***Date***REMOVED***
   * @readonly
   */
  get createdAt() ***REMOVED***
    return new Date(this.createdTimestamp);
  ***REMOVED***

  /**
   * The time the message was last edited at (if applicable)
   * @type ***REMOVED***?Date***REMOVED***
   * @readonly
   */
  get editedAt() ***REMOVED***
    return this.editedTimestamp ? new Date(this.editedTimestamp) : null;
  ***REMOVED***

  /**
   * The guild the message was sent in (if in a guild channel)
   * @type ***REMOVED***?Guild***REMOVED***
   * @readonly
   */
  get guild() ***REMOVED***
    return this.channel.guild || null;
  ***REMOVED***

  /**
   * The url to jump to the message
   * @type ***REMOVED***string***REMOVED***
   * @readonly
   */
  get url() ***REMOVED***
    return `https://discordapp.com/channels/$***REMOVED***this.guild ? this.guild.id : '@me'***REMOVED***/$***REMOVED***this.channel.id***REMOVED***/$***REMOVED***this.id***REMOVED***`;
  ***REMOVED***

  /**
   * The message contents with all mentions replaced by the equivalent text.
   * If mentions cannot be resolved to a name, the relevant mention in the message content will not be converted.
   * @type ***REMOVED***string***REMOVED***
   * @readonly
   */
  get cleanContent() ***REMOVED***
    return this.content
      .replace(/@(everyone|here)/g, '@\u200b$1')
      .replace(/<@!?[0-9]+>/g, input => ***REMOVED***
        const id = input.replace(/<|!|>|@/g, '');
        if (this.channel.type === 'dm' || this.channel.type === 'group') ***REMOVED***
          return this.client.users.has(id) ? `@$***REMOVED***this.client.users.get(id).username***REMOVED***` : input;
        ***REMOVED***

        const member = this.channel.guild.members.get(id);
        if (member) ***REMOVED***
          if (member.nickname) return `@$***REMOVED***member.nickname***REMOVED***`;
          return `@$***REMOVED***member.user.username***REMOVED***`;
        ***REMOVED*** else ***REMOVED***
          const user = this.client.users.get(id);
          if (user) return `@$***REMOVED***user.username***REMOVED***`;
          return input;
        ***REMOVED***
      ***REMOVED***)
      .replace(/<#[0-9]+>/g, input => ***REMOVED***
        const channel = this.client.channels.get(input.replace(/<|#|>/g, ''));
        if (channel) return `#$***REMOVED***channel.name***REMOVED***`;
        return input;
      ***REMOVED***)
      .replace(/<@&[0-9]+>/g, input => ***REMOVED***
        if (this.channel.type === 'dm' || this.channel.type === 'group') return input;
        const role = this.guild.roles.get(input.replace(/<|@|>|&/g, ''));
        if (role) return `@$***REMOVED***role.name***REMOVED***`;
        return input;
      ***REMOVED***);
  ***REMOVED***

  /**
   * Creates a reaction collector.
   * @param ***REMOVED***CollectorFilter***REMOVED*** filter The filter to apply
   * @param ***REMOVED***ReactionCollectorOptions***REMOVED*** [options=***REMOVED******REMOVED***] Options to send to the collector
   * @returns ***REMOVED***ReactionCollector***REMOVED***
   * @example
   * // Create a reaction collector
   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someID'
   * const collector = message.createReactionCollector(filter, ***REMOVED*** time: 15000 ***REMOVED***);
   * collector.on('collect', r => console.log(`Collected $***REMOVED***r.emoji.name***REMOVED***`));
   * collector.on('end', collected => console.log(`Collected $***REMOVED***collected.size***REMOVED*** items`));
   */
  createReactionCollector(filter, options = ***REMOVED******REMOVED***) ***REMOVED***
    return new ReactionCollector(this, filter, options);
  ***REMOVED***

  /**
   * An object containing the same properties as CollectorOptions, but a few more:
   * @typedef ***REMOVED***ReactionCollectorOptions***REMOVED*** AwaitReactionsOptions
   * @property ***REMOVED***string[]***REMOVED*** [errors] Stop/end reasons that cause the promise to reject
   */

  /**
   * Similar to createMessageCollector but in promise form.
   * Resolves with a collection of reactions that pass the specified filter.
   * @param ***REMOVED***CollectorFilter***REMOVED*** filter The filter function to use
   * @param ***REMOVED***AwaitReactionsOptions***REMOVED*** [options=***REMOVED******REMOVED***] Optional options to pass to the internal collector
   * @returns ***REMOVED***Promise<Collection<string, MessageReaction>>***REMOVED***
   * @example
   * // Create a reaction collector
   * const filter = (reaction, user) => reaction.emoji.name === '👌' && user.id === 'someID'
   * message.awaitReactions(filter, ***REMOVED*** time: 15000 ***REMOVED***)
   *   .then(collected => console.log(`Collected $***REMOVED***collected.size***REMOVED*** reactions`))
   *   .catch(console.error);
   */
  awaitReactions(filter, options = ***REMOVED******REMOVED***) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      const collector = this.createReactionCollector(filter, options);
      collector.once('end', (reactions, reason) => ***REMOVED***
        if (options.errors && options.errors.includes(reason)) reject(reactions);
        else resolve(reactions);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  /**
   * An array of cached versions of the message, including the current version
   * Sorted from latest (first) to oldest (last)
   * @type ***REMOVED***Message[]***REMOVED***
   * @readonly
   */
  get edits() ***REMOVED***
    const copy = this._edits.slice();
    copy.unshift(this);
    return copy;
  ***REMOVED***

  /**
   * Whether the message is editable by the client user
   * @type ***REMOVED***boolean***REMOVED***
   * @readonly
   */
  get editable() ***REMOVED***
    return this.author.id === this.client.user.id;
  ***REMOVED***

  /**
   * Whether the message is deletable by the client user
   * @type ***REMOVED***boolean***REMOVED***
   * @readonly
   */
  get deletable() ***REMOVED***
    return !this.deleted && (this.author.id === this.client.user.id || (this.guild &&
      this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES)
    ));
  ***REMOVED***

  /**
   * Whether the message is pinnable by the client user
   * @type ***REMOVED***boolean***REMOVED***
   * @readonly
   */
  get pinnable() ***REMOVED***
    return this.type === 'DEFAULT' && (!this.guild ||
      this.channel.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_MESSAGES));
  ***REMOVED***

  /**
   * Whether or not a user, channel or role is mentioned in this message.
   * @param ***REMOVED***GuildChannel|User|Role|string***REMOVED*** data Either a guild channel, user or a role object, or a string representing
   * the ID of any of these
   * @returns ***REMOVED***boolean***REMOVED***
   */
  isMentioned(data) ***REMOVED***
    data = data && data.id ? data.id : data;
    return this.mentions.users.has(data) || this.mentions.channels.has(data) || this.mentions.roles.has(data);
  ***REMOVED***

  /**
   * Whether or not a guild member is mentioned in this message. Takes into account
   * user mentions, role mentions, and @everyone/@here mentions.
   * @param ***REMOVED***GuildMember|User***REMOVED*** member The member/user to check for a mention of
   * @returns ***REMOVED***boolean***REMOVED***
   */
  isMemberMentioned(member) ***REMOVED***
    // Lazy-loading is used here to get around a circular dependency that breaks things
    if (!GuildMember) GuildMember = require('./GuildMember');
    if (this.mentions.everyone) return true;
    if (this.mentions.users.has(member.id)) return true;
    if (member instanceof GuildMember && member.roles.some(r => this.mentions.roles.has(r.id))) return true;
    return false;
  ***REMOVED***

  /**
   * Options that can be passed into editMessage.
   * @typedef ***REMOVED***Object***REMOVED*** MessageEditOptions
   * @property ***REMOVED***Object***REMOVED*** [embed] An embed to be added/edited
   * @property ***REMOVED***string|boolean***REMOVED*** [code] Language for optional codeblock formatting to apply
   * @property ***REMOVED***MessageFlagsResolvable***REMOVED*** [flags] Message flags to apply
   */

  /**
   * Edit the content of the message.
   * @param ***REMOVED***StringResolvable***REMOVED*** [content] The new content for the message
   * @param ***REMOVED***MessageEditOptions|RichEmbed***REMOVED*** [options] The options to provide
   * @returns ***REMOVED***Promise<Message>***REMOVED***
   * @example
   * // Update the content of a message
   * message.edit('This is my new content!')
   *   .then(msg => console.log(`New message content: $***REMOVED***msg***REMOVED***`))
   *   .catch(console.error);
   */
  edit(content, options) ***REMOVED***
    if (!options && typeof content === 'object' && !(content instanceof Array)) ***REMOVED***
      options = content;
      content = '';
    ***REMOVED*** else if (!options) ***REMOVED***
      options = ***REMOVED******REMOVED***;
    ***REMOVED***
    if (options instanceof RichEmbed) options = ***REMOVED*** embed: options ***REMOVED***;
    return this.client.rest.methods.updateMessage(this, content, options);
  ***REMOVED***

  /**
   * Edit the content of the message, with a code block.
   * @param ***REMOVED***string***REMOVED*** lang The language for the code block
   * @param ***REMOVED***StringResolvable***REMOVED*** content The new content for the message
   * @returns ***REMOVED***Promise<Message>***REMOVED***
   * @deprecated
   */
  editCode(lang, content) ***REMOVED***
    content = Util.escapeMarkdown(this.client.resolver.resolveString(content), true);
    return this.edit(`\`\`\`$***REMOVED***lang || ''***REMOVED***\n$***REMOVED***content***REMOVED***\n\`\`\``);
  ***REMOVED***

  /**
   * Pins this message to the channel's pinned messages.
   * @returns ***REMOVED***Promise<Message>***REMOVED***
   */
  pin() ***REMOVED***
    return this.client.rest.methods.pinMessage(this);
  ***REMOVED***

  /**
   * Unpins this message from the channel's pinned messages.
   * @returns ***REMOVED***Promise<Message>***REMOVED***
   */
  unpin() ***REMOVED***
    return this.client.rest.methods.unpinMessage(this);
  ***REMOVED***

  /**
   * Add a reaction to the message.
   * @param ***REMOVED***string|Emoji|ReactionEmoji***REMOVED*** emoji The emoji to react with
   * @returns ***REMOVED***Promise<MessageReaction>***REMOVED***
   * @example
   * // React to a message with a unicode emoji
   * message.react('🤔')
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // React to a message with a custom emoji
   * message.react(message.guild.emojis.get('123456789012345678'))
   *   .then(console.log)
   *   .catch(console.error);
   */
  react(emoji) ***REMOVED***
    emoji = this.client.resolver.resolveEmojiIdentifier(emoji);
    if (!emoji) throw new TypeError('Emoji must be a string or Emoji/ReactionEmoji');

    return this.client.rest.methods.addMessageReaction(this, emoji);
  ***REMOVED***

  /**
   * Remove all reactions from a message.
   * @returns ***REMOVED***Promise<Message>***REMOVED***
   */
  clearReactions() ***REMOVED***
    return this.client.rest.methods.removeMessageReactions(this);
  ***REMOVED***

  /**
   * Deletes the message.
   * @param ***REMOVED***number***REMOVED*** [timeout=0] How long to wait to delete the message in milliseconds
   * @returns ***REMOVED***Promise<Message>***REMOVED***
   * @example
   * // Delete a message
   * message.delete()
   *   .then(msg => console.log(`Deleted message from $***REMOVED***msg.author.username***REMOVED***`))
   *   .catch(console.error);
   */
  delete(timeout = 0) ***REMOVED***
    if (timeout <= 0) ***REMOVED***
      return this.client.rest.methods.deleteMessage(this);
    ***REMOVED*** else ***REMOVED***
      return new Promise(resolve => ***REMOVED***
        this.client.setTimeout(() => ***REMOVED***
          resolve(this.delete());
        ***REMOVED***, timeout);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  /**
   * Reply to the message.
   * @param ***REMOVED***StringResolvable***REMOVED*** [content] The content for the message
   * @param ***REMOVED***MessageOptions***REMOVED*** [options] The options to provide
   * @returns ***REMOVED***Promise<Message|Message[]>***REMOVED***
   * @example
   * // Reply to a message
   * message.reply('Hey, I\'m a reply!')
   *   .then(sent => console.log(`Sent a reply to $***REMOVED***sent.author.username***REMOVED***`))
   *   .catch(console.error);
   */
  reply(content, options) ***REMOVED***
    if (!options && typeof content === 'object' && !(content instanceof Array)) ***REMOVED***
      options = content;
      content = '';
    ***REMOVED*** else if (!options) ***REMOVED***
      options = ***REMOVED******REMOVED***;
    ***REMOVED***
    return this.channel.send(content, Object.assign(options, ***REMOVED*** reply: this.member || this.author ***REMOVED***));
  ***REMOVED***

  /**
   * Marks the message as read.
   * <warn>This is only available when using a user account.</warn>
   * @returns ***REMOVED***Promise<Message>***REMOVED***
   * @deprecated
   */
  acknowledge() ***REMOVED***
    return this.client.rest.methods.ackMessage(this);
  ***REMOVED***

  /**
   * Fetches the webhook used to create this message.
   * @returns ***REMOVED***Promise<?Webhook>***REMOVED***
   */
  fetchWebhook() ***REMOVED***
    if (!this.webhookID) return Promise.reject(new Error('The message was not sent by a webhook.'));
    return this.client.fetchWebhook(this.webhookID);
  ***REMOVED***

  /**
   * Suppresses or unsuppresses embeds on a message
   * @param ***REMOVED***boolean***REMOVED*** [suppress=true] If the embeds should be suppressed or not
   * @returns ***REMOVED***Promise<Message>***REMOVED***
   */
  suppressEmbeds(suppress = true) ***REMOVED***
    const flags = new MessageFlags(this.flags.bitfield);

    if (suppress) ***REMOVED***
      flags.add(MessageFlags.FLAGS.SUPPRESS_EMBEDS);
    ***REMOVED*** else ***REMOVED***
      flags.remove(MessageFlags.FLAGS.SUPPRESS_EMBEDS);
    ***REMOVED***

    return this.edit(undefined, ***REMOVED*** flags ***REMOVED***);
  ***REMOVED***

  /**
   * Used mainly internally. Whether two messages are identical in properties. If you want to compare messages
   * without checking all the properties, use `message.id === message2.id`, which is much more efficient. This
   * method allows you to see if there are differences in content, embeds, attachments, nonce and tts properties.
   * @param ***REMOVED***Message***REMOVED*** message The message to compare it to
   * @param ***REMOVED***Object***REMOVED*** rawData Raw data passed through the WebSocket about this message
   * @returns ***REMOVED***boolean***REMOVED***
   */
  equals(message, rawData) ***REMOVED***
    if (!message) return false;
    const embedUpdate = !message.author && !message.attachments;
    if (embedUpdate) return this.id === message.id && this.embeds.length === message.embeds.length;

    let equal = this.id === message.id &&
      this.author.id === message.author.id &&
      this.content === message.content &&
      this.tts === message.tts &&
      this.nonce === message.nonce &&
      this.embeds.length === message.embeds.length &&
      this.attachments.length === message.attachments.length;

    if (equal && rawData) ***REMOVED***
      equal = this.mentions.everyone === message.mentions.everyone &&
        this.createdTimestamp === new Date(rawData.timestamp).getTime() &&
        this.editedTimestamp === new Date(rawData.edited_timestamp).getTime();
    ***REMOVED***

    return equal;
  ***REMOVED***

  /**
   * When concatenated with a string, this automatically concatenates the message's content instead of the object.
   * @returns ***REMOVED***string***REMOVED***
   * @example
   * // Logs: Message: This is a message!
   * console.log(`Message: $***REMOVED***message***REMOVED***`);
   */
  toString() ***REMOVED***
    return this.content;
  ***REMOVED***

  _addReaction(emoji, user) ***REMOVED***
    const emojiID = emoji.id ? `$***REMOVED***emoji.name***REMOVED***:$***REMOVED***emoji.id***REMOVED***` : emoji.name;
    let reaction;
    if (this.reactions.has(emojiID)) ***REMOVED***
      reaction = this.reactions.get(emojiID);
      if (!reaction.me) reaction.me = user.id === this.client.user.id;
    ***REMOVED*** else ***REMOVED***
      reaction = new MessageReaction(this, emoji, 0, user.id === this.client.user.id);
      this.reactions.set(emojiID, reaction);
    ***REMOVED***
    if (!reaction.users.has(user.id)) ***REMOVED***
      reaction.users.set(user.id, user);
      reaction.count++;
    ***REMOVED***
    return reaction;
  ***REMOVED***

  _removeReaction(emoji, user) ***REMOVED***
    const emojiID = emoji.id ? `$***REMOVED***emoji.name***REMOVED***:$***REMOVED***emoji.id***REMOVED***` : emoji.name;
    if (this.reactions.has(emojiID)) ***REMOVED***
      const reaction = this.reactions.get(emojiID);
      if (!user) ***REMOVED***
        this.reactions.delete(emojiID);
        return reaction;
      ***REMOVED***
      if (reaction.users.has(user.id)) ***REMOVED***
        reaction.users.delete(user.id);
        reaction.count--;
        if (user.id === this.client.user.id) reaction.me = false;
        if (reaction.count <= 0) this.reactions.delete(emojiID);
        return reaction;
      ***REMOVED***
    ***REMOVED***
    return null;
  ***REMOVED***

  _clearReactions() ***REMOVED***
    this.reactions.clear();
  ***REMOVED***
***REMOVED***

module.exports = Message;
