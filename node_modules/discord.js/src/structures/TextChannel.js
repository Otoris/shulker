const GuildChannel = require('./GuildChannel');
const TextBasedChannel = require('./interfaces/TextBasedChannel');
const Collection = require('../util/Collection');

/**
 * Represents a guild text channel on Discord.
 * @extends ***REMOVED***GuildChannel***REMOVED***
 * @implements ***REMOVED***TextBasedChannel***REMOVED***
 */
class TextChannel extends GuildChannel ***REMOVED***
  constructor(guild, data) ***REMOVED***
    super(guild, data);
    this.type = 'text';
    /**
     * A collection containing the messages sent to this channel
     * @type ***REMOVED***Collection<Snowflake, Message>***REMOVED***
     */
    this.messages = new Collection();
    this._typing = new Map();
  ***REMOVED***

  setup(data) ***REMOVED***
    super.setup(data);

    /**
     * The topic of the text channel
     * @type ***REMOVED***?string***REMOVED***
     */
    this.topic = data.topic;

    /**
     * If the Discord considers this channel NSFW
     * @type ***REMOVED***boolean***REMOVED***
     * @readonly
     */
    this.nsfw = Boolean(data.nsfw);

    /**
     * The ID of the last message sent in this channel, if one was sent
     * @type ***REMOVED***?Snowflake***REMOVED***
     */
    this.lastMessageID = data.last_message_id;

    /**
     * The timestamp when the last pinned message was pinned, if there was one
     * @type ***REMOVED***?number***REMOVED***
     */
    this.lastPinTimestamp = data.last_pin_timestamp ? new Date(data.last_pin_timestamp).getTime() : null;

    /**
     * The ratelimit per user for this channel in seconds
     * @type ***REMOVED***number***REMOVED***
     */
    this.rateLimitPerUser = data.rate_limit_per_user || 0;
  ***REMOVED***

  /**
   * A collection of members that can see this channel, mapped by their ID
   * @type ***REMOVED***Collection<Snowflake, GuildMember>***REMOVED***
   * @readonly
   */
  get members() ***REMOVED***
    const members = new Collection();
    for (const member of this.guild.members.values()) ***REMOVED***
      if (this.permissionsFor(member).has('READ_MESSAGES')) ***REMOVED***
        members.set(member.id, member);
      ***REMOVED***
    ***REMOVED***
    return members;
  ***REMOVED***

  /**
   * Fetch all webhooks for the channel.
   * @returns ***REMOVED***Promise<Collection<Snowflake, Webhook>>***REMOVED***
   * @example
   * // Fetch webhooks
   * channel.fetchWebhooks()
   *   .then(hooks => console.log(`This channel has $***REMOVED***hooks.size***REMOVED*** hooks`))
   *   .catch(console.error);
   */
  fetchWebhooks() ***REMOVED***
    return this.client.rest.methods.getChannelWebhooks(this);
  ***REMOVED***

  /**
   * Sets whether this channel is flagged as NSFW.
   * @param ***REMOVED***boolean***REMOVED*** nsfw Whether the channel should be considered NSFW
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the channel's NSFW flag
   * @returns ***REMOVED***Promise<TextChannel>***REMOVED***
   */
  setNSFW(nsfw, reason) ***REMOVED***
    return this.edit(***REMOVED*** nsfw ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Create a webhook for the channel.
   * @param ***REMOVED***string***REMOVED*** name The name of the webhook
   * @param ***REMOVED***BufferResolvable|Base64Resolvable***REMOVED*** [avatar] The avatar for the webhook
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for creating this webhook
   * @returns ***REMOVED***Promise<Webhook>***REMOVED*** webhook The created webhook
   * @example
   * channel.createWebhook('Snek', 'https://i.imgur.com/mI8XcpG.jpg')
   *   .then(webhook => console.log(`Created webhook $***REMOVED***webhook***REMOVED***`))
   *   .catch(console.error)
   */
  createWebhook(name, avatar, reason) ***REMOVED***
    if (typeof avatar === 'string' && avatar.startsWith('data:')) ***REMOVED***
      return this.client.rest.methods.createWebhook(this, name, avatar, reason);
    ***REMOVED*** else ***REMOVED***
      return this.client.resolver.resolveImage(avatar).then(data =>
        this.client.rest.methods.createWebhook(this, name, data, reason)
      );
    ***REMOVED***
  ***REMOVED***

  /**
   * Sets the rate limit per user for this channel.
   * @param ***REMOVED***number***REMOVED*** rateLimitPerUser The new ratelimit in seconds
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the channel's ratelimits
   * @returns ***REMOVED***Promise<TextChannel>***REMOVED***
   */
  setRateLimitPerUser(rateLimitPerUser, reason) ***REMOVED***
    return this.edit(***REMOVED*** rateLimitPerUser ***REMOVED***, reason);
  ***REMOVED***

  // These are here only for documentation purposes - they are implemented by TextBasedChannel
  /* eslint-disable no-empty-function */
  get lastMessage() ***REMOVED******REMOVED***
  get lastPinAt() ***REMOVED******REMOVED***
  send() ***REMOVED*** ***REMOVED***
  sendMessage() ***REMOVED*** ***REMOVED***
  sendEmbed() ***REMOVED*** ***REMOVED***
  sendFile() ***REMOVED*** ***REMOVED***
  sendFiles() ***REMOVED*** ***REMOVED***
  sendCode() ***REMOVED*** ***REMOVED***
  fetchMessage() ***REMOVED*** ***REMOVED***
  fetchMessages() ***REMOVED*** ***REMOVED***
  fetchPinnedMessages() ***REMOVED*** ***REMOVED***
  search() ***REMOVED*** ***REMOVED***
  startTyping() ***REMOVED*** ***REMOVED***
  stopTyping() ***REMOVED*** ***REMOVED***
  get typing() ***REMOVED*** ***REMOVED***
  get typingCount() ***REMOVED*** ***REMOVED***
  createCollector() ***REMOVED*** ***REMOVED***
  createMessageCollector() ***REMOVED*** ***REMOVED***
  awaitMessages() ***REMOVED*** ***REMOVED***
  bulkDelete() ***REMOVED*** ***REMOVED***
  acknowledge() ***REMOVED*** ***REMOVED***
  _cacheMessage() ***REMOVED*** ***REMOVED***
***REMOVED***

TextBasedChannel.applyToClass(TextChannel, true);

module.exports = TextChannel;
