const User = require('./User');
const Collection = require('../util/Collection');
const ClientUserSettings = require('./ClientUserSettings');
const ClientUserGuildSettings = require('./ClientUserGuildSettings');
const Constants = require('../util/Constants');
const util = require('util');

/**
 * Represents the logged in client's Discord user.
 * @extends ***REMOVED***User***REMOVED***
 */
class ClientUser extends User ***REMOVED***
  setup(data) ***REMOVED***
    super.setup(data);

    /**
     * Whether or not this account has been verified
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.verified = data.verified;

    /**
     * The email of this account
     * <warn>This is only filled when using a user account.</warn>
     * @type ***REMOVED***?string***REMOVED***
     * @deprecated
     */
    this.email = data.email;
    this.localPresence = ***REMOVED******REMOVED***;
    this._typing = new Map();

    /**
     * A Collection of friends for the logged in user
     * <warn>This is only filled when using a user account.</warn>
     * @type ***REMOVED***Collection<Snowflake, User>***REMOVED***
     * @deprecated
     */
    this.friends = new Collection();

    /**
     * A Collection of blocked users for the logged in user
     * <warn>This is only filled when using a user account.</warn>
     * @type ***REMOVED***Collection<Snowflake, User>***REMOVED***
     * @deprecated
     */
    this.blocked = new Collection();

    /**
     * A Collection of notes for the logged in user
     * <warn>This is only filled when using a user account.</warn>
     * @type ***REMOVED***Collection<Snowflake, string>***REMOVED***
     * @deprecated
     */
    this.notes = new Collection();

    /**
     * If the user has Discord premium (nitro)
     * <warn>This is only filled when using a user account.</warn>
     * @type ***REMOVED***?boolean***REMOVED***
     * @deprecated
     */
    this.premium = typeof data.premium === 'boolean' ? data.premium : null;

    /**
     * If the user has MFA enabled on their account
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.mfaEnabled = data.mfa_enabled;

    /**
     * If the user has ever used a mobile device on Discord
     * <warn>This is only filled when using a user account.</warn>
     * @type ***REMOVED***?boolean***REMOVED***
     * @deprecated
     */
    this.mobile = typeof data.mobile === 'boolean' ? data.mobile : null;

    /**
     * Various settings for this user
     * <warn>This is only filled when using a user account.</warn>
     * @type ***REMOVED***?ClientUserSettings***REMOVED***
     * @deprecated
     */
    this.settings = data.user_settings ? new ClientUserSettings(this, data.user_settings) : null;

    /**
     * All of the user's guild settings
     * <warn>This is only filled when using a user account</warn>
     * @type ***REMOVED***Collection<Snowflake, ClientUserGuildSettings>***REMOVED***
     * @deprecated
     */
    this.guildSettings = new Collection();
    if (data.user_guild_settings) ***REMOVED***
      for (const settings of data.user_guild_settings) ***REMOVED***
        this.guildSettings.set(settings.guild_id, new ClientUserGuildSettings(settings, this.client));
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  edit(data) ***REMOVED***
    return this.client.rest.methods.updateCurrentUser(data);
  ***REMOVED***

  /**
   * Set the username of the logged in client.
   * <info>Changing usernames in Discord is heavily rate limited, with only 2 requests
   * every hour. Use this sparingly!</info>
   * @param ***REMOVED***string***REMOVED*** username The new username
   * @param ***REMOVED***string***REMOVED*** [password] Current password (only for user accounts)
   * @returns ***REMOVED***Promise<ClientUser>***REMOVED***
   * @example
   * // Set username
   * client.user.setUsername('discordjs')
   *   .then(user => console.log(`My new username is $***REMOVED***user.username***REMOVED***`))
   *   .catch(console.error);
   */
  setUsername(username, password) ***REMOVED***
    return this.client.rest.methods.updateCurrentUser(***REMOVED*** username ***REMOVED***, password);
  ***REMOVED***

  /**
   * Changes the email for the client user's account.
   * <warn>This is only available when using a user account.</warn>
   * @param ***REMOVED***string***REMOVED*** email New email to change to
   * @param ***REMOVED***string***REMOVED*** password Current password
   * @returns ***REMOVED***Promise<ClientUser>***REMOVED***
   * @deprecated
   * @example
   * // Set email
   * client.user.setEmail('bob@gmail.com', 'some amazing password 123')
   *   .then(user => console.log(`My new email is $***REMOVED***user.email***REMOVED***`))
   *   .catch(console.error);
   */
  setEmail(email, password) ***REMOVED***
    return this.client.rest.methods.updateCurrentUser(***REMOVED*** email ***REMOVED***, password);
  ***REMOVED***

  /**
   * Changes the password for the client user's account.
   * <warn>This is only available when using a user account.</warn>
   * @param ***REMOVED***string***REMOVED*** newPassword New password to change to
   * @param ***REMOVED***string***REMOVED*** oldPassword Current password
   * @returns ***REMOVED***Promise<ClientUser>***REMOVED***
   * @deprecated
   * @example
   * // Set password
   * client.user.setPassword('some new amazing password 456', 'some amazing password 123')
   *   .then(user => console.log('New password set!'))
   *   .catch(console.error);
   */
  setPassword(newPassword, oldPassword) ***REMOVED***
    return this.client.rest.methods.updateCurrentUser(***REMOVED*** password: newPassword ***REMOVED***, oldPassword);
  ***REMOVED***

  /**
   * Set the avatar of the logged in client.
   * @param ***REMOVED***BufferResolvable|Base64Resolvable***REMOVED*** avatar The new avatar
   * @returns ***REMOVED***Promise<ClientUser>***REMOVED***
   * @example
   * // Set avatar
   * client.user.setAvatar('./avatar.png')
   *   .then(user => console.log(`New avatar set!`))
   *   .catch(console.error);
   */
  setAvatar(avatar) ***REMOVED***
    return this.client.resolver.resolveImage(avatar).then(data =>
      this.client.rest.methods.updateCurrentUser(***REMOVED*** avatar: data ***REMOVED***)
    );
  ***REMOVED***

  /**
   * Data resembling a raw Discord presence.
   * @typedef ***REMOVED***Object***REMOVED*** PresenceData
   * @property ***REMOVED***PresenceStatus***REMOVED*** [status] Status of the user
   * @property ***REMOVED***boolean***REMOVED*** [afk] Whether the user is AFK
   * @property ***REMOVED***Object***REMOVED*** [game] Game the user is playing
   * @property ***REMOVED***string***REMOVED*** [game.name] Name of the game
   * @property ***REMOVED***string***REMOVED*** [game.url] Twitch stream URL
   * @property ***REMOVED***?ActivityType|number***REMOVED*** [game.type] Type of the activity
   */

  /**
   * Sets the full presence of the client user.
   * @param ***REMOVED***PresenceData***REMOVED*** data Data for the presence
   * @returns ***REMOVED***Promise<ClientUser>***REMOVED***
   * @example
   * // Set the client user's presence
   * client.user.setPresence(***REMOVED*** game: ***REMOVED*** name: 'with discord.js' ***REMOVED***, status: 'idle' ***REMOVED***)
   *   .then(console.log)
   *   .catch(console.error);
   */
  setPresence(data) ***REMOVED***
    // ***REMOVED***"op":3,"d":***REMOVED***"status":"dnd","since":0,"game":null,"afk":false***REMOVED******REMOVED***
    return new Promise(resolve => ***REMOVED***
      let status = this.localPresence.status || this.presence.status;
      let game = this.localPresence.game;
      let afk = this.localPresence.afk || this.presence.afk;

      if (!game && this.presence.game) ***REMOVED***
        game = ***REMOVED***
          name: this.presence.game.name,
          type: this.presence.game.type,
          url: this.presence.game.url,
        ***REMOVED***;
      ***REMOVED***

      if (data.status) ***REMOVED***
        if (typeof data.status !== 'string') throw new TypeError('Status must be a string');
        if (this.bot) ***REMOVED***
          status = data.status;
        ***REMOVED*** else ***REMOVED***
          this.settings.update(Constants.UserSettingsMap.status, data.status);
          status = 'invisible';
        ***REMOVED***
      ***REMOVED***

      if (data.game) ***REMOVED***
        game = data.game;
        game.type = game.url && typeof game.type === 'undefined' ? 1 : game.type || 0;
        if (typeof game.type === 'string') ***REMOVED***
          game.type = Constants.ActivityTypes.indexOf(game.type.toUpperCase());
        ***REMOVED***
      ***REMOVED*** else if (typeof data.game !== 'undefined') ***REMOVED***
        game = null;
      ***REMOVED***

      if (typeof data.afk !== 'undefined') afk = data.afk;
      afk = Boolean(afk);

      this.localPresence = ***REMOVED*** status, game, afk ***REMOVED***;
      this.localPresence.since = 0;
      this.localPresence.game = this.localPresence.game || null;

      this.client.ws.send(***REMOVED***
        op: 3,
        d: this.localPresence,
      ***REMOVED***);

      this.client._setPresence(this.id, this.localPresence);

      resolve(this);
    ***REMOVED***);
  ***REMOVED***

  /**
   * A user's status. Must be one of:
   * * `online`
   * * `idle`
   * * `invisible`
   * * `dnd` (do not disturb)
   * @typedef ***REMOVED***string***REMOVED*** PresenceStatus
   */

  /**
   * Sets the status of the client user.
   * @param ***REMOVED***PresenceStatus***REMOVED*** status Status to change to
   * @returns ***REMOVED***Promise<ClientUser>***REMOVED***
   * @example
   * // Set the client user's status
   * client.user.setStatus('idle')
   *   .then(console.log)
   *   .catch(console.error);
   */
  setStatus(status) ***REMOVED***
    return this.setPresence(***REMOVED*** status ***REMOVED***);
  ***REMOVED***

  /**
   * Sets the game the client user is playing.
   * @param ***REMOVED***?string***REMOVED*** game Game being played
   * @param ***REMOVED***?string***REMOVED*** [streamingURL] Twitch stream URL
   * @returns ***REMOVED***Promise<ClientUser>***REMOVED***
   * @deprecated
   */
  setGame(game, streamingURL) ***REMOVED***
    if (!game) return this.setPresence(***REMOVED*** game: null ***REMOVED***);
    return this.setPresence(***REMOVED***
      game: ***REMOVED***
        name: game,
        url: streamingURL,
      ***REMOVED***,
    ***REMOVED***);
  ***REMOVED***

  /**
   * Sets the activity the client user is playing.
   * @param ***REMOVED***?string***REMOVED*** name Activity being played
   * @param ***REMOVED***Object***REMOVED*** [options] Options for setting the activity
   * @param ***REMOVED***string***REMOVED*** [options.url] Twitch stream URL
   * @param ***REMOVED***ActivityType|number***REMOVED*** [options.type] Type of the activity
   * @returns ***REMOVED***Promise<Presence>***REMOVED***
   * @example
   * client.user.setActivity('YouTube', ***REMOVED*** type: 'WATCHING' ***REMOVED***)
   *   .then(presence => console.log(`Activity set to $***REMOVED***presence.game ? presence.game.name : 'none'***REMOVED***`))
   *   .catch(console.error);
   */
  setActivity(name, ***REMOVED*** url, type ***REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
    if (!name) return this.setPresence(***REMOVED*** game: null ***REMOVED***);
    return this.setPresence(***REMOVED***
      game: ***REMOVED*** name, type, url ***REMOVED***,
    ***REMOVED***).then(clientUser => clientUser.presence);
  ***REMOVED***

  /**
   * Sets/removes the AFK flag for the client user.
   * @param ***REMOVED***boolean***REMOVED*** afk Whether or not the user is AFK
   * @returns ***REMOVED***Promise<ClientUser>***REMOVED***
   */
  setAFK(afk) ***REMOVED***
    return this.setPresence(***REMOVED*** afk ***REMOVED***);
  ***REMOVED***

  /**
   * Fetches messages that mentioned the client's user.
   * <warn>This is only available when using a user account.</warn>
   * @param ***REMOVED***Object***REMOVED*** [options] Options for the fetch
   * @param ***REMOVED***number***REMOVED*** [options.limit=25] Maximum number of mentions to retrieve
   * @param ***REMOVED***boolean***REMOVED*** [options.roles=true] Whether to include role mentions
   * @param ***REMOVED***boolean***REMOVED*** [options.everyone=true] Whether to include everyone/here mentions
   * @param ***REMOVED***GuildResolvable***REMOVED*** [options.guild] Limit the search to a specific guild
   * @returns ***REMOVED***Promise<Message[]>***REMOVED***
   * @deprecated
   * @example
   * // Fetch mentions
   * client.user.fetchMentions()
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Fetch mentions from a guild
   * client.user.fetchMentions(***REMOVED*** guild: '222078108977594368' ***REMOVED***)
   *   .then(console.log)
   *   .catch(console.error);
   */
  fetchMentions(options = ***REMOVED******REMOVED***) ***REMOVED***
    return this.client.rest.methods.fetchMentions(options);
  ***REMOVED***

  /**
   * Send a friend request.
   * <warn>This is only available when using a user account.</warn>
   * @param ***REMOVED***UserResolvable***REMOVED*** user The user to send the friend request to
   * @returns ***REMOVED***Promise<User>***REMOVED*** The user the friend request was sent to
   * @deprecated
   */
  addFriend(user) ***REMOVED***
    user = this.client.resolver.resolveUser(user);
    return this.client.rest.methods.addFriend(user);
  ***REMOVED***

  /**
   * Remove a friend.
   * <warn>This is only available when using a user account.</warn>
   * @param ***REMOVED***UserResolvable***REMOVED*** user The user to remove from your friends
   * @returns ***REMOVED***Promise<User>***REMOVED*** The user that was removed
   * @deprecated
   */
  removeFriend(user) ***REMOVED***
    user = this.client.resolver.resolveUser(user);
    return this.client.rest.methods.removeFriend(user);
  ***REMOVED***

  /**
   * Creates a guild.
   * <warn>This is only available to bots in less than 10 guilds and user accounts.</warn>
   * @param ***REMOVED***string***REMOVED*** name The name of the guild
   * @param ***REMOVED***string***REMOVED*** [region] The region for the server
   * @param ***REMOVED***BufferResolvable|Base64Resolvable***REMOVED*** [icon=null] The icon for the guild
   * @returns ***REMOVED***Promise<Guild>***REMOVED*** The guild that was created
   */
  createGuild(name, region, icon = null) ***REMOVED***
    if (typeof icon === 'string' && icon.startsWith('data:')) ***REMOVED***
      return this.client.rest.methods.createGuild(***REMOVED*** name, icon, region ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      return this.client.resolver.resolveImage(icon).then(data =>
        this.client.rest.methods.createGuild(***REMOVED*** name, icon: data, region ***REMOVED***)
      );
    ***REMOVED***
  ***REMOVED***

  /**
   * An object containing either a user or access token, and an optional nickname.
   * @typedef ***REMOVED***Object***REMOVED*** GroupDMRecipientOptions
   * @property ***REMOVED***UserResolvable|Snowflake***REMOVED*** [user] User to add to the Group DM
   * (only available if a user is creating the DM)
   * @property ***REMOVED***string***REMOVED*** [accessToken] Access token to use to add a user to the Group DM
   * (only available if a bot is creating the DM)
   * @property ***REMOVED***string***REMOVED*** [nick] Permanent nickname (only available if a bot is creating the DM)
   */

  /**
   * Creates a Group DM.
   * @param ***REMOVED***GroupDMRecipientOptions[]***REMOVED*** recipients The recipients
   * @returns ***REMOVED***Promise<GroupDMChannel>***REMOVED***
   * @example
   * // Create a Group DM with a token provided from OAuth
   * client.user.createGroupDM([***REMOVED***
   *   user: '66564597481480192',
   *   accessToken: token
   * ***REMOVED***])
   *   .then(console.log)
   *   .catch(console.error);
   */
  createGroupDM(recipients) ***REMOVED***
    return this.client.rest.methods.createGroupDM(***REMOVED***
      recipients: recipients.map(u => this.client.resolver.resolveUserID(u.user)),
      accessTokens: recipients.map(u => u.accessToken),
      nicks: recipients.reduce((o, r) => ***REMOVED***
        if (r.nick) o[r.user ? r.user.id : r.id] = r.nick;
        return o;
      ***REMOVED***, ***REMOVED******REMOVED***),
    ***REMOVED***);
  ***REMOVED***

  /**
   * Accepts an invite to join a guild.
   * <warn>This is only available when using a user account.</warn>
   * @param ***REMOVED***Invite|string***REMOVED*** invite Invite or code to accept
   * @returns ***REMOVED***Promise<Guild>***REMOVED*** Joined guild
   * @deprecated
   */
  acceptInvite(invite) ***REMOVED***
    return this.client.rest.methods.acceptInvite(invite);
  ***REMOVED***
***REMOVED***

ClientUser.prototype.acceptInvite =
  util.deprecate(ClientUser.prototype.acceptInvite, 'ClientUser#acceptInvite: userbot methods will be removed');

ClientUser.prototype.setGame =
  util.deprecate(ClientUser.prototype.setGame, 'ClientUser#setGame: use ClientUser#setActivity instead');

ClientUser.prototype.addFriend =
  util.deprecate(ClientUser.prototype.addFriend, 'ClientUser#addFriend: userbot methods will be removed');

ClientUser.prototype.removeFriend =
  util.deprecate(ClientUser.prototype.removeFriend, 'ClientUser#removeFriend: userbot methods will be removed');

ClientUser.prototype.setPassword =
  util.deprecate(ClientUser.prototype.setPassword, 'ClientUser#setPassword: userbot methods will be removed');

ClientUser.prototype.setEmail =
  util.deprecate(ClientUser.prototype.setEmail, 'ClientUser#setEmail: userbot methods will be removed');

ClientUser.prototype.fetchMentions =
  util.deprecate(ClientUser.prototype.fetchMentions, 'ClientUser#fetchMentions: userbot methods will be removed');

module.exports = ClientUser;
