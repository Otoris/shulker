const EventEmitter = require('events');
const path = require('path');
const Util = require('../util/Util');
const Attachment = require('./Attachment');
const RichEmbed = require('./RichEmbed');
const Constants = require('../util/Constants');
const Snowflake = require('../util/Snowflake');

/**
 * Represents a webhook.
 */
class Webhook extends EventEmitter ***REMOVED***
  constructor(client, dataOrID, token) ***REMOVED***
    super();
    if (client) ***REMOVED***
      /**
       * The client that instantiated the webhook
       * @name Webhook#client
       * @type ***REMOVED***Client***REMOVED***
       * @readonly
       */
      Object.defineProperty(this, 'client', ***REMOVED*** value: client ***REMOVED***);
      if (dataOrID) this.setup(dataOrID);
    ***REMOVED*** else ***REMOVED***
      this.id = dataOrID;
      this.token = token;
      Object.defineProperty(this, 'client', ***REMOVED*** value: this ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  setup(data) ***REMOVED***
    /**
     * The name of the webhook
     * @type ***REMOVED***string***REMOVED***
     */
    this.name = data.name;

    /**
     * The token for the webhook
     * @name Webhook#token
     * @type ***REMOVED***?string***REMOVED***
     */
    Object.defineProperty(this, 'token', ***REMOVED*** value: data.token || null, writable: true, configurable: true ***REMOVED***);

    /**
     * The avatar for the webhook
     * @type ***REMOVED***?string***REMOVED***
     */
    this.avatar = data.avatar;

    /**
     * The ID of the webhook
     * @type ***REMOVED***Snowflake***REMOVED***
     */
    this.id = data.id;

    /**
     * The type of the webhook
     * @type ***REMOVED***WebhookTypes***REMOVED***
     */
    this.type = Constants.WebhookTypes[data.type];

    /**
     * The guild the webhook belongs to
     * @type ***REMOVED***Snowflake***REMOVED***
     */
    this.guildID = data.guild_id;

    /**
     * The channel the webhook belongs to
     * @type ***REMOVED***Snowflake***REMOVED***
     */
    this.channelID = data.channel_id;

    if (data.user) ***REMOVED***
      /**
       * The owner of the webhook
       * @type ***REMOVED***?User|Object***REMOVED***
       */
      this.owner = this.client.users ? this.client.users.get(data.user.id) : data.user;
    ***REMOVED*** else ***REMOVED***
      this.owner = null;
    ***REMOVED***
  ***REMOVED***

  /**
   * The timestamp the webhook was created at
   * @type ***REMOVED***number***REMOVED***
   * @readonly
   */
  get createdTimestamp() ***REMOVED***
    return Snowflake.deconstruct(this.id).timestamp;
  ***REMOVED***

  /**
   * The time the webhook was created at
   * @type ***REMOVED***Date***REMOVED***
   * @readonly
   */
  get createdAt() ***REMOVED***
    return new Date(this.createdTimestamp);
  ***REMOVED***

  /**
   * A link to the webhook user's avatar
   * @type ***REMOVED***?stirng***REMOVED***
   * @readonly
   */
  get avatarURL() ***REMOVED***
    if (!this.avatar) return null;
    return Constants.Endpoints.CDN(this.client.options.http.cdn).Avatar(this.id, this.avatar);
  ***REMOVED***

  /**
   * The url of this webhook
   * @type ***REMOVED***string***REMOVED***
   * @readonly
   */
  get url() ***REMOVED***
    const API = `$***REMOVED***this.client.options.http.host***REMOVED***/api/v$***REMOVED***this.client.options.http.version***REMOVED***`;
    return API + Constants.Endpoints.Webhook(this.id, this.token);
  ***REMOVED***

  /**
   * Options that can be passed into send, sendMessage, sendFile, sendEmbed, and sendCode.
   * @typedef ***REMOVED***Object***REMOVED*** WebhookMessageOptions
   * @property ***REMOVED***string***REMOVED*** [username=this.name] Username override for the message
   * @property ***REMOVED***string***REMOVED*** [avatarURL] Avatar URL override for the message
   * @property ***REMOVED***boolean***REMOVED*** [tts=false] Whether or not the message should be spoken aloud
   * @property ***REMOVED***string***REMOVED*** [nonce=''] The nonce for the message
   * @property ***REMOVED***Array<RichEmbed|Object>***REMOVED*** [embeds] An array of embeds for the message
   * (see [here](https://discordapp.com/developers/docs/resources/channel#embed-object) for more details)
   * @property ***REMOVED***boolean***REMOVED*** [disableEveryone=this.client.options.disableEveryone] Whether or not @everyone and @here
   * should be replaced with plain-text
   * @property ***REMOVED***FileOptions|BufferResolvable|Attachment***REMOVED*** [file] A file to send with the message **(deprecated)**
   * @property ***REMOVED***FileOptions[]|BufferResolvable[]|Attachment[]***REMOVED*** [files] Files to send with the message
   * @property ***REMOVED***string|boolean***REMOVED*** [code] Language for optional codeblock formatting to apply
   * @property ***REMOVED***boolean|SplitOptions***REMOVED*** [split=false] Whether or not the message should be split into multiple messages if
   * it exceeds the character limit. If an object is provided, these are the options for splitting the message.
   */

  /**
   * Send a message with this webhook.
   * @param ***REMOVED***StringResolvable***REMOVED*** content The content to send
   * @param ***REMOVED***WebhookMessageOptions|Attachment|RichEmbed***REMOVED*** [options] The options to provide,
   * can also be just a RichEmbed or Attachment
   * @returns ***REMOVED***Promise<Message|Message[]|Object|Object[]>***REMOVED***
   * @example
   * // Send a basic message
   * webhook.send('hello!')
   *   .then(message => console.log(`Sent message: $***REMOVED***message.content***REMOVED***`))
   *   .catch(console.error);
   * @example
   * // Send a remote file
   * webhook.send(***REMOVED***
   *   files: ['https://cdn.discordapp.com/icons/222078108977594368/6e1019b3179d71046e463a75915e7244.png?size=2048']
   * ***REMOVED***)
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Send a local file
   * webhook.send(***REMOVED***
   *   files: [***REMOVED***
   *     attachment: 'entire/path/to/file.jpg',
   *     name: 'file.jpg'
   *   ***REMOVED***]
   * ***REMOVED***)
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Send an embed with a local image inside
   * webhook.send('This is an embed', ***REMOVED***
   *   embeds: [***REMOVED***
   *     thumbnail: ***REMOVED***
   *          url: 'attachment://file.jpg'
   *       ***REMOVED***
   *    ***REMOVED***],
   *    files: [***REMOVED***
   *       attachment: 'entire/path/to/file.jpg',
   *       name: 'file.jpg'
   *    ***REMOVED***]
   * ***REMOVED***)
   *   .then(console.log)
   *   .catch(console.error);
   */
  send(content, options) ***REMOVED*** // eslint-disable-line complexity
    if (!options && typeof content === 'object' && !(content instanceof Array)) ***REMOVED***
      options = content;
      content = '';
    ***REMOVED*** else if (!options) ***REMOVED***
      options = ***REMOVED******REMOVED***;
    ***REMOVED***

    if (options instanceof Attachment) options = ***REMOVED*** files: [options] ***REMOVED***;
    if (options instanceof RichEmbed) options = ***REMOVED*** embeds: [options] ***REMOVED***;

    if (content) ***REMOVED***
      content = this.client.resolver.resolveString(content);
      let ***REMOVED*** split, code, disableEveryone ***REMOVED*** = options;
      if (split && typeof split !== 'object') split = ***REMOVED******REMOVED***;
      if (typeof code !== 'undefined' && (typeof code !== 'boolean' || code === true)) ***REMOVED***
        content = Util.escapeMarkdown(content, true);
        content = `\`\`\`$***REMOVED***typeof code !== 'boolean' ? code || '' : ''***REMOVED***\n$***REMOVED***content***REMOVED***\n\`\`\``;
        if (split) ***REMOVED***
          split.prepend = `\`\`\`$***REMOVED***typeof code !== 'boolean' ? code || '' : ''***REMOVED***\n`;
          split.append = '\n```';
        ***REMOVED***
      ***REMOVED***
      if (disableEveryone || (typeof disableEveryone === 'undefined' && this.client.options.disableEveryone)) ***REMOVED***
        content = content.replace(/@(everyone|here)/g, '@\u200b$1');
      ***REMOVED***

      if (split) content = Util.splitMessage(content, split);
    ***REMOVED***

    if (options.file) ***REMOVED***
      if (options.files) options.files.push(options.file);
      else options.files = [options.file];
    ***REMOVED***

    if (options.embeds) ***REMOVED***
      const files = [];
      for (const embed of options.embeds) ***REMOVED***
        if (embed.file) files.push(embed.file);
      ***REMOVED***
      if (options.files) options.files.push(...files);
      else options.files = files;
    ***REMOVED***

    if (options.embeds) options.embeds = options.embeds.map(e => new RichEmbed(e).toJSON());

    if (options.files) ***REMOVED***
      for (let i = 0; i < options.files.length; i++) ***REMOVED***
        let file = options.files[i];
        if (typeof file === 'string' || Buffer.isBuffer(file)) file = ***REMOVED*** attachment: file ***REMOVED***;
        if (!file.name) ***REMOVED***
          if (typeof file.attachment === 'string') ***REMOVED***
            file.name = path.basename(file.attachment);
          ***REMOVED*** else if (file.attachment && file.attachment.path) ***REMOVED***
            file.name = path.basename(file.attachment.path);
          ***REMOVED*** else if (file instanceof Attachment) ***REMOVED***
            file = ***REMOVED*** attachment: file.file, name: path.basename(file.file) || 'file.jpg' ***REMOVED***;
          ***REMOVED*** else ***REMOVED***
            file.name = 'file.jpg';
          ***REMOVED***
        ***REMOVED*** else if (file instanceof Attachment) ***REMOVED***
          file = file.file;
        ***REMOVED***
        options.files[i] = file;
      ***REMOVED***

      return Promise.all(options.files.map(file =>
        this.client.resolver.resolveFile(file.attachment).then(resource => ***REMOVED***
          file.file = resource;
          return file;
        ***REMOVED***)
      )).then(files => this.client.rest.methods.sendWebhookMessage(this, content, options, files));
    ***REMOVED***

    return this.client.rest.methods.sendWebhookMessage(this, content, options);
  ***REMOVED***

  /**
   * Send a message with this webhook
   * @param ***REMOVED***StringResolvable***REMOVED*** content The content to send
   * @param ***REMOVED***WebhookMessageOptions***REMOVED*** [options=***REMOVED******REMOVED***] The options to provide
   * @returns ***REMOVED***Promise<Message|Message[]>***REMOVED***
   * @deprecated
   * @example
   * // Send a message
   * webhook.sendMessage('hello!')
   *  .then(message => console.log(`Sent message: $***REMOVED***message.content***REMOVED***`))
   *  .catch(console.error);
   */
  sendMessage(content, options = ***REMOVED******REMOVED***) ***REMOVED***
    return this.send(content, options);
  ***REMOVED***

  /**
   * Send a file with this webhook.
   * @param ***REMOVED***BufferResolvable***REMOVED*** attachment The file to send
   * @param ***REMOVED***string***REMOVED*** [name='file.jpg'] The name and extension of the file
   * @param ***REMOVED***StringResolvable***REMOVED*** [content] Text message to send with the attachment
   * @param ***REMOVED***WebhookMessageOptions***REMOVED*** [options] The options to provide
   * @returns ***REMOVED***Promise<Message>***REMOVED***
   * @deprecated
   */
  sendFile(attachment, name, content, options = ***REMOVED******REMOVED***) ***REMOVED***
    return this.send(content, Object.assign(options, ***REMOVED*** file: ***REMOVED*** attachment, name ***REMOVED*** ***REMOVED***));
  ***REMOVED***

  /**
   * Send a code block with this webhook.
   * @param ***REMOVED***string***REMOVED*** lang Language for the code block
   * @param ***REMOVED***StringResolvable***REMOVED*** content Content of the code block
   * @param ***REMOVED***WebhookMessageOptions***REMOVED*** options The options to provide
   * @returns ***REMOVED***Promise<Message|Message[]>***REMOVED***
   * @deprecated
   */
  sendCode(lang, content, options = ***REMOVED******REMOVED***) ***REMOVED***
    return this.send(content, Object.assign(options, ***REMOVED*** code: lang ***REMOVED***));
  ***REMOVED***

  /**
   * Send a raw slack message with this webhook.
   * @param ***REMOVED***Object***REMOVED*** body The raw body to send
   * @returns ***REMOVED***Promise***REMOVED***
   * @example
   * // Send a slack message
   * webhook.sendSlackMessage(***REMOVED***
   *   'username': 'Wumpus',
   *   'attachments': [***REMOVED***
   *     'pretext': 'this looks pretty cool',
   *     'color': '#F0F',
   *     'footer_icon': 'http://snek.s3.amazonaws.com/topSnek.png',
   *     'footer': 'Powered by sneks',
   *     'ts': Date.now() / 1000
   *   ***REMOVED***]
   * ***REMOVED***).catch(console.error);
   */
  sendSlackMessage(body) ***REMOVED***
    return this.client.rest.methods.sendSlackWebhookMessage(this, body);
  ***REMOVED***

  /**
   * Options provided to edit a webhook.
   * @property ***REMOVED***string***REMOVED*** [name] The new name for the webhook
   * @property ***REMOVED***BufferResolvable***REMOVED*** [avatar] The new avatar for the webhook
   * @property ***REMOVED***ChannelResolvable***REMOVED*** [channel] The new channel for the webhook
   * @typedef ***REMOVED***Object***REMOVED*** WebhookEditOptions
   */

  /**
   * Edit the webhook.
   * @param ***REMOVED***string|WebhookEditOptions***REMOVED*** nameOrOptions The new name for the webhook **(deprecated, use options)**
   * Alternatively options for the webhook, overriding the avatar parameter.
   * @param ***REMOVED***BufferResolvable|string***REMOVED*** [avatarOrReason] The new avatar for the webhook **(deprecated, use options)**
   * Alternatively a reason to edit, if using options as first parameter.
   * @returns ***REMOVED***Promise<Webhook>***REMOVED***
   */
  edit(nameOrOptions = this.name, avatarOrReason) ***REMOVED***
    if (typeof nameOrOptions !== 'object') ***REMOVED***
      process.emitWarning('Webhook#edit: Use options object instead of separate parameters.');
      nameOrOptions = ***REMOVED***
        name: nameOrOptions,
        avatar: avatarOrReason,
      ***REMOVED***;
      // Parameter was an avatar here; Clear the now reason parameter
      avatarOrReason = undefined;
    ***REMOVED***

    if (nameOrOptions.channel) ***REMOVED***
      nameOrOptions.channel_id = this.client.resolver.resolveChannelID(nameOrOptions.channel);
      nameOrOptions.channel = undefined;
    ***REMOVED***

    if (nameOrOptions.avatar) ***REMOVED***
      return this.client.resolver.resolveImage(nameOrOptions.avatar).then(data => ***REMOVED***
        nameOrOptions.avatar = data;
        return this.client.rest.methods.editWebhook(this, nameOrOptions, avatarOrReason);
      ***REMOVED***);
    ***REMOVED***

    return this.client.rest.methods.editWebhook(this, nameOrOptions, avatarOrReason);
  ***REMOVED***

  /**
   * Delete the webhook.
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for deleting the webhook
   * @returns ***REMOVED***Promise***REMOVED***
   */
  delete(reason) ***REMOVED***
    return this.client.rest.methods.deleteWebhook(this, reason);
  ***REMOVED***
***REMOVED***

module.exports = Webhook;
