const util = require('util');
const Long = require('long');
const User = require('./User');
const Role = require('./Role');
const Emoji = require('./Emoji');
const Presence = require('./Presence').Presence;
const GuildMember = require('./GuildMember');
const Integration = require('./Integration');
const Constants = require('../util/Constants');
const Collection = require('../util/Collection');
const Util = require('../util/Util');
const Snowflake = require('../util/Snowflake');
const SystemChannelFlags = require('../util/SystemChannelFlags');

/**
 * Represents a guild (or a server) on Discord.
 * <info>It's recommended to see if a guild is available before performing operations or reading data from it. You can
 * check this with `guild.available`.</info>
 */
class Guild ***REMOVED***
  constructor(client, data) ***REMOVED***
    /**
     * The client that created the instance of the guild
     * @name Guild#client
     * @type ***REMOVED***Client***REMOVED***
     * @readonly
     */
    Object.defineProperty(this, 'client', ***REMOVED*** value: client ***REMOVED***);

    /**
     * A collection of members that are in this guild. The key is the member's ID, the value is the member
     * @type ***REMOVED***Collection<Snowflake, GuildMember>***REMOVED***
     */
    this.members = new Collection();

    /**
     * A collection of channels that are in this guild. The key is the channel's ID, the value is the channel
     * @type ***REMOVED***Collection<Snowflake, GuildChannel>***REMOVED***
     */
    this.channels = new Collection();

    /**
     * A collection of roles that are in this guild. The key is the role's ID, the value is the role
     * @type ***REMOVED***Collection<Snowflake, Role>***REMOVED***
     */
    this.roles = new Collection();

    /**
     * A collection of presences in this guild
     * @type ***REMOVED***Collection<Snowflake, Presence>***REMOVED***
     */
    this.presences = new Collection();

    /**
     * Whether the bot has been removed from the guild
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.deleted = false;

    if (!data) return;
    if (data.unavailable) ***REMOVED***
      /**
       * Whether the guild is available to access. If it is not available, it indicates a server outage
       * @type ***REMOVED***boolean***REMOVED***
       */
      this.available = false;

      /**
       * The Unique ID of the guild, useful for comparisons
       * @type ***REMOVED***Snowflake***REMOVED***
       */
      this.id = data.id;
    ***REMOVED*** else ***REMOVED***
      this.setup(data);
      if (!data.channels) this.available = false;
    ***REMOVED***
  ***REMOVED***

  /* eslint-disable complexity */
  /**
   * Sets up the guild.
   * @param ***REMOVED*******REMOVED*** data The raw data of the guild
   * @private
   */
  setup(data) ***REMOVED***
    /**
     * The name of the guild
     * @type ***REMOVED***string***REMOVED***
     */
    this.name = data.name;

    /**
     * The hash of the guild icon
     * @type ***REMOVED***?string***REMOVED***
     */
    this.icon = data.icon;

    /**
     * The hash of the guild splash image (VIP only)
     * @type ***REMOVED***?string***REMOVED***
     */
    this.splash = data.splash;

    /**
     * The region the guild is located in
     * @type ***REMOVED***string***REMOVED***
     */
    this.region = data.region;

    /**
     * The full amount of members in this guild
     * @type ***REMOVED***number***REMOVED***
     */
    this.memberCount = data.member_count || this.memberCount;

    /**
     * Whether the guild is "large" (has more than 250 members)
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.large = Boolean('large' in data ? data.large : this.large);

    /**
     * An array of guild features
     * @type ***REMOVED***Object[]***REMOVED***
     */
    this.features = data.features;

    /**
     * The ID of the application that created this guild (if applicable)
     * @type ***REMOVED***?Snowflake***REMOVED***
     */
    this.applicationID = data.application_id;

    /**
     * The time in seconds before a user is counted as "away from keyboard"
     * @type ***REMOVED***?number***REMOVED***
     */
    this.afkTimeout = data.afk_timeout;

    /**
     * The ID of the voice channel where AFK members are moved
     * @type ***REMOVED***?string***REMOVED***
     */
    this.afkChannelID = data.afk_channel_id;

    /**
     * The ID of the system channel
     * @type ***REMOVED***?Snowflake***REMOVED***
     */
    this.systemChannelID = data.system_channel_id;

    /**
     * Whether embedded images are enabled on this guild
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.embedEnabled = data.embed_enabled;

    /**
     * The verification level of the guild
     * @type ***REMOVED***number***REMOVED***
     */
    this.verificationLevel = data.verification_level;

    /**
     * The explicit content filter level of the guild
     * @type ***REMOVED***number***REMOVED***
     */
    this.explicitContentFilter = data.explicit_content_filter;

    /**
     * The required MFA level for the guild
     * @type ***REMOVED***number***REMOVED***
     */
    this.mfaLevel = data.mfa_level;

    /**
     * The timestamp the client user joined the guild at
     * @type ***REMOVED***number***REMOVED***
     */
    this.joinedTimestamp = data.joined_at ? new Date(data.joined_at).getTime() : this.joinedTimestamp;

    /**
     * The value set for a guild's default message notifications
     * @type ***REMOVED***DefaultMessageNotifications|number***REMOVED***
     */
    this.defaultMessageNotifications = Constants.DefaultMessageNotifications[data.default_message_notifications] ||
      data.default_message_notifications;

    /**
     * The value for the guild's system channel flags
     * @type ***REMOVED***Readonly<SystemChannelFlags>***REMOVED***
     */
    this.systemChannelFlags = new SystemChannelFlags(data.system_channel_flags).freeze();

    /**
     * The type of premium tier:
     * * 0: NONE
     * * 1: TIER_1
     * * 2: TIER_2
     * * 3: TIER_3
     * @typedef ***REMOVED***number***REMOVED*** PremiumTier
     */

    /**
     * The premium tier on this guild
     * @type ***REMOVED***PremiumTier***REMOVED***
     */
    this.premiumTier = data.premium_tier;

    /**
     * The total number of users currently boosting this server
     * @type ***REMOVED***?number***REMOVED***
     * @name Guild#premiumSubscriptionCount
     */
    if (typeof data.premium_subscription_count !== 'undefined') ***REMOVED***
      this.premiumSubscriptionCount = data.premium_subscription_count;
    ***REMOVED***

    /**
     * The hash of the guild banner
     * @type ***REMOVED***?string***REMOVED***
     */
    this.banner = data.banner;

    /**
     * The description of the guild, if any
     * @type ***REMOVED***?string***REMOVED***
     */
    this.description = data.description;

    /**
     * The embed channel ID, if enabled
     * @type ***REMOVED***?string***REMOVED***
     * @name Guild#embedChannelID
     */
    if (typeof data.embed_channel_id !== 'undefined') this.embedChannelID = data.embed_channel_id;

    /**
     * The maximum amount of members the guild can have
     * <info>You will need to fetch the guild using ***REMOVED***@link Guild#fetch***REMOVED*** if you want to receive this parameter</info>
     * @type ***REMOVED***?number***REMOVED***
     * @name Guild#maximumMembers
     */
    if (typeof data.max_members !== 'undefined') this.maximumMembers = data.max_members || 250000;

    /**
     * The maximum amount of presences the guild can have
     * <info>You will need to fetch the guild using ***REMOVED***@link Guild#fetch***REMOVED*** if you want to receive this parameter</info>
     * @type ***REMOVED***?number***REMOVED***
     * @name Guild#maximumPresences
     */
    if (typeof data.max_presences !== 'undefined') this.maximumPresences = data.max_presences || 5000;

    /**
     * Whether widget images are enabled on this guild
     * @type ***REMOVED***?boolean***REMOVED***
     * @name Guild#widgetEnabled
     */
    if (typeof data.widget_enabled !== 'undefined') this.widgetEnabled = data.widget_enabled;

    /**
     * The widget channel ID, if enabled
     * @type ***REMOVED***?string***REMOVED***
     * @name Guild#widgetChannelID
     */
    if (typeof data.widget_channel_id !== 'undefined') this.widgetChannelID = data.widget_channel_id;

    /**
     * The vanity URL code of the guild, if any
     * @type ***REMOVED***?string***REMOVED***
     */
    this.vanityURLCode = data.vanity_url_code;

    this.id = data.id;
    this.available = !data.unavailable;
    this.features = data.features || this.features || [];

    /**
     * The ID of the rules channel for the guild
     * <info>This is only available on guilds with the `PUBLIC` feature</info>
     * @type ***REMOVED***?Snowflake***REMOVED***
     */
    this.rulesChannelID = data.rules_channel_id;

    /**
     * The ID of the public updates channel for the guild
     * <info>This is only available on guilds with the `PUBLIC` feature</info>
     * @type ***REMOVED***?Snowflake***REMOVED***
     */
    this.publicUpdatesChannelID = data.public_updates_channel_id;

    if (data.members) ***REMOVED***
      this.members.clear();
      for (const guildUser of data.members) this._addMember(guildUser, false);
    ***REMOVED***

    if (data.owner_id) ***REMOVED***
      /**
       * The user ID of this guild's owner
       * @type ***REMOVED***Snowflake***REMOVED***
       */
      this.ownerID = data.owner_id;
    ***REMOVED***

    if (data.channels) ***REMOVED***
      this.channels.clear();
      for (const channel of data.channels) this.client.dataManager.newChannel(channel, this);
    ***REMOVED***

    if (data.roles) ***REMOVED***
      this.roles.clear();
      for (const role of data.roles) ***REMOVED***
        const newRole = new Role(this, role);
        this.roles.set(newRole.id, newRole);
      ***REMOVED***
    ***REMOVED***

    if (data.presences) ***REMOVED***
      for (const presence of data.presences) ***REMOVED***
        this._setPresence(presence.user.id, presence);
      ***REMOVED***
    ***REMOVED***

    this._rawVoiceStates = new Collection();
    if (data.voice_states) ***REMOVED***
      for (const voiceState of data.voice_states) ***REMOVED***
        this._rawVoiceStates.set(voiceState.user_id, voiceState);
        const member = this.members.get(voiceState.user_id);
        const voiceChannel = this.channels.get(voiceState.channel_id);
        if (member && voiceChannel) ***REMOVED***
          member.serverMute = voiceState.mute;
          member.serverDeaf = voiceState.deaf;
          member.selfMute = voiceState.self_mute;
          member.selfDeaf = voiceState.self_deaf;
          member.selfStream = voiceState.self_stream || false;
          member.voiceSessionID = voiceState.session_id;
          member.voiceChannelID = voiceState.channel_id;
          voiceChannel.members.set(member.user.id, member);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    if (!this.emojis) ***REMOVED***
      /**
       * A collection of emojis that are in this guild
       * The key is the emoji's ID, the value is the emoji
       * @type ***REMOVED***Collection<Snowflake, Emoji>***REMOVED***
       */
      this.emojis = new Collection();
      for (const emoji of data.emojis) this.emojis.set(emoji.id, new Emoji(this, emoji));
    ***REMOVED*** else ***REMOVED***
      this.client.actions.GuildEmojisUpdate.handle(***REMOVED***
        guild_id: this.id,
        emojis: data.emojis,
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  /**
   * The timestamp the guild was created at
   * @type ***REMOVED***number***REMOVED***
   * @readonly
   */
  get createdTimestamp() ***REMOVED***
    return Snowflake.deconstruct(this.id).timestamp;
  ***REMOVED***

  /**
   * The time the guild was created
   * @type ***REMOVED***Date***REMOVED***
   * @readonly
   */
  get createdAt() ***REMOVED***
    return new Date(this.createdTimestamp);
  ***REMOVED***

  /**
   * Embed channel for this guild
   * @type ***REMOVED***?TextChannel***REMOVED***
   * @readonly
   */
  get embedChannel() ***REMOVED***
    return this.channels.get(this.embedChannelID) || null;
  ***REMOVED***

  /**
   * Widget channel for this guild
   * @type ***REMOVED***?TextChannel***REMOVED***
   * @readonly
   */
  get widgetChannel() ***REMOVED***
    return this.channels.get(this.widgetChannelID) || null;
  ***REMOVED***

  /**
   * The time the client user joined the guild
   * @type ***REMOVED***Date***REMOVED***
   * @readonly
   */
  get joinedAt() ***REMOVED***
    return new Date(this.joinedTimestamp);
  ***REMOVED***

  /**
   * If this guild is verified
   * @type ***REMOVED***boolean***REMOVED***
   * @readonly
   */
  get verified() ***REMOVED***
    return this.features.includes('VERIFIED');
  ***REMOVED***

  /**
   * The URL to this guild's icon
   * @type ***REMOVED***?string***REMOVED***
   * @readonly
   */
  get iconURL() ***REMOVED***
    if (!this.icon) return null;
    return Constants.Endpoints.Guild(this).Icon(this.client.options.http.cdn, this.icon);
  ***REMOVED***

  /**
   * The URL to this guild's banner.
   * @type ***REMOVED***?string***REMOVED***
   * @readonly
   */
  get bannerURL() ***REMOVED***
    if (!this.banner) return null;
    return Constants.Endpoints.Guild(this).Banner(this.client.options.http.cdn, this.banner);
  ***REMOVED***

  /**
   * The acronym that shows up in place of a guild icon.
   * @type ***REMOVED***string***REMOVED***
   * @readonly
   */
  get nameAcronym() ***REMOVED***
    return this.name.replace(/\w+/g, name => name[0]).replace(/\s/g, '');
  ***REMOVED***

  /**
   * The URL to this guild's splash
   * @type ***REMOVED***?string***REMOVED***
   * @readonly
   */
  get splashURL() ***REMOVED***
    if (!this.splash) return null;
    return Constants.Endpoints.Guild(this).Splash(this.client.options.http.cdn, this.splash);
  ***REMOVED***

  /**
   * The owner of the guild
   * @type ***REMOVED***?GuildMember***REMOVED***
   * @readonly
   */
  get owner() ***REMOVED***
    return this.members.get(this.ownerID);
  ***REMOVED***

  /**
   * AFK voice channel for this guild
   * @type ***REMOVED***?VoiceChannel***REMOVED***
   * @readonly
   */
  get afkChannel() ***REMOVED***
    return this.client.channels.get(this.afkChannelID) || null;
  ***REMOVED***

  /**
   * System channel for this guild
   * @type ***REMOVED***?GuildChannel***REMOVED***
   * @readonly
   */
  get systemChannel() ***REMOVED***
    return this.client.channels.get(this.systemChannelID) || null;
  ***REMOVED***

  /**
   * If the client is connected to any voice channel in this guild, this will be the relevant VoiceConnection
   * @type ***REMOVED***?VoiceConnection***REMOVED***
   * @readonly
   */
  get voiceConnection() ***REMOVED***
    if (this.client.browser) return null;
    return this.client.voice.connections.get(this.id) || null;
  ***REMOVED***

  /**
   * The position of this guild
   * <warn>This is only available when using a user account.</warn>
   * @type ***REMOVED***?number***REMOVED***
   * @readonly
   * @deprecated
   */
  get position() ***REMOVED***
    if (this.client.user.bot) return null;
    if (!this.client.user.settings.guildPositions) return null;
    return this.client.user.settings.guildPositions.indexOf(this.id);
  ***REMOVED***

  /**
   * Whether the guild is muted
   * <warn>This is only available when using a user account.</warn>
   * @type ***REMOVED***?boolean***REMOVED***
   * @readonly
   * @deprecated
   */
  get muted() ***REMOVED***
    if (this.client.user.bot) return null;
    try ***REMOVED***
      return this.client.user.guildSettings.get(this.id).muted;
    ***REMOVED*** catch (err) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  /**
   * The type of message that should notify you
   * <warn>This is only available when using a user account.</warn>
   * @type ***REMOVED***?MessageNotificationType***REMOVED***
   * @readonly
   * @deprecated
   */
  get messageNotifications() ***REMOVED***
    if (this.client.user.bot) return null;
    try ***REMOVED***
      return this.client.user.guildSettings.get(this.id).messageNotifications;
    ***REMOVED*** catch (err) ***REMOVED***
      return null;
    ***REMOVED***
  ***REMOVED***

  /**
   * Whether to receive mobile push notifications
   * <warn>This is only available when using a user account.</warn>
   * @type ***REMOVED***?boolean***REMOVED***
   * @readonly
   * @deprecated
   */
  get mobilePush() ***REMOVED***
    if (this.client.user.bot) return null;
    try ***REMOVED***
      return this.client.user.guildSettings.get(this.id).mobilePush;
    ***REMOVED*** catch (err) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  /**
   * Whether to suppress everyone messages
   * <warn>This is only available when using a user account.</warn>
   * @type ***REMOVED***?boolean***REMOVED***
   * @readonly
   * @deprecated
   */
  get suppressEveryone() ***REMOVED***
    if (this.client.user.bot) return null;
    try ***REMOVED***
      return this.client.user.guildSettings.get(this.id).suppressEveryone;
    ***REMOVED*** catch (err) ***REMOVED***
      return null;
    ***REMOVED***
  ***REMOVED***

  /**
   * The `@everyone` role of the guild
   * @type ***REMOVED***Role***REMOVED***
   * @readonly
   */
  get defaultRole() ***REMOVED***
    return this.roles.get(this.id);
  ***REMOVED***

  /**
   * Rules channel for this guild
   * <info>This is only available on guilds with the `PUBLIC` feature</info>
   * @type ***REMOVED***?TextChannel***REMOVED***
   * @readonly
   */
  get rulesChannel() ***REMOVED***
    return this.client.channels.get(this.rulesChannelID) || null;
  ***REMOVED***

  /**
   * Public updates channel for this guild
   * <info>This is only available on guilds with the `PUBLIC` feature</info>
   * @type ***REMOVED***?TextChannel***REMOVED***
   * @readonly
   */
  get publicUpdatesChannel() ***REMOVED***
    return this.client.channels.get(this.publicUpdatesChannelID) || null;
  ***REMOVED***

  /**
   * The client user as a GuildMember of this guild
   * @type ***REMOVED***?GuildMember***REMOVED***
   * @readonly
   */
  get me() ***REMOVED***
    return this.members.get(this.client.user.id);
  ***REMOVED***

  /**
   * Fetches a collection of roles in the current guild sorted by position
   * @type ***REMOVED***Collection<Snowflake, Role>***REMOVED***
   * @readonly
   * @private
   */
  get _sortedRoles() ***REMOVED***
    return this._sortPositionWithID(this.roles);
  ***REMOVED***

  /**
   * Returns the GuildMember form of a User object, if the user is present in the guild.
   * @param ***REMOVED***UserResolvable***REMOVED*** user The user that you want to obtain the GuildMember of
   * @returns ***REMOVED***?GuildMember***REMOVED***
   * @example
   * // Get the guild member of a user
   * const member = guild.member(message.author);
   */
  member(user) ***REMOVED***
    return this.client.resolver.resolveGuildMember(this, user);
  ***REMOVED***

  /**
   * Fetches this guild.
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   */
  fetch() ***REMOVED***
    return this.client.rest.methods.getGuild(this).then(data => ***REMOVED***
      this.setup(data);

      return this;
    ***REMOVED***);
  ***REMOVED***

  /**
   * An object containing information about a guild member's ban.
   * @typedef ***REMOVED***Object***REMOVED*** BanInfo
   * @property ***REMOVED***User***REMOVED*** user User that was banned
   * @property ***REMOVED***?string***REMOVED*** reason Reason the user was banned
   */

  /**
   * Fetch a ban for a user.
   * @returns ***REMOVED***Promise<BanInfo>***REMOVED***
   * @param ***REMOVED***UserResolvable***REMOVED*** user The user to fetch the ban for
   * @example
   * // Get ban
   * guild.fetchBan(message.author)
   *   .then((***REMOVED*** user, reason ***REMOVED***) => console.log(`$***REMOVED***user.tag***REMOVED*** was banned for the reason: $***REMOVED***reason***REMOVED***.`))
   *   .catch(console.error);
   */
  fetchBan(user) ***REMOVED***
    return this.client.rest.methods.getGuildBan(this, user);
  ***REMOVED***

  /**
   * Fetch a collection of banned users in this guild.
   * @returns ***REMOVED***Promise<Collection<Snowflake, User|BanInfo>>***REMOVED***
   * @param ***REMOVED***boolean***REMOVED*** [withReasons=false] Whether or not to include the ban reason(s)
   * @example
   * // Fetch bans in guild
   * guild.fetchBans()
   *   .then(bans => console.log(`This guild has $***REMOVED***bans.size***REMOVED*** bans`))
   *   .catch(console.error);
   */
  fetchBans(withReasons = false) ***REMOVED***
    if (withReasons) return this.client.rest.methods.getGuildBans(this);
    return this.client.rest.methods.getGuildBans(this)
      .then(bans => ***REMOVED***
        const users = new Collection();
        for (const ban of bans.values()) users.set(ban.user.id, ban.user);
        return users;
      ***REMOVED***);
  ***REMOVED***

  /**
   * Fetches a collection of integrations to this guild.
   * Resolves with a collection mapping integrations by their ids.
   * @returns ***REMOVED***Promise<Collection<string, Integration>>***REMOVED***
   * @example
   * // Fetch integrations
   * guild.fetchIntegrations()
   *   .then(integrations => console.log(`Fetched $***REMOVED***integrations.size***REMOVED*** integrations`))
   *   .catch(console.error);
   */
  fetchIntegrations() ***REMOVED***
    return this.client.rest.methods.getIntegrations(this).then(data =>
      data.reduce((collection, integration) =>
        collection.set(integration.id, new Integration(this.client, integration, this)),
      new Collection())
    );
  ***REMOVED***

  /**
   * The data for creating an integration.
   * @typedef ***REMOVED***Object***REMOVED*** IntegrationData
   * @property ***REMOVED***string***REMOVED*** id The integration id
   * @property ***REMOVED***string***REMOVED*** type The integration type
   */

  /**
   * Creates an integration by attaching an integration object
   * @param ***REMOVED***IntegrationData***REMOVED*** data The data for thes integration
   * @param ***REMOVED***string***REMOVED*** reason Reason for creating the integration
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   */
  createIntegration(data, reason) ***REMOVED***
    return this.client.rest.methods.createIntegration(this, data, reason)
      .then(() => this);
  ***REMOVED***

  /**
   * Fetch a collection of invites to this guild.
   * Resolves with a collection mapping invites by their codes.
   * @returns ***REMOVED***Promise<Collection<string, Invite>>***REMOVED***
   * @example
   * // Fetch invites
   * guild.fetchInvites()
   *   .then(invites => console.log(`Fetched $***REMOVED***invites.size***REMOVED*** invites`))
   *   .catch(console.error);
   * @example
   * // Fetch invite creator by their id
   * guild.fetchInvites()
   *  .then(invites => console.log(invites.find(invite => invite.inviter.id === '84484653687267328')))
   *  .catch(console.error);
   */
  fetchInvites() ***REMOVED***
    return this.client.rest.methods.getGuildInvites(this);
  ***REMOVED***

  /**
   * Fetches the vanity url invite code to this guild.
   * Resolves with a string matching the vanity url invite code, not the full url.
   * @returns ***REMOVED***Promise<string>***REMOVED***
   * @example
   * // Fetch invites
   * guild.fetchVanityCode()
   *   .then(code => ***REMOVED***
   *     console.log(`Vanity URL: https://discord.gg/$***REMOVED***code***REMOVED***`);
   *   ***REMOVED***)
   *   .catch(console.error);
   */
  fetchVanityCode() ***REMOVED***
    if (!this.features.includes('VANITY_URL')) ***REMOVED***
      return Promise.reject(new Error('This guild does not have the VANITY_URL feature enabled.'));
    ***REMOVED***
    return this.client.rest.methods.getGuildVanityCode(this);
  ***REMOVED***


  /**
   * Fetch all webhooks for the guild.
   * @returns ***REMOVED***Promise<Collection<Snowflake, Webhook>>***REMOVED***
   * @example
   * // Fetch webhooks
   * guild.fetchWebhooks()
   *   .then(webhooks => console.log(`Fetched $***REMOVED***webhooks.size***REMOVED*** webhooks`))
   *   .catch(console.error);
   */
  fetchWebhooks() ***REMOVED***
    return this.client.rest.methods.getGuildWebhooks(this);
  ***REMOVED***

  /**
   * Fetch available voice regions.
   * @returns ***REMOVED***Promise<Collection<string, VoiceRegion>>***REMOVED***
   * @example
   * // Fetch voice regions
   * guild.fetchVoiceRegions()
   *   .then(console.log)
   *   .catch(console.error);
   */
  fetchVoiceRegions() ***REMOVED***
    return this.client.rest.methods.fetchVoiceRegions(this.id);
  ***REMOVED***

  /**
   * The Guild Embed object
   * @typedef ***REMOVED***Object***REMOVED*** GuildEmbedData
   * @property ***REMOVED***boolean***REMOVED*** enabled Whether the embed is enabled
   * @property ***REMOVED***?ChannelResolvable***REMOVED*** channel The embed channel
   */

  /**
   * Fetches the guild embed.
   * @returns ***REMOVED***Promise<GuildEmbedData>***REMOVED***
   * @example
   * // Fetches the guild embed
   * guild.fetchEmbed()
   *   .then(embed => console.log(`The embed is $***REMOVED***embed.enabled ? 'enabled' : 'disabled'***REMOVED***`))
   *   .catch(console.error);
   */
  fetchEmbed() ***REMOVED***
    return this.client.rest.methods.fetchEmbed(this.id);
  ***REMOVED***

  /**
   * Fetch audit logs for this guild.
   * @param ***REMOVED***Object***REMOVED*** [options=***REMOVED******REMOVED***] Options for fetching audit logs
   * @param ***REMOVED***Snowflake|GuildAuditLogsEntry***REMOVED*** [options.before] Limit to entries from before specified entry
   * @param ***REMOVED***Snowflake|GuildAuditLogsEntry***REMOVED*** [options.after] Limit to entries from after specified entry
   * @param ***REMOVED***number***REMOVED*** [options.limit] Limit number of entries
   * @param ***REMOVED***UserResolvable***REMOVED*** [options.user] Only show entries involving this user
   * @param ***REMOVED***AuditLogAction***REMOVED*** [options.type] Only show entries involving this action type
   * @returns ***REMOVED***Promise<GuildAuditLogs>***REMOVED***
   * @example
   * // Output audit log entries
   * guild.fetchAuditLogs()
   *   .then(audit => console.log(audit.entries.first()))
   *   .catch(console.error);
   */
  fetchAuditLogs(options) ***REMOVED***
    return this.client.rest.methods.getGuildAuditLogs(this, options);
  ***REMOVED***

  /**
   * Adds a user to the guild using OAuth2. Requires the `CREATE_INSTANT_INVITE` permission.
   * @param ***REMOVED***UserResolvable***REMOVED*** user User to add to the guild
   * @param ***REMOVED***Object***REMOVED*** options Options for the addition
   * @param ***REMOVED***string***REMOVED*** options.accessToken An OAuth2 access token for the user with the `guilds.join` scope granted to the
   * bot's application
   * @param ***REMOVED***string***REMOVED*** [options.nick] Nickname to give the member (requires `MANAGE_NICKNAMES`)
   * @param ***REMOVED***Collection<Snowflake, Role>|Role[]|Snowflake[]***REMOVED*** [options.roles] Roles to add to the member
   * (requires `MANAGE_ROLES`)
   * @param ***REMOVED***boolean***REMOVED*** [options.mute] Whether the member should be muted (requires `MUTE_MEMBERS`)
   * @param ***REMOVED***boolean***REMOVED*** [options.deaf] Whether the member should be deafened (requires `DEAFEN_MEMBERS`)
   * @returns ***REMOVED***Promise<GuildMember>***REMOVED***
   */
  addMember(user, options) ***REMOVED***
    user = this.client.resolver.resolveUserID(user);
    if (this.members.has(user)) return Promise.resolve(this.members.get(user));
    return this.client.rest.methods.putGuildMember(this, user, options);
  ***REMOVED***

  /**
   * Fetch a single guild member from a user.
   * @param ***REMOVED***UserResolvable***REMOVED*** user The user to fetch the member for
   * @param ***REMOVED***boolean***REMOVED*** [cache=true] Insert the member into the members cache
   * @returns ***REMOVED***Promise<GuildMember>***REMOVED***
   * @example
   * // Fetch a guild member
   * guild.fetchMember(message.author)
   *   .then(console.log)
   *   .catch(console.error);
   */
  fetchMember(user, cache = true) ***REMOVED***
    const userID = this.client.resolver.resolveUserID(user);
    if (!userID) return Promise.reject(new Error('Invalid id provided.'));
    const member = this.members.get(userID);
    if (member && member.joinedTimestamp) return Promise.resolve(member);
    return this.client.rest.methods.getGuildMember(this, userID, cache);
  ***REMOVED***

  /**
   * Fetches all the members in the guild, even if they are offline. If the guild has less than 250 members,
   * this should not be necessary.
   * @param ***REMOVED***string***REMOVED*** [query=''] Limit fetch to members with similar usernames
   * @param ***REMOVED***number***REMOVED*** [limit=0] Maximum number of members to request
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @example
   * // Fetch guild members
   * guild.fetchMembers()
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Fetches a maximum of 1 member with the given query
   * guild.fetchMembers('hydrabolt', 1)
   *   .then(console.log)
   *   .catch(console.error);
   */
  fetchMembers(query = '', limit = 0) ***REMOVED***
    return new Promise((resolve, reject) => ***REMOVED***
      if (this.memberCount === this.members.size) ***REMOVED***
        resolve(this);
        return;
      ***REMOVED***
      this.client.ws.send(***REMOVED***
        op: Constants.OPCodes.REQUEST_GUILD_MEMBERS,
        d: ***REMOVED***
          guild_id: this.id,
          query,
          limit,
        ***REMOVED***,
      ***REMOVED***);
      const handler = (members, guild) => ***REMOVED***
        if (guild.id !== this.id) return;
        if (this.memberCount === this.members.size || members.length < 1000) ***REMOVED***
          this.client.removeListener(Constants.Events.GUILD_MEMBERS_CHUNK, handler);
          resolve(this);
        ***REMOVED***
      ***REMOVED***;
      this.client.on(Constants.Events.GUILD_MEMBERS_CHUNK, handler);
      this.client.setTimeout(() => reject(new Error('Members didn\'t arrive in time.')), 120 * 1000);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Performs a search within the entire guild.
   * <warn>This is only available when using a user account.</warn>
   * @param ***REMOVED***MessageSearchOptions***REMOVED*** [options=***REMOVED******REMOVED***] Options to pass to the search
   * @returns ***REMOVED***Promise<MessageSearchResult>***REMOVED***
   * @deprecated
   * @example
   * guild.search(***REMOVED***
   *   content: 'discord.js',
   *   before: '2016-11-17'
   * ***REMOVED***)
   *   .then(res => ***REMOVED***
   *     const hit = res.messages[0].find(m => m.hit).content;
   *     console.log(`I found: **$***REMOVED***hit***REMOVED*****, total results: $***REMOVED***res.totalResults***REMOVED***`);
   *   ***REMOVED***)
   *   .catch(console.error);
   */
  search(options = ***REMOVED******REMOVED***) ***REMOVED***
    return this.client.rest.methods.search(this, options);
  ***REMOVED***

  /**
   * The data for editing a guild.
   * @typedef ***REMOVED***Object***REMOVED*** GuildEditData
   * @property ***REMOVED***string***REMOVED*** [name] The name of the guild
   * @property ***REMOVED***string***REMOVED*** [region] The region of the guild
   * @property ***REMOVED***number***REMOVED*** [verificationLevel] The verification level of the guild
   * @property ***REMOVED***number***REMOVED*** [explicitContentFilter] The level of the explicit content filter
   * @property ***REMOVED***ChannelResolvable***REMOVED*** [afkChannel] The AFK channel of the guild
   * @property ***REMOVED***ChannelResolvable***REMOVED*** [systemChannel] The system channel of the guild
   * @property ***REMOVED***number***REMOVED*** [afkTimeout] The AFK timeout of the guild
   * @property ***REMOVED***Base64Resolvable***REMOVED*** [icon] The icon of the guild
   * @property ***REMOVED***Base64Resolvable***REMOVED*** [banner] The banner of the guild
   * @property ***REMOVED***GuildMemberResolvable***REMOVED*** [owner] The owner of the guild
   * @property ***REMOVED***Base64Resolvable***REMOVED*** [splash] The splash screen of the guild
   * @property ***REMOVED***SystemChannelFlagsResolvable***REMOVED*** [systemChannelFlags] The system channel flags of the guild
   */

  /**
   * Updates the guild with new information - e.g. a new name.
   * @param ***REMOVED***GuildEditData***REMOVED*** data The data to update the guild with
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for editing the guild
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @example
   * // Set the guild name and region
   * guild.edit(***REMOVED***
   *   name: 'Discord Guild',
   *   region: 'london',
   * ***REMOVED***)
   *   .then(g => console.log(`Changed guild name to $***REMOVED***g***REMOVED*** and region to $***REMOVED***g.region***REMOVED***`))
   *   .catch(console.error);
   */
  edit(data, reason) ***REMOVED***
    const _data = ***REMOVED******REMOVED***;
    if (data.name) _data.name = data.name;
    if (data.region) _data.region = data.region;
    if (typeof data.verificationLevel !== 'undefined') _data.verification_level = Number(data.verificationLevel);
    if (typeof data.afkChannel !== 'undefined') ***REMOVED***
      _data.afk_channel_id = this.client.resolver.resolveChannelID(data.afkChannel);
    ***REMOVED***
    if (typeof data.systemChannel !== 'undefined') ***REMOVED***
      _data.system_channel_id = this.client.resolver.resolveChannelID(data.systemChannel);
    ***REMOVED***
    if (data.afkTimeout) _data.afk_timeout = Number(data.afkTimeout);
    if (typeof data.icon !== 'undefined') _data.icon = data.icon;
    if (data.owner) _data.owner_id = this.client.resolver.resolveUser(data.owner).id;
    if (typeof data.splash !== 'undefined') _data.splash = data.splash;
    if (typeof data.banner !== 'undefined') _data.banner = data.banner;
    if (typeof data.explicitContentFilter !== 'undefined') ***REMOVED***
      _data.explicit_content_filter = Number(data.explicitContentFilter);
    ***REMOVED***
    if (typeof data.defaultMessageNotifications !== 'undefined') ***REMOVED***
      _data.default_message_notifications = typeof data.defaultMessageNotifications === 'string' ?
        Constants.DefaultMessageNotifications.indexOf(data.defaultMessageNotifications) :
        Number(data.defaultMessageNotifications);
    ***REMOVED***
    if (typeof data.systemChannelFlags !== 'undefined') ***REMOVED***
      _data.system_channel_flags = SystemChannelFlags.resolve(data.systemChannelFlags);
    ***REMOVED***
    return this.client.rest.methods.updateGuild(this, _data, reason);
  ***REMOVED***

  /**
   * Sets a new guild banner.
   * @param ***REMOVED***BufferResolvable|Base64Resolvable***REMOVED*** banner The new banner of the guild
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the guild's banner
   * @returns ***REMOVED***Guild***REMOVED***
   */
  setBanner(banner, reason) ***REMOVED***
    return this.client.resolver.resolveImage(banner).then(data => this.edit(***REMOVED*** banner: data ***REMOVED***, reason));
  ***REMOVED***

  /**
   * Edit the level of the explicit content filter.
   * @param ***REMOVED***number***REMOVED*** explicitContentFilter The new level of the explicit content filter
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the level of the guild's explicit content filter
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   */
  setExplicitContentFilter(explicitContentFilter, reason) ***REMOVED***
    return this.edit(***REMOVED*** explicitContentFilter ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Edits the setting of the default message notifications of the guild.
   * @param ***REMOVED***DefaultMessageNotifications|number***REMOVED*** defaultMessageNotifications
   * The new setting for the default message notifications
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the setting of the default message notifications
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   */
  setDefaultMessageNotifications(defaultMessageNotifications, reason) ***REMOVED***
    return this.edit(***REMOVED*** defaultMessageNotifications ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Edits the flags of the default message notifications of the guild.
   * @param ***REMOVED***SystemChannelFlagsResolvable***REMOVED*** systemChannelFlags The new flags for the default message notifications
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the flags of the default message notifications
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   */
  setSystemChannelFlags(systemChannelFlags, reason) ***REMOVED***
    return this.edit(***REMOVED*** systemChannelFlags ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Edit the name of the guild.
   * @param ***REMOVED***string***REMOVED*** name The new name of the guild
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the guild's name
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @example
   * // Edit the guild name
   * guild.setName('Discord Guild')
   *  .then(g => console.log(`Updated guild name to $***REMOVED***g***REMOVED***`))
   *  .catch(console.error);
   */
  setName(name, reason) ***REMOVED***
    return this.edit(***REMOVED*** name ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Edit the region of the guild.
   * @param ***REMOVED***string***REMOVED*** region The new region of the guild
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the guild's region
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @example
   * // Edit the guild region
   * guild.setRegion('london')
   *  .then(g => console.log(`Updated guild region to $***REMOVED***g.region***REMOVED***`))
   *  .catch(console.error);
   */
  setRegion(region, reason) ***REMOVED***
    return this.edit(***REMOVED*** region ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Edit the verification level of the guild.
   * @param ***REMOVED***number***REMOVED*** verificationLevel The new verification level of the guild
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the guild's verification level
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @example
   * // Edit the guild verification level
   * guild.setVerificationLevel(1)
   *  .then(g => console.log(`Updated guild verification level to $***REMOVED***g.verificationLevel***REMOVED***`))
   *  .catch(console.error);
   */
  setVerificationLevel(verificationLevel, reason) ***REMOVED***
    return this.edit(***REMOVED*** verificationLevel ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Edit the AFK channel of the guild.
   * @param ***REMOVED***ChannelResolvable***REMOVED*** afkChannel The new AFK channel
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the guild's AFK channel
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @example
   * // Edit the guild AFK channel
   * guild.setAFKChannel(channel)
   *  .then(g => console.log(`Updated guild AFK channel to $***REMOVED***g.afkChannel.name***REMOVED***`))
   *  .catch(console.error);
   */
  setAFKChannel(afkChannel, reason) ***REMOVED***
    return this.edit(***REMOVED*** afkChannel ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Edit the system channel of the guild.
   * @param ***REMOVED***ChannelResolvable***REMOVED*** systemChannel The new system channel
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the guild's system channel
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   */
  setSystemChannel(systemChannel, reason) ***REMOVED***
    return this.edit(***REMOVED*** systemChannel ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Edit the AFK timeout of the guild.
   * @param ***REMOVED***number***REMOVED*** afkTimeout The time in seconds that a user must be idle to be considered AFK
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the guild's AFK timeout
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @example
   * // Edit the guild AFK channel
   * guild.setAFKTimeout(60)
   *  .then(g => console.log(`Updated guild AFK timeout to $***REMOVED***g.afkTimeout***REMOVED***`))
   *  .catch(console.error);
   */
  setAFKTimeout(afkTimeout, reason) ***REMOVED***
    return this.edit(***REMOVED*** afkTimeout ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Set a new guild icon.
   * @param ***REMOVED***Base64Resolvable|BufferResolvable***REMOVED*** icon The new icon of the guild
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the guild's icon
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @example
   * // Edit the guild icon
   * guild.setIcon('./icon.png')
   *  .then(console.log)
   *  .catch(console.error);
   */
  setIcon(icon, reason) ***REMOVED***
    return this.client.resolver.resolveImage(icon).then(data => this.edit(***REMOVED*** icon: data, reason ***REMOVED***));
  ***REMOVED***

  /**
   * Sets a new owner of the guild.
   * @param ***REMOVED***GuildMemberResolvable***REMOVED*** owner The new owner of the guild
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for setting the new owner
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @example
   * // Edit the guild owner
   * guild.setOwner(guild.members.first())
   *  .then(g => console.log(`Updated the guild owner to $***REMOVED***g.owner.displayName***REMOVED***`))
   *  .catch(console.error);
   */
  setOwner(owner, reason) ***REMOVED***
    return this.edit(***REMOVED*** owner ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Set a new guild splash screen.
   * @param ***REMOVED***BufferResolvable|Base64Resolvable***REMOVED*** splash The new splash screen of the guild
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the guild's splash screen
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @example
   * // Edit the guild splash
   * guild.setSplash('./splash.png')
   *  .then(console.log)
   *  .catch(console.error);
   */
  setSplash(splash) ***REMOVED***
    return this.client.resolver.resolveImage(splash).then(data => this.edit(***REMOVED*** splash: data ***REMOVED***));
  ***REMOVED***

  /**
   * Sets the position of the guild in the guild listing.
   * <warn>This is only available when using a user account.</warn>
   * @param ***REMOVED***number***REMOVED*** position Absolute or relative position
   * @param ***REMOVED***boolean***REMOVED*** [relative=false] Whether to position relatively or absolutely
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @deprecated
   */
  setPosition(position, relative) ***REMOVED***
    if (this.client.user.bot) ***REMOVED***
      return Promise.reject(new Error('Setting guild position is only available for user accounts'));
    ***REMOVED***
    return this.client.user.settings.setGuildPosition(this, position, relative);
  ***REMOVED***

  /**
   * Marks all messages in this guild as read.
   * <warn>This is only available when using a user account.</warn>
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @deprecated
   */
  acknowledge() ***REMOVED***
    return this.client.rest.methods.ackGuild(this);
  ***REMOVED***

  /**
   * Allow direct messages from guild members.
   * <warn>This is only available when using a user account.</warn>
   * @param ***REMOVED***boolean***REMOVED*** allow Whether to allow direct messages
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @deprecated
   */
  allowDMs(allow) ***REMOVED***
    const settings = this.client.user.settings;
    if (allow) return settings.removeRestrictedGuild(this);
    else return settings.addRestrictedGuild(this);
  ***REMOVED***

  /**
   * Bans a user from the guild.
   * @param ***REMOVED***UserResolvable***REMOVED*** user The user to ban
   * @param ***REMOVED***Object|number|string***REMOVED*** [options] Ban options. If a number, the number of days to delete messages for, if a
   * string, the ban reason. Supplying an object allows you to do both.
   * @param ***REMOVED***number***REMOVED*** [options.days=0] Number of days of messages to delete
   * @param ***REMOVED***string***REMOVED*** [options.reason] Reason for banning
   * @returns ***REMOVED***Promise<GuildMember|User|string>***REMOVED*** Result object will be resolved as specifically as possible.
   * If the GuildMember cannot be resolved, the User will instead be attempted to be resolved. If that also cannot
   * be resolved, the user ID will be the result.
   * @example
   * // Ban a user by ID
   * guild.ban('some user ID')
   *   .then(user => console.log(`Banned $***REMOVED***user.username || user.id || user***REMOVED*** from $***REMOVED***guild***REMOVED***`))
   *   .catch(console.error);
   * @example
   * // Ban a user by object with reason and days
   * guild.ban(user, ***REMOVED*** days: 7, reason: 'He needed to go' ***REMOVED***)
   *   .then(console.log)
   *   .catch(console.error);
   */
  ban(user, options = ***REMOVED******REMOVED***) ***REMOVED***
    if (typeof options === 'number') ***REMOVED***
      options = ***REMOVED*** reason: null, 'delete-message-days': options ***REMOVED***;
    ***REMOVED*** else if (typeof options === 'string') ***REMOVED***
      options = ***REMOVED*** reason: options, 'delete-message-days': 0 ***REMOVED***;
    ***REMOVED***
    if (options.days) options['delete-message-days'] = options.days;
    return this.client.rest.methods.banGuildMember(this, user, options);
  ***REMOVED***

  /**
   * Unbans a user from the guild.
   * @param ***REMOVED***UserResolvable***REMOVED*** user The user to unban
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for unbanning the user
   * @returns ***REMOVED***Promise<User>***REMOVED***
   * @example
   * // Unban a user by ID (or with a user/guild member object)
   * guild.unban('some user ID')
   *   .then(user => console.log(`Unbanned $***REMOVED***user.username***REMOVED*** from $***REMOVED***guild***REMOVED***`))
   *   .catch(console.error);
   */
  unban(user, reason) ***REMOVED***
    return this.client.rest.methods.unbanGuildMember(this, user, reason);
  ***REMOVED***

  /**
   * Prunes members from the guild based on how long they have been inactive.
   * @param ***REMOVED***number***REMOVED*** days Number of days of inactivity required to kick
   * @param ***REMOVED***boolean***REMOVED*** [dry=false] If true, will return number of users that will be kicked, without actually doing it
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for this prune
   * @returns ***REMOVED***Promise<number>***REMOVED*** The number of members that were/will be kicked
   * @example
   * // See how many members will be pruned
   * guild.pruneMembers(12, true)
   *   .then(pruned => console.log(`This will prune $***REMOVED***pruned***REMOVED*** people!`))
   *   .catch(console.error);
   * @example
   * // Actually prune the members
   * guild.pruneMembers(12)
   *   .then(pruned => console.log(`I just pruned $***REMOVED***pruned***REMOVED*** people!`))
   *   .catch(console.error);
   */
  pruneMembers(days, dry = false, reason) ***REMOVED***
    if (typeof days !== 'number') throw new TypeError('Days must be a number.');
    return this.client.rest.methods.pruneGuildMembers(this, days, dry, reason);
  ***REMOVED***

  /**
   * Syncs this guild (already done automatically every 30 seconds).
   * <warn>This is only available when using a user account.</warn>
   * @deprecated
   */
  sync() ***REMOVED***
    if (!this.client.user.bot) this.client.syncGuilds([this]);
  ***REMOVED***

  /**
   * Overwrites to use when creating a channel or replacing overwrites
   * @typedef ***REMOVED***Object***REMOVED*** ChannelCreationOverwrites
   * @property ***REMOVED***PermissionResolvable***REMOVED*** [allow] The permissions to allow
   * @property ***REMOVED***PermissionResolvable***REMOVED*** [allowed] The permissions to allow
   * **(deprecated)**
   * @property ***REMOVED***PermissionResolvable***REMOVED*** [deny] The permissions to deny
   * @property ***REMOVED***PermissionResolvable***REMOVED*** [denied] The permissions to deny
   * **(deprecated)**
   * @property ***REMOVED***GuildMemberResolvable|RoleResolvable***REMOVED*** id Member or role this overwrite is for
   */

  /**
   * Creates a new channel in the guild.
   * @param ***REMOVED***string***REMOVED*** name The name of the new channel
   * @param ***REMOVED***string|ChannelData***REMOVED*** [typeOrOptions='text']
   * The type of the new channel, one of `text`, `voice`, `category`, `news`, or `store`. **(deprecated, use options)**
   * Alternatively options for the new channel, overriding the following parameters.
   * @param ***REMOVED***ChannelCreationOverwrites[]|Collection<Snowflake, PermissionOverwrites>***REMOVED*** [permissionOverwrites]
   * Permission overwrites **(deprecated, use options)**
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for creating this channel **(deprecated, use options)**
   * @returns ***REMOVED***Promise<CategoryChannel|TextChannel|VoiceChannel>***REMOVED***
   * @example
   * // Create a new text channel
   * guild.createChannel('new-general', ***REMOVED*** type: 'text' ***REMOVED***)
   *   .then(console.log)
   *   .catch(console.error);
   * @example
   * // Create a new category channel with permission overwrites
   * guild.createChannel('new-category', ***REMOVED***
   *   type: 'category',
   *   permissionOverwrites: [***REMOVED***
   *     id: guild.id,
   *     deny: ['MANAGE_MESSAGES'],
   *     allow: ['SEND_MESSAGES']
   *   ***REMOVED***]
   * ***REMOVED***)
   *   .then(console.log)
   *   .catch(console.error);
   */
  createChannel(name, typeOrOptions, permissionOverwrites, reason) ***REMOVED***
    if (!typeOrOptions || (typeof typeOrOptions === 'string')) ***REMOVED***
      if (typeOrOptions) ***REMOVED***
        process.emitWarning(
          'Guild#createChannel: Create channels with an options object instead of separate parameters',
          'DeprecationWarning'
        );
      ***REMOVED***
      typeOrOptions = ***REMOVED***
        type: typeOrOptions,
        permissionOverwrites,
        reason,
      ***REMOVED***;
    ***REMOVED***
    return this.client.rest.methods.createChannel(this, name, typeOrOptions);
  ***REMOVED***

  /**
   * The data needed for updating a channel's position.
   * @typedef ***REMOVED***Object***REMOVED*** ChannelPosition
   * @property ***REMOVED***ChannelResolvable***REMOVED*** channel Channel to update
   * @property ***REMOVED***number***REMOVED*** position New position for the channel
   */

  /**
   * Batch-updates the guild's channels' positions.
   * @param ***REMOVED***ChannelPosition[]***REMOVED*** channelPositions Channel positions to update
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @example
   * guild.updateChannels([***REMOVED*** channel: channelID, position: newChannelIndex ***REMOVED***])
   *   .then(g => console.log(`Updated channel positions for $***REMOVED***g***REMOVED***`))
   *   .catch(console.error);
   */
  setChannelPositions(channelPositions) ***REMOVED***
    channelPositions = channelPositions.map((***REMOVED*** channel, position ***REMOVED***) => (***REMOVED*** id: channel.id || channel, position ***REMOVED***));
    return this.client.rest.methods.setChannelPositions(this.id, channelPositions);
  ***REMOVED***

  /**
   * The data needed for updating a role's position.
   * @typedef ***REMOVED***Object***REMOVED*** RolePosition
   * @property ***REMOVED***RoleResolvable***REMOVED*** role Role to update
   * @property ***REMOVED***number***REMOVED*** position New position for the role
   */

  /**
   * Batch-updates the guild's role's positions.
   * @param ***REMOVED***RolePosition[]***REMOVED*** rolePositions Role positions to update
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   */
  setRolePositions(rolePositions) ***REMOVED***
    rolePositions = rolePositions.map((***REMOVED*** role, position ***REMOVED***) => (***REMOVED*** id: role.id || role, position ***REMOVED***));
    return this.client.rest.methods.setRolePositions(this.id, rolePositions);
  ***REMOVED***

  /**
   * Edits the guild's embed.
   * @param ***REMOVED***GuildEmbedData***REMOVED*** embed The embed for the guild
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the guild's embed
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   */
  setEmbed(embed, reason) ***REMOVED***
    return this.client.rest.methods.updateEmbed(this.id, embed, reason)
      .then(() => this);
  ***REMOVED***

  /**
   * Creates a new role in the guild with given information.
   * @param ***REMOVED***RoleData***REMOVED*** [data] The data to update the role with
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for creating this role
   * @returns ***REMOVED***Promise<Role>***REMOVED***
   * @example
   * // Create a new role
   * guild.createRole()
   *   .then(role => console.log(`Created new role with name $***REMOVED***role.name***REMOVED***`))
   *   .catch(console.error);
   * @example
   * // Create a new role with data
   * guild.createRole(***REMOVED***
   *   name: 'Super Cool People',
   *   color: 'BLUE',
   * ***REMOVED***)
   *   .then(role => console.log(`Created new role with name $***REMOVED***role.name***REMOVED*** and color $***REMOVED***role.color***REMOVED***`))
   *   .catch(console.error)
   */
  createRole(data = ***REMOVED******REMOVED***, reason) ***REMOVED***
    return this.client.rest.methods.createGuildRole(this, data, reason);
  ***REMOVED***

  /**
   * Creates a new custom emoji in the guild.
   * @param ***REMOVED***BufferResolvable|Base64Resolvable***REMOVED*** attachment The image for the emoji
   * @param ***REMOVED***string***REMOVED*** name The name for the emoji
   * @param ***REMOVED***Collection<Snowflake, Role>|Role[]***REMOVED*** [roles] Roles to limit the emoji to
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for creating the emoji
   * @returns ***REMOVED***Promise<Emoji>***REMOVED*** The created emoji
   * @example
   * // Create a new emoji from a url
   * guild.createEmoji('https://i.imgur.com/w3duR07.png', 'rip')
   *   .then(emoji => console.log(`Created new emoji with name $***REMOVED***emoji.name***REMOVED***`))
   *   .catch(console.error);
   * @example
   * // Create a new emoji from a file on your computer
   * guild.createEmoji('./memes/banana.png', 'banana')
   *   .then(emoji => console.log(`Created new emoji with name $***REMOVED***emoji.name***REMOVED***`))
   *   .catch(console.error);
   */
  createEmoji(attachment, name, roles, reason) ***REMOVED***
    if (typeof attachment === 'string' && attachment.startsWith('data:')) ***REMOVED***
      return this.client.rest.methods.createEmoji(this, attachment, name, roles, reason);
    ***REMOVED*** else ***REMOVED***
      return this.client.resolver.resolveImage(attachment).then(data =>
        this.client.rest.methods.createEmoji(this, data, name, roles, reason)
      );
    ***REMOVED***
  ***REMOVED***

  /**
   * Delete an emoji.
   * @param ***REMOVED***Emoji|string***REMOVED*** emoji The emoji to delete
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for deleting the emoji
   * @returns ***REMOVED***Promise***REMOVED***
   * @deprecated
   */
  deleteEmoji(emoji, reason) ***REMOVED***
    if (typeof emoji === 'string') emoji = this.emojis.get(emoji);
    if (!(emoji instanceof Emoji)) throw new TypeError('Emoji must be either an instance of Emoji or an ID');
    return emoji.delete(reason);
  ***REMOVED***

  /**
   * Causes the client to leave the guild.
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @example
   * // Leave a guild
   * guild.leave()
   *   .then(g => console.log(`Left the guild $***REMOVED***g***REMOVED***`))
   *   .catch(console.error);
   */
  leave() ***REMOVED***
    return this.client.rest.methods.leaveGuild(this);
  ***REMOVED***

  /**
   * Causes the client to delete the guild.
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   * @example
   * // Delete a guild
   * guild.delete()
   *   .then(g => console.log(`Deleted the guild $***REMOVED***g***REMOVED***`))
   *   .catch(console.error);
   */
  delete() ***REMOVED***
    return this.client.rest.methods.deleteGuild(this);
  ***REMOVED***

  /**
   * Whether this guild equals another guild. It compares all properties, so for most operations
   * it is advisable to just compare `guild.id === guild2.id` as it is much faster and is often
   * what most users need.
   * @param ***REMOVED***Guild***REMOVED*** guild The guild to compare with
   * @returns ***REMOVED***boolean***REMOVED***
   */
  equals(guild) ***REMOVED***
    let equal =
      guild &&
      this.id === guild.id &&
      this.available === !guild.unavailable &&
      this.splash === guild.splash &&
      this.region === guild.region &&
      this.name === guild.name &&
      this.memberCount === guild.member_count &&
      this.large === guild.large &&
      this.icon === guild.icon &&
      Util.arraysEqual(this.features, guild.features) &&
      this.ownerID === guild.owner_id &&
      this.verificationLevel === guild.verification_level &&
      this.embedEnabled === guild.embed_enabled;

    if (equal) ***REMOVED***
      if (this.embedChannel) ***REMOVED***
        if (this.embedChannel.id !== guild.embed_channel_id) equal = false;
      ***REMOVED*** else if (guild.embed_channel_id) ***REMOVED***
        equal = false;
      ***REMOVED***
    ***REMOVED***

    return equal;
  ***REMOVED***

  /**
   * When concatenated with a string, this automatically concatenates the guild's name instead of the guild object.
   * @returns ***REMOVED***string***REMOVED***
   * @example
   * // Logs: Hello from My Guild!
   * console.log(`Hello from $***REMOVED***guild***REMOVED***!`);
   * @example
   * // Logs: Hello from My Guild!
   * console.log('Hello from ' + guild + '!');
   */
  toString() ***REMOVED***
    return this.name;
  ***REMOVED***

  _addMember(guildUser, emitEvent = true) ***REMOVED***
    const existing = this.members.has(guildUser.user.id);
    if (!(guildUser.user instanceof User)) guildUser.user = this.client.dataManager.newUser(guildUser.user);

    guildUser.joined_at = guildUser.joined_at || 0;
    const member = new GuildMember(this, guildUser);
    this.members.set(member.id, member);

    if (this._rawVoiceStates && this._rawVoiceStates.has(member.user.id)) ***REMOVED***
      const voiceState = this._rawVoiceStates.get(member.user.id);
      member.serverMute = voiceState.mute;
      member.serverDeaf = voiceState.deaf;
      member.selfMute = voiceState.self_mute;
      member.selfDeaf = voiceState.self_deaf;
      member.selfStream = voiceState.self_stream || false;
      member.voiceSessionID = voiceState.session_id;
      member.voiceChannelID = voiceState.channel_id;
      if (this.client.channels.has(voiceState.channel_id)) ***REMOVED***
        this.client.channels.get(voiceState.channel_id).members.set(member.user.id, member);
      ***REMOVED*** else ***REMOVED***
        this.client.emit('warn', `Member $***REMOVED***member.id***REMOVED*** added in guild $***REMOVED***this.id***REMOVED*** with an uncached voice channel`);
      ***REMOVED***
    ***REMOVED***

    /**
     * Emitted whenever a user joins a guild.
     * @event Client#guildMemberAdd
     * @param ***REMOVED***GuildMember***REMOVED*** member The member that has joined a guild
     */
    if (this.client.ws.connection.status === Constants.Status.READY && emitEvent && !existing) ***REMOVED***
      this.client.emit(Constants.Events.GUILD_MEMBER_ADD, member);
    ***REMOVED***

    return member;
  ***REMOVED***

  _updateMember(member, data) ***REMOVED***
    const oldMember = Util.cloneObject(member);

    if (data.premium_since) member.premiumSinceTimestamp = new Date(data.premium_since).getTime();
    if (data.roles) member._roles = data.roles;
    if (typeof data.nick !== 'undefined') member.nickname = data.nick;

    const notSame = member.nickname !== oldMember.nickname ||
    member.premiumSinceTimestamp !== oldMember.premiumSinceTimestamp ||
    !Util.arraysEqual(member._roles, oldMember._roles);

    if (this.client.ws.connection.status === Constants.Status.READY && notSame) ***REMOVED***
      /**
       * Emitted whenever a guild member changes - i.e. new role, removed role, nickname.
       * @event Client#guildMemberUpdate
       * @param ***REMOVED***GuildMember***REMOVED*** oldMember The member before the update
       * @param ***REMOVED***GuildMember***REMOVED*** newMember The member after the update
       */
      this.client.emit(Constants.Events.GUILD_MEMBER_UPDATE, oldMember, member);
    ***REMOVED***

    return ***REMOVED***
      old: oldMember,
      mem: member,
    ***REMOVED***;
  ***REMOVED***

  _removeMember(guildMember) ***REMOVED***
    if (guildMember.voiceChannel) guildMember.voiceChannel.members.delete(guildMember.id);
    this.members.delete(guildMember.id);
  ***REMOVED***

  _memberSpeakUpdate(user, speaking) ***REMOVED***
    const member = this.members.get(user);
    if (member && member.speaking !== speaking) ***REMOVED***
      member.speaking = speaking;
      /**
       * Emitted once a guild member starts/stops speaking.
       * @event Client#guildMemberSpeaking
       * @param ***REMOVED***GuildMember***REMOVED*** member The member that started/stopped speaking
       * @param ***REMOVED***boolean***REMOVED*** speaking Whether or not the member is speaking
       */
      this.client.emit(Constants.Events.GUILD_MEMBER_SPEAKING, member, speaking);
    ***REMOVED***
  ***REMOVED***

  _setPresence(id, presence) ***REMOVED***
    if (this.presences.get(id)) ***REMOVED***
      this.presences.get(id).update(presence);
      return;
    ***REMOVED***
    this.presences.set(id, new Presence(presence, this.client));
  ***REMOVED***

  /**
   * Set the position of a role in this guild.
   * @param ***REMOVED***string|Role***REMOVED*** role The role to edit, can be a role object or a role ID
   * @param ***REMOVED***number***REMOVED*** position The new position of the role
   * @param ***REMOVED***boolean***REMOVED*** [relative=false] Position Moves the role relative to its current position
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   */
  setRolePosition(role, position, relative = false) ***REMOVED***
    if (typeof role === 'string') ***REMOVED***
      role = this.roles.get(role);
      if (!role) return Promise.reject(new Error('Supplied role is not a role or snowflake.'));
    ***REMOVED***

    position = Number(position);
    if (isNaN(position)) return Promise.reject(new Error('Supplied position is not a number.'));

    let updatedRoles = this._sortedRoles.array();

    Util.moveElementInArray(updatedRoles, role, position, relative);

    updatedRoles = updatedRoles.map((r, i) => (***REMOVED*** id: r.id, position: i ***REMOVED***));
    return this.client.rest.methods.setRolePositions(this.id, updatedRoles);
  ***REMOVED***

  /**
   * Set the position of a channel in this guild.
   * @param ***REMOVED***string|GuildChannel***REMOVED*** channel The channel to edit, can be a channel object or a channel ID
   * @param ***REMOVED***number***REMOVED*** position The new position of the channel
   * @param ***REMOVED***boolean***REMOVED*** [relative=false] Position Moves the channel relative to its current position
   * @returns ***REMOVED***Promise<Guild>***REMOVED***
   */
  setChannelPosition(channel, position, relative = false) ***REMOVED***
    if (typeof channel === 'string') ***REMOVED***
      channel = this.channels.get(channel);
      if (!channel) return Promise.reject(new Error('Supplied channel is not a channel or snowflake.'));
    ***REMOVED***

    position = Number(position);
    if (isNaN(position)) return Promise.reject(new Error('Supplied position is not a number.'));

    let updatedChannels = this._sortedChannels(channel.type).array();

    Util.moveElementInArray(updatedChannels, channel, position, relative);

    updatedChannels = updatedChannels.map((c, i) => (***REMOVED*** id: c.id, position: i ***REMOVED***));
    return this.client.rest.methods.setChannelPositions(this.id, updatedChannels);
  ***REMOVED***

  /**
   * Fetches a collection of channels in the current guild sorted by position.
   * @param ***REMOVED***string***REMOVED*** type The channel type
   * @returns ***REMOVED***Collection<Snowflake, GuildChannel>***REMOVED***
   * @private
   */
  _sortedChannels(type) ***REMOVED***
    return this._sortPositionWithID(this.channels.filter(c => ***REMOVED***
      if (type === 'voice' && c.type === 'voice') return true;
      else if (type !== 'voice' && c.type !== 'voice') return true;
      else return type === c.type;
    ***REMOVED***));
  ***REMOVED***

  /**
   * Sorts a collection by object position or ID if the positions are equivalent.
   * Intended to be identical to Discord's sorting method.
   * @param ***REMOVED***Collection***REMOVED*** collection The collection to sort
   * @returns ***REMOVED***Collection***REMOVED***
   * @private
   */
  _sortPositionWithID(collection) ***REMOVED***
    return collection.sort((a, b) =>
      a.position !== b.position ?
        a.position - b.position :
        Long.fromString(b.id).sub(Long.fromString(a.id)).toNumber()
    );
  ***REMOVED***
***REMOVED***

/**
 * The `#general` TextChannel of the guild
 * @name Guild#defaultChannel
 * @type ***REMOVED***TextChannel***REMOVED***
 * @readonly
 * @deprecated
 */
Object.defineProperty(Guild.prototype, 'defaultChannel', ***REMOVED***
  get: util.deprecate(function defaultChannel() ***REMOVED***
    return this.channels.get(this.id);
  ***REMOVED***, 'Guild#defaultChannel: This property is obsolete, will be removed in v12.0.0, and may not function as expected.'),
***REMOVED***);

Guild.prototype.allowDMs =
  util.deprecate(Guild.prototype.allowDMs, 'Guild#allowDMs: userbot methods will be removed');

Guild.prototype.acknowledge =
  util.deprecate(Guild.prototype.acknowledge, 'Guild#acknowledge: userbot methods will be removed');

Guild.prototype.setPosition =
  util.deprecate(Guild.prototype.setPosition, 'Guild#setPosition: userbot methods will be removed');

Guild.prototype.search =
  util.deprecate(Guild.prototype.search, 'Guild#search: userbot methods will be removed');

Guild.prototype.sync =
  util.deprecate(Guild.prototype.sync, 'Guild#sync:, userbot methods will be removed');

Guild.prototype.deleteEmoji =
  util.deprecate(Guild.prototype.deleteEmoji, 'Guild#deleteEmoji: use Emoji#delete instead');

module.exports = Guild;
