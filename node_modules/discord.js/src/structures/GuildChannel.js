const Channel = require('./Channel');
const Role = require('./Role');
const PermissionOverwrites = require('./PermissionOverwrites');
const Permissions = require('../util/Permissions');
const Collection = require('../util/Collection');
const Constants = require('../util/Constants');
const Invite = require('./Invite');
const Util = require('../util/Util');

/**
 * Represents a guild channel (i.e. text channels and voice channels).
 * @extends ***REMOVED***Channel***REMOVED***
 */
class GuildChannel extends Channel ***REMOVED***
  constructor(guild, data) ***REMOVED***
    super(guild.client, data);

    /**
     * The guild the channel is in
     * @type ***REMOVED***Guild***REMOVED***
     */
    this.guild = guild;
  ***REMOVED***

  setup(data) ***REMOVED***
    super.setup(data);

    /**
     * The name of the guild channel
     * @type ***REMOVED***string***REMOVED***
     */
    this.name = data.name;

    /**
     * The position of the channel in the list
     * @type ***REMOVED***number***REMOVED***
     */
    this.position = data.position;

    /**
     * The ID of the category parent of this channel
     * @type ***REMOVED***?Snowflake***REMOVED***
     */
    this.parentID = data.parent_id;

    /**
     * A map of permission overwrites in this channel for roles and users
     * @type ***REMOVED***Collection<Snowflake, PermissionOverwrites>***REMOVED***
     */
    this.permissionOverwrites = new Collection();
    if (data.permission_overwrites) ***REMOVED***
      for (const overwrite of data.permission_overwrites) ***REMOVED***
        this.permissionOverwrites.set(overwrite.id, new PermissionOverwrites(this, overwrite));
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  /**
   * The position of the channel
   * @type ***REMOVED***number***REMOVED***
   * @readonly
   */
  get calculatedPosition() ***REMOVED***
    const sorted = this.guild._sortedChannels(this.type);
    return sorted.array().indexOf(sorted.get(this.id));
  ***REMOVED***

  /**
   * The category parent of this channel
   * @type ***REMOVED***?CategoryChannel***REMOVED***
   * @readonly
   */
  get parent() ***REMOVED***
    return this.guild.channels.get(this.parentID) || null;
  ***REMOVED***

  /**
   * If the permissionOverwrites match the parent channel, null if no parent
   * @type ***REMOVED***?boolean***REMOVED***
   * @readonly
   */
  get permissionsLocked() ***REMOVED***
    if (!this.parent) return null;
    if (this.permissionOverwrites.size !== this.parent.permissionOverwrites.size) return false;
    return this.permissionOverwrites.every((value, key) => ***REMOVED***
      const testVal = this.parent.permissionOverwrites.get(key);
      return testVal !== undefined &&
        testVal.deny === value.deny &&
        testVal.allow === value.allow;
    ***REMOVED***);
  ***REMOVED***

  /**
   * Gets the overall set of permissions for a user in this channel, taking into account channel overwrites.
   * @param ***REMOVED***GuildMemberResolvable***REMOVED*** member The user that you want to obtain the overall permissions for
   * @returns ***REMOVED***?Permissions***REMOVED***
   */
  memberPermissions(member) ***REMOVED***
    member = this.client.resolver.resolveGuildMember(this.guild, member);
    if (!member) return null;

    if (member.id === this.guild.ownerID) return new Permissions(member, Permissions.ALL);

    const roles = member.roles;
    const permissions = new Permissions(roles.map(role => role.permissions));

    if (permissions.has(Permissions.FLAGS.ADMINISTRATOR)) return new Permissions(Permissions.ALL).freeze();

    const overwrites = this.overwritesFor(member, true, roles);

    return permissions
      .remove(overwrites.everyone ? overwrites.everyone.deny : 0)
      .add(overwrites.everyone ? overwrites.everyone.allow : 0)
      .remove(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.deny) : 0)
      .add(overwrites.roles.length > 0 ? overwrites.roles.map(role => role.allow) : 0)
      .remove(overwrites.member ? overwrites.member.deny : 0)
      .add(overwrites.member ? overwrites.member.allow : 0)
      .freeze();
  ***REMOVED***

  /**
   * Gets the overall set of permissions for a role in this channel, taking into account channel overwrites.
   * @param ***REMOVED***RoleResolvable***REMOVED*** role The role that you want to obtain the overall permissions for
   * @returns ***REMOVED***?Permissions***REMOVED***
   */
  rolePermissions(role) ***REMOVED***
    if (role.permissions & Permissions.FLAGS.ADMINISTRATOR) return new Permissions(Permissions.ALL).freeze();

    const everyoneOverwrites = this.permissionOverwrites.get(this.guild.id);
    const roleOverwrites = this.permissionOverwrites.get(role.id);

    return new Permissions(role.permissions)
      .remove(everyoneOverwrites ? everyoneOverwrites.deny : 0)
      .add(everyoneOverwrites ? everyoneOverwrites.allow : 0)
      .remove(roleOverwrites ? roleOverwrites.deny : 0)
      .add(roleOverwrites ? roleOverwrites.allow : 0)
      .freeze();
  ***REMOVED***

  /**
   * Get the overall set of permissions for a member or role in this channel, taking into account channel overwrites.
   * @param ***REMOVED***GuildMemberResolvable|RoleResolvable***REMOVED*** memberOrRole The member or role to obtain the overall permissions for
   * @returns ***REMOVED***?Permissions***REMOVED***
   */
  permissionsFor(memberOrRole) ***REMOVED***
    const member = this.guild.member(memberOrRole);
    if (member) return this.memberPermissions(member);
    const role = this.client.resolver.resolveRole(this.guild, memberOrRole);
    if (role) return this.rolePermissions(role);
    return null;
  ***REMOVED***

  overwritesFor(member, verified = false, roles = null) ***REMOVED***
    if (!verified) member = this.client.resolver.resolveGuildMember(this.guild, member);
    if (!member) return [];

    roles = roles || member.roles;
    const roleOverwrites = [];
    let memberOverwrites;
    let everyoneOverwrites;

    for (const overwrite of this.permissionOverwrites.values()) ***REMOVED***
      if (overwrite.id === this.guild.id) ***REMOVED***
        everyoneOverwrites = overwrite;
      ***REMOVED*** else if (roles.has(overwrite.id)) ***REMOVED***
        roleOverwrites.push(overwrite);
      ***REMOVED*** else if (overwrite.id === member.id) ***REMOVED***
        memberOverwrites = overwrite;
      ***REMOVED***
    ***REMOVED***

    return ***REMOVED***
      everyone: everyoneOverwrites,
      roles: roleOverwrites,
      member: memberOverwrites,
    ***REMOVED***;
  ***REMOVED***

  /**
   * Replaces the permission overwrites for a channel
   * @param ***REMOVED***Object***REMOVED*** [options] Options
   * @param ***REMOVED***ChannelCreationOverwrites[]|Collection<Snowflake, PermissionOverwrites>***REMOVED*** [options.overwrites]
   * Permission overwrites
   * @param ***REMOVED***string***REMOVED*** [options.reason] Reason for updating the channel overwrites
   * @returns ***REMOVED***Promise<GuildChannel>***REMOVED***
   * @example
   * channel.replacePermissionOverwrites(***REMOVED***
   * overwrites: [
   *   ***REMOVED***
   *      id: message.author.id,
   *      denied: ['VIEW_CHANNEL'],
   *   ***REMOVED***,
   * ],
   *   reason: 'Needed to change permissions'
   * ***REMOVED***);
   */
  replacePermissionOverwrites(***REMOVED*** overwrites, reason ***REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
    return this.edit(***REMOVED*** permissionOverwrites: overwrites, reason ***REMOVED***)
      .then(() => this);
  ***REMOVED***

  /**
   * An object mapping permission flags to `true` (enabled), `null` (unset) or `false` (disabled).
   * ```js
   * ***REMOVED***
   *  'SEND_MESSAGES': true,
   *  'EMBED_LINKS': null,
   *  'ATTACH_FILES': false,
   * ***REMOVED***
   * ```
   * @typedef ***REMOVED***Object***REMOVED*** PermissionOverwriteOptions
   */

  /**
   * Overwrites the permissions for a user or role in this channel.
   * @param ***REMOVED***Role|Snowflake|UserResolvable***REMOVED*** userOrRole The user or role to update
   * @param ***REMOVED***PermissionOverwriteOptions***REMOVED*** options The configuration for the update
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for creating/editing this overwrite
   * @returns ***REMOVED***Promise<GuildChannel>***REMOVED***
   * @example
   * // Overwrite permissions for a message author
   * message.channel.overwritePermissions(message.author, ***REMOVED***
   *   SEND_MESSAGES: false
   * ***REMOVED***)
   *   .then(updated => console.log(updated.permissionOverwrites.get(message.author.id)))
   *   .catch(console.error);
   * @example
   * // Overwite permissions for a message author and reset some
   * message.channel.overwritePermissions(message.author, ***REMOVED***
   *   VIEW_CHANNEL: false,
   *   SEND_MESSAGES: null
   * ***REMOVED***)
   *   .then(updated => console.log(updated.permissionOverwrites.get(message.author.id)))
   *   .catch(console.error);
   */
  overwritePermissions(userOrRole, options, reason) ***REMOVED***
    const payload = ***REMOVED***
      allow: 0,
      deny: 0,
    ***REMOVED***;

    if (userOrRole instanceof Role) ***REMOVED***
      payload.type = 'role';
    ***REMOVED*** else if (this.guild.roles.has(userOrRole)) ***REMOVED***
      userOrRole = this.guild.roles.get(userOrRole);
      payload.type = 'role';
    ***REMOVED*** else ***REMOVED***
      userOrRole = this.client.resolver.resolveUser(userOrRole);
      payload.type = 'member';
      if (!userOrRole) return Promise.reject(new TypeError('Supplied parameter was neither a User nor a Role.'));
    ***REMOVED***

    payload.id = userOrRole.id;

    const prevOverwrite = this.permissionOverwrites.get(userOrRole.id);

    if (prevOverwrite) ***REMOVED***
      payload.allow = prevOverwrite.allow;
      payload.deny = prevOverwrite.deny;
    ***REMOVED***

    for (const perm of Object.keys(options)) ***REMOVED***
      if (options[perm] === true) ***REMOVED***
        payload.allow |= Permissions.FLAGS[perm] || 0;
        payload.deny &= ~(Permissions.FLAGS[perm] || 0);
      ***REMOVED*** else if (options[perm] === false) ***REMOVED***
        payload.allow &= ~(Permissions.FLAGS[perm] || 0);
        payload.deny |= Permissions.FLAGS[perm] || 0;
      ***REMOVED*** else if (options[perm] === null) ***REMOVED***
        payload.allow &= ~(Permissions.FLAGS[perm] || 0);
        payload.deny &= ~(Permissions.FLAGS[perm] || 0);
      ***REMOVED***
    ***REMOVED***

    return this.client.rest.methods.setChannelOverwrite(this, payload, reason).then(() => this);
  ***REMOVED***

  /**
   * Locks in the permission overwrites from the parent channel.
   * @returns ***REMOVED***Promise<GuildChannel>***REMOVED***
   */
  lockPermissions() ***REMOVED***
    if (!this.parent) return Promise.reject(new TypeError('Could not find a parent to this guild channel.'));
    const permissionOverwrites = this.parent.permissionOverwrites.map(overwrite => (***REMOVED***
      deny: overwrite.deny,
      allow: overwrite.allow,
      id: overwrite.id,
      type: overwrite.type,
    ***REMOVED***));
    return this.edit(***REMOVED*** permissionOverwrites ***REMOVED***);
  ***REMOVED***

  /**
   * The data for a guild channel.
   * @typedef ***REMOVED***Object***REMOVED*** ChannelData
   * @property ***REMOVED***string***REMOVED*** [type] The type of the channel (Only when creating)
   * @property ***REMOVED***string***REMOVED*** [name] The name of the channel
   * @property ***REMOVED***number***REMOVED*** [position] The position of the channel
   * @property ***REMOVED***string***REMOVED*** [topic] The topic of the text channel
   * @property ***REMOVED***boolean***REMOVED*** [nsfw] Whether the channel is NSFW
   * @property ***REMOVED***number***REMOVED*** [bitrate] The bitrate of the voice channel
   * @property ***REMOVED***number***REMOVED*** [userLimit] The user limit of the channel
   * @property ***REMOVED***CategoryChannel|Snowflake***REMOVED*** [parent] The parent or parent ID of the channel
   * @property ***REMOVED***ChannelCreationOverwrites[]|Collection<Snowflake, PermissionOverwrites>***REMOVED*** [permissionOverwrites]
   * Overwrites of the channel
   * @property ***REMOVED***number***REMOVED*** [rateLimitPerUser] The rate limit per user of the channel in seconds
   * @property ***REMOVED***string***REMOVED*** [reason] Reason for creating the channel (Only when creating)
   */

  /**
   * Edits the channel.
   * @param ***REMOVED***ChannelData***REMOVED*** data The new data for the channel
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for editing this channel
   * @returns ***REMOVED***Promise<GuildChannel>***REMOVED***
   * @example
   * // Edit a channel
   * channel.edit(***REMOVED*** name: 'new-channel' ***REMOVED***)
   *   .then(console.log)
   *   .catch(console.error);
   */
  edit(data, reason) ***REMOVED***
    return this.client.rest.methods.updateChannel(this, data, reason).then(() => this);
  ***REMOVED***

  /**
   * Set a new name for the guild channel.
   * @param ***REMOVED***string***REMOVED*** name The new name for the guild channel
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the guild channel's name
   * @returns ***REMOVED***Promise<GuildChannel>***REMOVED***
   * @example
   * // Set a new channel name
   * channel.setName('not_general')
   *   .then(newChannel => console.log(`Channel's new name is $***REMOVED***newChannel.name***REMOVED***`))
   *   .catch(console.error);
   */
  setName(name, reason) ***REMOVED***
    return this.edit(***REMOVED*** name ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Set a new position for the guild channel.
   * @param ***REMOVED***number***REMOVED*** position The new position for the guild channel
   * @param ***REMOVED***boolean***REMOVED*** [relative=false] Move the position relative to its current value
   * @returns ***REMOVED***Promise<GuildChannel>***REMOVED***
   * @example
   * // Set a new channel position
   * channel.setPosition(2)
   *   .then(newChannel => console.log(`Channel's new position is $***REMOVED***newChannel.position***REMOVED***`))
   *   .catch(console.error);
   */
  setPosition(position, relative) ***REMOVED***
    return this.guild.setChannelPosition(this, position, relative).then(() => this);
  ***REMOVED***

  /**
   * Set a new parent for the guild channel.
   * @param ***REMOVED***CategoryChannel|SnowFlake***REMOVED*** parent The new parent for the guild channel
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the guild channel's parent
   * @returns ***REMOVED***Promise<GuildChannel>***REMOVED***
   * @example
   * // Sets the parent of a channel
   * channel.setParent('174674066072928256')
   *   .then(updated => console.log(`Set the category of $***REMOVED***updated.name***REMOVED*** to $***REMOVED***updated.parent.name***REMOVED***`))
   *   .catch(console.error);
   */
  setParent(parent, reason) ***REMOVED***
    parent = this.client.resolver.resolveChannelID(parent);
    return this.edit(***REMOVED*** parent ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Set a new topic for the guild channel.
   * @param ***REMOVED***string***REMOVED*** topic The new topic for the guild channel
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for changing the guild channel's topic
   * @returns ***REMOVED***Promise<GuildChannel>***REMOVED***
   * @example
   * // Set a new channel topic
   * channel.setTopic('Needs more rate limiting')
   *   .then(updated => console.log(`Channel's new topic is $***REMOVED***updated.topic***REMOVED***`))
   *   .catch(console.error);
   */
  setTopic(topic, reason) ***REMOVED***
    return this.edit(***REMOVED*** topic ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Create an invite to this guild channel.
   * <warn>This is only available when using a bot account.</warn>
   * @param ***REMOVED***Object***REMOVED*** [options=***REMOVED******REMOVED***] Options for the invite
   * @param ***REMOVED***boolean***REMOVED*** [options.temporary=false] Whether members that joined via the invite should be automatically
   * kicked after 24 hours if they have not yet received a role
   * @param ***REMOVED***number***REMOVED*** [options.maxAge=86400] How long the invite should last (in seconds, 0 for forever)
   * @param ***REMOVED***number***REMOVED*** [options.maxUses=0] Maximum number of uses
   * @param ***REMOVED***boolean***REMOVED*** [options.unique=false] Create a unique invite, or use an existing one with similar settings
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for creating the invite
   * @returns ***REMOVED***Promise<Invite>***REMOVED***
   * @example
   * // Create an invite to a channel
   * channel.createInvite()
   *   .then(invite => console.log(`Created an invite with a code of $***REMOVED***invite.code***REMOVED***`))
   *   .catch(console.error);
   */
  createInvite(options = ***REMOVED******REMOVED***, reason) ***REMOVED***
    return this.client.rest.methods.createChannelInvite(this, options, reason);
  ***REMOVED***

  /* eslint-disable max-len */
  /**
   * Options to clone a guild channel.
   * @typedef ***REMOVED***Object***REMOVED*** GuildChannelCloneOptions
   * @property ***REMOVED***string***REMOVED*** [name=this.name] Name of the new channel
   * @property ***REMOVED***ChannelCreationOverwrites[]|Collection<Snowflake, PermissionOverwrites>***REMOVED*** [permissionOverwrites=this.permissionOverwrites]
   * Permission overwrites of the new channel
   * @property ***REMOVED***string***REMOVED*** [type=this.type] Type of the new channel
   * @property ***REMOVED***string***REMOVED*** [topic=this.topic] Topic of the new channel (only text)
   * @property ***REMOVED***boolean***REMOVED*** [nsfw=this.nsfw] Whether the new channel is nsfw (only text)
   * @property ***REMOVED***number***REMOVED*** [bitrate=this.bitrate] Bitrate of the new channel in bits (only voice)
   * @property ***REMOVED***number***REMOVED*** [userLimit=this.userLimit] Maximum amount of users allowed in the new channel (only voice)
   * @property ***REMOVED***number***REMOVED*** [rateLimitPerUser=ThisType.rateLimitPerUser] Ratelimit per user for the new channel (only text)
   * @property ***REMOVED***ChannelResolvable***REMOVED*** [parent=this.parent] Parent of the new channel
   * @property ***REMOVED***string***REMOVED*** [reason] Reason for cloning this channel
   */
  /* eslint-enable max-len */

  /**
   * Clone this channel.
   * @param ***REMOVED***string|GuildChannelCloneOptions***REMOVED*** [nameOrOptions=***REMOVED******REMOVED***] Name for the new channel.
   * **(deprecated, use options)**
   * Alternatively options for cloning the channel
   * @param ***REMOVED***boolean***REMOVED*** [withPermissions=true] Whether to clone the channel with this channel's permission overwrites
   * **(deprecated, use options)**
   * @param ***REMOVED***boolean***REMOVED*** [withTopic=true] Whether to clone the channel with this channel's topic
   * **(deprecated, use options)**
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for cloning this channel **(deprecated, user options)**
   * @returns ***REMOVED***Promise<GuildChannel>***REMOVED***
   * @example
   * // Clone a channel
   * channel.clone(***REMOVED*** topic: null, reason: 'Needed a clone' ***REMOVED***)
   *   .then(clone => console.log(`Cloned $***REMOVED***channel.name***REMOVED*** to make a channel called $***REMOVED***clone.name***REMOVED***`))
   *   .catch(console.error);
   */
  clone(nameOrOptions = ***REMOVED******REMOVED***, withPermissions = true, withTopic = true, reason) ***REMOVED***
    // If more than one parameter was specified or the first is a string,
    // convert them to a compatible options object and issue a warning
    if (arguments.length > 1 || typeof nameOrOptions === 'string') ***REMOVED***
      process.emitWarning(
        'GuildChannel#clone: Clone channels using an options object instead of separate parameters.',
        'Deprecation Warning'
      );

      nameOrOptions = ***REMOVED***
        name: nameOrOptions,
        permissionOverwrites: withPermissions ? this.permissionOverwrites : null,
        topic: withTopic ? this.topic : null,
        reason: reason || null,
      ***REMOVED***;
    ***REMOVED***

    Util.mergeDefault(***REMOVED***
      name: this.name,
      permissionOverwrites: this.permissionOverwrites,
      topic: this.topic,
      type: this.type,
      nsfw: this.nsfw,
      parent: this.parent,
      bitrate: this.bitrate,
      userLimit: this.userLimit,
      rateLimitPerUser: this.rateLimitPerUser,
      reason: null,
    ***REMOVED***, nameOrOptions);

    return this.guild.createChannel(nameOrOptions.name, nameOrOptions);
  ***REMOVED***

  /**
   * Fetches a collection of invites to this guild channel.
   * Resolves with a collection mapping invites by their codes.
   * @returns ***REMOVED***Promise<Collection<string, Invite>>***REMOVED***
   */
  fetchInvites() ***REMOVED***
    return this.client.rest.makeRequest('get', Constants.Endpoints.Channel(this.id).invites, true)
      .then(data => ***REMOVED***
        const invites = new Collection();
        for (let invite of data) ***REMOVED***
          invite = new Invite(this.client, invite);
          invites.set(invite.code, invite);
        ***REMOVED***

        return invites;
      ***REMOVED***);
  ***REMOVED***

  /**
   * Deletes this channel.
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for deleting this channel
   * @returns ***REMOVED***Promise<GuildChannel>***REMOVED***
   * @example
   * // Delete the channel
   * channel.delete('Making room for new channels')
   *   .then(deleted => console.log(`Deleted $***REMOVED***deleted.name***REMOVED*** to make room for new channels`))
   *   .catch(console.error);
   */
  delete(reason) ***REMOVED***
    return this.client.rest.methods.deleteChannel(this, reason);
  ***REMOVED***

  /**
   * Checks if this channel has the same type, topic, position, name, overwrites and ID as another channel.
   * In most cases, a simple `channel.id === channel2.id` will do, and is much faster too.
   * @param ***REMOVED***GuildChannel***REMOVED*** channel Channel to compare with
   * @returns ***REMOVED***boolean***REMOVED***
   */
  equals(channel) ***REMOVED***
    let equal = channel &&
      this.id === channel.id &&
      this.type === channel.type &&
      this.topic === channel.topic &&
      this.position === channel.position &&
      this.name === channel.name;

    if (equal) ***REMOVED***
      if (this.permissionOverwrites && channel.permissionOverwrites) ***REMOVED***
        equal = this.permissionOverwrites.equals(channel.permissionOverwrites);
      ***REMOVED*** else ***REMOVED***
        equal = !this.permissionOverwrites && !channel.permissionOverwrites;
      ***REMOVED***
    ***REMOVED***

    return equal;
  ***REMOVED***

  /**
   * Whether the channel is deletable by the client user
   * @type ***REMOVED***boolean***REMOVED***
   * @readonly
   */
  get deletable() ***REMOVED***
    return this.id !== this.guild.id &&
      this.permissionsFor(this.client.user).has(Permissions.FLAGS.MANAGE_CHANNELS);
  ***REMOVED***

  /**
   * Whether the channel is manageable by the client user
   * @type ***REMOVED***boolean***REMOVED***
   * @readonly
   */
  get manageable() ***REMOVED***
    if (this.client.user.id === this.guild.ownerID) return true;
    const permissions = this.permissionsFor(this.client.user);
    if (!permissions) return false;
    return permissions.has([Permissions.FLAGS.MANAGE_CHANNELS, Permissions.FLAGS.VIEW_CHANNEL]);
  ***REMOVED***

  /**
   * Whether the channel is muted
   * <warn>This is only available when using a user account.</warn>
   * @type ***REMOVED***?boolean***REMOVED***
   * @readonly
   * @deprecated
   */
  get muted() ***REMOVED***
    if (this.client.user.bot) return null;
    try ***REMOVED***
      return this.client.user.guildSettings.get(this.guild.id).channelOverrides.get(this.id).muted;
    ***REMOVED*** catch (err) ***REMOVED***
      return false;
    ***REMOVED***
  ***REMOVED***

  /**
   * The type of message that should notify you
   * <warn>This is only available when using a user account.</warn>
   * @type ***REMOVED***?MessageNotificationType***REMOVED***
   * @readonly
   * @deprecated
   */
  get messageNotifications() ***REMOVED***
    if (this.client.user.bot) return null;
    try ***REMOVED***
      return this.client.user.guildSettings.get(this.guild.id).channelOverrides.get(this.id).messageNotifications;
    ***REMOVED*** catch (err) ***REMOVED***
      return Constants.MessageNotificationTypes[3];
    ***REMOVED***
  ***REMOVED***

  /**
   * When concatenated with a string, this automatically returns the channel's mention instead of the Channel object.
   * @returns ***REMOVED***string***REMOVED***
   * @example
   * // Logs: Hello from <#123456789012345678>
   * console.log(`Hello from $***REMOVED***channel***REMOVED***`);
   * @example
   * // Logs: Hello from <#123456789012345678>
   * console.log('Hello from ' + channel);
   */
  toString() ***REMOVED***
    return `<#$***REMOVED***this.id***REMOVED***>`;
  ***REMOVED***
***REMOVED***

module.exports = GuildChannel;
