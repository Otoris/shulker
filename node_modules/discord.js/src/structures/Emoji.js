const Constants = require('../util/Constants');
const Collection = require('../util/Collection');
const Permissions = require('../util/Permissions');
const Snowflake = require('../util/Snowflake');

/**
 * Represents a custom emoji.
 */
class Emoji ***REMOVED***
  constructor(guild, data) ***REMOVED***
    /**
     * The client that instantiated this object
     * @name Emoji#client
     * @type ***REMOVED***Client***REMOVED***
     * @readonly
     */
    Object.defineProperty(this, 'client', ***REMOVED*** value: guild.client ***REMOVED***);

    /**
     * The guild this emoji is part of
     * @type ***REMOVED***Guild***REMOVED***
     */
    this.guild = guild;

    /**
     * Whether this emoji has been deleted
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.deleted = false;

    this.setup(data);
  ***REMOVED***

  setup(data) ***REMOVED***
    /**
     * The ID of the emoji
     * @type ***REMOVED***Snowflake***REMOVED***
     */
    this.id = data.id;

    /**
     * The name of the emoji
     * @type ***REMOVED***string***REMOVED***
     */
    this.name = data.name;

    /**
     * Whether or not this emoji requires colons surrounding it
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.requiresColons = data.require_colons;

    /**
     * Whether this emoji is managed by an external service
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.managed = data.managed;

    /**
     * Whether this emoji is animated
     * @type ***REMOVED***boolean***REMOVED***
     */
    this.animated = data.animated;

    /**
     * Whether this emoji is available
     * @type ***REMOVED***boolean***REMOVED***
     * @name Emoji#available
     */
    if (typeof data.available !== 'undefined') this.available = data.available;

    this._roles = data.roles;
  ***REMOVED***

  /**
   * The timestamp the emoji was created at
   * @type ***REMOVED***number***REMOVED***
   * @readonly
   */
  get createdTimestamp() ***REMOVED***
    return Snowflake.deconstruct(this.id).timestamp;
  ***REMOVED***

  /**
   * The time the emoji was created
   * @type ***REMOVED***Date***REMOVED***
   * @readonly
   */
  get createdAt() ***REMOVED***
    return new Date(this.createdTimestamp);
  ***REMOVED***

  /**
   * Whether the emoji is deletable by the client user
   * @type ***REMOVED***boolean***REMOVED***
   * @readonly
   */
  get deletable() ***REMOVED***
    return !this.managed && this.guild.me.hasPermission(Permissions.FLAGS.MANAGE_EMOJIS);
  ***REMOVED***

  /**
   * A collection of roles this emoji is active for (empty if all), mapped by role ID
   * @type ***REMOVED***Collection<Snowflake, Role>***REMOVED***
   * @readonly
   */
  get roles() ***REMOVED***
    const roles = new Collection();
    for (const role of this._roles) ***REMOVED***
      if (this.guild.roles.has(role)) roles.set(role, this.guild.roles.get(role));
    ***REMOVED***
    return roles;
  ***REMOVED***

  /**
   * The URL to the emoji file
   * @type ***REMOVED***string***REMOVED***
   * @readonly
   */
  get url() ***REMOVED***
    return Constants.Endpoints.CDN(this.client.options.http.cdn).Emoji(this.id, this.animated ? 'gif' : 'png');
  ***REMOVED***

  /**
   * The identifier of this emoji, used for message reactions
   * @type ***REMOVED***string***REMOVED***
   * @readonly
   */
  get identifier() ***REMOVED***
    if (this.id) return `$***REMOVED***this.name***REMOVED***:$***REMOVED***this.id***REMOVED***`;
    return encodeURIComponent(this.name);
  ***REMOVED***

  /**
   * Data for editing an emoji.
   * @typedef ***REMOVED***Object***REMOVED*** EmojiEditData
   * @property ***REMOVED***string***REMOVED*** [name] The name of the emoji
   * @property ***REMOVED***Collection<Snowflake, Role>|Array<Snowflake|Role>***REMOVED*** [roles] Roles to restrict emoji to
   */

  /**
   * Edits the emoji.
   * @param ***REMOVED***EmojiEditData***REMOVED*** data The new data for the emoji
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for editing this emoji
   * @returns ***REMOVED***Promise<Emoji>***REMOVED***
   * @example
   * // Edit an emoji
   * emoji.edit(***REMOVED***name: 'newemoji'***REMOVED***)
   *   .then(e => console.log(`Edited emoji $***REMOVED***e***REMOVED***`))
   *   .catch(console.error);
   */
  edit(data, reason) ***REMOVED***
    return this.client.rest.methods.updateEmoji(this, data, reason);
  ***REMOVED***

  /**
   * Set the name of the emoji.
   * @param ***REMOVED***string***REMOVED*** name The new name for the emoji
   * @param ***REMOVED***string***REMOVED*** [reason] The reason for changing the emoji's name
   * @returns ***REMOVED***Promise<Emoji>***REMOVED***
   */
  setName(name, reason) ***REMOVED***
    return this.edit(***REMOVED*** name ***REMOVED***, reason);
  ***REMOVED***

  /**
   * Fetches the author for this emoji
   * @returns ***REMOVED***Promise<User>***REMOVED***
   */
  fetchAuthor() ***REMOVED***
    if (this.managed) return Promise.reject(new Error('Emoji is managed and has no Author.'));
    if (!this.guild.me.permissions.has(Permissions.FLAGS.MANAGE_EMOJIS)) ***REMOVED***
      return Promise.reject(
        new Error(`Client must have Manage Emoji permission in guild $***REMOVED***this.guild***REMOVED*** to see emoji authors.`)
      );
    ***REMOVED***
    return this.client.rest.makeRequest('get', Constants.Endpoints.Guild(this.guild).Emoji(this.id), true)
      .then(emoji => this.client.dataManager.newUser(emoji.user));
  ***REMOVED***

  /**
   * Add a role to the list of roles that can use this emoji.
   * @param ***REMOVED***Role***REMOVED*** role The role to add
   * @returns ***REMOVED***Promise<Emoji>***REMOVED***
   */
  addRestrictedRole(role) ***REMOVED***
    return this.addRestrictedRoles([role]);
  ***REMOVED***

  /**
   * Add multiple roles to the list of roles that can use this emoji.
   * @param ***REMOVED***Role[]***REMOVED*** roles Roles to add
   * @returns ***REMOVED***Promise<Emoji>***REMOVED***
   */
  addRestrictedRoles(roles) ***REMOVED***
    const newRoles = new Collection(this.roles);
    for (const role of roles) ***REMOVED***
      if (this.guild.roles.has(role.id)) newRoles.set(role.id, role);
    ***REMOVED***
    return this.edit(***REMOVED*** roles: newRoles ***REMOVED***);
  ***REMOVED***

  /**
   * Remove a role from the list of roles that can use this emoji.
   * @param ***REMOVED***Role***REMOVED*** role The role to remove
   * @returns ***REMOVED***Promise<Emoji>***REMOVED***
   */
  removeRestrictedRole(role) ***REMOVED***
    return this.removeRestrictedRoles([role]);
  ***REMOVED***

  /**
   * Remove multiple roles from the list of roles that can use this emoji.
   * @param ***REMOVED***Role[]***REMOVED*** roles Roles to remove
   * @returns ***REMOVED***Promise<Emoji>***REMOVED***
   */
  removeRestrictedRoles(roles) ***REMOVED***
    const newRoles = new Collection(this.roles);
    for (const role of roles) ***REMOVED***
      if (newRoles.has(role.id)) newRoles.delete(role.id);
    ***REMOVED***
    return this.edit(***REMOVED*** roles: newRoles ***REMOVED***);
  ***REMOVED***


  /**
   * Deletes the emoji.
   * @param ***REMOVED***string***REMOVED*** [reason] Reason for deleting the emoji
   * @returns ***REMOVED***Promise<Emoji>***REMOVED***
   */
  delete(reason) ***REMOVED***
    return this.client.rest.methods.deleteEmoji(this, reason);
  ***REMOVED***

  /**
   * When concatenated with a string, this automatically returns the emoji mention rather than the object.
   * @returns ***REMOVED***string***REMOVED***
   * @example
   * // Send an emoji:
   * const emoji = guild.emojis.first();
   * msg.reply(`Hello! $***REMOVED***emoji***REMOVED***`);
   */
  toString() ***REMOVED***
    if (!this.id || !this.requiresColons) ***REMOVED***
      return this.name;
    ***REMOVED***

    return `<$***REMOVED***this.animated ? 'a' : ''***REMOVED***:$***REMOVED***this.name***REMOVED***:$***REMOVED***this.id***REMOVED***>`;
  ***REMOVED***

  /**
   * Whether this emoji is the same as another one.
   * @param ***REMOVED***Emoji|Object***REMOVED*** other The emoji to compare it to
   * @returns ***REMOVED***boolean***REMOVED*** Whether the emoji is equal to the given emoji or not
   */
  equals(other) ***REMOVED***
    if (other instanceof Emoji) ***REMOVED***
      return (
        other.id === this.id &&
        other.name === this.name &&
        other.managed === this.managed &&
        other.requiresColons === this.requiresColons
      );
    ***REMOVED*** else ***REMOVED***
      return (
        other.id === this.id &&
        other.name === this.name
      );
    ***REMOVED***
  ***REMOVED***
***REMOVED***

module.exports = Emoji;
