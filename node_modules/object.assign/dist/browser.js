(function e(t,n,r)***REMOVED***function s(o,u)***REMOVED***if(!n[o])***REMOVED***if(!t[o])***REMOVED***var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f***REMOVED***var l=n[o]=***REMOVED***exports:***REMOVED******REMOVED******REMOVED***;t[o][0].call(l.exports,function(e)***REMOVED***var n=t[o][1][e];return s(n?n:e)***REMOVED***,l,l.exports,e,t,n,r)***REMOVED***return n[o].exports***REMOVED***var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s***REMOVED***)(***REMOVED***1:[function(require,module,exports)***REMOVED***
'use strict';

var keys = require('object-keys').shim();
delete keys.shim;

var assign = require('./');

module.exports = assign.shim();

delete assign.shim;

***REMOVED***,***REMOVED***"./":3,"object-keys":9***REMOVED***],2:[function(require,module,exports)***REMOVED***
'use strict';

// modified from https://github.com/es-shims/es6-shim
var keys = require('object-keys');
var bind = require('function-bind');
var canBeObject = function (obj) ***REMOVED***
	return typeof obj !== 'undefined' && obj !== null;
***REMOVED***;
var hasSymbols = require('has-symbols/shams')();
var toObject = Object;
var push = bind.call(Function.call, Array.prototype.push);
var propIsEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);
var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;

module.exports = function assign(target, source1) ***REMOVED***
	if (!canBeObject(target)) ***REMOVED*** throw new TypeError('target must be an object'); ***REMOVED***
	var objTarget = toObject(target);
	var s, source, i, props, syms, value, key;
	for (s = 1; s < arguments.length; ++s) ***REMOVED***
		source = toObject(arguments[s]);
		props = keys(source);
		var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
		if (getSymbols) ***REMOVED***
			syms = getSymbols(source);
			for (i = 0; i < syms.length; ++i) ***REMOVED***
				key = syms[i];
				if (propIsEnumerable(source, key)) ***REMOVED***
					push(props, key);
				***REMOVED***
			***REMOVED***
		***REMOVED***
		for (i = 0; i < props.length; ++i) ***REMOVED***
			key = props[i];
			value = source[key];
			if (propIsEnumerable(source, key)) ***REMOVED***
				objTarget[key] = value;
			***REMOVED***
		***REMOVED***
	***REMOVED***
	return objTarget;
***REMOVED***;

***REMOVED***,***REMOVED***"function-bind":7,"has-symbols/shams":8,"object-keys":9***REMOVED***],3:[function(require,module,exports)***REMOVED***
'use strict';

var defineProperties = require('define-properties');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var polyfill = getPolyfill();

defineProperties(polyfill, ***REMOVED***
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
***REMOVED***);

module.exports = polyfill;

***REMOVED***,***REMOVED***"./implementation":2,"./polyfill":11,"./shim":12,"define-properties":4***REMOVED***],4:[function(require,module,exports)***REMOVED***
'use strict';

var keys = require('object-keys');
var foreach = require('foreach');
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

var toStr = Object.prototype.toString;

var isFunction = function (fn) ***REMOVED***
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
***REMOVED***;

var arePropertyDescriptorsSupported = function () ***REMOVED***
	var obj = ***REMOVED******REMOVED***;
	try ***REMOVED***
		Object.defineProperty(obj, 'x', ***REMOVED*** enumerable: false, value: obj ***REMOVED***);
        /* eslint-disable no-unused-vars, no-restricted-syntax */
        for (var _ in obj) ***REMOVED*** return false; ***REMOVED***
        /* eslint-enable no-unused-vars, no-restricted-syntax */
		return obj.x === obj;
	***REMOVED*** catch (e) ***REMOVED*** /* this is IE 8. */
		return false;
	***REMOVED***
***REMOVED***;
var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) ***REMOVED***
	if (name in object && (!isFunction(predicate) || !predicate())) ***REMOVED***
		return;
	***REMOVED***
	if (supportsDescriptors) ***REMOVED***
		Object.defineProperty(object, name, ***REMOVED***
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		***REMOVED***);
	***REMOVED*** else ***REMOVED***
		object[name] = value;
	***REMOVED***
***REMOVED***;

var defineProperties = function (object, map) ***REMOVED***
	var predicates = arguments.length > 2 ? arguments[2] : ***REMOVED******REMOVED***;
	var props = keys(map);
	if (hasSymbols) ***REMOVED***
		props = props.concat(Object.getOwnPropertySymbols(map));
	***REMOVED***
	foreach(props, function (name) ***REMOVED***
		defineProperty(object, name, map[name], predicates[name]);
	***REMOVED***);
***REMOVED***;

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;

***REMOVED***,***REMOVED***"foreach":5,"object-keys":9***REMOVED***],5:[function(require,module,exports)***REMOVED***

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) ***REMOVED***
    if (toString.call(fn) !== '[object Function]') ***REMOVED***
        throw new TypeError('iterator must be a function');
    ***REMOVED***
    var l = obj.length;
    if (l === +l) ***REMOVED***
        for (var i = 0; i < l; i++) ***REMOVED***
            fn.call(ctx, obj[i], i, obj);
        ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        for (var k in obj) ***REMOVED***
            if (hasOwn.call(obj, k)) ***REMOVED***
                fn.call(ctx, obj[k], k, obj);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
***REMOVED***;


***REMOVED***,***REMOVED******REMOVED***],6:[function(require,module,exports)***REMOVED***
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) ***REMOVED***
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) ***REMOVED***
        throw new TypeError(ERROR_MESSAGE + target);
    ***REMOVED***
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () ***REMOVED***
        if (this instanceof bound) ***REMOVED***
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) ***REMOVED***
                return result;
            ***REMOVED***
            return this;
        ***REMOVED*** else ***REMOVED***
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        ***REMOVED***
    ***REMOVED***;

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) ***REMOVED***
        boundArgs.push('$' + i);
    ***REMOVED***

    bound = Function('binder', 'return function (' + boundArgs.join(',') + ')***REMOVED*** return binder.apply(this,arguments); ***REMOVED***')(binder);

    if (target.prototype) ***REMOVED***
        var Empty = function Empty() ***REMOVED******REMOVED***;
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    ***REMOVED***

    return bound;
***REMOVED***;

***REMOVED***,***REMOVED******REMOVED***],7:[function(require,module,exports)***REMOVED***
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

***REMOVED***,***REMOVED***"./implementation":6***REMOVED***],8:[function(require,module,exports)***REMOVED***
'use strict';

/* eslint complexity: [2, 17], max-statements: [2, 33] */
module.exports = function hasSymbols() ***REMOVED***
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') ***REMOVED*** return false; ***REMOVED***
	if (typeof Symbol.iterator === 'symbol') ***REMOVED*** return true; ***REMOVED***

	var obj = ***REMOVED******REMOVED***;
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') ***REMOVED*** return false; ***REMOVED***

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') ***REMOVED*** return false; ***REMOVED***
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') ***REMOVED*** return false; ***REMOVED***

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) ***REMOVED*** return false; ***REMOVED***
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) ***REMOVED*** return false; ***REMOVED***

	// if (typeof Symbol.prototype.toString !== 'function') ***REMOVED*** return false; ***REMOVED***
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) ***REMOVED*** return false; ***REMOVED***

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) ***REMOVED*** return false; ***REMOVED*** // eslint-disable-line no-restricted-syntax
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) ***REMOVED*** return false; ***REMOVED***

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) ***REMOVED*** return false; ***REMOVED***

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) ***REMOVED*** return false; ***REMOVED***

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) ***REMOVED*** return false; ***REMOVED***

	if (typeof Object.getOwnPropertyDescriptor === 'function') ***REMOVED***
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) ***REMOVED*** return false; ***REMOVED***
	***REMOVED***

	return true;
***REMOVED***;

***REMOVED***,***REMOVED******REMOVED***],9:[function(require,module,exports)***REMOVED***
'use strict';

// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var isEnumerable = Object.prototype.propertyIsEnumerable;
var hasDontEnumBug = !isEnumerable.call(***REMOVED*** toString: null ***REMOVED***, 'toString');
var hasProtoEnumBug = isEnumerable.call(function () ***REMOVED******REMOVED***, 'prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) ***REMOVED***
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
***REMOVED***;
var excludedKeys = ***REMOVED***
	$console: true,
	$external: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$innerHeight: true,
	$innerWidth: true,
	$outerHeight: true,
	$outerWidth: true,
	$pageXOffset: true,
	$pageYOffset: true,
	$parent: true,
	$scrollLeft: true,
	$scrollTop: true,
	$scrollX: true,
	$scrollY: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
***REMOVED***;
var hasAutomationEqualityBug = (function () ***REMOVED***
	/* global window */
	if (typeof window === 'undefined') ***REMOVED*** return false; ***REMOVED***
	for (var k in window) ***REMOVED***
		try ***REMOVED***
			if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') ***REMOVED***
				try ***REMOVED***
					equalsConstructorPrototype(window[k]);
				***REMOVED*** catch (e) ***REMOVED***
					return true;
				***REMOVED***
			***REMOVED***
		***REMOVED*** catch (e) ***REMOVED***
			return true;
		***REMOVED***
	***REMOVED***
	return false;
***REMOVED***());
var equalsConstructorPrototypeIfNotBuggy = function (o) ***REMOVED***
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) ***REMOVED***
		return equalsConstructorPrototype(o);
	***REMOVED***
	try ***REMOVED***
		return equalsConstructorPrototype(o);
	***REMOVED*** catch (e) ***REMOVED***
		return false;
	***REMOVED***
***REMOVED***;

var keysShim = function keys(object) ***REMOVED***
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) ***REMOVED***
		throw new TypeError('Object.keys called on a non-object');
	***REMOVED***

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) ***REMOVED***
		for (var i = 0; i < object.length; ++i) ***REMOVED***
			theKeys.push(String(i));
		***REMOVED***
	***REMOVED***

	if (isArguments && object.length > 0) ***REMOVED***
		for (var j = 0; j < object.length; ++j) ***REMOVED***
			theKeys.push(String(j));
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		for (var name in object) ***REMOVED***
			if (!(skipProto && name === 'prototype') && has.call(object, name)) ***REMOVED***
				theKeys.push(String(name));
			***REMOVED***
		***REMOVED***
	***REMOVED***

	if (hasDontEnumBug) ***REMOVED***
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) ***REMOVED***
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) ***REMOVED***
				theKeys.push(dontEnums[k]);
			***REMOVED***
		***REMOVED***
	***REMOVED***
	return theKeys;
***REMOVED***;

keysShim.shim = function shimObjectKeys() ***REMOVED***
	if (Object.keys) ***REMOVED***
		var keysWorksWithArguments = (function () ***REMOVED***
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		***REMOVED***(1, 2));
		if (!keysWorksWithArguments) ***REMOVED***
			var originalKeys = Object.keys;
			Object.keys = function keys(object) ***REMOVED***
				if (isArgs(object)) ***REMOVED***
					return originalKeys(slice.call(object));
				***REMOVED*** else ***REMOVED***
					return originalKeys(object);
				***REMOVED***
			***REMOVED***;
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		Object.keys = keysShim;
	***REMOVED***
	return Object.keys || keysShim;
***REMOVED***;

module.exports = keysShim;

***REMOVED***,***REMOVED***"./isArguments":10***REMOVED***],10:[function(require,module,exports)***REMOVED***
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) ***REMOVED***
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) ***REMOVED***
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	***REMOVED***
	return isArgs;
***REMOVED***;

***REMOVED***,***REMOVED******REMOVED***],11:[function(require,module,exports)***REMOVED***
'use strict';

var implementation = require('./implementation');

var lacksProperEnumerationOrder = function () ***REMOVED***
	if (!Object.assign) ***REMOVED***
		return false;
	***REMOVED***
	// v8, specifically in node 4.x, has a bug with incorrect property enumeration order
	// note: this does not detect the bug unless there's 20 characters
	var str = 'abcdefghijklmnopqrst';
	var letters = str.split('');
	var map = ***REMOVED******REMOVED***;
	for (var i = 0; i < letters.length; ++i) ***REMOVED***
		map[letters[i]] = letters[i];
	***REMOVED***
	var obj = Object.assign(***REMOVED******REMOVED***, map);
	var actual = '';
	for (var k in obj) ***REMOVED***
		actual += k;
	***REMOVED***
	return str !== actual;
***REMOVED***;

var assignHasPendingExceptions = function () ***REMOVED***
	if (!Object.assign || !Object.preventExtensions) ***REMOVED***
		return false;
	***REMOVED***
	// Firefox 37 still has "pending exception" logic in its Object.assign implementation,
	// which is 72% slower than our shim, and Firefox 40's native implementation.
	var thrower = Object.preventExtensions(***REMOVED*** 1: 2 ***REMOVED***);
	try ***REMOVED***
		Object.assign(thrower, 'xy');
	***REMOVED*** catch (e) ***REMOVED***
		return thrower[1] === 'y';
	***REMOVED***
	return false;
***REMOVED***;

module.exports = function getPolyfill() ***REMOVED***
	if (!Object.assign) ***REMOVED***
		return implementation;
	***REMOVED***
	if (lacksProperEnumerationOrder()) ***REMOVED***
		return implementation;
	***REMOVED***
	if (assignHasPendingExceptions()) ***REMOVED***
		return implementation;
	***REMOVED***
	return Object.assign;
***REMOVED***;

***REMOVED***,***REMOVED***"./implementation":2***REMOVED***],12:[function(require,module,exports)***REMOVED***
'use strict';

var define = require('define-properties');
var getPolyfill = require('./polyfill');

module.exports = function shimAssign() ***REMOVED***
	var polyfill = getPolyfill();
	define(
		Object,
		***REMOVED*** assign: polyfill ***REMOVED***,
		***REMOVED*** assign: function () ***REMOVED*** return Object.assign !== polyfill; ***REMOVED*** ***REMOVED***
	);
	return polyfill;
***REMOVED***;

***REMOVED***,***REMOVED***"./polyfill":11,"define-properties":4***REMOVED***]***REMOVED***,***REMOVED******REMOVED***,[1]);
