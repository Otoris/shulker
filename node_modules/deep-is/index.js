var pSlice = Array.prototype.slice;
var Object_keys = typeof Object.keys === 'function'
    ? Object.keys
    : function (obj) ***REMOVED***
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    ***REMOVED***
;

var deepEqual = module.exports = function (actual, expected) ***REMOVED***
  // enforce Object.is +0 !== -0
  if (actual === 0 && expected === 0) ***REMOVED***
    return areZerosEqual(actual, expected);

  // 7.1. All identical values are equivalent, as determined by ===.
  ***REMOVED*** else if (actual === expected) ***REMOVED***
    return true;

  ***REMOVED*** else if (actual instanceof Date && expected instanceof Date) ***REMOVED***
    return actual.getTime() === expected.getTime();

  ***REMOVED*** else if (isNumberNaN(actual)) ***REMOVED***
    return isNumberNaN(expected);

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  ***REMOVED*** else if (typeof actual != 'object' && typeof expected != 'object') ***REMOVED***
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  ***REMOVED*** else ***REMOVED***
    return objEquiv(actual, expected);
  ***REMOVED***
***REMOVED***;

function isUndefinedOrNull(value) ***REMOVED***
  return value === null || value === undefined;
***REMOVED***

function isArguments(object) ***REMOVED***
  return Object.prototype.toString.call(object) == '[object Arguments]';
***REMOVED***

function isNumberNaN(value) ***REMOVED***
  // NaN === NaN -> false
  return typeof value == 'number' && value !== value;
***REMOVED***

function areZerosEqual(zeroA, zeroB) ***REMOVED***
  // (1 / +0|0) -> Infinity, but (1 / -0) -> -Infinity and (Infinity !== -Infinity)
  return (1 / zeroA) === (1 / zeroB);
***REMOVED***

function objEquiv(a, b) ***REMOVED***
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;

  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) ***REMOVED***
    if (!isArguments(b)) ***REMOVED***
      return false;
    ***REMOVED***
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b);
  ***REMOVED***
  try ***REMOVED***
    var ka = Object_keys(a),
        kb = Object_keys(b),
        key, i;
  ***REMOVED*** catch (e) ***REMOVED***//happens when one is a string literal and the other isn't
    return false;
  ***REMOVED***
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) ***REMOVED***
    if (ka[i] != kb[i])
      return false;
  ***REMOVED***
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) ***REMOVED***
    key = ka[i];
    if (!deepEqual(a[key], b[key])) return false;
  ***REMOVED***
  return true;
***REMOVED***
