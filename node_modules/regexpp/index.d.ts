// Generated by dts-bundle v0.7.3

declare module 'regexpp' ***REMOVED***
    import * as AST from "regexpp/ast";
    import ***REMOVED*** RegExpParser ***REMOVED*** from "regexpp/parser";
    import ***REMOVED*** RegExpValidator ***REMOVED*** from "regexpp/validator";
    import ***REMOVED*** RegExpVisitor ***REMOVED*** from "regexpp/visitor";
    export ***REMOVED*** AST, RegExpParser, RegExpValidator ***REMOVED***;
    export function parseRegExpLiteral(source: string | RegExp, options?: RegExpParser.Options): AST.RegExpLiteral;
    export function validateRegExpLiteral(source: string, options?: RegExpValidator.Options): void;
    export function visitRegExpAST(node: AST.Node, handlers: RegExpVisitor.Handlers): void;
***REMOVED***

declare module 'regexpp/ast' ***REMOVED***
    export type Node = BranchNode | LeafNode;
    export type BranchNode = RegExpLiteral | Pattern | Alternative | Group | CapturingGroup | Quantifier | CharacterClass | LookaroundAssertion | CharacterClassRange;
    export type LeafNode = BoundaryAssertion | CharacterSet | Character | Backreference | Flags;
    export type Element = Assertion | Quantifier | QuantifiableElement;
    export type QuantifiableElement = Group | CapturingGroup | CharacterClass | CharacterSet | Character | Backreference | LookaheadAssertion;
    export type CharacterClassElement = EscapeCharacterSet | UnicodePropertyCharacterSet | Character | CharacterClassRange;
    export interface NodeBase ***REMOVED***
        type: Node["type"];
        parent: Node["parent"];
        start: number;
        end: number;
        raw: string;
    ***REMOVED***
    export interface RegExpLiteral extends NodeBase ***REMOVED***
        type: "RegExpLiteral";
        parent: null;
        pattern: Pattern;
        flags: Flags;
    ***REMOVED***
    export interface Pattern extends NodeBase ***REMOVED***
        type: "Pattern";
        parent: RegExpLiteral | null;
        alternatives: Alternative[];
    ***REMOVED***
    export interface Alternative extends NodeBase ***REMOVED***
        type: "Alternative";
        parent: Pattern | Group | CapturingGroup | LookaroundAssertion;
        elements: Element[];
    ***REMOVED***
    export interface Group extends NodeBase ***REMOVED***
        type: "Group";
        parent: Alternative | Quantifier;
        alternatives: Alternative[];
    ***REMOVED***
    export interface CapturingGroup extends NodeBase ***REMOVED***
        type: "CapturingGroup";
        parent: Alternative | Quantifier;
        name: string | null;
        alternatives: Alternative[];
        references: Backreference[];
    ***REMOVED***
    export type LookaroundAssertion = LookaheadAssertion | LookbehindAssertion;
    export interface LookaheadAssertion extends NodeBase ***REMOVED***
        type: "Assertion";
        parent: Alternative | Quantifier;
        kind: "lookahead";
        negate: boolean;
        alternatives: Alternative[];
    ***REMOVED***
    export interface LookbehindAssertion extends NodeBase ***REMOVED***
        type: "Assertion";
        parent: Alternative;
        kind: "lookbehind";
        negate: boolean;
        alternatives: Alternative[];
    ***REMOVED***
    export interface Quantifier extends NodeBase ***REMOVED***
        type: "Quantifier";
        parent: Alternative;
        min: number;
        max: number;
        greedy: boolean;
        element: QuantifiableElement;
    ***REMOVED***
    export interface CharacterClass extends NodeBase ***REMOVED***
        type: "CharacterClass";
        parent: Alternative | Quantifier;
        negate: boolean;
        elements: CharacterClassElement[];
    ***REMOVED***
    export interface CharacterClassRange extends NodeBase ***REMOVED***
        type: "CharacterClassRange";
        parent: CharacterClass;
        min: Character;
        max: Character;
    ***REMOVED***
    export type Assertion = BoundaryAssertion | LookaroundAssertion;
    export type BoundaryAssertion = EdgeAssertion | WordBoundaryAssertion;
    export interface EdgeAssertion extends NodeBase ***REMOVED***
        type: "Assertion";
        parent: Alternative | Quantifier;
        kind: "start" | "end";
    ***REMOVED***
    export interface WordBoundaryAssertion extends NodeBase ***REMOVED***
        type: "Assertion";
        parent: Alternative | Quantifier;
        kind: "word";
        negate: boolean;
    ***REMOVED***
    export type CharacterSet = AnyCharacterSet | EscapeCharacterSet | UnicodePropertyCharacterSet;
    export interface AnyCharacterSet extends NodeBase ***REMOVED***
        type: "CharacterSet";
        parent: Alternative | Quantifier;
        kind: "any";
    ***REMOVED***
    export interface EscapeCharacterSet extends NodeBase ***REMOVED***
        type: "CharacterSet";
        parent: Alternative | Quantifier | CharacterClass;
        kind: "digit" | "space" | "word";
        negate: boolean;
    ***REMOVED***
    export interface UnicodePropertyCharacterSet extends NodeBase ***REMOVED***
        type: "CharacterSet";
        parent: Alternative | Quantifier | CharacterClass;
        kind: "property";
        key: string;
        value: string | null;
        negate: boolean;
    ***REMOVED***
    export interface Character extends NodeBase ***REMOVED***
        type: "Character";
        parent: Alternative | Quantifier | CharacterClass | CharacterClassRange;
        value: number;
    ***REMOVED***
    export interface Backreference extends NodeBase ***REMOVED***
        type: "Backreference";
        parent: Alternative | Quantifier;
        ref: number | string;
        resolved: CapturingGroup;
    ***REMOVED***
    export interface Flags extends NodeBase ***REMOVED***
        type: "Flags";
        parent: RegExpLiteral | null;
        dotAll: boolean;
        global: boolean;
        ignoreCase: boolean;
        multiline: boolean;
        sticky: boolean;
        unicode: boolean;
    ***REMOVED***
***REMOVED***

declare module 'regexpp/parser' ***REMOVED***
    import ***REMOVED*** Flags, RegExpLiteral, Pattern ***REMOVED*** from "regexpp/ast";
    export namespace RegExpParser ***REMOVED***
        interface Options ***REMOVED***
            strict?: boolean;
            ecmaVersion?: 5 | 2015 | 2016 | 2017 | 2018;
        ***REMOVED***
    ***REMOVED***
    export class RegExpParser ***REMOVED***
        constructor(options?: RegExpParser.Options);
        parseLiteral(source: string, start?: number, end?: number): RegExpLiteral;
        parseFlags(source: string, start?: number, end?: number): Flags;
        parsePattern(source: string, start?: number, end?: number, uFlag?: boolean): Pattern;
    ***REMOVED***
***REMOVED***

declare module 'regexpp/validator' ***REMOVED***
    export namespace RegExpValidator ***REMOVED***
        interface Options ***REMOVED***
            strict?: boolean;
            ecmaVersion?: 5 | 2015 | 2016 | 2017 | 2018;
            onLiteralEnter?(start: number): void;
            onLiteralLeave?(start: number, end: number): void;
            onFlags?(start: number, end: number, global: boolean, ignoreCase: boolean, multiline: boolean, unicode: boolean, sticky: boolean, dotAll: boolean): void;
            onPatternEnter?(start: number): void;
            onPatternLeave?(start: number, end: number): void;
            onDisjunctionEnter?(start: number): void;
            onDisjunctionLeave?(start: number, end: number): void;
            onAlternativeEnter?(start: number, index: number): void;
            onAlternativeLeave?(start: number, end: number, index: number): void;
            onGroupEnter?(start: number): void;
            onGroupLeave?(start: number, end: number): void;
            onCapturingGroupEnter?(start: number, name: string | null): void;
            onCapturingGroupLeave?(start: number, end: number, name: string | null): void;
            onQuantifier?(start: number, end: number, min: number, max: number, greedy: boolean): void;
            onLookaroundAssertionEnter?(start: number, kind: "lookahead" | "lookbehind", negate: boolean): void;
            onLookaroundAssertionLeave?(start: number, end: number, kind: "lookahead" | "lookbehind", negate: boolean): void;
            onEdgeAssertion?(start: number, end: number, kind: "start" | "end"): void;
            onWordBoundaryAssertion?(start: number, end: number, kind: "word", negate: boolean): void;
            onAnyCharacterSet?(start: number, end: number, kind: "any"): void;
            onEscapeCharacterSet?(start: number, end: number, kind: "digit" | "space" | "word", negate: boolean): void;
            onUnicodePropertyCharacterSet?(start: number, end: number, kind: "property", key: string, value: string | null, negate: boolean): void;
            onCharacter?(start: number, end: number, value: number): void;
            onBackreference?(start: number, end: number, ref: number | string): void;
            onCharacterClassEnter?(start: number, negate: boolean): void;
            onCharacterClassLeave?(start: number, end: number, negate: boolean): void;
            onCharacterClassRange?(start: number, end: number, min: number, max: number): void;
        ***REMOVED***
    ***REMOVED***
    export class RegExpValidator ***REMOVED***
        constructor(options?: RegExpValidator.Options);
        validateLiteral(source: string, start?: number, end?: number): void;
        validateFlags(source: string, start?: number, end?: number): void;
        validatePattern(source: string, start?: number, end?: number, uFlag?: boolean): void;
    ***REMOVED***
***REMOVED***

declare module 'regexpp/visitor' ***REMOVED***
    import ***REMOVED*** Alternative, Assertion, Backreference, CapturingGroup, Character, CharacterClass, CharacterClassRange, CharacterSet, Flags, Group, Node, Pattern, Quantifier, RegExpLiteral ***REMOVED*** from "regexpp/ast";
    export class RegExpVisitor ***REMOVED***
        constructor(handlers: RegExpVisitor.Handlers);
        visit(node: Node): void;
    ***REMOVED***
    export namespace RegExpVisitor ***REMOVED***
        interface Handlers ***REMOVED***
            onAlternativeEnter?(node: Alternative): void;
            onAlternativeLeave?(node: Alternative): void;
            onAssertionEnter?(node: Assertion): void;
            onAssertionLeave?(node: Assertion): void;
            onBackreferenceEnter?(node: Backreference): void;
            onBackreferenceLeave?(node: Backreference): void;
            onCapturingGroupEnter?(node: CapturingGroup): void;
            onCapturingGroupLeave?(node: CapturingGroup): void;
            onCharacterEnter?(node: Character): void;
            onCharacterLeave?(node: Character): void;
            onCharacterClassEnter?(node: CharacterClass): void;
            onCharacterClassLeave?(node: CharacterClass): void;
            onCharacterClassRangeEnter?(node: CharacterClassRange): void;
            onCharacterClassRangeLeave?(node: CharacterClassRange): void;
            onCharacterSetEnter?(node: CharacterSet): void;
            onCharacterSetLeave?(node: CharacterSet): void;
            onFlagsEnter?(node: Flags): void;
            onFlagsLeave?(node: Flags): void;
            onGroupEnter?(node: Group): void;
            onGroupLeave?(node: Group): void;
            onPatternEnter?(node: Pattern): void;
            onPatternLeave?(node: Pattern): void;
            onQuantifierEnter?(node: Quantifier): void;
            onQuantifierLeave?(node: Quantifier): void;
            onRegExpLiteralEnter?(node: RegExpLiteral): void;
            onRegExpLiteralLeave?(node: RegExpLiteral): void;
        ***REMOVED***
    ***REMOVED***
***REMOVED***

