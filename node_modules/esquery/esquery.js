/* vim: set sw=4 sts=4 : */
(function () ***REMOVED***

    var estraverse = require('estraverse');
    var parser = require('./parser');

    var isArray = Array.isArray || function isArray(array) ***REMOVED***
        return ***REMOVED******REMOVED***.toString.call(array) === '[object Array]';
    ***REMOVED***;

    var LEFT_SIDE = ***REMOVED******REMOVED***;
    var RIGHT_SIDE = ***REMOVED******REMOVED***;

    function esqueryModule() ***REMOVED***

        /**
         * Get the value of a property which may be multiple levels down in the object.
         */
        function getPath(obj, key) ***REMOVED***
            var i, keys = key.split(".");
            for (i = 0; i < keys.length; i++) ***REMOVED***
                if (obj == null) ***REMOVED*** return obj; ***REMOVED***
                obj = obj[keys[i]];
            ***REMOVED***
            return obj;
        ***REMOVED***

        /**
         * Determine whether `node` can be reached by following `path`, starting at `ancestor`.
         */
        function inPath(node, ancestor, path) ***REMOVED***
            var field, remainingPath, i;
            if (path.length === 0) ***REMOVED*** return node === ancestor; ***REMOVED***
            if (ancestor == null) ***REMOVED*** return false; ***REMOVED***
            field = ancestor[path[0]];
            remainingPath = path.slice(1);
            if (isArray(field)) ***REMOVED***
                for (i = 0, l = field.length; i < l; ++i) ***REMOVED***
                    if (inPath(node, field[i], remainingPath)) ***REMOVED*** return true; ***REMOVED***
                ***REMOVED***
                return false;
            ***REMOVED*** else ***REMOVED***
                return inPath(node, field, remainingPath);
            ***REMOVED***
        ***REMOVED***

        /**
         * Given a `node` and its ancestors, determine if `node` is matched by `selector`.
         */
        function matches(node, selector, ancestry) ***REMOVED***
            var path, ancestor, i, l, p;
            if (!selector) ***REMOVED*** return true; ***REMOVED***
            if (!node) ***REMOVED*** return false; ***REMOVED***
            if (!ancestry) ***REMOVED*** ancestry = []; ***REMOVED***

            switch(selector.type) ***REMOVED***
                case 'wildcard':
                    return true;

                case 'identifier':
                    return selector.value.toLowerCase() === node.type.toLowerCase();

                case 'field':
                    path = selector.name.split('.');
                    ancestor = ancestry[path.length - 1];
                    return inPath(node, ancestor, path);

                case 'matches':
                    for (i = 0, l = selector.selectors.length; i < l; ++i) ***REMOVED***
                        if (matches(node, selector.selectors[i], ancestry)) ***REMOVED*** return true; ***REMOVED***
                    ***REMOVED***
                    return false;

                case 'compound':
                    for (i = 0, l = selector.selectors.length; i < l; ++i) ***REMOVED***
                        if (!matches(node, selector.selectors[i], ancestry)) ***REMOVED*** return false; ***REMOVED***
                    ***REMOVED***
                    return true;

                case 'not':
                    for (i = 0, l = selector.selectors.length; i < l; ++i) ***REMOVED***
                        if (matches(node, selector.selectors[i], ancestry)) ***REMOVED*** return false; ***REMOVED***
                    ***REMOVED***
                    return true;

                case 'has':
                    var a, collector = [];
                    for (i = 0, l = selector.selectors.length; i < l; ++i) ***REMOVED***
                      a = [];
                      estraverse.traverse(node, ***REMOVED***
                          enter: function (node, parent) ***REMOVED***
                              if (parent != null) ***REMOVED*** a.unshift(parent); ***REMOVED***
                              if (matches(node, selector.selectors[i], a)) ***REMOVED***
                                collector.push(node);
                              ***REMOVED***
                          ***REMOVED***,
                          leave: function () ***REMOVED*** a.shift(); ***REMOVED***
                      ***REMOVED***);
                    ***REMOVED***
                    return collector.length !== 0;

                case 'child':
                    if (matches(node, selector.right, ancestry)) ***REMOVED***
                        return matches(ancestry[0], selector.left, ancestry.slice(1));
                    ***REMOVED***
                    return false;

                case 'descendant':
                    if (matches(node, selector.right, ancestry)) ***REMOVED***
                        for (i = 0, l = ancestry.length; i < l; ++i) ***REMOVED***
                            if (matches(ancestry[i], selector.left, ancestry.slice(i + 1))) ***REMOVED***
                                return true;
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***
                    return false;

                case 'attribute':
                    p = getPath(node, selector.name);
                    switch (selector.operator) ***REMOVED***
                        case null:
                        case void 0:
                            return p != null;
                        case '=':
                            switch (selector.value.type) ***REMOVED***
                                case 'regexp': return typeof p === 'string' && selector.value.value.test(p);
                                case 'literal': return '' + selector.value.value === '' + p;
                                case 'type': return selector.value.value === typeof p;
                            ***REMOVED***
                        case '!=':
                            switch (selector.value.type) ***REMOVED***
                                case 'regexp': return !selector.value.value.test(p);
                                case 'literal': return '' + selector.value.value !== '' + p;
                                case 'type': return selector.value.value !== typeof p;
                            ***REMOVED***
                        case '<=': return p <= selector.value.value;
                        case '<': return p < selector.value.value;
                        case '>': return p > selector.value.value;
                        case '>=': return p >= selector.value.value;
                    ***REMOVED***

                case 'sibling':
                    return matches(node, selector.right, ancestry) &&
                        sibling(node, selector.left, ancestry, LEFT_SIDE) ||
                        selector.left.subject &&
                        matches(node, selector.left, ancestry) &&
                        sibling(node, selector.right, ancestry, RIGHT_SIDE);

                case 'adjacent':
                    return matches(node, selector.right, ancestry) &&
                        adjacent(node, selector.left, ancestry, LEFT_SIDE) ||
                        selector.right.subject &&
                        matches(node, selector.left, ancestry) &&
                        adjacent(node, selector.right, ancestry, RIGHT_SIDE);

                case 'nth-child':
                    return matches(node, selector.right, ancestry) &&
                        nthChild(node, ancestry, function (length) ***REMOVED***
                            return selector.index.value - 1;
                        ***REMOVED***);

                case 'nth-last-child':
                    return matches(node, selector.right, ancestry) &&
                        nthChild(node, ancestry, function (length) ***REMOVED***
                            return length - selector.index.value;
                        ***REMOVED***);

                case 'class':
                    if(!node.type) return false;
                    switch(selector.name.toLowerCase())***REMOVED***
                        case 'statement':
                            if(node.type.slice(-9) === 'Statement') return true;
                            // fallthrough: interface Declaration <: Statement ***REMOVED*** ***REMOVED***
                        case 'declaration':
                            return node.type.slice(-11) === 'Declaration';
                        case 'pattern':
                            if(node.type.slice(-7) === 'Pattern') return true;
                            // fallthrough: interface Expression <: Node, Pattern ***REMOVED*** ***REMOVED***
                        case 'expression':
                            return node.type.slice(-10) === 'Expression' ||
                                node.type.slice(-7) === 'Literal' ||
                                (
                                    node.type === 'Identifier' &&
                                    (ancestry.length === 0 || ancestry[0].type !== 'MetaProperty')
                                ) ||
                                node.type === 'MetaProperty';
                        case 'function':
                            return node.type.slice(0, 8) === 'Function' ||
                                node.type === 'ArrowFunctionExpression';
                    ***REMOVED***
                    throw new Error('Unknown class name: ' + selector.name);
            ***REMOVED***

            throw new Error('Unknown selector type: ' + selector.type);
        ***REMOVED***

        /*
         * Determines if the given node has a sibling that matches the given selector.
         */
        function sibling(node, selector, ancestry, side) ***REMOVED***
            var parent = ancestry[0], listProp, startIndex, keys, i, l, k, lowerBound, upperBound;
            if (!parent) ***REMOVED*** return false; ***REMOVED***
            keys = estraverse.VisitorKeys[parent.type];
            for (i = 0, l = keys.length; i < l; ++i) ***REMOVED***
                listProp = parent[keys[i]];
                if (isArray(listProp)) ***REMOVED***
                    startIndex = listProp.indexOf(node);
                    if (startIndex < 0) ***REMOVED*** continue; ***REMOVED***
                    if (side === LEFT_SIDE) ***REMOVED***
                      lowerBound = 0;
                      upperBound = startIndex;
                    ***REMOVED*** else ***REMOVED***
                      lowerBound = startIndex + 1;
                      upperBound = listProp.length;
                    ***REMOVED***
                    for (k = lowerBound; k < upperBound; ++k) ***REMOVED***
                        if (matches(listProp[k], selector, ancestry)) ***REMOVED***
                            return true;
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            return false;
        ***REMOVED***

        /*
         * Determines if the given node has an asjacent sibling that matches the given selector.
         */
        function adjacent(node, selector, ancestry, side) ***REMOVED***
            var parent = ancestry[0], listProp, keys, i, l, idx;
            if (!parent) ***REMOVED*** return false; ***REMOVED***
            keys = estraverse.VisitorKeys[parent.type];
            for (i = 0, l = keys.length; i < l; ++i) ***REMOVED***
                listProp = parent[keys[i]];
                if (isArray(listProp)) ***REMOVED***
                    idx = listProp.indexOf(node);
                    if (idx < 0) ***REMOVED*** continue; ***REMOVED***
                    if (side === LEFT_SIDE && idx > 0 && matches(listProp[idx - 1], selector, ancestry)) ***REMOVED***
                        return true;
                    ***REMOVED***
                    if (side === RIGHT_SIDE && idx < listProp.length - 1 && matches(listProp[idx + 1], selector, ancestry)) ***REMOVED***
                        return true;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            return false;
        ***REMOVED***

        /*
         * Determines if the given node is the nth child, determined by idxFn, which is given the containing list's length.
         */
        function nthChild(node, ancestry, idxFn) ***REMOVED***
            var parent = ancestry[0], listProp, keys, i, l, idx;
            if (!parent) ***REMOVED*** return false; ***REMOVED***
            keys = estraverse.VisitorKeys[parent.type];
            for (i = 0, l = keys.length; i < l; ++i) ***REMOVED***
                listProp = parent[keys[i]];
                if (isArray(listProp)) ***REMOVED***
                    idx = listProp.indexOf(node);
                    if (idx >= 0 && idx === idxFn(listProp.length)) ***REMOVED*** return true; ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            return false;
        ***REMOVED***

        /*
         * For each selector node marked as a subject, find the portion of the selector that the subject must match.
         */
        function subjects(selector, ancestor) ***REMOVED***
            var results, p;
            if (selector == null || typeof selector != 'object') ***REMOVED*** return []; ***REMOVED***
            if (ancestor == null) ***REMOVED*** ancestor = selector; ***REMOVED***
            results = selector.subject ? [ancestor] : [];
            for(p in selector) ***REMOVED***
                if(!***REMOVED******REMOVED***.hasOwnProperty.call(selector, p)) ***REMOVED*** continue; ***REMOVED***
                [].push.apply(results, subjects(selector[p], p === 'left' ? selector[p] : ancestor));
            ***REMOVED***
            return results;
        ***REMOVED***

        /**
         * From a JS AST and a selector AST, collect all JS AST nodes that match the selector.
         */
        function match(ast, selector) ***REMOVED***
            var ancestry = [], results = [], altSubjects, i, l, k, m;
            if (!selector) ***REMOVED*** return results; ***REMOVED***
            altSubjects = subjects(selector);
            estraverse.traverse(ast, ***REMOVED***
                enter: function (node, parent) ***REMOVED***
                    if (parent != null) ***REMOVED*** ancestry.unshift(parent); ***REMOVED***
                    if (matches(node, selector, ancestry)) ***REMOVED***
                        if (altSubjects.length) ***REMOVED***
                            for (i = 0, l = altSubjects.length; i < l; ++i) ***REMOVED***
                                if (matches(node, altSubjects[i], ancestry)) ***REMOVED*** results.push(node); ***REMOVED***
                                for (k = 0, m = ancestry.length; k < m; ++k) ***REMOVED***
                                    if (matches(ancestry[k], altSubjects[i], ancestry.slice(k + 1))) ***REMOVED***
                                        results.push(ancestry[k]);
                                    ***REMOVED***
                                ***REMOVED***
                            ***REMOVED***
                        ***REMOVED*** else ***REMOVED***
                            results.push(node);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***,
                leave: function () ***REMOVED*** ancestry.shift(); ***REMOVED***
            ***REMOVED***);
            return results;
        ***REMOVED***

        /**
         * Parse a selector string and return its AST.
         */
        function parse(selector) ***REMOVED***
            return parser.parse(selector);
        ***REMOVED***

        /**
         * Query the code AST using the selector string.
         */
        function query(ast, selector) ***REMOVED***
            return match(ast, parse(selector));
        ***REMOVED***

        query.parse = parse;
        query.match = match;
        query.matches = matches;
        return query.query = query;
    ***REMOVED***


    if (typeof define === "function" && define.amd) ***REMOVED***
        define(esqueryModule);
    ***REMOVED*** else if (typeof module !== 'undefined' && module.exports) ***REMOVED***
        module.exports = esqueryModule();
    ***REMOVED*** else ***REMOVED***
        this.esquery = esqueryModule();
    ***REMOVED***

***REMOVED***)();
