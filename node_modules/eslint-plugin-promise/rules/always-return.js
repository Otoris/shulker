'use strict'

const getDocsUrl = require('./lib/get-docs-url')

function isFunctionWithBlockStatement(node) ***REMOVED***
  if (node.type === 'FunctionExpression') ***REMOVED***
    return true
  ***REMOVED***
  if (node.type === 'ArrowFunctionExpression') ***REMOVED***
    return node.body.type === 'BlockStatement'
  ***REMOVED***
  return false
***REMOVED***

function isThenCallExpression(node) ***REMOVED***
  return (
    node.type === 'CallExpression' &&
    node.callee.type === 'MemberExpression' &&
    node.callee.property.name === 'then'
  )
***REMOVED***

function isFirstArgument(node) ***REMOVED***
  return (
    node.parent && node.parent.arguments && node.parent.arguments[0] === node
  )
***REMOVED***

function isInlineThenFunctionExpression(node) ***REMOVED***
  return (
    isFunctionWithBlockStatement(node) &&
    isThenCallExpression(node.parent) &&
    isFirstArgument(node)
  )
***REMOVED***

function hasParentReturnStatement(node) ***REMOVED***
  if (node && node.parent && node.parent.type) ***REMOVED***
    // if the parent is a then, and we haven't returned anything, fail
    if (isThenCallExpression(node.parent)) ***REMOVED***
      return false
    ***REMOVED***

    if (node.parent.type === 'ReturnStatement') ***REMOVED***
      return true
    ***REMOVED***
    return hasParentReturnStatement(node.parent)
  ***REMOVED***

  return false
***REMOVED***

function peek(arr) ***REMOVED***
  return arr[arr.length - 1]
***REMOVED***

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      url: getDocsUrl('always-return')
    ***REMOVED***
  ***REMOVED***,
  create(context) ***REMOVED***
    // funcInfoStack is a stack representing the stack of currently executing
    //   functions
    // funcInfoStack[i].branchIDStack is a stack representing the currently
    //   executing branches ("codePathSegment"s) within the given function
    // funcInfoStack[i].branchInfoMap is an object representing information
    //   about all branches within the given function
    // funcInfoStack[i].branchInfoMap[j].good is a boolean representing whether
    //   the given branch explictly `return`s or `throw`s. It starts as `false`
    //   for every branch and is updated to `true` if a `return` or `throw`
    //   statement is found
    // funcInfoStack[i].branchInfoMap[j].loc is a eslint SourceLocation object
    //   for the given branch
    // example:
    //   funcInfoStack = [ ***REMOVED*** branchIDStack: [ 's1_1' ],
    //       branchInfoMap:
    //        ***REMOVED*** s1_1:
    //           ***REMOVED*** good: false,
    //             loc: <loc> ***REMOVED*** ***REMOVED*** ***REMOVED***,
    //     ***REMOVED*** branchIDStack: ['s2_1', 's2_4'],
    //       branchInfoMap:
    //        ***REMOVED*** s2_1:
    //           ***REMOVED*** good: false,
    //             loc: <loc> ***REMOVED***,
    //          s2_2:
    //           ***REMOVED*** good: true,
    //             loc: <loc> ***REMOVED***,
    //          s2_4:
    //           ***REMOVED*** good: false,
    //             loc: <loc> ***REMOVED*** ***REMOVED*** ***REMOVED*** ]
    const funcInfoStack = []

    function markCurrentBranchAsGood() ***REMOVED***
      const funcInfo = peek(funcInfoStack)
      const currentBranchID = peek(funcInfo.branchIDStack)
      if (funcInfo.branchInfoMap[currentBranchID]) ***REMOVED***
        funcInfo.branchInfoMap[currentBranchID].good = true
      ***REMOVED***
      // else unreachable code
    ***REMOVED***

    return ***REMOVED***
      ReturnStatement: markCurrentBranchAsGood,
      ThrowStatement: markCurrentBranchAsGood,

      onCodePathSegmentStart(segment, node) ***REMOVED***
        const funcInfo = peek(funcInfoStack)
        funcInfo.branchIDStack.push(segment.id)
        funcInfo.branchInfoMap[segment.id] = ***REMOVED*** good: false, node ***REMOVED***
      ***REMOVED***,

      onCodePathSegmentEnd() ***REMOVED***
        const funcInfo = peek(funcInfoStack)
        funcInfo.branchIDStack.pop()
      ***REMOVED***,

      onCodePathStart() ***REMOVED***
        funcInfoStack.push(***REMOVED***
          branchIDStack: [],
          branchInfoMap: ***REMOVED******REMOVED***
        ***REMOVED***)
      ***REMOVED***,

      onCodePathEnd(path, node) ***REMOVED***
        const funcInfo = funcInfoStack.pop()

        if (!isInlineThenFunctionExpression(node)) ***REMOVED***
          return
        ***REMOVED***

        path.finalSegments.forEach(segment => ***REMOVED***
          const id = segment.id
          const branch = funcInfo.branchInfoMap[id]
          if (!branch.good) ***REMOVED***
            if (hasParentReturnStatement(branch.node)) ***REMOVED***
              return
            ***REMOVED***

            // check shortcircuit syntax like `x && x()` and `y || x()``
            const prevSegments = segment.prevSegments
            for (let ii = prevSegments.length - 1; ii >= 0; --ii) ***REMOVED***
              const prevSegment = prevSegments[ii]
              if (funcInfo.branchInfoMap[prevSegment.id].good) return
            ***REMOVED***

            context.report(***REMOVED***
              message: 'Each then() should return a value or throw',
              node: branch.node
            ***REMOVED***)
          ***REMOVED***
        ***REMOVED***)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***
