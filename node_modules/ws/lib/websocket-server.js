'use strict';

const EventEmitter = require('events');
const crypto = require('crypto');
const http = require('http');

const PerMessageDeflate = require('./permessage-deflate');
const extension = require('./extension');
const WebSocket = require('./websocket');
const ***REMOVED*** GUID ***REMOVED*** = require('./constants');

const keyRegex = /^[+/0-9A-Za-z]***REMOVED***22***REMOVED***==$/;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter ***REMOVED***
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param ***REMOVED***Object***REMOVED*** options Configuration options
   * @param ***REMOVED***Number***REMOVED*** options.backlog The maximum length of the queue of pending
   *     connections
   * @param ***REMOVED***Boolean***REMOVED*** options.clientTracking Specifies whether or not to track
   *     clients
   * @param ***REMOVED***Function***REMOVED*** options.handleProtocols An hook to handle protocols
   * @param ***REMOVED***String***REMOVED*** options.host The hostname where to bind the server
   * @param ***REMOVED***Number***REMOVED*** options.maxPayload The maximum allowed message size
   * @param ***REMOVED***Boolean***REMOVED*** options.noServer Enable no server mode
   * @param ***REMOVED***String***REMOVED*** options.path Accept only connections matching this path
   * @param ***REMOVED***(Boolean|Object)***REMOVED*** options.perMessageDeflate Enable/disable
   *     permessage-deflate
   * @param ***REMOVED***Number***REMOVED*** options.port The port where to bind the server
   * @param ***REMOVED***http.Server***REMOVED*** options.server A pre-created HTTP/S server to use
   * @param ***REMOVED***Function***REMOVED*** options.verifyClient An hook to reject connections
   * @param ***REMOVED***Function***REMOVED*** callback A listener for the `listening` event
   */
  constructor(options, callback) ***REMOVED***
    super();

    options = Object.assign(
      ***REMOVED***
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null, // use default (511 as implemented in net.js)
        server: null,
        host: null,
        path: null,
        port: null
      ***REMOVED***,
      options
    );

    if (options.port == null && !options.server && !options.noServer) ***REMOVED***
      throw new TypeError(
        'One of the "port", "server", or "noServer" options must be specified'
      );
    ***REMOVED***

    if (options.port != null) ***REMOVED***
      this._server = http.createServer((req, res) => ***REMOVED***
        const body = http.STATUS_CODES[426];

        res.writeHead(426, ***REMOVED***
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        ***REMOVED***);
        res.end(body);
      ***REMOVED***);
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    ***REMOVED*** else if (options.server) ***REMOVED***
      this._server = options.server;
    ***REMOVED***

    if (this._server) ***REMOVED***
      this._removeListeners = addListeners(this._server, ***REMOVED***
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => ***REMOVED***
          this.handleUpgrade(req, socket, head, (ws) => ***REMOVED***
            this.emit('connection', ws, req);
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    if (options.perMessageDeflate === true) options.perMessageDeflate = ***REMOVED******REMOVED***;
    if (options.clientTracking) this.clients = new Set();
    this.options = options;
  ***REMOVED***

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return ***REMOVED***(Object|String|null)***REMOVED*** The address of the server
   * @public
   */
  address() ***REMOVED***
    if (this.options.noServer) ***REMOVED***
      throw new Error('The server is operating in "noServer" mode');
    ***REMOVED***

    if (!this._server) return null;
    return this._server.address();
  ***REMOVED***

  /**
   * Close the server.
   *
   * @param ***REMOVED***Function***REMOVED*** cb Callback
   * @public
   */
  close(cb) ***REMOVED***
    if (cb) this.once('close', cb);

    //
    // Terminate all associated clients.
    //
    if (this.clients) ***REMOVED***
      for (const client of this.clients) client.terminate();
    ***REMOVED***

    const server = this._server;

    if (server) ***REMOVED***
      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // Close the http server if it was internally created.
      //
      if (this.options.port != null) ***REMOVED***
        server.close(() => this.emit('close'));
        return;
      ***REMOVED***
    ***REMOVED***

    process.nextTick(emitClose, this);
  ***REMOVED***

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param ***REMOVED***http.IncomingMessage***REMOVED*** req Request object to inspect
   * @return ***REMOVED***Boolean***REMOVED*** `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) ***REMOVED***
    if (this.options.path) ***REMOVED***
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    ***REMOVED***

    return true;
  ***REMOVED***

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param ***REMOVED***http.IncomingMessage***REMOVED*** req The request object
   * @param ***REMOVED***net.Socket***REMOVED*** socket The network socket between the server and client
   * @param ***REMOVED***Buffer***REMOVED*** head The first packet of the upgraded stream
   * @param ***REMOVED***Function***REMOVED*** cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) ***REMOVED***
    socket.on('error', socketOnError);

    const key =
      req.headers['sec-websocket-key'] !== undefined
        ? req.headers['sec-websocket-key'].trim()
        : false;
    const version = +req.headers['sec-websocket-version'];
    const extensions = ***REMOVED******REMOVED***;

    if (
      req.method !== 'GET' ||
      req.headers.upgrade.toLowerCase() !== 'websocket' ||
      !key ||
      !keyRegex.test(key) ||
      (version !== 8 && version !== 13) ||
      !this.shouldHandle(req)
    ) ***REMOVED***
      return abortHandshake(socket, 400);
    ***REMOVED***

    if (this.options.perMessageDeflate) ***REMOVED***
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try ***REMOVED***
        const offers = extension.parse(req.headers['sec-websocket-extensions']);

        if (offers[PerMessageDeflate.extensionName]) ***REMOVED***
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        ***REMOVED***
      ***REMOVED*** catch (err) ***REMOVED***
        return abortHandshake(socket, 400);
      ***REMOVED***
    ***REMOVED***

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) ***REMOVED***
      const info = ***REMOVED***
        origin:
          req.headers[`$***REMOVED***version === 8 ? 'sec-websocket-origin' : 'origin'***REMOVED***`],
        secure: !!(req.connection.authorized || req.connection.encrypted),
        req
      ***REMOVED***;

      if (this.options.verifyClient.length === 2) ***REMOVED***
        this.options.verifyClient(info, (verified, code, message, headers) => ***REMOVED***
          if (!verified) ***REMOVED***
            return abortHandshake(socket, code || 401, message, headers);
          ***REMOVED***

          this.completeUpgrade(key, extensions, req, socket, head, cb);
        ***REMOVED***);
        return;
      ***REMOVED***

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    ***REMOVED***

    this.completeUpgrade(key, extensions, req, socket, head, cb);
  ***REMOVED***

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param ***REMOVED***String***REMOVED*** key The value of the `Sec-WebSocket-Key` header
   * @param ***REMOVED***Object***REMOVED*** extensions The accepted extensions
   * @param ***REMOVED***http.IncomingMessage***REMOVED*** req The request object
   * @param ***REMOVED***net.Socket***REMOVED*** socket The network socket between the server and client
   * @param ***REMOVED***Buffer***REMOVED*** head The first packet of the upgraded stream
   * @param ***REMOVED***Function***REMOVED*** cb Callback
   * @private
   */
  completeUpgrade(key, extensions, req, socket, head, cb) ***REMOVED***
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    const digest = crypto
      .createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: $***REMOVED***digest***REMOVED***`
    ];

    const ws = new WebSocket(null);
    var protocol = req.headers['sec-websocket-protocol'];

    if (protocol) ***REMOVED***
      protocol = protocol.trim().split(/ *, */);

      //
      // Optionally call external protocol selection handler.
      //
      if (this.options.handleProtocols) ***REMOVED***
        protocol = this.options.handleProtocols(protocol, req);
      ***REMOVED*** else ***REMOVED***
        protocol = protocol[0];
      ***REMOVED***

      if (protocol) ***REMOVED***
        headers.push(`Sec-WebSocket-Protocol: $***REMOVED***protocol***REMOVED***`);
        ws.protocol = protocol;
      ***REMOVED***
    ***REMOVED***

    if (extensions[PerMessageDeflate.extensionName]) ***REMOVED***
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format(***REMOVED***
        [PerMessageDeflate.extensionName]: [params]
      ***REMOVED***);
      headers.push(`Sec-WebSocket-Extensions: $***REMOVED***value***REMOVED***`);
      ws._extensions = extensions;
    ***REMOVED***

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, this.options.maxPayload);

    if (this.clients) ***REMOVED***
      this.clients.add(ws);
      ws.on('close', () => this.clients.delete(ws));
    ***REMOVED***

    cb(ws);
  ***REMOVED***
***REMOVED***

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param ***REMOVED***EventEmitter***REMOVED*** server The event emitter
 * @param ***REMOVED***Object.<String, Function>***REMOVED*** map The listeners to add
 * @return ***REMOVED***Function***REMOVED*** A function that will remove the added listeners when called
 * @private
 */
function addListeners(server, map) ***REMOVED***
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() ***REMOVED***
    for (const event of Object.keys(map)) ***REMOVED***
      server.removeListener(event, map[event]);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param ***REMOVED***EventEmitter***REMOVED*** server The event emitter
 * @private
 */
function emitClose(server) ***REMOVED***
  server.emit('close');
***REMOVED***

/**
 * Handle premature socket errors.
 *
 * @private
 */
function socketOnError() ***REMOVED***
  this.destroy();
***REMOVED***

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param ***REMOVED***net.Socket***REMOVED*** socket The socket of the upgrade request
 * @param ***REMOVED***Number***REMOVED*** code The HTTP response status code
 * @param ***REMOVED***String***REMOVED*** [message] The HTTP response body
 * @param ***REMOVED***Object***REMOVED*** [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) ***REMOVED***
  if (socket.writable) ***REMOVED***
    message = message || http.STATUS_CODES[code];
    headers = Object.assign(
      ***REMOVED***
        Connection: 'close',
        'Content-type': 'text/html',
        'Content-Length': Buffer.byteLength(message)
      ***REMOVED***,
      headers
    );

    socket.write(
      `HTTP/1.1 $***REMOVED***code***REMOVED*** $***REMOVED***http.STATUS_CODES[code]***REMOVED***\r\n` +
        Object.keys(headers)
          .map((h) => `$***REMOVED***h***REMOVED***: $***REMOVED***headers[h]***REMOVED***`)
          .join('\r\n') +
        '\r\n\r\n' +
        message
    );
  ***REMOVED***

  socket.removeListener('error', socketOnError);
  socket.destroy();
***REMOVED***
