'use strict';

const EventEmitter = require('events');
const crypto = require('crypto');
const https = require('https');
const http = require('http');
const net = require('net');
const tls = require('tls');
const url = require('url');

const PerMessageDeflate = require('./permessage-deflate');
const EventTarget = require('./event-target');
const extension = require('./extension');
const Receiver = require('./receiver');
const Sender = require('./sender');
const ***REMOVED***
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kStatusCode,
  kWebSocket,
  NOOP
***REMOVED*** = require('./constants');

const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const protocolVersions = [8, 13];
const closeTimeout = 30 * 1000;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter ***REMOVED***
  /**
   * Create a new `WebSocket`.
   *
   * @param ***REMOVED***(String|url.Url|url.URL)***REMOVED*** address The URL to which to connect
   * @param ***REMOVED***(String|String[])***REMOVED*** protocols The subprotocols
   * @param ***REMOVED***Object***REMOVED*** options Connection options
   */
  constructor(address, protocols, options) ***REMOVED***
    super();

    this.readyState = WebSocket.CONNECTING;
    this.protocol = '';

    this._binaryType = BINARY_TYPES[0];
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = '';
    this._closeTimer = null;
    this._closeCode = 1006;
    this._extensions = ***REMOVED******REMOVED***;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) ***REMOVED***
      this._isServer = false;
      this._redirects = 0;

      if (Array.isArray(protocols)) ***REMOVED***
        protocols = protocols.join(', ');
      ***REMOVED*** else if (typeof protocols === 'object' && protocols !== null) ***REMOVED***
        options = protocols;
        protocols = undefined;
      ***REMOVED***

      initAsClient(this, address, protocols, options);
    ***REMOVED*** else ***REMOVED***
      this._isServer = true;
    ***REMOVED***
  ***REMOVED***

  get CONNECTING() ***REMOVED***
    return WebSocket.CONNECTING;
  ***REMOVED***
  get CLOSING() ***REMOVED***
    return WebSocket.CLOSING;
  ***REMOVED***
  get CLOSED() ***REMOVED***
    return WebSocket.CLOSED;
  ***REMOVED***
  get OPEN() ***REMOVED***
    return WebSocket.OPEN;
  ***REMOVED***

  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type ***REMOVED***String***REMOVED***
   */
  get binaryType() ***REMOVED***
    return this._binaryType;
  ***REMOVED***

  set binaryType(type) ***REMOVED***
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  ***REMOVED***

  /**
   * @type ***REMOVED***Number***REMOVED***
   */
  get bufferedAmount() ***REMOVED***
    if (!this._socket) return 0;

    //
    // `socket.bufferSize` is `undefined` if the socket is closed.
    //
    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;
  ***REMOVED***

  /**
   * @type ***REMOVED***String***REMOVED***
   */
  get extensions() ***REMOVED***
    return Object.keys(this._extensions).join();
  ***REMOVED***

  /**
   * Set up the socket and the internal resources.
   *
   * @param ***REMOVED***net.Socket***REMOVED*** socket The network socket between the server and client
   * @param ***REMOVED***Buffer***REMOVED*** head The first packet of the upgraded stream
   * @param ***REMOVED***Number***REMOVED*** maxPayload The maximum allowed message size
   * @private
   */
  setSocket(socket, head, maxPayload) ***REMOVED***
    const receiver = new Receiver(
      this._binaryType,
      this._extensions,
      maxPayload
    );

    this._sender = new Sender(socket, this._extensions);
    this._receiver = receiver;
    this._socket = socket;

    receiver[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    socket.setTimeout(0);
    socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this.readyState = WebSocket.OPEN;
    this.emit('open');
  ***REMOVED***

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() ***REMOVED***
    this.readyState = WebSocket.CLOSED;

    if (!this._socket) ***REMOVED***
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    ***REMOVED***

    if (this._extensions[PerMessageDeflate.extensionName]) ***REMOVED***
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    ***REMOVED***

    this._receiver.removeAllListeners();
    this.emit('close', this._closeCode, this._closeMessage);
  ***REMOVED***

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param ***REMOVED***Number***REMOVED*** code Status code explaining why the connection is closing
   * @param ***REMOVED***String***REMOVED*** data A string explaining why the connection is closing
   * @public
   */
  close(code, data) ***REMOVED***
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) ***REMOVED***
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    ***REMOVED***

    if (this.readyState === WebSocket.CLOSING) ***REMOVED***
      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();
      return;
    ***REMOVED***

    this.readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => ***REMOVED***
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;
      if (this._closeFrameReceived) this._socket.end();
    ***REMOVED***);

    //
    // Specify a timeout for the closing handshake to complete.
    //
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  ***REMOVED***

  /**
   * Send a ping.
   *
   * @param ***REMOVED*******REMOVED*** data The data to send
   * @param ***REMOVED***Boolean***REMOVED*** mask Indicates whether or not to mask `data`
   * @param ***REMOVED***Function***REMOVED*** cb Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) ***REMOVED***
    if (typeof data === 'function') ***REMOVED***
      cb = data;
      data = mask = undefined;
    ***REMOVED*** else if (typeof mask === 'function') ***REMOVED***
      cb = mask;
      mask = undefined;
    ***REMOVED***

    if (this.readyState !== WebSocket.OPEN) ***REMOVED***
      const err = new Error(
        `WebSocket is not open: readyState $***REMOVED***this.readyState***REMOVED*** ` +
          `($***REMOVED***readyStates[this.readyState]***REMOVED***)`
      );

      if (cb) return cb(err);
      throw err;
    ***REMOVED***

    if (typeof data === 'number') data = data.toString();
    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  ***REMOVED***

  /**
   * Send a pong.
   *
   * @param ***REMOVED*******REMOVED*** data The data to send
   * @param ***REMOVED***Boolean***REMOVED*** mask Indicates whether or not to mask `data`
   * @param ***REMOVED***Function***REMOVED*** cb Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) ***REMOVED***
    if (typeof data === 'function') ***REMOVED***
      cb = data;
      data = mask = undefined;
    ***REMOVED*** else if (typeof mask === 'function') ***REMOVED***
      cb = mask;
      mask = undefined;
    ***REMOVED***

    if (this.readyState !== WebSocket.OPEN) ***REMOVED***
      const err = new Error(
        `WebSocket is not open: readyState $***REMOVED***this.readyState***REMOVED*** ` +
          `($***REMOVED***readyStates[this.readyState]***REMOVED***)`
      );

      if (cb) return cb(err);
      throw err;
    ***REMOVED***

    if (typeof data === 'number') data = data.toString();
    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  ***REMOVED***

  /**
   * Send a data message.
   *
   * @param ***REMOVED*******REMOVED*** data The message to send
   * @param ***REMOVED***Object***REMOVED*** options Options object
   * @param ***REMOVED***Boolean***REMOVED*** options.compress Specifies whether or not to compress `data`
   * @param ***REMOVED***Boolean***REMOVED*** options.binary Specifies whether `data` is binary or text
   * @param ***REMOVED***Boolean***REMOVED*** options.fin Specifies whether the fragment is the last one
   * @param ***REMOVED***Boolean***REMOVED*** options.mask Specifies whether or not to mask `data`
   * @param ***REMOVED***Function***REMOVED*** cb Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) ***REMOVED***
    if (typeof options === 'function') ***REMOVED***
      cb = options;
      options = ***REMOVED******REMOVED***;
    ***REMOVED***

    if (this.readyState !== WebSocket.OPEN) ***REMOVED***
      const err = new Error(
        `WebSocket is not open: readyState $***REMOVED***this.readyState***REMOVED*** ` +
          `($***REMOVED***readyStates[this.readyState]***REMOVED***)`
      );

      if (cb) return cb(err);
      throw err;
    ***REMOVED***

    if (typeof data === 'number') data = data.toString();

    const opts = Object.assign(
      ***REMOVED***
        binary: typeof data !== 'string',
        mask: !this._isServer,
        compress: true,
        fin: true
      ***REMOVED***,
      options
    );

    if (!this._extensions[PerMessageDeflate.extensionName]) ***REMOVED***
      opts.compress = false;
    ***REMOVED***

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  ***REMOVED***

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() ***REMOVED***
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) ***REMOVED***
      const msg = 'WebSocket was closed before the connection was established';
      return abortHandshake(this, this._req, msg);
    ***REMOVED***

    if (this._socket) ***REMOVED***
      this.readyState = WebSocket.CLOSING;
      this._socket.destroy();
    ***REMOVED***
  ***REMOVED***
***REMOVED***

readyStates.forEach((readyState, i) => ***REMOVED***
  WebSocket[readyState] = i;
***REMOVED***);

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => ***REMOVED***
  Object.defineProperty(WebSocket.prototype, `on$***REMOVED***method***REMOVED***`, ***REMOVED***
    /**
     * Return the listener of the event.
     *
     * @return ***REMOVED***(Function|undefined)***REMOVED*** The event listener or `undefined`
     * @public
     */
    get() ***REMOVED***
      const listeners = this.listeners(method);
      for (var i = 0; i < listeners.length; i++) ***REMOVED***
        if (listeners[i]._listener) return listeners[i]._listener;
      ***REMOVED***

      return undefined;
    ***REMOVED***,
    /**
     * Add a listener for the event.
     *
     * @param ***REMOVED***Function***REMOVED*** listener The listener to add
     * @public
     */
    set(listener) ***REMOVED***
      const listeners = this.listeners(method);
      for (var i = 0; i < listeners.length; i++) ***REMOVED***
        //
        // Remove only the listeners added via `addEventListener`.
        //
        if (listeners[i]._listener) this.removeListener(method, listeners[i]);
      ***REMOVED***
      this.addEventListener(method, listener);
    ***REMOVED***
  ***REMOVED***);
***REMOVED***);

WebSocket.prototype.addEventListener = EventTarget.addEventListener;
WebSocket.prototype.removeEventListener = EventTarget.removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param ***REMOVED***WebSocket***REMOVED*** websocket The client to initialize
 * @param ***REMOVED***(String|url.Url|url.URL)***REMOVED*** address The URL to which to connect
 * @param ***REMOVED***String***REMOVED*** protocols The subprotocols
 * @param ***REMOVED***Object***REMOVED*** options Connection options
 * @param ***REMOVED***(Boolean|Object)***REMOVED*** options.perMessageDeflate Enable/disable
 *     permessage-deflate
 * @param ***REMOVED***Number***REMOVED*** options.handshakeTimeout Timeout in milliseconds for the
 *     handshake request
 * @param ***REMOVED***Number***REMOVED*** options.protocolVersion Value of the `Sec-WebSocket-Version`
 *     header
 * @param ***REMOVED***String***REMOVED*** options.origin Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param ***REMOVED***Number***REMOVED*** options.maxPayload The maximum allowed message size
 * @param ***REMOVED***Boolean***REMOVED*** options.followRedirects Whether or not to follow redirects
 * @param ***REMOVED***Number***REMOVED*** options.maxRedirects The maximum number of redirects allowed
 * @private
 */
function initAsClient(websocket, address, protocols, options) ***REMOVED***
  const opts = Object.assign(
    ***REMOVED***
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10
    ***REMOVED***,
    options,
    ***REMOVED***
      createConnection: undefined,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: undefined,
      auth: undefined,
      host: undefined,
      path: undefined,
      port: undefined
    ***REMOVED***
  );

  if (!protocolVersions.includes(opts.protocolVersion)) ***REMOVED***
    throw new RangeError(
      `Unsupported protocol version: $***REMOVED***opts.protocolVersion***REMOVED*** ` +
        `(supported versions: $***REMOVED***protocolVersions.join(', ')***REMOVED***)`
    );
  ***REMOVED***

  var parsedUrl;

  if (typeof address === 'object' && address.href !== undefined) ***REMOVED***
    parsedUrl = address;
    websocket.url = address.href;
  ***REMOVED*** else ***REMOVED***
    //
    // The WHATWG URL constructor is not available on Node.js < 6.13.0
    //
    parsedUrl = url.URL ? new url.URL(address) : url.parse(address);
    websocket.url = address;
  ***REMOVED***

  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';

  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) ***REMOVED***
    throw new Error(`Invalid URL: $***REMOVED***websocket.url***REMOVED***`);
  ***REMOVED***

  const isSecure =
    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';
  const defaultPort = isSecure ? 443 : 80;
  const key = crypto.randomBytes(16).toString('base64');
  const get = isSecure ? https.get : http.get;
  const path = parsedUrl.search
    ? `$***REMOVED***parsedUrl.pathname || '/'***REMOVED***$***REMOVED***parsedUrl.search***REMOVED***`
    : parsedUrl.pathname || '/';
  var perMessageDeflate;

  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = Object.assign(
    ***REMOVED***
      'Sec-WebSocket-Version': opts.protocolVersion,
      'Sec-WebSocket-Key': key,
      Connection: 'Upgrade',
      Upgrade: 'websocket'
    ***REMOVED***,
    opts.headers
  );
  opts.path = path;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) ***REMOVED***
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : ***REMOVED******REMOVED***,
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = extension.format(***REMOVED***
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    ***REMOVED***);
  ***REMOVED***
  if (protocols) ***REMOVED***
    opts.headers['Sec-WebSocket-Protocol'] = protocols;
  ***REMOVED***
  if (opts.origin) ***REMOVED***
    if (opts.protocolVersion < 13) ***REMOVED***
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    ***REMOVED*** else ***REMOVED***
      opts.headers.Origin = opts.origin;
    ***REMOVED***
  ***REMOVED***
  if (parsedUrl.auth) ***REMOVED***
    opts.auth = parsedUrl.auth;
  ***REMOVED*** else if (parsedUrl.username || parsedUrl.password) ***REMOVED***
    opts.auth = `$***REMOVED***parsedUrl.username***REMOVED***:$***REMOVED***parsedUrl.password***REMOVED***`;
  ***REMOVED***

  if (isUnixSocket) ***REMOVED***
    const parts = path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  ***REMOVED***

  var req = (websocket._req = get(opts));

  if (opts.timeout) ***REMOVED***
    req.on('timeout', () => ***REMOVED***
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    ***REMOVED***);
  ***REMOVED***

  req.on('error', (err) => ***REMOVED***
    if (websocket._req.aborted) return;

    req = websocket._req = null;
    websocket.readyState = WebSocket.CLOSING;
    websocket.emit('error', err);
    websocket.emitClose();
  ***REMOVED***);

  req.on('response', (res) => ***REMOVED***
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) ***REMOVED***
      if (++websocket._redirects > opts.maxRedirects) ***REMOVED***
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      ***REMOVED***

      req.abort();

      const addr = url.URL
        ? new url.URL(location, address)
        : url.resolve(address, location);

      initAsClient(websocket, addr, protocols, options);
    ***REMOVED*** else if (!websocket.emit('unexpected-response', req, res)) ***REMOVED***
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: $***REMOVED***res.statusCode***REMOVED***`
      );
    ***REMOVED***
  ***REMOVED***);

  req.on('upgrade', (res, socket, head) => ***REMOVED***
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const digest = crypto
      .createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) ***REMOVED***
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    ***REMOVED***

    const serverProt = res.headers['sec-websocket-protocol'];
    const protList = (protocols || '').split(/, */);
    var protError;

    if (!protocols && serverProt) ***REMOVED***
      protError = 'Server sent a subprotocol but none was requested';
    ***REMOVED*** else if (protocols && !serverProt) ***REMOVED***
      protError = 'Server sent no subprotocol';
    ***REMOVED*** else if (serverProt && !protList.includes(serverProt)) ***REMOVED***
      protError = 'Server sent an invalid subprotocol';
    ***REMOVED***

    if (protError) ***REMOVED***
      abortHandshake(websocket, socket, protError);
      return;
    ***REMOVED***

    if (serverProt) websocket.protocol = serverProt;

    if (perMessageDeflate) ***REMOVED***
      try ***REMOVED***
        const extensions = extension.parse(
          res.headers['sec-websocket-extensions']
        );

        if (extensions[PerMessageDeflate.extensionName]) ***REMOVED***
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          websocket._extensions[
            PerMessageDeflate.extensionName
          ] = perMessageDeflate;
        ***REMOVED***
      ***REMOVED*** catch (err) ***REMOVED***
        abortHandshake(
          websocket,
          socket,
          'Invalid Sec-WebSocket-Extensions header'
        );
        return;
      ***REMOVED***
    ***REMOVED***

    websocket.setSocket(socket, head, opts.maxPayload);
  ***REMOVED***);
***REMOVED***

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param ***REMOVED***Object***REMOVED*** options Connection options
 * @return ***REMOVED***net.Socket***REMOVED*** The newly created socket used to start the connection
 * @private
 */
function netConnect(options) ***REMOVED***
  //
  // Override `options.path` only if `options` is a copy of the original options
  // object. This is always true on Node.js >= 8 but not on Node.js 6 where
  // `options.socketPath` might be `undefined` even if the `socketPath` option
  // was originally set.
  //
  if (options.protocolVersion) options.path = options.socketPath;
  return net.connect(options);
***REMOVED***

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param ***REMOVED***Object***REMOVED*** options Connection options
 * @return ***REMOVED***tls.TLSSocket***REMOVED*** The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) ***REMOVED***
  options.path = undefined;
  options.servername = options.servername || options.host;
  return tls.connect(options);
***REMOVED***

/**
 * Abort the handshake and emit an error.
 *
 * @param ***REMOVED***WebSocket***REMOVED*** websocket The WebSocket instance
 * @param ***REMOVED***(http.ClientRequest|net.Socket)***REMOVED*** stream The request to abort or the
 *     socket to destroy
 * @param ***REMOVED***String***REMOVED*** message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) ***REMOVED***
  websocket.readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) ***REMOVED***
    stream.abort();
    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  ***REMOVED*** else ***REMOVED***
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  ***REMOVED***
***REMOVED***

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param ***REMOVED***Number***REMOVED*** code The status code
 * @param ***REMOVED***String***REMOVED*** reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) ***REMOVED***
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);
  websocket._socket.resume();

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
***REMOVED***

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() ***REMOVED***
  this[kWebSocket]._socket.resume();
***REMOVED***

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param ***REMOVED***(RangeError|Error)***REMOVED*** err The emitted error
 * @private
 */
function receiverOnError(err) ***REMOVED***
  const websocket = this[kWebSocket];

  websocket._socket.removeListener('data', socketOnData);

  websocket.readyState = WebSocket.CLOSING;
  websocket._closeCode = err[kStatusCode];
  websocket.emit('error', err);
  websocket._socket.destroy();
***REMOVED***

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() ***REMOVED***
  this[kWebSocket].emitClose();
***REMOVED***

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param ***REMOVED***(String|Buffer|ArrayBuffer|Buffer[])***REMOVED*** data The message
 * @private
 */
function receiverOnMessage(data) ***REMOVED***
  this[kWebSocket].emit('message', data);
***REMOVED***

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param ***REMOVED***Buffer***REMOVED*** data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) ***REMOVED***
  const websocket = this[kWebSocket];

  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
***REMOVED***

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param ***REMOVED***Buffer***REMOVED*** data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) ***REMOVED***
  this[kWebSocket].emit('pong', data);
***REMOVED***

/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */
function socketOnClose() ***REMOVED***
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('end', socketOnEnd);

  websocket.readyState = WebSocket.CLOSING;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk and emitted synchronously in a single
  // `'data'` event.
  //
  websocket._socket.read();
  websocket._receiver.end();

  this.removeListener('data', socketOnData);
  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) ***REMOVED***
    websocket.emitClose();
  ***REMOVED*** else ***REMOVED***
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  ***REMOVED***
***REMOVED***

/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param ***REMOVED***Buffer***REMOVED*** chunk A chunk of data
 * @private
 */
function socketOnData(chunk) ***REMOVED***
  if (!this[kWebSocket]._receiver.write(chunk)) ***REMOVED***
    this.pause();
  ***REMOVED***
***REMOVED***

/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */
function socketOnEnd() ***REMOVED***
  const websocket = this[kWebSocket];

  websocket.readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
***REMOVED***

/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */
function socketOnError() ***REMOVED***
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  websocket.readyState = WebSocket.CLOSING;
  this.destroy();
***REMOVED***
