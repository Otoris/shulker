'use strict';

var test = require('tape');

var forEach = require('foreach');
var is = require('object-is');
var debug = require('object-inspect');
var assign = require('object.assign');
var keys = require('object-keys');
var has = require('has');
var arrowFns = require('make-arrow-function').list();
var hasStrictMode = require('has-strict-mode')();
var functionsHaveNames = require('functions-have-names')();
var functionsHaveConfigurableNames = require('functions-have-names').functionsHaveConfigurableNames();

var $getProto = require('../helpers/getProto');
var $setProto = require('../helpers/setProto');
var defineProperty = require('./helpers/defineProperty');
var getInferredName = require('../helpers/getInferredName');
var getOwnPropertyDescriptor = require('../helpers/getOwnPropertyDescriptor');
var assertRecordTests = require('./helpers/assertRecord');
var v = require('./helpers/values');
var diffOps = require('./diffOps');

var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

var canDistinguishSparseFromUndefined = 0 in [undefined]; // IE 6 - 8 have a bug where this returns false

var getArraySubclassWithSpeciesConstructor = function getArraySubclass(speciesConstructor) ***REMOVED***
	var Bar = function Bar() ***REMOVED***
		var inst = [];
		Object.setPrototypeOf(inst, Bar.prototype);
		defineProperty(inst, 'constructor', ***REMOVED*** value: Bar ***REMOVED***);
		return inst;
	***REMOVED***;
	Bar.prototype = Object.create(Array.prototype);
	Object.setPrototypeOf(Bar, Array);
	defineProperty(Bar, Symbol.species, ***REMOVED*** value: speciesConstructor ***REMOVED***);

	return Bar;
***REMOVED***;

var testIterator = function (t, iterator, expected) ***REMOVED***
	var resultCount = 0;
	var result;
	while (result = iterator.next(), !result.done) ***REMOVED*** // eslint-disable-line no-sequences
		t.deepEqual(result, ***REMOVED*** done: false, value: expected[resultCount] ***REMOVED***, 'result ' + resultCount);
		resultCount += 1;
	***REMOVED***
	t.equal(resultCount, expected.length, 'expected ' + expected.length + ', got ' + resultCount);
***REMOVED***;

var hasSpecies = v.hasSymbols && Symbol.species;

var hasLastIndex = 'lastIndex' in (/a/).exec('a'); // IE 8
var hasGroups = 'groups' in (/a/).exec('a'); // modern engines
var kludgeMatch = function kludgeMatch(R, matchObject) ***REMOVED***
	if (hasGroups) ***REMOVED***
		assign(matchObject, ***REMOVED*** groups: matchObject.groups ***REMOVED***);
	***REMOVED***
	if (hasLastIndex) ***REMOVED***
		assign(matchObject, ***REMOVED*** lastIndex: R.lastIndex ***REMOVED***);
	***REMOVED***
	return matchObject;
***REMOVED***;

var testEnumerableOwnNames = function (t, enumerableOwnNames) ***REMOVED***
	forEach(v.primitives, function (nonObject) ***REMOVED***
		t['throws'](
			function () ***REMOVED*** enumerableOwnNames(nonObject); ***REMOVED***,
			debug(nonObject) + ' is not an Object'
		);
	***REMOVED***);

	var Child = function Child() ***REMOVED***
		this.own = ***REMOVED******REMOVED***;
	***REMOVED***;
	Child.prototype = ***REMOVED***
		inherited: ***REMOVED******REMOVED***
	***REMOVED***;

	var obj = new Child();

	t.equal('own' in obj, true, 'has "own"');
	t.equal(has(obj, 'own'), true, 'has own "own"');
	t.equal(Object.prototype.propertyIsEnumerable.call(obj, 'own'), true, 'has enumerable "own"');

	t.equal('inherited' in obj, true, 'has "inherited"');
	t.equal(has(obj, 'inherited'), false, 'has non-own "inherited"');
	t.equal(has(Child.prototype, 'inherited'), true, 'Child.prototype has own "inherited"');
	t.equal(Child.prototype.inherited, obj.inherited, 'Child.prototype.inherited === obj.inherited');
	t.equal(Object.prototype.propertyIsEnumerable.call(Child.prototype, 'inherited'), true, 'has enumerable "inherited"');

	t.equal('toString' in obj, true, 'has "toString"');
	t.equal(has(obj, 'toString'), false, 'has non-own "toString"');
	t.equal(has(Object.prototype, 'toString'), true, 'Object.prototype has own "toString"');
	t.equal(Object.prototype.toString, obj.toString, 'Object.prototype.toString === obj.toString');
	// eslint-disable-next-line no-useless-call
	t.equal(Object.prototype.propertyIsEnumerable.call(Object.prototype, 'toString'), false, 'has non-enumerable "toString"');

	return obj;
***REMOVED***;

var es2015 = function ES2015(ES, ops, expectedMissing, skips) ***REMOVED***
	test('has expected operations', function (t) ***REMOVED***
		var diff = diffOps(ES, ops, expectedMissing);

		t.deepEqual(diff.extra, [], 'no extra ops');

		t.deepEqual(diff.missing, [], 'no unexpected missing ops');

		t.end();
	***REMOVED***);

	test('ToPrimitive', function (t) ***REMOVED***
		t.test('primitives', function (st) ***REMOVED***
			var testPrimitive = function (primitive) ***REMOVED***
				st.ok(is(ES.ToPrimitive(primitive), primitive), debug(primitive) + ' is returned correctly');
			***REMOVED***;
			forEach(v.primitives, testPrimitive);
			st.end();
		***REMOVED***);

		t.test('objects', function (st) ***REMOVED***
			st.equal(ES.ToPrimitive(v.coercibleObject), 3, 'coercibleObject with no hint coerces to valueOf');
			st.ok(is(ES.ToPrimitive(***REMOVED******REMOVED***), '[object Object]'), '***REMOVED******REMOVED*** with no hint coerces to Object#toString');
			st.equal(ES.ToPrimitive(v.coercibleObject, Number), 3, 'coercibleObject with hint Number coerces to valueOf');
			st.ok(is(ES.ToPrimitive(***REMOVED******REMOVED***, Number), '[object Object]'), '***REMOVED******REMOVED*** with hint Number coerces to NaN');
			st.equal(ES.ToPrimitive(v.coercibleObject, String), 42, 'coercibleObject with hint String coerces to nonstringified toString');
			st.equal(ES.ToPrimitive(***REMOVED******REMOVED***, String), '[object Object]', '***REMOVED******REMOVED*** with hint String coerces to Object#toString');
			st.equal(ES.ToPrimitive(v.toStringOnlyObject), 7, 'toStringOnlyObject returns non-stringified toString');
			st.equal(ES.ToPrimitive(v.valueOfOnlyObject), 4, 'valueOfOnlyObject returns valueOf');
			st['throws'](function () ***REMOVED*** return ES.ToPrimitive(v.uncoercibleObject); ***REMOVED***, TypeError, 'uncoercibleObject throws a TypeError');
			st.end();
		***REMOVED***);

		t.test('dates', function (st) ***REMOVED***
			var invalid = new Date(NaN);
			st.equal(ES.ToPrimitive(invalid), Date.prototype.toString.call(invalid), 'invalid Date coerces to Date#toString');
			var now = new Date();
			st.equal(ES.ToPrimitive(now), Date.prototype.toString.call(now), 'Date coerces to Date#toString');
			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('ToBoolean', function (t) ***REMOVED***
		t.equal(false, ES.ToBoolean(undefined), 'undefined coerces to false');
		t.equal(false, ES.ToBoolean(null), 'null coerces to false');
		t.equal(false, ES.ToBoolean(false), 'false returns false');
		t.equal(true, ES.ToBoolean(true), 'true returns true');

		t.test('numbers', function (st) ***REMOVED***
			forEach(v.zeroes.concat(NaN), function (falsyNumber) ***REMOVED***
				st.equal(false, ES.ToBoolean(falsyNumber), 'falsy number ' + falsyNumber + ' coerces to false');
			***REMOVED***);
			forEach(v.infinities.concat([42, 1]), function (truthyNumber) ***REMOVED***
				st.equal(true, ES.ToBoolean(truthyNumber), 'truthy number ' + truthyNumber + ' coerces to true');
			***REMOVED***);

			st.end();
		***REMOVED***);

		t.equal(false, ES.ToBoolean(''), 'empty string coerces to false');
		t.equal(true, ES.ToBoolean('foo'), 'nonempty string coerces to true');

		t.test('objects', function (st) ***REMOVED***
			forEach(v.objects, function (obj) ***REMOVED***
				st.equal(true, ES.ToBoolean(obj), 'object coerces to true');
			***REMOVED***);
			st.equal(true, ES.ToBoolean(v.uncoercibleObject), 'uncoercibleObject coerces to true');

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('ToNumber', function (t) ***REMOVED***
		t.ok(is(NaN, ES.ToNumber(undefined)), 'undefined coerces to NaN');
		t.ok(is(ES.ToNumber(null), 0), 'null coerces to +0');
		t.ok(is(ES.ToNumber(false), 0), 'false coerces to +0');
		t.equal(1, ES.ToNumber(true), 'true coerces to 1');

		t.test('numbers', function (st) ***REMOVED***
			st.ok(is(NaN, ES.ToNumber(NaN)), 'NaN returns itself');
			forEach(v.zeroes.concat(v.infinities, 42), function (num) ***REMOVED***
				st.equal(num, ES.ToNumber(num), num + ' returns itself');
			***REMOVED***);
			forEach(['foo', '0', '4a', '2.0', 'Infinity', '-Infinity'], function (numString) ***REMOVED***
				st.ok(is(+numString, ES.ToNumber(numString)), '"' + numString + '" coerces to ' + Number(numString));
			***REMOVED***);
			st.end();
		***REMOVED***);

		t.test('objects', function (st) ***REMOVED***
			forEach(v.objects, function (object) ***REMOVED***
				st.ok(is(ES.ToNumber(object), ES.ToNumber(ES.ToPrimitive(object))), 'object ' + object + ' coerces to same as ToPrimitive of object does');
			***REMOVED***);
			st['throws'](function () ***REMOVED*** return ES.ToNumber(v.uncoercibleObject); ***REMOVED***, TypeError, 'uncoercibleObject throws');
			st.end();
		***REMOVED***);

		t.test('binary literals', function (st) ***REMOVED***
			st.equal(ES.ToNumber('0b10'), 2, '0b10 is 2');
			st.equal(ES.ToNumber(***REMOVED*** toString: function () ***REMOVED*** return '0b11'; ***REMOVED*** ***REMOVED***), 3, 'Object that toStrings to 0b11 is 3');

			st.equal(true, is(ES.ToNumber('0b12'), NaN), '0b12 is NaN');
			st.equal(true, is(ES.ToNumber(***REMOVED*** toString: function () ***REMOVED*** return '0b112'; ***REMOVED*** ***REMOVED***), NaN), 'Object that toStrings to 0b112 is NaN');
			st.end();
		***REMOVED***);

		t.test('octal literals', function (st) ***REMOVED***
			st.equal(ES.ToNumber('0o10'), 8, '0o10 is 8');
			st.equal(ES.ToNumber(***REMOVED*** toString: function () ***REMOVED*** return '0o11'; ***REMOVED*** ***REMOVED***), 9, 'Object that toStrings to 0o11 is 9');

			st.equal(true, is(ES.ToNumber('0o18'), NaN), '0o18 is NaN');
			st.equal(true, is(ES.ToNumber(***REMOVED*** toString: function () ***REMOVED*** return '0o118'; ***REMOVED*** ***REMOVED***), NaN), 'Object that toStrings to 0o118 is NaN');
			st.end();
		***REMOVED***);

		t.test('signed hex numbers', function (st) ***REMOVED***
			st.equal(true, is(ES.ToNumber('-0xF'), NaN), '-0xF is NaN');
			st.equal(true, is(ES.ToNumber(' -0xF '), NaN), 'space-padded -0xF is NaN');
			st.equal(true, is(ES.ToNumber('+0xF'), NaN), '+0xF is NaN');
			st.equal(true, is(ES.ToNumber(' +0xF '), NaN), 'space-padded +0xF is NaN');

			st.end();
		***REMOVED***);

		t.test('trimming of whitespace and non-whitespace characters', function (st) ***REMOVED***
			var whitespace = ' \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000';
			st.equal(0, ES.ToNumber(whitespace + 0 + whitespace), 'whitespace is trimmed');

			// Zero-width space (zws), next line character (nel), and non-character (bom) are not whitespace.
			var nonWhitespaces = ***REMOVED***
				'\\u0085': '\u0085',
				'\\u200b': '\u200b',
				'\\ufffe': '\ufffe'
			***REMOVED***;

			forEach(nonWhitespaces, function (desc, nonWS) ***REMOVED***
				st.equal(true, is(ES.ToNumber(nonWS + 0 + nonWS), NaN), 'non-whitespace ' + desc + ' not trimmed');
			***REMOVED***);

			st.end();
		***REMOVED***);

		forEach(v.symbols, function (symbol) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.ToNumber(symbol); ***REMOVED***,
				TypeError,
				'Symbols can’t be converted to a Number: ' + debug(symbol)
			);
		***REMOVED***);

		t.test('dates', function (st) ***REMOVED***
			var invalid = new Date(NaN);
			st.ok(is(ES.ToNumber(invalid), NaN), 'invalid Date coerces to NaN');
			var now = +new Date();
			st.equal(ES.ToNumber(new Date(now)), now, 'Date coerces to timestamp');
			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('ToInteger', function (t) ***REMOVED***
		t.ok(is(0, ES.ToInteger(NaN)), 'NaN coerces to +0');
		forEach([0, Infinity, 42], function (num) ***REMOVED***
			t.ok(is(num, ES.ToInteger(num)), num + ' returns itself');
			t.ok(is(-num, ES.ToInteger(-num)), '-' + num + ' returns itself');
		***REMOVED***);
		t.equal(3, ES.ToInteger(Math.PI), 'pi returns 3');
		t['throws'](function () ***REMOVED*** return ES.ToInteger(v.uncoercibleObject); ***REMOVED***, TypeError, 'uncoercibleObject throws');
		t.end();
	***REMOVED***);

	test('ToInt32', function (t) ***REMOVED***
		t.ok(is(0, ES.ToInt32(NaN)), 'NaN coerces to +0');
		forEach([0, Infinity], function (num) ***REMOVED***
			t.ok(is(0, ES.ToInt32(num)), num + ' returns +0');
			t.ok(is(0, ES.ToInt32(-num)), '-' + num + ' returns +0');
		***REMOVED***);
		t['throws'](function () ***REMOVED*** return ES.ToInt32(v.uncoercibleObject); ***REMOVED***, TypeError, 'uncoercibleObject throws');
		t.ok(is(ES.ToInt32(0x100000000), 0), '2^32 returns +0');
		t.ok(is(ES.ToInt32(0x100000000 - 1), -1), '2^32 - 1 returns -1');
		t.ok(is(ES.ToInt32(0x80000000), -0x80000000), '2^31 returns -2^31');
		t.ok(is(ES.ToInt32(0x80000000 - 1), 0x80000000 - 1), '2^31 - 1 returns 2^31 - 1');
		forEach([0, Infinity, NaN, 0x100000000, 0x80000000, 0x10000, 0x42], function (num) ***REMOVED***
			t.ok(is(ES.ToInt32(num), ES.ToInt32(ES.ToUint32(num))), 'ToInt32(x) === ToInt32(ToUint32(x)) for 0x' + num.toString(16));
			t.ok(is(ES.ToInt32(-num), ES.ToInt32(ES.ToUint32(-num))), 'ToInt32(x) === ToInt32(ToUint32(x)) for -0x' + num.toString(16));
		***REMOVED***);
		t.end();
	***REMOVED***);

	test('ToUint32', function (t) ***REMOVED***
		t.ok(is(0, ES.ToUint32(NaN)), 'NaN coerces to +0');
		forEach([0, Infinity], function (num) ***REMOVED***
			t.ok(is(0, ES.ToUint32(num)), num + ' returns +0');
			t.ok(is(0, ES.ToUint32(-num)), '-' + num + ' returns +0');
		***REMOVED***);
		t['throws'](function () ***REMOVED*** return ES.ToUint32(v.uncoercibleObject); ***REMOVED***, TypeError, 'uncoercibleObject throws');
		t.ok(is(ES.ToUint32(0x100000000), 0), '2^32 returns +0');
		t.ok(is(ES.ToUint32(0x100000000 - 1), 0x100000000 - 1), '2^32 - 1 returns 2^32 - 1');
		t.ok(is(ES.ToUint32(0x80000000), 0x80000000), '2^31 returns 2^31');
		t.ok(is(ES.ToUint32(0x80000000 - 1), 0x80000000 - 1), '2^31 - 1 returns 2^31 - 1');
		forEach([0, Infinity, NaN, 0x100000000, 0x80000000, 0x10000, 0x42], function (num) ***REMOVED***
			t.ok(is(ES.ToUint32(num), ES.ToUint32(ES.ToInt32(num))), 'ToUint32(x) === ToUint32(ToInt32(x)) for 0x' + num.toString(16));
			t.ok(is(ES.ToUint32(-num), ES.ToUint32(ES.ToInt32(-num))), 'ToUint32(x) === ToUint32(ToInt32(x)) for -0x' + num.toString(16));
		***REMOVED***);
		t.end();
	***REMOVED***);

	test('ToInt16', function (t) ***REMOVED***
		t.ok(is(0, ES.ToInt16(NaN)), 'NaN coerces to +0');
		forEach([0, Infinity], function (num) ***REMOVED***
			t.ok(is(0, ES.ToInt16(num)), num + ' returns +0');
			t.ok(is(0, ES.ToInt16(-num)), '-' + num + ' returns +0');
		***REMOVED***);
		t['throws'](function () ***REMOVED*** return ES.ToInt16(v.uncoercibleObject); ***REMOVED***, TypeError, 'uncoercibleObject throws');
		t.ok(is(ES.ToInt16(0x100000000), 0), '2^32 returns +0');
		t.ok(is(ES.ToInt16(0x100000000 - 1), -1), '2^32 - 1 returns -1');
		t.ok(is(ES.ToInt16(0x80000000), 0), '2^31 returns +0');
		t.ok(is(ES.ToInt16(0x80000000 - 1), -1), '2^31 - 1 returns -1');
		t.ok(is(ES.ToInt16(0x10000), 0), '2^16 returns +0');
		t.ok(is(ES.ToInt16(0x10000 - 1), -1), '2^16 - 1 returns -1');
		t.end();
	***REMOVED***);

	test('ToUint16', function (t) ***REMOVED***
		t.ok(is(0, ES.ToUint16(NaN)), 'NaN coerces to +0');
		forEach([0, Infinity], function (num) ***REMOVED***
			t.ok(is(0, ES.ToUint16(num)), num + ' returns +0');
			t.ok(is(0, ES.ToUint16(-num)), '-' + num + ' returns +0');
		***REMOVED***);
		t['throws'](function () ***REMOVED*** return ES.ToUint16(v.uncoercibleObject); ***REMOVED***, TypeError, 'uncoercibleObject throws');
		t.ok(is(ES.ToUint16(0x100000000), 0), '2^32 returns +0');
		t.ok(is(ES.ToUint16(0x100000000 - 1), 0x10000 - 1), '2^32 - 1 returns 2^16 - 1');
		t.ok(is(ES.ToUint16(0x80000000), 0), '2^31 returns +0');
		t.ok(is(ES.ToUint16(0x80000000 - 1), 0x10000 - 1), '2^31 - 1 returns 2^16 - 1');
		t.ok(is(ES.ToUint16(0x10000), 0), '2^16 returns +0');
		t.ok(is(ES.ToUint16(0x10000 - 1), 0x10000 - 1), '2^16 - 1 returns 2^16 - 1');
		t.end();
	***REMOVED***);

	test('ToInt8', function (t) ***REMOVED***
		t.ok(is(0, ES.ToInt8(NaN)), 'NaN coerces to +0');
		forEach([0, Infinity], function (num) ***REMOVED***
			t.ok(is(0, ES.ToInt8(num)), num + ' returns +0');
			t.ok(is(0, ES.ToInt8(-num)), '-' + num + ' returns +0');
		***REMOVED***);
		t['throws'](function () ***REMOVED*** return ES.ToInt8(v.uncoercibleObject); ***REMOVED***, TypeError, 'uncoercibleObject throws');
		t.ok(is(ES.ToInt8(0x100000000), 0), '2^32 returns +0');
		t.ok(is(ES.ToInt8(0x100000000 - 1), -1), '2^32 - 1 returns -1');
		t.ok(is(ES.ToInt8(0x80000000), 0), '2^31 returns +0');
		t.ok(is(ES.ToInt8(0x80000000 - 1), -1), '2^31 - 1 returns -1');
		t.ok(is(ES.ToInt8(0x10000), 0), '2^16 returns +0');
		t.ok(is(ES.ToInt8(0x10000 - 1), -1), '2^16 - 1 returns -1');
		t.ok(is(ES.ToInt8(0x100), 0), '2^8 returns +0');
		t.ok(is(ES.ToInt8(0x100 - 1), -1), '2^8 - 1 returns -1');
		t.ok(is(ES.ToInt8(0x10), 0x10), '2^4 returns 2^4');
		t.end();
	***REMOVED***);

	test('ToUint8', function (t) ***REMOVED***
		t.ok(is(0, ES.ToUint8(NaN)), 'NaN coerces to +0');
		forEach([0, Infinity], function (num) ***REMOVED***
			t.ok(is(0, ES.ToUint8(num)), num + ' returns +0');
			t.ok(is(0, ES.ToUint8(-num)), '-' + num + ' returns +0');
		***REMOVED***);
		t['throws'](function () ***REMOVED*** return ES.ToUint8(v.uncoercibleObject); ***REMOVED***, TypeError, 'uncoercibleObject throws');
		t.ok(is(ES.ToUint8(0x100000000), 0), '2^32 returns +0');
		t.ok(is(ES.ToUint8(0x100000000 - 1), 0x100 - 1), '2^32 - 1 returns 2^8 - 1');
		t.ok(is(ES.ToUint8(0x80000000), 0), '2^31 returns +0');
		t.ok(is(ES.ToUint8(0x80000000 - 1), 0x100 - 1), '2^31 - 1 returns 2^8 - 1');
		t.ok(is(ES.ToUint8(0x10000), 0), '2^16 returns +0');
		t.ok(is(ES.ToUint8(0x10000 - 1), 0x100 - 1), '2^16 - 1 returns 2^8 - 1');
		t.ok(is(ES.ToUint8(0x100), 0), '2^8 returns +0');
		t.ok(is(ES.ToUint8(0x100 - 1), 0x100 - 1), '2^8 - 1 returns 2^16 - 1');
		t.ok(is(ES.ToUint8(0x10), 0x10), '2^4 returns 2^4');
		t.ok(is(ES.ToUint8(0x10 - 1), 0x10 - 1), '2^4 - 1 returns 2^4 - 1');
		t.end();
	***REMOVED***);

	test('ToUint8Clamp', function (t) ***REMOVED***
		t.ok(is(0, ES.ToUint8Clamp(NaN)), 'NaN coerces to +0');
		t.ok(is(0, ES.ToUint8Clamp(0)), '+0 returns +0');
		t.ok(is(0, ES.ToUint8Clamp(-0)), '-0 returns +0');
		t.ok(is(0, ES.ToUint8Clamp(-Infinity)), '-Infinity returns +0');
		t['throws'](function () ***REMOVED*** return ES.ToUint8Clamp(v.uncoercibleObject); ***REMOVED***, TypeError, 'uncoercibleObject throws');
		forEach([255, 256, 0x100000, Infinity], function (number) ***REMOVED***
			t.ok(is(255, ES.ToUint8Clamp(number)), number + ' coerces to 255');
		***REMOVED***);
		t.equal(1, ES.ToUint8Clamp(1.49), '1.49 coerces to 1');
		t.equal(2, ES.ToUint8Clamp(1.5), '1.5 coerces to 2, because 2 is even');
		t.equal(2, ES.ToUint8Clamp(1.51), '1.51 coerces to 2');

		t.equal(2, ES.ToUint8Clamp(2.49), '2.49 coerces to 2');
		t.equal(2, ES.ToUint8Clamp(2.5), '2.5 coerces to 2, because 2 is even');
		t.equal(3, ES.ToUint8Clamp(2.51), '2.51 coerces to 3');
		t.end();
	***REMOVED***);

	test('ToString', function (t) ***REMOVED***
		forEach(v.objects.concat(v.nonSymbolPrimitives), function (item) ***REMOVED***
			t.equal(ES.ToString(item), String(item), 'ES.ToString(' + debug(item) + ') ToStrings to String(' + debug(item) + ')');
		***REMOVED***);

		t['throws'](function () ***REMOVED*** return ES.ToString(v.uncoercibleObject); ***REMOVED***, TypeError, 'uncoercibleObject throws');

		forEach(v.symbols, function (symbol) ***REMOVED***
			t['throws'](function () ***REMOVED*** return ES.ToString(symbol); ***REMOVED***, TypeError, debug(symbol) + ' throws');
		***REMOVED***);
		t.end();
	***REMOVED***);

	test('ToObject', function (t) ***REMOVED***
		t['throws'](function () ***REMOVED*** return ES.ToObject(undefined); ***REMOVED***, TypeError, 'undefined throws');
		t['throws'](function () ***REMOVED*** return ES.ToObject(null); ***REMOVED***, TypeError, 'null throws');
		forEach(v.numbers, function (number) ***REMOVED***
			var obj = ES.ToObject(number);
			t.equal(typeof obj, 'object', 'number ' + number + ' coerces to object');
			t.equal(true, obj instanceof Number, 'object of ' + number + ' is Number object');
			t.ok(is(obj.valueOf(), number), 'object of ' + number + ' coerces to ' + number);
		***REMOVED***);
		t.end();
	***REMOVED***);

	test('RequireObjectCoercible', function (t) ***REMOVED***
		t.equal(false, 'CheckObjectCoercible' in ES, 'CheckObjectCoercible -> RequireObjectCoercible in ES6');
		t['throws'](function () ***REMOVED*** return ES.RequireObjectCoercible(undefined); ***REMOVED***, TypeError, 'undefined throws');
		t['throws'](function () ***REMOVED*** return ES.RequireObjectCoercible(null); ***REMOVED***, TypeError, 'null throws');
		var isCoercible = function (value) ***REMOVED***
			t.doesNotThrow(function () ***REMOVED*** return ES.RequireObjectCoercible(value); ***REMOVED***, debug(value) + ' does not throw');
		***REMOVED***;
		forEach(v.objects.concat(v.nonNullPrimitives), isCoercible);
		t.end();
	***REMOVED***);

	test('IsCallable', function (t) ***REMOVED***
		t.equal(true, ES.IsCallable(function () ***REMOVED******REMOVED***), 'function is callable');
		var nonCallables = [/a/g, ***REMOVED******REMOVED***, Object.prototype, NaN].concat(v.nonFunctions);
		forEach(nonCallables, function (nonCallable) ***REMOVED***
			t.equal(false, ES.IsCallable(nonCallable), debug(nonCallable) + ' is not callable');
		***REMOVED***);
		t.end();
	***REMOVED***);

	test('SameValue', function (t) ***REMOVED***
		t.equal(true, ES.SameValue(NaN, NaN), 'NaN is SameValue as NaN');
		t.equal(false, ES.SameValue(0, -0), '+0 is not SameValue as -0');
		forEach(v.objects.concat(v.primitives), function (val) ***REMOVED***
			t.equal(val === val, ES.SameValue(val, val), debug(val) + ' is SameValue to itself');
		***REMOVED***);
		t.end();
	***REMOVED***);

	test('SameValueZero', function (t) ***REMOVED***
		t.equal(true, ES.SameValueZero(NaN, NaN), 'NaN is SameValueZero as NaN');
		t.equal(true, ES.SameValueZero(0, -0), '+0 is SameValueZero as -0');
		forEach(v.objects.concat(v.primitives), function (val) ***REMOVED***
			t.equal(val === val, ES.SameValueZero(val, val), debug(val) + ' is SameValueZero to itself');
		***REMOVED***);
		t.end();
	***REMOVED***);

	test('ToPropertyKey', function (t) ***REMOVED***
		forEach(v.objects.concat(v.nonSymbolPrimitives), function (value) ***REMOVED***
			t.equal(ES.ToPropertyKey(value), String(value), 'ToPropertyKey(value) === String(value) for non-Symbols');
		***REMOVED***);

		forEach(v.symbols, function (symbol) ***REMOVED***
			t.equal(
				ES.ToPropertyKey(symbol),
				symbol,
				'ToPropertyKey(' + debug(symbol) + ') === ' + debug(symbol)
			);
			t.equal(
				ES.ToPropertyKey(Object(symbol)),
				symbol,
				'ToPropertyKey(' + debug(Object(symbol)) + ') === ' + debug(symbol)
			);
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('ToLength', function (t) ***REMOVED***
		t['throws'](function () ***REMOVED*** return ES.ToLength(v.uncoercibleObject); ***REMOVED***, TypeError, 'uncoercibleObject throws a TypeError');
		t.equal(3, ES.ToLength(v.coercibleObject), 'coercibleObject coerces to 3');
		t.equal(42, ES.ToLength('42.5'), '"42.5" coerces to 42');
		t.equal(7, ES.ToLength(7.3), '7.3 coerces to 7');
		forEach([-0, -1, -42, -Infinity], function (negative) ***REMOVED***
			t.ok(is(0, ES.ToLength(negative)), negative + ' coerces to +0');
		***REMOVED***);
		t.equal(MAX_SAFE_INTEGER, ES.ToLength(MAX_SAFE_INTEGER + 1), '2^53 coerces to 2^53 - 1');
		t.equal(MAX_SAFE_INTEGER, ES.ToLength(MAX_SAFE_INTEGER + 3), '2^53 + 2 coerces to 2^53 - 1');
		t.end();
	***REMOVED***);

	test('IsArray', function (t) ***REMOVED***
		t.equal(true, ES.IsArray([]), '[] is array');
		t.equal(false, ES.IsArray(***REMOVED******REMOVED***), '***REMOVED******REMOVED*** is not array');
		t.equal(false, ES.IsArray(***REMOVED*** length: 1, 0: true ***REMOVED***), 'arraylike object is not array');
		forEach(v.objects.concat(v.primitives), function (value) ***REMOVED***
			t.equal(false, ES.IsArray(value), debug(value) + ' is not array');
		***REMOVED***);
		t.end();
	***REMOVED***);

	test('IsRegExp', function (t) ***REMOVED***
		forEach([/a/g, new RegExp('a', 'g')], function (regex) ***REMOVED***
			t.equal(true, ES.IsRegExp(regex), regex + ' is regex');
		***REMOVED***);

		forEach(v.objects.concat(v.primitives), function (nonRegex) ***REMOVED***
			t.equal(false, ES.IsRegExp(nonRegex), debug(nonRegex) + ' is not regex');
		***REMOVED***);

		t.test('Symbol.match', ***REMOVED*** skip: !v.hasSymbols || !Symbol.match ***REMOVED***, function (st) ***REMOVED***
			var obj = ***REMOVED******REMOVED***;
			obj[Symbol.match] = true;
			st.equal(true, ES.IsRegExp(obj), 'object with truthy Symbol.match is regex');

			var regex = /a/;
			regex[Symbol.match] = false;
			st.equal(false, ES.IsRegExp(regex), 'regex with falsy Symbol.match is not regex');

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('IsPropertyKey', function (t) ***REMOVED***
		forEach(v.numbers.concat(v.objects), function (notKey) ***REMOVED***
			t.equal(false, ES.IsPropertyKey(notKey), debug(notKey) + ' is not property key');
		***REMOVED***);

		t.equal(true, ES.IsPropertyKey('foo'), 'string is property key');

		forEach(v.symbols, function (symbol) ***REMOVED***
			t.equal(true, ES.IsPropertyKey(symbol), debug(symbol) + ' is property key');
		***REMOVED***);
		t.end();
	***REMOVED***);

	test('IsInteger', function (t) ***REMOVED***
		for (var i = -100; i < 100; i += 10) ***REMOVED***
			t.equal(true, ES.IsInteger(i), i + ' is integer');
			t.equal(false, ES.IsInteger(i + 0.2), (i + 0.2) + ' is not integer');
		***REMOVED***
		t.equal(true, ES.IsInteger(-0), '-0 is integer');
		var notInts = v.nonNumbers.concat(v.nonIntegerNumbers, v.infinities, [NaN, [], new Date()]);
		forEach(notInts, function (notInt) ***REMOVED***
			t.equal(false, ES.IsInteger(notInt), debug(notInt) + ' is not integer');
		***REMOVED***);
		t.equal(false, ES.IsInteger(v.uncoercibleObject), 'uncoercibleObject is not integer');
		t.end();
	***REMOVED***);

	test('IsExtensible', function (t) ***REMOVED***
		forEach(v.objects, function (object) ***REMOVED***
			t.equal(true, ES.IsExtensible(object), debug(object) + ' object is extensible');
		***REMOVED***);
		forEach(v.primitives, function (primitive) ***REMOVED***
			t.equal(false, ES.IsExtensible(primitive), debug(primitive) + ' is not extensible');
		***REMOVED***);
		if (Object.preventExtensions) ***REMOVED***
			t.equal(false, ES.IsExtensible(Object.preventExtensions(***REMOVED******REMOVED***)), 'object with extensions prevented is not extensible');
		***REMOVED***
		t.end();
	***REMOVED***);

	test('CanonicalNumericIndexString', function (t) ***REMOVED***
		var throwsOnNonString = function (notString) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** return ES.CanonicalNumericIndexString(notString); ***REMOVED***,
				TypeError,
				debug(notString) + ' is not a string'
			);
		***REMOVED***;
		forEach(v.objects.concat(v.numbers), throwsOnNonString);
		t.ok(is(-0, ES.CanonicalNumericIndexString('-0')), '"-0" returns -0');
		for (var i = -50; i < 50; i += 10) ***REMOVED***
			t.equal(i, ES.CanonicalNumericIndexString(String(i)), '"' + i + '" returns ' + i);
			t.equal(undefined, ES.CanonicalNumericIndexString(String(i) + 'a'), '"' + i + 'a" returns undefined');
		***REMOVED***
		t.end();
	***REMOVED***);

	test('IsConstructor', function (t) ***REMOVED***
		t.equal(true, ES.IsConstructor(function () ***REMOVED******REMOVED***), 'function is constructor');
		t.equal(false, ES.IsConstructor(/a/g), 'regex is not constructor');
		forEach(v.objects, function (object) ***REMOVED***
			t.equal(false, ES.IsConstructor(object), object + ' object is not constructor');
		***REMOVED***);

		try ***REMOVED***
			var foo = Function('return class Foo ***REMOVED******REMOVED***')(); // eslint-disable-line no-new-func
			t.equal(ES.IsConstructor(foo), true, 'class is constructor');
		***REMOVED*** catch (e) ***REMOVED***
			t.comment('SKIP: class syntax not supported.');
		***REMOVED***
		t.end();
	***REMOVED***);

	test('Call', function (t) ***REMOVED***
		var receiver = ***REMOVED******REMOVED***;
		var notFuncs = v.nonFunctions.concat([/a/g, new RegExp('a', 'g')]);
		t.plan(notFuncs.length + 4);
		var throwsIfNotCallable = function (notFunc) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** return ES.Call(notFunc, receiver); ***REMOVED***,
				TypeError,
				debug(notFunc) + ' (' + typeof notFunc + ') is not callable'
			);
		***REMOVED***;
		forEach(notFuncs, throwsIfNotCallable);
		ES.Call(
			function (a, b) ***REMOVED***
				t.equal(this, receiver, 'context matches expected');
				t.deepEqual([a, b], [1, 2], 'named args are correct');
				t.equal(arguments.length, 3, 'extra argument was passed');
				t.equal(arguments[2], 3, 'extra argument was correct');
			***REMOVED***,
			receiver,
			[1, 2, 3]
		);
		t.end();
	***REMOVED***);

	test('GetV', function (t) ***REMOVED***
		t['throws'](function () ***REMOVED*** return ES.GetV(***REMOVED*** 7: 7 ***REMOVED***, 7); ***REMOVED***, TypeError, 'Throws a TypeError if `P` is not a property key');
		var obj = ***REMOVED*** a: function () ***REMOVED******REMOVED*** ***REMOVED***;
		t.equal(ES.GetV(obj, 'a'), obj.a, 'returns property if it exists');
		t.equal(ES.GetV(obj, 'b'), undefined, 'returns undefiend if property does not exist');
		t.end();
	***REMOVED***);

	test('GetMethod', function (t) ***REMOVED***
		t['throws'](function () ***REMOVED*** return ES.GetMethod(***REMOVED*** 7: 7 ***REMOVED***, 7); ***REMOVED***, TypeError, 'Throws a TypeError if `P` is not a property key');
		t.equal(ES.GetMethod(***REMOVED******REMOVED***, 'a'), undefined, 'returns undefined in property is undefined');
		t.equal(ES.GetMethod(***REMOVED*** a: null ***REMOVED***, 'a'), undefined, 'returns undefined if property is null');
		t.equal(ES.GetMethod(***REMOVED*** a: undefined ***REMOVED***, 'a'), undefined, 'returns undefined if property is undefined');
		var obj = ***REMOVED*** a: function () ***REMOVED******REMOVED*** ***REMOVED***;
		t['throws'](function () ***REMOVED*** ES.GetMethod(***REMOVED*** a: 'b' ***REMOVED***, 'a'); ***REMOVED***, TypeError, 'throws TypeError if property exists and is not callable');
		t.equal(ES.GetMethod(obj, 'a'), obj.a, 'returns property if it is callable');
		t.end();
	***REMOVED***);

	test('Get', function (t) ***REMOVED***
		t['throws'](function () ***REMOVED*** return ES.Get('a', 'a'); ***REMOVED***, TypeError, 'Throws a TypeError if `O` is not an Object');
		t['throws'](function () ***REMOVED*** return ES.Get(***REMOVED*** 7: 7 ***REMOVED***, 7); ***REMOVED***, TypeError, 'Throws a TypeError if `P` is not a property key');

		var value = ***REMOVED******REMOVED***;
		t.test('Symbols', ***REMOVED*** skip: !v.hasSymbols ***REMOVED***, function (st) ***REMOVED***
			var sym = Symbol('sym');
			var obj = ***REMOVED******REMOVED***;
			obj[sym] = value;
			st.equal(ES.Get(obj, sym), value, 'returns property `P` if it exists on object `O`');
			st.end();
		***REMOVED***);
		t.equal(ES.Get(***REMOVED*** a: value ***REMOVED***, 'a'), value, 'returns property `P` if it exists on object `O`');
		t.end();
	***REMOVED***);

	test('Type', ***REMOVED*** skip: !v.hasSymbols ***REMOVED***, function (t) ***REMOVED***
		t.equal(ES.Type(Symbol.iterator), 'Symbol', 'Type(Symbol.iterator) is Symbol');
		t.end();
	***REMOVED***);

	test('SpeciesConstructor', function (t) ***REMOVED***
		t['throws'](function () ***REMOVED*** ES.SpeciesConstructor(null); ***REMOVED***, TypeError);
		t['throws'](function () ***REMOVED*** ES.SpeciesConstructor(undefined); ***REMOVED***, TypeError);

		var defaultConstructor = function Foo() ***REMOVED******REMOVED***;

		t.equal(
			ES.SpeciesConstructor(***REMOVED*** constructor: undefined ***REMOVED***, defaultConstructor),
			defaultConstructor,
			'undefined constructor returns defaultConstructor'
		);

		t['throws'](
			function () ***REMOVED*** return ES.SpeciesConstructor(***REMOVED*** constructor: null ***REMOVED***, defaultConstructor); ***REMOVED***,
			TypeError,
			'non-undefined non-object constructor throws'
		);

		t.test('with Symbol.species', ***REMOVED*** skip: !hasSpecies ***REMOVED***, function (st) ***REMOVED***
			var Bar = function Bar() ***REMOVED******REMOVED***;
			Bar[Symbol.species] = null;

			st.equal(
				ES.SpeciesConstructor(new Bar(), defaultConstructor),
				defaultConstructor,
				'undefined/null Symbol.species returns default constructor'
			);

			var Baz = function Baz() ***REMOVED******REMOVED***;
			Baz[Symbol.species] = Bar;
			st.equal(
				ES.SpeciesConstructor(new Baz(), defaultConstructor),
				Bar,
				'returns Symbol.species constructor value'
			);

			Baz[Symbol.species] = ***REMOVED******REMOVED***;
			st['throws'](
				function () ***REMOVED*** ES.SpeciesConstructor(new Baz(), defaultConstructor); ***REMOVED***,
				TypeError,
				'throws when non-constructor non-null non-undefined species value found'
			);

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('IsPropertyDescriptor', ***REMOVED*** skip: skips && skips.IsPropertyDescriptor ***REMOVED***, function (t) ***REMOVED***
		forEach(v.nonUndefinedPrimitives, function (primitive) ***REMOVED***
			t.equal(
				ES.IsPropertyDescriptor(primitive),
				false,
				debug(primitive) + ' is not a Property Descriptor'
			);
		***REMOVED***);

		t.equal(ES.IsPropertyDescriptor(***REMOVED*** invalid: true ***REMOVED***), false, 'invalid keys not allowed on a Property Descriptor');

		t.equal(ES.IsPropertyDescriptor(***REMOVED******REMOVED***), true, 'empty object is an incomplete Property Descriptor');

		t.equal(ES.IsPropertyDescriptor(v.accessorDescriptor()), true, 'accessor descriptor is a Property Descriptor');
		t.equal(ES.IsPropertyDescriptor(v.mutatorDescriptor()), true, 'mutator descriptor is a Property Descriptor');
		t.equal(ES.IsPropertyDescriptor(v.dataDescriptor()), true, 'data descriptor is a Property Descriptor');
		t.equal(ES.IsPropertyDescriptor(v.genericDescriptor()), true, 'generic descriptor is a Property Descriptor');

		t['throws'](
			function () ***REMOVED*** ES.IsPropertyDescriptor(v.bothDescriptor()); ***REMOVED***,
			TypeError,
			'a Property Descriptor can not be both a Data and an Accessor Descriptor'
		);

		t.end();
	***REMOVED***);

	assertRecordTests(ES, test);

	test('IsAccessorDescriptor', function (t) ***REMOVED***
		forEach(v.nonUndefinedPrimitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.IsAccessorDescriptor(primitive); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not a Property Descriptor'
			);
		***REMOVED***);

		t.equal(ES.IsAccessorDescriptor(), false, 'no value is not an Accessor Descriptor');
		t.equal(ES.IsAccessorDescriptor(undefined), false, 'undefined value is not an Accessor Descriptor');

		t.equal(ES.IsAccessorDescriptor(v.accessorDescriptor()), true, 'accessor descriptor is an Accessor Descriptor');
		t.equal(ES.IsAccessorDescriptor(v.mutatorDescriptor()), true, 'mutator descriptor is an Accessor Descriptor');
		t.equal(ES.IsAccessorDescriptor(v.dataDescriptor()), false, 'data descriptor is not an Accessor Descriptor');
		t.equal(ES.IsAccessorDescriptor(v.genericDescriptor()), false, 'generic descriptor is not an Accessor Descriptor');

		t.end();
	***REMOVED***);

	test('IsDataDescriptor', function (t) ***REMOVED***
		forEach(v.nonUndefinedPrimitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.IsDataDescriptor(primitive); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not a Property Descriptor'
			);
		***REMOVED***);

		t.equal(ES.IsDataDescriptor(), false, 'no value is not a Data Descriptor');
		t.equal(ES.IsDataDescriptor(undefined), false, 'undefined value is not a Data Descriptor');

		t.equal(ES.IsDataDescriptor(v.accessorDescriptor()), false, 'accessor descriptor is not a Data Descriptor');
		t.equal(ES.IsDataDescriptor(v.mutatorDescriptor()), false, 'mutator descriptor is not a Data Descriptor');
		t.equal(ES.IsDataDescriptor(v.dataDescriptor()), true, 'data descriptor is a Data Descriptor');
		t.equal(ES.IsDataDescriptor(v.genericDescriptor()), false, 'generic descriptor is not a Data Descriptor');

		t.end();
	***REMOVED***);

	test('IsGenericDescriptor', function (t) ***REMOVED***
		forEach(v.nonUndefinedPrimitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.IsGenericDescriptor(primitive); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not a Property Descriptor'
			);
		***REMOVED***);

		t.equal(ES.IsGenericDescriptor(), false, 'no value is not a Data Descriptor');
		t.equal(ES.IsGenericDescriptor(undefined), false, 'undefined value is not a Data Descriptor');

		t.equal(ES.IsGenericDescriptor(v.accessorDescriptor()), false, 'accessor descriptor is not a generic Descriptor');
		t.equal(ES.IsGenericDescriptor(v.mutatorDescriptor()), false, 'mutator descriptor is not a generic Descriptor');
		t.equal(ES.IsGenericDescriptor(v.dataDescriptor()), false, 'data descriptor is not a generic Descriptor');

		t.equal(ES.IsGenericDescriptor(v.genericDescriptor()), true, 'generic descriptor is a generic Descriptor');

		t.end();
	***REMOVED***);

	test('FromPropertyDescriptor', function (t) ***REMOVED***
		t.equal(ES.FromPropertyDescriptor(), undefined, 'no value begets undefined');
		t.equal(ES.FromPropertyDescriptor(undefined), undefined, 'undefined value begets undefined');

		forEach(v.nonUndefinedPrimitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.FromPropertyDescriptor(primitive); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not a Property Descriptor'
			);
		***REMOVED***);

		var accessor = v.accessorDescriptor();
		t.deepEqual(ES.FromPropertyDescriptor(accessor), ***REMOVED***
			get: accessor['[[Get]]'],
			enumerable: !!accessor['[[Enumerable]]'],
			configurable: !!accessor['[[Configurable]]']
		***REMOVED***);

		var mutator = v.mutatorDescriptor();
		t.deepEqual(ES.FromPropertyDescriptor(mutator), ***REMOVED***
			set: mutator['[[Set]]'],
			enumerable: !!mutator['[[Enumerable]]'],
			configurable: !!mutator['[[Configurable]]']
		***REMOVED***);
		var data = v.dataDescriptor();
		t.deepEqual(ES.FromPropertyDescriptor(data), ***REMOVED***
			value: data['[[Value]]'],
			writable: data['[[Writable]]']
		***REMOVED***);

		t.deepEqual(ES.FromPropertyDescriptor(v.genericDescriptor()), ***REMOVED***
			enumerable: false,
			configurable: true
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('ToPropertyDescriptor', function (t) ***REMOVED***
		forEach(v.nonUndefinedPrimitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.ToPropertyDescriptor(primitive); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not an Object'
			);
		***REMOVED***);

		var accessor = v.accessorDescriptor();
		t.deepEqual(ES.ToPropertyDescriptor(***REMOVED***
			get: accessor['[[Get]]'],
			enumerable: !!accessor['[[Enumerable]]'],
			configurable: !!accessor['[[Configurable]]']
		***REMOVED***), accessor);

		var mutator = v.mutatorDescriptor();
		t.deepEqual(ES.ToPropertyDescriptor(***REMOVED***
			set: mutator['[[Set]]'],
			enumerable: !!mutator['[[Enumerable]]'],
			configurable: !!mutator['[[Configurable]]']
		***REMOVED***), mutator);

		var data = v.dataDescriptor();
		t.deepEqual(ES.ToPropertyDescriptor(***REMOVED***
			value: data['[[Value]]'],
			writable: data['[[Writable]]'],
			configurable: !!data['[[Configurable]]']
		***REMOVED***), assign(data, ***REMOVED*** '[[Configurable]]': false ***REMOVED***));

		var both = v.bothDescriptor();
		t['throws'](
			function () ***REMOVED***
				ES.FromPropertyDescriptor(***REMOVED*** get: both['[[Get]]'], value: both['[[Value]]'] ***REMOVED***);
			***REMOVED***,
			TypeError,
			'data and accessor descriptors are mutually exclusive'
		);

		t.end();
	***REMOVED***);

	test('CompletePropertyDescriptor', function (t) ***REMOVED***
		forEach(v.nonUndefinedPrimitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.CompletePropertyDescriptor(primitive); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not a Property Descriptor'
			);
		***REMOVED***);

		var generic = v.genericDescriptor();
		t.deepEqual(
			ES.CompletePropertyDescriptor(generic),
			***REMOVED***
				'[[Configurable]]': !!generic['[[Configurable]]'],
				'[[Enumerable]]': !!generic['[[Enumerable]]'],
				'[[Value]]': undefined,
				'[[Writable]]': false
			***REMOVED***,
			'completes a Generic Descriptor'
		);

		var data = v.dataDescriptor();
		t.deepEqual(
			ES.CompletePropertyDescriptor(data),
			***REMOVED***
				'[[Configurable]]': !!data['[[Configurable]]'],
				'[[Enumerable]]': false,
				'[[Value]]': data['[[Value]]'],
				'[[Writable]]': !!data['[[Writable]]']
			***REMOVED***,
			'completes a Data Descriptor'
		);

		var accessor = v.accessorDescriptor();
		t.deepEqual(
			ES.CompletePropertyDescriptor(accessor),
			***REMOVED***
				'[[Get]]': accessor['[[Get]]'],
				'[[Enumerable]]': !!accessor['[[Enumerable]]'],
				'[[Configurable]]': !!accessor['[[Configurable]]'],
				'[[Set]]': undefined
			***REMOVED***,
			'completes an Accessor Descriptor'
		);

		var mutator = v.mutatorDescriptor();
		t.deepEqual(
			ES.CompletePropertyDescriptor(mutator),
			***REMOVED***
				'[[Set]]': mutator['[[Set]]'],
				'[[Enumerable]]': !!mutator['[[Enumerable]]'],
				'[[Configurable]]': !!mutator['[[Configurable]]'],
				'[[Get]]': undefined
			***REMOVED***,
			'completes a mutator Descriptor'
		);

		t['throws'](
			function () ***REMOVED*** ES.CompletePropertyDescriptor(v.bothDescriptor()); ***REMOVED***,
			TypeError,
			'data and accessor descriptors are mutually exclusive'
		);

		t.end();
	***REMOVED***);

	test('Set', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.Set(primitive, '', null, false); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not an Object'
			);
		***REMOVED***);

		forEach(v.nonPropertyKeys, function (nonKey) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.Set(***REMOVED******REMOVED***, nonKey, null, false); ***REMOVED***,
				TypeError,
				debug(nonKey) + ' is not a Property Key'
			);
		***REMOVED***);

		forEach(v.nonBooleans, function (nonBoolean) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.Set(***REMOVED******REMOVED***, '', null, nonBoolean); ***REMOVED***,
				TypeError,
				debug(nonBoolean) + ' is not a Boolean'
			);
		***REMOVED***);

		var o = ***REMOVED******REMOVED***;
		var value = ***REMOVED******REMOVED***;
		ES.Set(o, 'key', value, true);
		t.deepEqual(o, ***REMOVED*** key: value ***REMOVED***, 'key is set');

		t.test('nonwritable', ***REMOVED*** skip: !defineProperty.oDP ***REMOVED***, function (st) ***REMOVED***
			var obj = ***REMOVED*** a: value ***REMOVED***;
			defineProperty(obj, 'a', ***REMOVED*** writable: false ***REMOVED***);

			st['throws'](
				function () ***REMOVED*** ES.Set(obj, 'a', value, true); ***REMOVED***,
				TypeError,
				'can not Set nonwritable property'
			);

			st.doesNotThrow(
				function () ***REMOVED*** ES.Set(obj, 'a', value, false); ***REMOVED***,
				'setting Throw to false prevents an exception'
			);

			st.end();
		***REMOVED***);

		t.test('nonconfigurable', ***REMOVED*** skip: !defineProperty.oDP ***REMOVED***, function (st) ***REMOVED***
			var obj = ***REMOVED*** a: value ***REMOVED***;
			defineProperty(obj, 'a', ***REMOVED*** configurable: false ***REMOVED***);

			ES.Set(obj, 'a', value, true);
			st.deepEqual(obj, ***REMOVED*** a: value ***REMOVED***, 'key is set');

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('HasOwnProperty', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.HasOwnProperty(primitive, 'key'); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not an Object'
			);
		***REMOVED***);

		forEach(v.nonPropertyKeys, function (nonKey) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.HasOwnProperty(***REMOVED******REMOVED***, nonKey); ***REMOVED***,
				TypeError,
				debug(nonKey) + ' is not a Property Key'
			);
		***REMOVED***);

		t.equal(ES.HasOwnProperty(***REMOVED******REMOVED***, 'toString'), false, 'inherited properties are not own');
		t.equal(
			ES.HasOwnProperty(***REMOVED*** toString: 1 ***REMOVED***, 'toString'),
			true,
			'shadowed inherited own properties are own'
		);
		t.equal(ES.HasOwnProperty(***REMOVED*** a: 1 ***REMOVED***, 'a'), true, 'own properties are own');

		t.end();
	***REMOVED***);

	test('HasProperty', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.HasProperty(primitive, 'key'); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not an Object'
			);
		***REMOVED***);

		forEach(v.nonPropertyKeys, function (nonKey) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.HasProperty(***REMOVED******REMOVED***, nonKey); ***REMOVED***,
				TypeError,
				debug(nonKey) + ' is not a Property Key'
			);
		***REMOVED***);

		t.equal(ES.HasProperty(***REMOVED******REMOVED***, 'nope'), false, 'object does not have nonexistent properties');
		t.equal(ES.HasProperty(***REMOVED******REMOVED***, 'toString'), true, 'object has inherited properties');
		t.equal(
			ES.HasProperty(***REMOVED*** toString: 1 ***REMOVED***, 'toString'),
			true,
			'object has shadowed inherited own properties'
		);
		t.equal(ES.HasProperty(***REMOVED*** a: 1 ***REMOVED***, 'a'), true, 'object has own properties');

		t.end();
	***REMOVED***);

	test('IsConcatSpreadable', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t.equal(ES.IsConcatSpreadable(primitive), false, debug(primitive) + ' is not an Object');
		***REMOVED***);

		var hasSymbolConcatSpreadable = v.hasSymbols && Symbol.isConcatSpreadable;
		t.test('Symbol.isConcatSpreadable', ***REMOVED*** skip: !hasSymbolConcatSpreadable ***REMOVED***, function (st) ***REMOVED***
			forEach(v.falsies, function (falsy) ***REMOVED***
				var obj = ***REMOVED******REMOVED***;
				obj[Symbol.isConcatSpreadable] = falsy;
				st.equal(
					ES.IsConcatSpreadable(obj),
					false,
					'an object with ' + debug(falsy) + ' as Symbol.isConcatSpreadable is not concat spreadable'
				);
			***REMOVED***);

			forEach(v.truthies, function (truthy) ***REMOVED***
				var obj = ***REMOVED******REMOVED***;
				obj[Symbol.isConcatSpreadable] = truthy;
				st.equal(
					ES.IsConcatSpreadable(obj),
					true,
					'an object with ' + debug(truthy) + ' as Symbol.isConcatSpreadable is concat spreadable'
				);
			***REMOVED***);

			st.end();
		***REMOVED***);

		forEach(v.objects, function (object) ***REMOVED***
			t.equal(
				ES.IsConcatSpreadable(object),
				false,
				'non-array without Symbol.isConcatSpreadable is not concat spreadable'
			);
		***REMOVED***);

		t.equal(ES.IsConcatSpreadable([]), true, 'arrays are concat spreadable');

		t.end();
	***REMOVED***);

	test('Invoke', function (t) ***REMOVED***
		forEach(v.nonPropertyKeys, function (nonKey) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.Invoke(***REMOVED******REMOVED***, nonKey); ***REMOVED***,
				TypeError,
				debug(nonKey) + ' is not a Property Key'
			);
		***REMOVED***);

		t['throws'](function () ***REMOVED*** ES.Invoke(***REMOVED*** o: false ***REMOVED***, 'o'); ***REMOVED***, TypeError, 'fails on a non-function');

		t.test('invoked callback', function (st) ***REMOVED***
			var aValue = ***REMOVED******REMOVED***;
			var bValue = ***REMOVED******REMOVED***;
			var obj = ***REMOVED***
				f: function (a) ***REMOVED***
					st.equal(arguments.length, 2, '2 args passed');
					st.equal(a, aValue, 'first arg is correct');
					st.equal(arguments[1], bValue, 'second arg is correct');
				***REMOVED***
			***REMOVED***;
			st.plan(3);
			ES.Invoke(obj, 'f', aValue, bValue);
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('GetIterator', function (t) ***REMOVED***
		var arr = [1, 2];
		testIterator(t, ES.GetIterator(arr), arr);

		testIterator(t, ES.GetIterator('abc'), 'abc'.split(''));

		t.test('Symbol.iterator', ***REMOVED*** skip: !v.hasSymbols ***REMOVED***, function (st) ***REMOVED***
			var m = new Map();
			m.set(1, 'a');
			m.set(2, 'b');

			testIterator(st, ES.GetIterator(m), [[1, 'a'], [2, 'b']]);

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('IteratorNext', ***REMOVED*** skip: true ***REMOVED***);

	test('IteratorComplete', ***REMOVED*** skip: true ***REMOVED***);

	test('IteratorValue', ***REMOVED*** skip: true ***REMOVED***);

	test('IteratorStep', ***REMOVED*** skip: true ***REMOVED***);

	test('IteratorClose', ***REMOVED*** skip: true ***REMOVED***);

	test('CreateIterResultObject', function (t) ***REMOVED***
		forEach(v.nonBooleans, function (nonBoolean) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.CreateIterResultObject(***REMOVED******REMOVED***, nonBoolean); ***REMOVED***,
				TypeError,
				'"done" argument must be a boolean; ' + debug(nonBoolean) + ' is not'
			);
		***REMOVED***);

		var value = ***REMOVED******REMOVED***;
		t.deepEqual(
			ES.CreateIterResultObject(value, true),
			***REMOVED*** value: value, done: true ***REMOVED***,
			'creates a "done" iteration result'
		);
		t.deepEqual(
			ES.CreateIterResultObject(value, false),
			***REMOVED*** value: value, done: false ***REMOVED***,
			'creates a "not done" iteration result'
		);

		t.end();
	***REMOVED***);

	test('RegExpExec', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.RegExpExec(primitive); ***REMOVED***,
				TypeError,
				'"R" argument must be an object; ' + debug(primitive) + ' is not'
			);
		***REMOVED***);

		forEach(v.nonStrings, function (nonString) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.RegExpExec(***REMOVED******REMOVED***, nonString); ***REMOVED***,
				TypeError,
				'"S" argument must be a String; ' + debug(nonString) + ' is not'
			);
		***REMOVED***);

		t.test('gets and calls a callable "exec"', function (st) ***REMOVED***
			var str = '123';
			var o = ***REMOVED***
				exec: function (S) ***REMOVED***
					st.equal(this, o, '"exec" receiver is R');
					st.equal(S, str, '"exec" argument is S');

					return null;
				***REMOVED***
			***REMOVED***;
			st.plan(2);
			ES.RegExpExec(o, str);
			st.end();
		***REMOVED***);

		t.test('throws if a callable "exec" returns a non-null non-object', function (st) ***REMOVED***
			var str = '123';
			st.plan(v.nonNullPrimitives.length);
			forEach(v.nonNullPrimitives, function (nonNullPrimitive) ***REMOVED***
				st['throws'](
					function () ***REMOVED*** ES.RegExpExec(***REMOVED*** exec: function () ***REMOVED*** return nonNullPrimitive; ***REMOVED*** ***REMOVED***, str); ***REMOVED***,
					TypeError,
					'"exec" method must return `null` or an Object; ' + debug(nonNullPrimitive) + ' is not'
				);
			***REMOVED***);
			st.end();
		***REMOVED***);

		t.test('actual regex that should match against a string', function (st) ***REMOVED***
			var S = 'aabc';
			var R = /a/g;
			var match1 = ES.RegExpExec(R, S);
			var expected1 = assign(['a'], kludgeMatch(R, ***REMOVED*** index: 0, input: S ***REMOVED***));
			var match2 = ES.RegExpExec(R, S);
			var expected2 = assign(['a'], kludgeMatch(R, ***REMOVED*** index: 1, input: S ***REMOVED***));
			var match3 = ES.RegExpExec(R, S);
			st.deepEqual(match1, expected1, 'match object 1 is as expected');
			st.deepEqual(match2, expected2, 'match object 2 is as expected');
			st.equal(match3, null, 'match 3 is null as expected');
			st.end();
		***REMOVED***);

		t.test('actual regex that should match against a string, with shadowed "exec"', function (st) ***REMOVED***
			var S = 'aabc';
			var R = /a/g;
			R.exec = undefined;
			var match1 = ES.RegExpExec(R, S);
			var expected1 = assign(['a'], kludgeMatch(R, ***REMOVED*** index: 0, input: S ***REMOVED***));
			var match2 = ES.RegExpExec(R, S);
			var expected2 = assign(['a'], kludgeMatch(R, ***REMOVED*** index: 1, input: S ***REMOVED***));
			var match3 = ES.RegExpExec(R, S);
			st.deepEqual(match1, expected1, 'match object 1 is as expected');
			st.deepEqual(match2, expected2, 'match object 2 is as expected');
			st.equal(match3, null, 'match 3 is null as expected');
			st.end();
		***REMOVED***);
		t.end();
	***REMOVED***);

	test('ArraySpeciesCreate', function (t) ***REMOVED***
		t.test('errors', function (st) ***REMOVED***
			var testNonNumber = function (nonNumber) ***REMOVED***
				st['throws'](
					function () ***REMOVED*** ES.ArraySpeciesCreate([], nonNumber); ***REMOVED***,
					TypeError,
					debug(nonNumber) + ' is not a number'
				);
			***REMOVED***;
			forEach(v.nonNumbers, testNonNumber);

			st['throws'](
				function () ***REMOVED*** ES.ArraySpeciesCreate([], -1); ***REMOVED***,
				TypeError,
				'-1 is not >= 0'
			);
			st['throws'](
				function () ***REMOVED*** ES.ArraySpeciesCreate([], -Infinity); ***REMOVED***,
				TypeError,
				'-Infinity is not >= 0'
			);

			var testNonIntegers = function (nonInteger) ***REMOVED***
				st['throws'](
					function () ***REMOVED*** ES.ArraySpeciesCreate([], nonInteger); ***REMOVED***,
					TypeError,
					debug(nonInteger) + ' is not an integer'
				);
			***REMOVED***;
			forEach(v.nonIntegerNumbers, testNonIntegers);

			st.end();
		***REMOVED***);

		t.test('works with a non-array', function (st) ***REMOVED***
			forEach(v.objects.concat(v.primitives), function (nonArray) ***REMOVED***
				var arr = ES.ArraySpeciesCreate(nonArray, 0);
				st.ok(ES.IsArray(arr), 'is an array');
				st.equal(arr.length, 0, 'length is correct');
				st.equal(arr.constructor, Array, 'constructor is correct');
			***REMOVED***);

			st.end();
		***REMOVED***);

		t.test('works with a normal array', function (st) ***REMOVED***
			var len = 2;
			var orig = [1, 2, 3];
			var arr = ES.ArraySpeciesCreate(orig, len);

			st.ok(ES.IsArray(arr), 'is an array');
			st.equal(arr.length, len, 'length is correct');
			st.equal(arr.constructor, orig.constructor, 'constructor is correct');

			st.end();
		***REMOVED***);

		t.test('-0 length produces +0 length', function (st) ***REMOVED***
			var len = -0;
			st.ok(is(len, -0), '-0 is negative zero');
			st.notOk(is(len, 0), '-0 is not positive zero');

			var orig = [1, 2, 3];
			var arr = ES.ArraySpeciesCreate(orig, len);

			st.equal(ES.IsArray(arr), true);
			st.ok(is(arr.length, 0));
			st.equal(arr.constructor, orig.constructor);

			st.end();
		***REMOVED***);

		t.test('works with species construtor', ***REMOVED*** skip: !hasSpecies ***REMOVED***, function (st) ***REMOVED***
			var sentinel = ***REMOVED******REMOVED***;
			var Foo = function Foo(len) ***REMOVED***
				this.length = len;
				this.sentinel = sentinel;
			***REMOVED***;
			var Bar = getArraySubclassWithSpeciesConstructor(Foo);
			var bar = new Bar();

			st.equal(ES.IsArray(bar), true, 'Bar instance is an array');

			var arr = ES.ArraySpeciesCreate(bar, 3);
			st.equal(arr.constructor, Foo, 'result used species constructor');
			st.equal(arr.length, 3, 'length property is correct');
			st.equal(arr.sentinel, sentinel, 'Foo constructor was exercised');

			st.end();
		***REMOVED***);

		t.test('works with null species constructor', ***REMOVED*** skip: !hasSpecies ***REMOVED***, function (st) ***REMOVED***
			var Bar = getArraySubclassWithSpeciesConstructor(null);
			var bar = new Bar();

			st.equal(ES.IsArray(bar), true, 'Bar instance is an array');

			var arr = ES.ArraySpeciesCreate(bar, 3);
			st.equal(arr.constructor, Array, 'result used default constructor');
			st.equal(arr.length, 3, 'length property is correct');

			st.end();
		***REMOVED***);

		t.test('works with undefined species constructor', ***REMOVED*** skip: !hasSpecies ***REMOVED***, function (st) ***REMOVED***
			var Bar = getArraySubclassWithSpeciesConstructor();
			var bar = new Bar();

			st.equal(ES.IsArray(bar), true, 'Bar instance is an array');

			var arr = ES.ArraySpeciesCreate(bar, 3);
			st.equal(arr.constructor, Array, 'result used default constructor');
			st.equal(arr.length, 3, 'length property is correct');

			st.end();
		***REMOVED***);

		t.test('throws with object non-construtor species constructor', ***REMOVED*** skip: !hasSpecies ***REMOVED***, function (st) ***REMOVED***
			forEach(v.objects, function (obj) ***REMOVED***
				var Bar = getArraySubclassWithSpeciesConstructor(obj);
				var bar = new Bar();

				st.equal(ES.IsArray(bar), true, 'Bar instance is an array');

				st['throws'](
					function () ***REMOVED*** ES.ArraySpeciesCreate(bar, 3); ***REMOVED***,
					TypeError,
					debug(obj) + ' is not a constructor'
				);
			***REMOVED***);

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('CreateDataProperty', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.CreateDataProperty(primitive); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not an object'
			);
		***REMOVED***);

		forEach(v.nonPropertyKeys, function (nonPropertyKey) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.CreateDataProperty(***REMOVED******REMOVED***, nonPropertyKey); ***REMOVED***,
				TypeError,
				debug(nonPropertyKey) + ' is not a property key'
			);
		***REMOVED***);

		var sentinel = ***REMOVED******REMOVED***;
		forEach(v.propertyKeys, function (propertyKey) ***REMOVED***
			var obj = ***REMOVED******REMOVED***;
			var status = ES.CreateDataProperty(obj, propertyKey, sentinel);
			t.equal(status, true, 'status is true');
			t.equal(
				obj[propertyKey],
				sentinel,
				debug(sentinel) + ' is installed on "' + debug(propertyKey) + '" on the object'
			);

			t.test('with defineProperty', ***REMOVED*** skip: !defineProperty.oDP ***REMOVED***, function (st) ***REMOVED***
				var nonWritable = defineProperty(***REMOVED******REMOVED***, propertyKey, ***REMOVED*** configurable: true, writable: false ***REMOVED***);

				var nonWritableStatus = ES.CreateDataProperty(nonWritable, propertyKey, sentinel);
				st.equal(nonWritableStatus, false, 'create data property failed');
				st.notEqual(
					nonWritable[propertyKey],
					sentinel,
					debug(sentinel) + ' is not installed on "' + debug(propertyKey) + '" on the object when key is nonwritable'
				);

				var nonConfigurable = defineProperty(***REMOVED******REMOVED***, propertyKey, ***REMOVED*** configurable: false, writable: true ***REMOVED***);

				var nonConfigurableStatus = ES.CreateDataProperty(nonConfigurable, propertyKey, sentinel);
				st.equal(nonConfigurableStatus, false, 'create data property failed');
				st.notEqual(
					nonConfigurable[propertyKey],
					sentinel,
					debug(sentinel) + ' is not installed on "' + debug(propertyKey) + '" on the object when key is nonconfigurable'
				);
				st.end();
			***REMOVED***);
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('CreateDataPropertyOrThrow', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.CreateDataPropertyOrThrow(primitive); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not an object'
			);
		***REMOVED***);

		forEach(v.nonPropertyKeys, function (nonPropertyKey) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.CreateDataPropertyOrThrow(***REMOVED******REMOVED***, nonPropertyKey); ***REMOVED***,
				TypeError,
				debug(nonPropertyKey) + ' is not a property key'
			);
		***REMOVED***);

		var sentinel = ***REMOVED******REMOVED***;
		forEach(v.propertyKeys, function (propertyKey) ***REMOVED***
			var obj = ***REMOVED******REMOVED***;
			var status = ES.CreateDataPropertyOrThrow(obj, propertyKey, sentinel);
			t.equal(status, true, 'status is true');
			t.equal(
				obj[propertyKey],
				sentinel,
				debug(sentinel) + ' is installed on "' + debug(propertyKey) + '" on the object'
			);

			if (typeof Object.preventExtensions === 'function') ***REMOVED***
				var notExtensible = ***REMOVED******REMOVED***;
				Object.preventExtensions(notExtensible);

				t['throws'](
					function () ***REMOVED*** ES.CreateDataPropertyOrThrow(notExtensible, propertyKey, sentinel); ***REMOVED***,
					TypeError,
					'can not install ' + debug(propertyKey) + ' on non-extensible object'
				);
				t.notEqual(
					notExtensible[propertyKey],
					sentinel,
					debug(sentinel) + ' is not installed on "' + debug(propertyKey) + '" on the object'
				);
			***REMOVED***
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('ObjectCreate', function (t) ***REMOVED***
		forEach(v.nonNullPrimitives, function (value) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.ObjectCreate(value); ***REMOVED***,
				TypeError,
				debug(value) + ' is not null, or an object'
			);
		***REMOVED***);

		t.test('proto arg', function (st) ***REMOVED***
			var Parent = function Parent() ***REMOVED******REMOVED***;
			Parent.prototype.foo = ***REMOVED******REMOVED***;
			var child = ES.ObjectCreate(Parent.prototype);
			st.equal(child instanceof Parent, true, 'child is instanceof Parent');
			st.equal(child.foo, Parent.prototype.foo, 'child inherits properties from Parent.prototype');

			st.end();
		***REMOVED***);

		t.test('internal slots arg', function (st) ***REMOVED***
			st.doesNotThrow(function () ***REMOVED*** ES.ObjectCreate(***REMOVED******REMOVED***, []); ***REMOVED***, 'an empty slot list is valid');

			st['throws'](
				function () ***REMOVED*** ES.ObjectCreate(***REMOVED******REMOVED***, ['a']); ***REMOVED***,
				SyntaxError,
				'internal slots are not supported'
			);

			st.end();
		***REMOVED***);

		t.test('null proto', ***REMOVED*** skip: !$setProto ***REMOVED***, function (st) ***REMOVED***
			st.equal('toString' in ***REMOVED******REMOVED***, true, 'normal objects have toString');
			st.equal('toString' in ES.ObjectCreate(null), false, 'makes a null object');

			st.end();
		***REMOVED***);

		t.test('null proto when no native Object.create', ***REMOVED*** skip: $setProto ***REMOVED***, function (st) ***REMOVED***
			st['throws'](
				function () ***REMOVED*** ES.ObjectCreate(null); ***REMOVED***,
				SyntaxError,
				'without a native Object.create, can not create null objects'
			);

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('AdvanceStringIndex', function (t) ***REMOVED***
		forEach(v.nonStrings, function (nonString) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.AdvanceStringIndex(nonString); ***REMOVED***,
				TypeError,
				'"S" argument must be a String; ' + debug(nonString) + ' is not'
			);
		***REMOVED***);

		var notInts = v.nonNumbers.concat(
			v.nonIntegerNumbers,
			v.infinities,
			[NaN, [], new Date(), Math.pow(2, 53), -1]
		);
		forEach(notInts, function (nonInt) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.AdvanceStringIndex('abc', nonInt); ***REMOVED***,
				TypeError,
				'"index" argument must be an integer, ' + debug(nonInt) + ' is not.'
			);
		***REMOVED***);

		forEach(v.nonBooleans, function (nonBoolean) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.AdvanceStringIndex('abc', 0, nonBoolean); ***REMOVED***,
				TypeError,
				debug(nonBoolean) + ' is not a Boolean'
			);
		***REMOVED***);

		var str = 'a\uD83D\uDCA9c';

		t.test('non-unicode mode', function (st) ***REMOVED***
			for (var i = 0; i < str.length + 2; i += 1) ***REMOVED***
				st.equal(ES.AdvanceStringIndex(str, i, false), i + 1, i + ' advances to ' + (i + 1));
			***REMOVED***

			st.end();
		***REMOVED***);

		t.test('unicode mode', function (st) ***REMOVED***
			st.equal(ES.AdvanceStringIndex(str, 0, true), 1, '0 advances to 1');
			st.equal(ES.AdvanceStringIndex(str, 1, true), 3, '1 advances to 3');
			st.equal(ES.AdvanceStringIndex(str, 2, true), 3, '2 advances to 3');
			st.equal(ES.AdvanceStringIndex(str, 3, true), 4, '3 advances to 4');
			st.equal(ES.AdvanceStringIndex(str, 4, true), 5, '4 advances to 5');

			st.end();
		***REMOVED***);

		t.test('lone surrogates', function (st) ***REMOVED***
			var halfPoo = 'a\uD83Dc';

			st.equal(ES.AdvanceStringIndex(halfPoo, 0, true), 1, '0 advances to 1');
			st.equal(ES.AdvanceStringIndex(halfPoo, 1, true), 2, '1 advances to 2');
			st.equal(ES.AdvanceStringIndex(halfPoo, 2, true), 3, '2 advances to 3');
			st.equal(ES.AdvanceStringIndex(halfPoo, 3, true), 4, '3 advances to 4');

			st.end();
		***REMOVED***);

		t.test('surrogate pairs', function (st) ***REMOVED***
			var lowestPair = String.fromCharCode('0xD800') + String.fromCharCode('0xDC00');
			var highestPair = String.fromCharCode('0xDBFF') + String.fromCharCode('0xDFFF');
			var poop = String.fromCharCode('0xD83D') + String.fromCharCode('0xDCA9');

			st.equal(ES.AdvanceStringIndex(lowestPair, 0, true), 2, 'lowest surrogate pair, 0 -> 2');
			st.equal(ES.AdvanceStringIndex(highestPair, 0, true), 2, 'highest surrogate pair, 0 -> 2');
			st.equal(ES.AdvanceStringIndex(poop, 0, true), 2, 'poop, 0 -> 2');

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('CreateMethodProperty', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.CreateMethodProperty(primitive, 'key'); ***REMOVED***,
				TypeError,
				'O must be an Object'
			);
		***REMOVED***);

		forEach(v.nonPropertyKeys, function (nonPropertyKey) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.CreateMethodProperty(***REMOVED******REMOVED***, nonPropertyKey); ***REMOVED***,
				TypeError,
				debug(nonPropertyKey) + ' is not a Property Key'
			);
		***REMOVED***);

		t.test('defines correctly', function (st) ***REMOVED***
			var obj = ***REMOVED******REMOVED***;
			var key = 'the key';
			var value = ***REMOVED*** foo: 'bar' ***REMOVED***;

			st.equal(ES.CreateMethodProperty(obj, key, value), true, 'defines property successfully');
			st.test('property descriptor', ***REMOVED*** skip: !getOwnPropertyDescriptor ***REMOVED***, function (s2t) ***REMOVED***
				s2t.deepEqual(
					getOwnPropertyDescriptor(obj, key),
					***REMOVED***
						configurable: true,
						enumerable: false,
						value: value,
						writable: true
					***REMOVED***,
					'sets the correct property descriptor'
				);

				s2t.end();
			***REMOVED***);
			st.equal(obj[key], value, 'sets the correct value');

			st.end();
		***REMOVED***);

		t.test('fails as expected on a frozen object', ***REMOVED*** skip: !Object.freeze ***REMOVED***, function (st) ***REMOVED***
			var obj = Object.freeze(***REMOVED*** foo: 'bar' ***REMOVED***);
			st['throws'](
				function () ***REMOVED*** ES.CreateMethodProperty(obj, 'foo', ***REMOVED*** value: 'baz' ***REMOVED***); ***REMOVED***,
				TypeError,
				'nonconfigurable key can not be defined'
			);

			st.end();
		***REMOVED***);

		t.test('fails as expected on a function with a nonconfigurable name', ***REMOVED*** skip: !functionsHaveNames || functionsHaveConfigurableNames ***REMOVED***, function (st) ***REMOVED***
			st['throws'](
				function () ***REMOVED*** ES.CreateMethodProperty(function () ***REMOVED******REMOVED***, 'name', ***REMOVED*** value: 'baz' ***REMOVED***); ***REMOVED***,
				TypeError,
				'nonconfigurable function name can not be defined'
			);
			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('DefinePropertyOrThrow', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.DefinePropertyOrThrow(primitive, 'key', ***REMOVED******REMOVED***); ***REMOVED***,
				TypeError,
				'O must be an Object'
			);
		***REMOVED***);

		forEach(v.nonPropertyKeys, function (nonPropertyKey) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.DefinePropertyOrThrow(***REMOVED******REMOVED***, nonPropertyKey, ***REMOVED******REMOVED***); ***REMOVED***,
				TypeError,
				debug(nonPropertyKey) + ' is not a Property Key'
			);
		***REMOVED***);

		t.test('defines correctly', function (st) ***REMOVED***
			var obj = ***REMOVED******REMOVED***;
			var key = 'the key';
			var descriptor = ***REMOVED***
				configurable: true,
				enumerable: false,
				value: ***REMOVED*** foo: 'bar' ***REMOVED***,
				writable: true
			***REMOVED***;

			st.equal(ES.DefinePropertyOrThrow(obj, key, descriptor), true, 'defines property successfully');
			st.test('property descriptor', ***REMOVED*** skip: !getOwnPropertyDescriptor ***REMOVED***, function (s2t) ***REMOVED***
				s2t.deepEqual(
					getOwnPropertyDescriptor(obj, key),
					descriptor,
					'sets the correct property descriptor'
				);

				s2t.end();
			***REMOVED***);
			st.deepEqual(obj[key], descriptor.value, 'sets the correct value');

			st.end();
		***REMOVED***);

		t.test('fails as expected on a frozen object', ***REMOVED*** skip: !Object.freeze ***REMOVED***, function (st) ***REMOVED***
			var obj = Object.freeze(***REMOVED*** foo: 'bar' ***REMOVED***);
			st['throws'](
				function () ***REMOVED***
					ES.DefinePropertyOrThrow(obj, 'foo', ***REMOVED*** configurable: true, value: 'baz' ***REMOVED***);
				***REMOVED***,
				TypeError,
				'nonconfigurable key can not be defined'
			);

			st.end();
		***REMOVED***);

		t.test('fails as expected on a function with a nonconfigurable name', ***REMOVED*** skip: !functionsHaveNames || functionsHaveConfigurableNames ***REMOVED***, function (st) ***REMOVED***
			st['throws'](
				function () ***REMOVED***
					ES.DefinePropertyOrThrow(function () ***REMOVED******REMOVED***, 'name', ***REMOVED*** configurable: true, value: 'baz' ***REMOVED***);
				***REMOVED***,
				TypeError,
				'nonconfigurable function name can not be defined'
			);
			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('DeletePropertyOrThrow', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.DeletePropertyOrThrow(primitive, 'key', ***REMOVED******REMOVED***); ***REMOVED***,
				TypeError,
				'O must be an Object'
			);
		***REMOVED***);

		forEach(v.nonPropertyKeys, function (nonPropertyKey) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.DeletePropertyOrThrow(***REMOVED******REMOVED***, nonPropertyKey, ***REMOVED******REMOVED***); ***REMOVED***,
				TypeError,
				debug(nonPropertyKey) + ' is not a Property Key'
			);
		***REMOVED***);

		t.test('defines correctly', function (st) ***REMOVED***
			var obj = ***REMOVED*** 'the key': 42 ***REMOVED***;
			var key = 'the key';

			st.equal(ES.DeletePropertyOrThrow(obj, key), true, 'deletes property successfully');
			st.equal(key in obj, false, 'key is no longer in the object');

			st.end();
		***REMOVED***);

		t.test('fails as expected on a frozen object', ***REMOVED*** skip: !Object.freeze ***REMOVED***, function (st) ***REMOVED***
			var obj = Object.freeze(***REMOVED*** foo: 'bar' ***REMOVED***);
			st['throws'](
				function () ***REMOVED*** ES.DeletePropertyOrThrow(obj, 'foo'); ***REMOVED***,
				TypeError,
				'nonconfigurable key can not be deleted'
			);

			st.end();
		***REMOVED***);

		t.test('fails as expected on a function with a nonconfigurable name', ***REMOVED*** skip: !functionsHaveNames || functionsHaveConfigurableNames ***REMOVED***, function (st) ***REMOVED***
			st['throws'](
				function () ***REMOVED*** ES.DeletePropertyOrThrow(function () ***REMOVED******REMOVED***, 'name'); ***REMOVED***,
				TypeError,
				'nonconfigurable function name can not be deleted'
			);
			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('EnumerableOwnNames', ***REMOVED*** skip: skips && skips.EnumerableOwnNames ***REMOVED***, function (t) ***REMOVED***
		var obj = testEnumerableOwnNames(t, function (O) ***REMOVED*** return ES.EnumerableOwnNames(O); ***REMOVED***);

		t.deepEqual(
			ES.EnumerableOwnNames(obj),
			['own'],
			'returns enumerable own names'
		);

		t.end();
	***REMOVED***);

	test('thisNumberValue', function (t) ***REMOVED***
		forEach(v.nonNumbers, function (nonNumber) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.thisNumberValue(nonNumber); ***REMOVED***,
				TypeError,
				debug(nonNumber) + ' is not a Number'
			);
		***REMOVED***);

		forEach(v.numbers, function (number) ***REMOVED***
			t.equal(ES.thisNumberValue(number), number, debug(number) + ' is its own thisNumberValue');
			var obj = Object(number);
			t.equal(ES.thisNumberValue(obj), number, debug(obj) + ' is the boxed thisNumberValue');
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('thisBooleanValue', function (t) ***REMOVED***
		forEach(v.nonBooleans, function (nonBoolean) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.thisBooleanValue(nonBoolean); ***REMOVED***,
				TypeError,
				debug(nonBoolean) + ' is not a Boolean'
			);
		***REMOVED***);

		forEach(v.booleans, function (boolean) ***REMOVED***
			t.equal(ES.thisBooleanValue(boolean), boolean, debug(boolean) + ' is its own thisBooleanValue');
			var obj = Object(boolean);
			t.equal(ES.thisBooleanValue(obj), boolean, debug(obj) + ' is the boxed thisBooleanValue');
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('thisStringValue', function (t) ***REMOVED***
		forEach(v.nonStrings, function (nonString) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.thisStringValue(nonString); ***REMOVED***,
				TypeError,
				debug(nonString) + ' is not a String'
			);
		***REMOVED***);

		forEach(v.strings, function (string) ***REMOVED***
			t.equal(ES.thisStringValue(string), string, debug(string) + ' is its own thisStringValue');
			var obj = Object(string);
			t.equal(ES.thisStringValue(obj), string, debug(obj) + ' is the boxed thisStringValue');
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('thisTimeValue', function (t) ***REMOVED***
		forEach(v.primitives.concat(v.objects), function (nonDate) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.thisTimeValue(nonDate); ***REMOVED***,
				TypeError,
				debug(nonDate) + ' is not a Date'
			);
		***REMOVED***);

		forEach(v.timestamps, function (timestamp) ***REMOVED***
			var date = new Date(timestamp);

			t.equal(ES.thisTimeValue(date), timestamp, debug(date) + ' is its own thisTimeValue');
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('SetIntegrityLevel', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.SetIntegrityLevel(primitive); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not an Object'
			);
		***REMOVED***);

		t['throws'](
			function () ***REMOVED*** ES.SetIntegrityLevel(***REMOVED******REMOVED***); ***REMOVED***,
			/^TypeError: Assertion failed: `level` must be `"sealed"` or `"frozen"`$/,
			'`level` must be `"sealed"` or `"frozen"`'
		);

		var O = ***REMOVED*** a: 1 ***REMOVED***;
		t.test('sealed', ***REMOVED*** skip: !Object.preventExtensions ***REMOVED***, function (st) ***REMOVED***
			st.equal(ES.SetIntegrityLevel(O, 'sealed'), true);
			st['throws'](
				function () ***REMOVED*** O.b = 2; ***REMOVED***,
				/^TypeError: (Cannot|Can't) add property b, object is not extensible$/,
				'sealing prevent new properties from being added'
			);
			O.a = 2;
			st.equal(O.a, 2, 'pre-frozen, existing properties are mutable');
			st.end();
		***REMOVED***);

		t.test('frozen', ***REMOVED*** skip: !Object.freeze ***REMOVED***, function (st) ***REMOVED***
			st.equal(ES.SetIntegrityLevel(O, 'frozen'), true);
			st['throws'](
				function () ***REMOVED*** O.a = 3; ***REMOVED***,
				/^TypeError: Cannot assign to read only property 'a' of /,
				'freezing prevents existing properties from being mutated'
			);
			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('TestIntegrityLevel', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.TestIntegrityLevel(primitive); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not an Object'
			);
		***REMOVED***);

		t['throws'](
			function () ***REMOVED*** ES.TestIntegrityLevel(***REMOVED*** a: 1 ***REMOVED***); ***REMOVED***,
			/^TypeError: Assertion failed: `level` must be `"sealed"` or `"frozen"`$/,
			'`level` must be `"sealed"` or `"frozen"`'
		);

		t.equal(ES.TestIntegrityLevel(***REMOVED*** a: 1 ***REMOVED***, 'sealed'), false, 'basic object is not sealed');
		t.equal(ES.TestIntegrityLevel(***REMOVED*** a: 1 ***REMOVED***, 'frozen'), false, 'basic object is not frozen');

		t.test('preventExtensions', ***REMOVED*** skip: !Object.preventExtensions ***REMOVED***, function (st) ***REMOVED***
			var o = Object.preventExtensions(***REMOVED*** a: 1 ***REMOVED***);
			st.equal(ES.TestIntegrityLevel(o, 'sealed'), false, 'nonextensible object is not sealed');
			st.equal(ES.TestIntegrityLevel(o, 'frozen'), false, 'nonextensible object is not frozen');

			var empty = Object.preventExtensions(***REMOVED******REMOVED***);
			st.equal(ES.TestIntegrityLevel(empty, 'sealed'), true, 'empty nonextensible object is sealed');
			st.equal(ES.TestIntegrityLevel(empty, 'frozen'), true, 'empty nonextensible object is frozen');
			st.end();
		***REMOVED***);

		t.test('seal', ***REMOVED*** skip: !Object.seal ***REMOVED***, function (st) ***REMOVED***
			var o = Object.seal(***REMOVED*** a: 1 ***REMOVED***);
			st.equal(ES.TestIntegrityLevel(o, 'sealed'), true, 'sealed object is sealed');
			st.equal(ES.TestIntegrityLevel(o, 'frozen'), false, 'sealed object is not frozen');

			var empty = Object.seal(***REMOVED******REMOVED***);
			st.equal(ES.TestIntegrityLevel(empty, 'sealed'), true, 'empty sealed object is sealed');
			st.equal(ES.TestIntegrityLevel(empty, 'frozen'), true, 'empty sealed object is frozen');

			st.end();
		***REMOVED***);

		t.test('freeze', ***REMOVED*** skip: !Object.freeze ***REMOVED***, function (st) ***REMOVED***
			var o = Object.freeze(***REMOVED*** a: 1 ***REMOVED***);
			st.equal(ES.TestIntegrityLevel(o, 'sealed'), true, 'frozen object is sealed');
			st.equal(ES.TestIntegrityLevel(o, 'frozen'), true, 'frozen object is frozen');

			var empty = Object.freeze(***REMOVED******REMOVED***);
			st.equal(ES.TestIntegrityLevel(empty, 'sealed'), true, 'empty frozen object is sealed');
			st.equal(ES.TestIntegrityLevel(empty, 'frozen'), true, 'empty frozen object is frozen');

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('OrdinaryHasInstance', function (t) ***REMOVED***
		forEach(v.nonFunctions, function (nonFunction) ***REMOVED***
			t.equal(ES.OrdinaryHasInstance(nonFunction, ***REMOVED******REMOVED***), false, debug(nonFunction) + ' is not callable');
		***REMOVED***);

		forEach(v.primitives, function (primitive) ***REMOVED***
			t.equal(ES.OrdinaryHasInstance(function () ***REMOVED******REMOVED***, primitive), false, debug(primitive) + ' is not an object');
		***REMOVED***);

		var C = function C() ***REMOVED******REMOVED***;
		var D = function D() ***REMOVED******REMOVED***;
		t.equal(ES.OrdinaryHasInstance(C, new C()), true, 'constructor function has an instance of itself');
		t.equal(ES.OrdinaryHasInstance(C, new D()), false, 'constructor/instance mismatch is false');
		t.equal(ES.OrdinaryHasInstance(D, new C()), false, 'instance/constructor mismatch is false');
		t.equal(ES.OrdinaryHasInstance(C, ***REMOVED******REMOVED***), false, 'plain object is not an instance of a constructor');
		t.equal(ES.OrdinaryHasInstance(Object, ***REMOVED******REMOVED***), true, 'plain object is an instance of Object');

		t.end();
	***REMOVED***);

	test('OrdinaryHasProperty', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.OrdinaryHasProperty(primitive, ''); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not an object'
			);
		***REMOVED***);
		forEach(v.nonPropertyKeys, function (nonPropertyKey) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.OrdinaryHasProperty(***REMOVED******REMOVED***, nonPropertyKey); ***REMOVED***,
				TypeError,
				'P: ' + debug(nonPropertyKey) + ' is not a Property Key'
			);
		***REMOVED***);

		t.equal(ES.OrdinaryHasProperty(***REMOVED*** a: 1 ***REMOVED***, 'a'), true, 'own property is true');
		t.equal(ES.OrdinaryHasProperty(***REMOVED******REMOVED***, 'toString'), true, 'inherited property is true');
		t.equal(ES.OrdinaryHasProperty(***REMOVED******REMOVED***, 'nope'), false, 'absent property is false');

		t.end();
	***REMOVED***);

	test('InstanceofOperator', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.InstanceofOperator(primitive, function () ***REMOVED******REMOVED***); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not an object'
			);
		***REMOVED***);

		forEach(v.nonFunctions, function (nonFunction) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.InstanceofOperator(***REMOVED******REMOVED***, nonFunction); ***REMOVED***,
				TypeError,
				debug(nonFunction) + ' is not callable'
			);
		***REMOVED***);

		var C = function C() ***REMOVED******REMOVED***;
		var D = function D() ***REMOVED******REMOVED***;

		t.equal(ES.InstanceofOperator(new C(), C), true, 'constructor function has an instance of itself');
		t.equal(ES.InstanceofOperator(new D(), C), false, 'constructor/instance mismatch is false');
		t.equal(ES.InstanceofOperator(new C(), D), false, 'instance/constructor mismatch is false');
		t.equal(ES.InstanceofOperator(***REMOVED******REMOVED***, C), false, 'plain object is not an instance of a constructor');
		t.equal(ES.InstanceofOperator(***REMOVED******REMOVED***, Object), true, 'plain object is an instance of Object');

		t.test('Symbol.hasInstance', ***REMOVED*** skip: !v.hasSymbols || !Symbol.hasInstance ***REMOVED***, function (st) ***REMOVED***
			st.plan(4);

			var O = ***REMOVED******REMOVED***;
			var C2 = function () ***REMOVED******REMOVED***;
			st.equal(ES.InstanceofOperator(O, C2), false, 'O is not an instance of C2');

			defineProperty(C2, Symbol.hasInstance, ***REMOVED***
				value: function (obj) ***REMOVED***
					st.equal(this, C2, 'hasInstance receiver is C2');
					st.equal(obj, O, 'hasInstance argument is O');

					return ***REMOVED******REMOVED***; // testing coercion to boolean
				***REMOVED***
			***REMOVED***);

			st.equal(ES.InstanceofOperator(O, C2), true, 'O is now an instance of C2');

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('Abstract Equality Comparison', function (t) ***REMOVED***
		t.test('same types use ===', function (st) ***REMOVED***
			forEach(v.primitives.concat(v.objects), function (value) ***REMOVED***
				st.equal(ES['Abstract Equality Comparison'](value, value), value === value, debug(value) + ' is abstractly equal to itself');
			***REMOVED***);
			st.end();
		***REMOVED***);

		t.test('different types coerce', function (st) ***REMOVED***
			var pairs = [
				[null, undefined],
				[3, '3'],
				[true, '3'],
				[true, 3],
				[false, 0],
				[false, '0'],
				[3, [3]],
				['3', [3]],
				[true, [1]],
				[false, [0]],
				[String(v.coercibleObject), v.coercibleObject],
				[Number(String(v.coercibleObject)), v.coercibleObject],
				[Number(v.coercibleObject), v.coercibleObject],
				[String(Number(v.coercibleObject)), v.coercibleObject]
			];
			forEach(pairs, function (pair) ***REMOVED***
				var a = pair[0];
				var b = pair[1];
				// eslint-disable-next-line eqeqeq
				st.equal(ES['Abstract Equality Comparison'](a, b), a == b, debug(a) + ' == ' + debug(b));
				// eslint-disable-next-line eqeqeq
				st.equal(ES['Abstract Equality Comparison'](b, a), b == a, debug(b) + ' == ' + debug(a));
			***REMOVED***);
			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('Strict Equality Comparison', function (t) ***REMOVED***
		t.test('same types use ===', function (st) ***REMOVED***
			forEach(v.primitives.concat(v.objects), function (value) ***REMOVED***
				st.equal(ES['Strict Equality Comparison'](value, value), value === value, debug(value) + ' is strictly equal to itself');
			***REMOVED***);
			st.end();
		***REMOVED***);

		t.test('different types are not ===', function (st) ***REMOVED***
			var pairs = [
				[null, undefined],
				[3, '3'],
				[true, '3'],
				[true, 3],
				[false, 0],
				[false, '0'],
				[3, [3]],
				['3', [3]],
				[true, [1]],
				[false, [0]],
				[String(v.coercibleObject), v.coercibleObject],
				[Number(String(v.coercibleObject)), v.coercibleObject],
				[Number(v.coercibleObject), v.coercibleObject],
				[String(Number(v.coercibleObject)), v.coercibleObject]
			];
			forEach(pairs, function (pair) ***REMOVED***
				var a = pair[0];
				var b = pair[1];
				st.equal(ES['Strict Equality Comparison'](a, b), a === b, debug(a) + ' === ' + debug(b));
				st.equal(ES['Strict Equality Comparison'](b, a), b === a, debug(b) + ' === ' + debug(a));
			***REMOVED***);
			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('Abstract Relational Comparison', function (t) ***REMOVED***
		t.test('at least one operand is NaN', function (st) ***REMOVED***
			st.equal(ES['Abstract Relational Comparison'](NaN, ***REMOVED******REMOVED***, true), undefined, 'LeftFirst: first is NaN, returns undefined');
			st.equal(ES['Abstract Relational Comparison'](***REMOVED******REMOVED***, NaN, true), undefined, 'LeftFirst: second is NaN, returns undefined');
			st.equal(ES['Abstract Relational Comparison'](NaN, ***REMOVED******REMOVED***, false), undefined, '!LeftFirst: first is NaN, returns undefined');
			st.equal(ES['Abstract Relational Comparison'](***REMOVED******REMOVED***, NaN, false), undefined, '!LeftFirst: second is NaN, returns undefined');
			st.end();
		***REMOVED***);

		t.equal(ES['Abstract Relational Comparison'](3, 4, true), true, 'LeftFirst: 3 is less than 4');
		t.equal(ES['Abstract Relational Comparison'](4, 3, true), false, 'LeftFirst: 3 is not less than 4');
		t.equal(ES['Abstract Relational Comparison'](3, 4, false), true, '!LeftFirst: 3 is less than 4');
		t.equal(ES['Abstract Relational Comparison'](4, 3, false), false, '!LeftFirst: 3 is not less than 4');

		t.equal(ES['Abstract Relational Comparison']('3', '4', true), true, 'LeftFirst: "3" is less than "4"');
		t.equal(ES['Abstract Relational Comparison']('4', '3', true), false, 'LeftFirst: "3" is not less than "4"');
		t.equal(ES['Abstract Relational Comparison']('3', '4', false), true, '!LeftFirst: "3" is less than "4"');
		t.equal(ES['Abstract Relational Comparison']('4', '3', false), false, '!LeftFirst: "3" is not less than "4"');

		t.equal(ES['Abstract Relational Comparison'](v.coercibleObject, 42, true), true, 'LeftFirst: coercible object is less than 42');
		t.equal(ES['Abstract Relational Comparison'](42, v.coercibleObject, true), false, 'LeftFirst: 42 is not less than coercible object');
		t.equal(ES['Abstract Relational Comparison'](v.coercibleObject, 42, false), true, '!LeftFirst: coercible object is less than 42');
		t.equal(ES['Abstract Relational Comparison'](42, v.coercibleObject, false), false, '!LeftFirst: 42 is not less than coercible object');

		t.equal(ES['Abstract Relational Comparison'](v.coercibleObject, '3', true), false, 'LeftFirst: coercible object is not less than "3"');
		t.equal(ES['Abstract Relational Comparison']('3', v.coercibleObject, true), false, 'LeftFirst: "3" is not less than coercible object');
		t.equal(ES['Abstract Relational Comparison'](v.coercibleObject, '3', false), false, '!LeftFirst: coercible object is not less than "3"');
		t.equal(ES['Abstract Relational Comparison']('3', v.coercibleObject, false), false, '!LeftFirst: "3" is not less than coercible object');

		t.end();
	***REMOVED***);

	test('ValidateAndApplyPropertyDescriptor', function (t) ***REMOVED***
		forEach(v.nonUndefinedPrimitives, function (nonUndefinedPrimitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.ValidateAndApplyPropertyDescriptor(nonUndefinedPrimitive, '', false, v.genericDescriptor(), v.genericDescriptor()); ***REMOVED***,
				TypeError,
				'O: ' + debug(nonUndefinedPrimitive) + ' is not undefined or an Object'
			);
		***REMOVED***);

		forEach(v.nonBooleans, function (nonBoolean) ***REMOVED***
			t['throws'](
				function () ***REMOVED***
					return ES.ValidateAndApplyPropertyDescriptor(
						undefined,
						null,
						nonBoolean,
						v.genericDescriptor(),
						v.genericDescriptor()
					);
				***REMOVED***,
				TypeError,
				'extensible: ' + debug(nonBoolean) + ' is not a Boolean'
			);
		***REMOVED***);

		forEach(v.primitives, function (primitive) ***REMOVED***
			// Desc must be a Property Descriptor
			t['throws'](
				function () ***REMOVED***
					return ES.ValidateAndApplyPropertyDescriptor(
						undefined,
						null,
						false,
						primitive,
						v.genericDescriptor()
					);
				***REMOVED***,
				TypeError,
				'Desc: ' + debug(primitive) + ' is not a Property Descriptor'
			);
		***REMOVED***);

		forEach(v.nonUndefinedPrimitives, function (primitive) ***REMOVED***
			// current must be undefined or a Property Descriptor
			t['throws'](
				function () ***REMOVED***
					return ES.ValidateAndApplyPropertyDescriptor(
						undefined,
						null,
						false,
						v.genericDescriptor(),
						primitive
					);
				***REMOVED***,
				TypeError,
				'current: ' + debug(primitive) + ' is not a Property Descriptor or undefined'
			);
		***REMOVED***);

		forEach(v.nonPropertyKeys, function (nonPropertyKey) ***REMOVED***
			// if O is an object, P must be a property key
			t['throws'](
				function () ***REMOVED***
					return ES.ValidateAndApplyPropertyDescriptor(
						***REMOVED******REMOVED***,
						nonPropertyKey,
						false,
						v.genericDescriptor(),
						v.genericDescriptor()
					);
				***REMOVED***,
				TypeError,
				'P: ' + debug(nonPropertyKey) + ' is not a Property Key'
			);
		***REMOVED***);

		t.test('current is undefined', function (st) ***REMOVED***
			var propertyKey = 'howdy';

			st.test('generic descriptor', function (s2t) ***REMOVED***
				var generic = v.genericDescriptor();
				generic['[[Enumerable]]'] = true;
				var O = ***REMOVED******REMOVED***;
				ES.ValidateAndApplyPropertyDescriptor(undefined, propertyKey, true, generic);
				s2t.equal(
					ES.ValidateAndApplyPropertyDescriptor(O, propertyKey, false, generic),
					false,
					'when extensible is false, nothing happens'
				);
				s2t.deepEqual(O, ***REMOVED******REMOVED***, 'no changes applied when O is undefined or extensible is false');
				s2t.equal(
					ES.ValidateAndApplyPropertyDescriptor(O, propertyKey, true, generic),
					true,
					'operation is successful'
				);
				var expected = ***REMOVED******REMOVED***;
				expected[propertyKey] = undefined;
				s2t.deepEqual(O, expected, 'generic descriptor has been defined as an own data property');
				s2t.end();
			***REMOVED***);

			st.test('data descriptor', function (s2t) ***REMOVED***
				var data = v.dataDescriptor();
				data['[[Enumerable]]'] = true;

				var O = ***REMOVED******REMOVED***;
				s2t.equal(
					ES.ValidateAndApplyPropertyDescriptor(undefined, propertyKey, true, data),
					true,
					'noop when O is undefined'
				);
				s2t.equal(
					ES.ValidateAndApplyPropertyDescriptor(O, propertyKey, false, data),
					false,
					'when extensible is false, nothing happens'
				);
				s2t.deepEqual(O, ***REMOVED******REMOVED***, 'no changes applied when O is undefined or extensible is false');
				s2t.equal(
					ES.ValidateAndApplyPropertyDescriptor(O, propertyKey, true, data),
					true,
					'operation is successful'
				);
				var expected = ***REMOVED******REMOVED***;
				expected[propertyKey] = data['[[Value]]'];
				s2t.deepEqual(O, expected, 'data descriptor has been defined as an own data property');
				s2t.end();
			***REMOVED***);

			st.test('accessor descriptor', ***REMOVED*** skip: !defineProperty.oDP ***REMOVED***, function (s2t) ***REMOVED***
				var count = 0;
				var accessor = v.accessorDescriptor();
				accessor['[[Enumerable]]'] = true;
				accessor['[[Get]]'] = function () ***REMOVED***
					count += 1;
					return count;
				***REMOVED***;

				var O = ***REMOVED******REMOVED***;
				ES.ValidateAndApplyPropertyDescriptor(undefined, propertyKey, true, accessor);
				s2t.equal(
					ES.ValidateAndApplyPropertyDescriptor(O, propertyKey, false, accessor),
					false,
					'when extensible is false, nothing happens'
				);
				s2t.deepEqual(O, ***REMOVED******REMOVED***, 'no changes applied when O is undefined or extensible is false');
				s2t.equal(
					ES.ValidateAndApplyPropertyDescriptor(O, propertyKey, true, accessor),
					true,
					'operation is successful'
				);
				var expected = ***REMOVED******REMOVED***;
				expected[propertyKey] = accessor['[[Get]]']() + 1;
				s2t.deepEqual(O, expected, 'accessor descriptor has been defined as an own accessor property');
				s2t.end();
			***REMOVED***);

			st.end();
		***REMOVED***);

		t.test('every field in Desc is absent', ***REMOVED*** skip: 'it is unclear if having no fields qualifies Desc to be a Property Descriptor' ***REMOVED***);

		forEach([v.dataDescriptor, v.accessorDescriptor, v.mutatorDescriptor], function (getDescriptor) ***REMOVED***
			t.equal(
				ES.ValidateAndApplyPropertyDescriptor(undefined, 'property key', true, getDescriptor(), getDescriptor()),
				true,
				'when Desc and current are the same, early return true'
			);
		***REMOVED***);

		t.test('current is nonconfigurable', function (st) ***REMOVED***
			// note: these must not be generic descriptors, or else the algorithm returns an early true
			st.equal(
				ES.ValidateAndApplyPropertyDescriptor(
					undefined,
					'property key',
					true,
					v.descriptors.configurable(v.dataDescriptor()),
					v.descriptors.nonConfigurable(v.dataDescriptor())
				),
				false,
				'false if Desc is configurable'
			);

			st.equal(
				ES.ValidateAndApplyPropertyDescriptor(
					undefined,
					'property key',
					true,
					v.descriptors.enumerable(v.dataDescriptor()),
					v.descriptors.nonEnumerable(v.dataDescriptor())
				),
				false,
				'false if Desc is Enumerable and current is not'
			);

			st.equal(
				ES.ValidateAndApplyPropertyDescriptor(
					undefined,
					'property key',
					true,
					v.descriptors.nonEnumerable(v.dataDescriptor()),
					v.descriptors.enumerable(v.dataDescriptor())
				),
				false,
				'false if Desc is not Enumerable and current is'
			);

			var descLackingEnumerable = v.accessorDescriptor();
			delete descLackingEnumerable['[[Enumerable]]'];
			st.equal(
				ES.ValidateAndApplyPropertyDescriptor(
					undefined,
					'property key',
					true,
					descLackingEnumerable,
					v.descriptors.enumerable(v.accessorDescriptor())
				),
				true,
				'not false if Desc lacks Enumerable'
			);

			st.end();
		***REMOVED***);

		t.test('Desc and current: one is a data descriptor, one is not', ***REMOVED*** skip: !defineProperty || !getOwnPropertyDescriptor ***REMOVED***, function (st) ***REMOVED***
			// note: Desc must be configurable if current is nonconfigurable, to hit this branch
			st.equal(
				ES.ValidateAndApplyPropertyDescriptor(
					undefined,
					'property key',
					true,
					v.descriptors.configurable(v.accessorDescriptor()),
					v.descriptors.nonConfigurable(v.dataDescriptor())
				),
				false,
				'false if current (data) is nonconfigurable'
			);

			st.equal(
				ES.ValidateAndApplyPropertyDescriptor(
					undefined,
					'property key',
					true,
					v.descriptors.configurable(v.dataDescriptor()),
					v.descriptors.nonConfigurable(v.accessorDescriptor())
				),
				false,
				'false if current (not data) is nonconfigurable'
			);

			// one is data and one is not,
			//	// if current is data, convert to accessor
			//	// else convert to data

			var startsWithData = ***REMOVED***
				'property key': 42
			***REMOVED***;
			st.equal(
				ES.ValidateAndApplyPropertyDescriptor(
					startsWithData,
					'property key',
					true,
					v.descriptors.enumerable(v.descriptors.configurable(v.accessorDescriptor())),
					v.descriptors.enumerable(v.descriptors.configurable(v.dataDescriptor()))
				),
				true,
				'operation is successful: current is data, Desc is accessor'
			);
			var shouldBeAccessor = getOwnPropertyDescriptor(startsWithData, 'property key');
			st.equal(typeof shouldBeAccessor.get, 'function', 'has a getter');

			var key = 'property key';
			var startsWithAccessor = ***REMOVED******REMOVED***;
			defineProperty(startsWithAccessor, key, ***REMOVED***
				configurable: true,
				enumerable: true,
				get: function get() ***REMOVED*** return 42; ***REMOVED***
			***REMOVED***);
			st.equal(
				ES.ValidateAndApplyPropertyDescriptor(
					startsWithAccessor,
					key,
					true,
					v.descriptors.enumerable(v.descriptors.configurable(v.dataDescriptor())),
					v.descriptors.enumerable(v.descriptors.configurable(v.accessorDescriptor(42)))
				),
				true,
				'operation is successful: current is accessor, Desc is data'
			);
			var shouldBeData = getOwnPropertyDescriptor(startsWithAccessor, 'property key');
			st.deepEqual(shouldBeData, ***REMOVED*** configurable: true, enumerable: true, value: 42, writable: false ***REMOVED***, 'is a data property');

			st.end();
		***REMOVED***);

		t.test('Desc and current are both data descriptors', function (st) ***REMOVED***
			st.equal(
				ES.ValidateAndApplyPropertyDescriptor(
					undefined,
					'property key',
					true,
					v.descriptors.writable(v.dataDescriptor()),
					v.descriptors.nonWritable(v.descriptors.nonConfigurable(v.dataDescriptor()))
				),
				false,
				'false if frozen current and writable Desc'
			);

			st.equal(
				ES.ValidateAndApplyPropertyDescriptor(
					undefined,
					'property key',
					true,
					v.descriptors.configurable(***REMOVED*** '[[Value]]': 42 ***REMOVED***),
					v.descriptors.nonWritable(***REMOVED*** '[[Value]]': 7 ***REMOVED***)
				),
				false,
				'false if nonwritable current has a different value than Desc'
			);

			st.end();
		***REMOVED***);

		t.test('current is nonconfigurable; Desc and current are both accessor descriptors', function (st) ***REMOVED***
			st.equal(
				ES.ValidateAndApplyPropertyDescriptor(
					undefined,
					'property key',
					true,
					v.mutatorDescriptor(),
					v.descriptors.nonConfigurable(v.mutatorDescriptor())
				),
				false,
				'false if both Sets are not equal'
			);

			st.equal(
				ES.ValidateAndApplyPropertyDescriptor(
					undefined,
					'property key',
					true,
					v.accessorDescriptor(),
					v.descriptors.nonConfigurable(v.accessorDescriptor())
				),
				false,
				'false if both Gets are not equal'
			);

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('OrdinaryGetOwnProperty', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.OrdinaryGetOwnProperty(primitive, ''); ***REMOVED***,
				TypeError,
				'O: ' + debug(primitive) + ' is not an Object'
			);
		***REMOVED***);
		forEach(v.nonPropertyKeys, function (nonPropertyKey) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.OrdinaryGetOwnProperty(***REMOVED******REMOVED***, nonPropertyKey); ***REMOVED***,
				TypeError,
				'P: ' + debug(nonPropertyKey) + ' is not a Property Key'
			);
		***REMOVED***);

		t.equal(ES.OrdinaryGetOwnProperty(***REMOVED******REMOVED***, 'not in the object'), undefined, 'missing property yields undefined');
		t.equal(ES.OrdinaryGetOwnProperty(***REMOVED******REMOVED***, 'toString'), undefined, 'inherited non-own property yields undefined');

		t.deepEqual(
			ES.OrdinaryGetOwnProperty(***REMOVED*** a: 1 ***REMOVED***, 'a'),
			ES.ToPropertyDescriptor(***REMOVED***
				configurable: true,
				enumerable: true,
				value: 1,
				writable: true
			***REMOVED***),
			'own assigned data property yields expected descriptor'
		);

		t.deepEqual(
			ES.OrdinaryGetOwnProperty(/a/, 'lastIndex'),
			ES.ToPropertyDescriptor(***REMOVED***
				configurable: false,
				enumerable: false,
				value: 0,
				writable: true
			***REMOVED***),
			'regex lastIndex yields expected descriptor'
		);

		t.deepEqual(
			ES.OrdinaryGetOwnProperty([], 'length'),
			ES.ToPropertyDescriptor(***REMOVED***
				configurable: false,
				enumerable: false,
				value: 0,
				writable: true
			***REMOVED***),
			'array length yields expected descriptor'
		);

		t.deepEqual(
			ES.OrdinaryGetOwnProperty(Object.prototype, 'toString'),
			ES.ToPropertyDescriptor(***REMOVED***
				configurable: true,
				enumerable: false,
				value: Object.prototype.toString,
				writable: true
			***REMOVED***),
			'own non-enumerable data property yields expected descriptor'
		);

		t.test('ES5+', ***REMOVED*** skip: !defineProperty.oDP ***REMOVED***, function (st) ***REMOVED***
			var O = ***REMOVED******REMOVED***;
			defineProperty(O, 'foo', ***REMOVED***
				configurable: false,
				enumerable: false,
				value: O,
				writable: true
			***REMOVED***);

			st.deepEqual(
				ES.OrdinaryGetOwnProperty(O, 'foo'),
				ES.ToPropertyDescriptor(***REMOVED***
					configurable: false,
					enumerable: false,
					value: O,
					writable: true
				***REMOVED***),
				'defined own property yields expected descriptor'
			);

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('OrdinaryDefineOwnProperty', ***REMOVED*** skip: !getOwnPropertyDescriptor ***REMOVED***, function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.CopyDataProperties(primitive, ***REMOVED******REMOVED***, []); ***REMOVED***,
				TypeError,
				'O: ' + debug(primitive) + ' is not an Object'
			);
		***REMOVED***);
		forEach(v.nonPropertyKeys, function (nonPropertyKey) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.OrdinaryDefineOwnProperty(***REMOVED******REMOVED***, nonPropertyKey, v.genericDescriptor()); ***REMOVED***,
				TypeError,
				'P: ' + debug(nonPropertyKey) + ' is not a Property Key'
			);
		***REMOVED***);
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.OrdinaryDefineOwnProperty(primitive, '', v.genericDescriptor()); ***REMOVED***,
				TypeError,
				'Desc: ' + debug(primitive) + ' is not a Property Descriptor'
			);
		***REMOVED***);

		var O = ***REMOVED******REMOVED***;
		var P = 'property key';
		var Desc = v.accessorDescriptor();
		t.equal(
			ES.OrdinaryDefineOwnProperty(O, P, Desc),
			true,
			'operation is successful'
		);
		t.deepEqual(
			getOwnPropertyDescriptor(O, P),
			ES.FromPropertyDescriptor(ES.CompletePropertyDescriptor(Desc)),
			'expected property descriptor is defined'
		);

		t.end();
	***REMOVED***);

	test('ArrayCreate', function (t) ***REMOVED***
		forEach(v.nonIntegerNumbers.concat([-1]), function (nonIntegerNumber) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.ArrayCreate(nonIntegerNumber); ***REMOVED***,
				TypeError,
				'length must be an integer number >= 0'
			);
		***REMOVED***);

		t['throws'](
			function () ***REMOVED*** ES.ArrayCreate(Math.pow(2, 32)); ***REMOVED***,
			RangeError,
			'length must be < 2**32'
		);

		t.deepEqual(ES.ArrayCreate(-0), [], 'length of -0 creates an empty array');
		t.deepEqual(ES.ArrayCreate(0), [], 'length of +0 creates an empty array');
		// eslint-disable-next-line no-sparse-arrays, comma-spacing
		t.deepEqual(ES.ArrayCreate(1), [,], 'length of 1 creates a sparse array of length 1');
		// eslint-disable-next-line no-sparse-arrays, comma-spacing
		t.deepEqual(ES.ArrayCreate(2), [,,], 'length of 2 creates a sparse array of length 2');

		t.test('proto argument', ***REMOVED*** skip: !$setProto ***REMOVED***, function (st) ***REMOVED***
			var fakeProto = ***REMOVED***
				push: ***REMOVED*** toString: function () ***REMOVED*** return 'not array push'; ***REMOVED*** ***REMOVED***
			***REMOVED***;
			st.equal(ES.ArrayCreate(0, fakeProto).push, fakeProto.push, 'passing the proto argument works');
			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('ArraySetLength', function (t) ***REMOVED***
		forEach(v.primitives.concat(v.objects), function (nonArray) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.ArraySetLength(nonArray, 0); ***REMOVED***,
				TypeError,
				'A: ' + debug(nonArray) + ' is not an Array'
			);
		***REMOVED***);

		forEach(v.nonUndefinedPrimitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.ArraySetLength([], primitive); ***REMOVED***,
				TypeError,
				'Desc: ' + debug(primitive) + ' is not a Property Descriptor'
			);
		***REMOVED***);

		t.test('making length nonwritable', ***REMOVED*** skip: !getOwnPropertyDescriptor ***REMOVED***, function (st) ***REMOVED***
			var a = [];
			ES.ArraySetLength(a, ***REMOVED*** '[[Writable]]': false ***REMOVED***);
			st.deepEqual(
				getOwnPropertyDescriptor(a, 'length'),
				***REMOVED***
					configurable: false,
					enumerable: false,
					value: 0,
					writable: false
				***REMOVED***,
				'without a value, length becomes nonwritable'
			);
			st.end();
		***REMOVED***);

		var arr = [];
		ES.ArraySetLength(arr, ***REMOVED*** '[[Value]]': 7 ***REMOVED***);
		t.equal(arr.length, 7, 'array now has a length of 7');

		t.end();
	***REMOVED***);

	test('CreateHTML', function (t) ***REMOVED***
		forEach(v.nonStrings, function (nonString) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.CreateHTML('', nonString, '', ''); ***REMOVED***,
				TypeError,
				'tag: ' + debug(nonString) + ' is not a String'
			);
			t['throws'](
				function () ***REMOVED*** ES.CreateHTML('', '', nonString, ''); ***REMOVED***,
				TypeError,
				'attribute: ' + debug(nonString) + ' is not a String'
			);
		***REMOVED***);

		t.equal(
			ES.CreateHTML(
				***REMOVED*** toString: function () ***REMOVED*** return 'the string'; ***REMOVED*** ***REMOVED***,
				'some HTML tag!',
				''
			),
			'<some HTML tag!>the string</some HTML tag!>',
			'works with an empty string attribute value'
		);

		t.equal(
			ES.CreateHTML(
				***REMOVED*** toString: function () ***REMOVED*** return 'the string'; ***REMOVED*** ***REMOVED***,
				'some HTML tag!',
				'attr',
				'value "with quotes"'
			),
			'<some HTML tag! attr="value &quot;with quotes&quot;">the string</some HTML tag!>',
			'works with an attribute, and a value with quotes'
		);

		t.end();
	***REMOVED***);

	test('GetOwnPropertyKeys', function (t) ***REMOVED***
		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.GetOwnPropertyKeys(primitive, 'String'); ***REMOVED***,
				TypeError,
				'O: ' + debug(primitive) + ' is not an Object'
			);
		***REMOVED***);

		t['throws'](
			function () ***REMOVED*** ES.GetOwnPropertyKeys(***REMOVED******REMOVED***, 'not string or symbol'); ***REMOVED***,
			TypeError,
			'Type: must be "String" or "Symbol"'
		);

		t.test('Symbols', ***REMOVED*** skip: !v.hasSymbols ***REMOVED***, function (st) ***REMOVED***
			var O = ***REMOVED*** a: 1 ***REMOVED***;
			O[Symbol.iterator] = true;
			var s = Symbol('test');
			defineProperty(O, s, ***REMOVED*** enumerable: false, value: true ***REMOVED***);

			st.deepEqual(
				ES.GetOwnPropertyKeys(O, 'Symbol'),
				[Symbol.iterator, s],
				'works with Symbols, enumerable or not'
			);

			st.end();
		***REMOVED***);

		t.test('non-enumerable names', ***REMOVED*** skip: !defineProperty.oDP ***REMOVED***, function (st) ***REMOVED***
			var O = ***REMOVED*** a: 1 ***REMOVED***;
			defineProperty(O, 'b', ***REMOVED*** enumerable: false, value: 2 ***REMOVED***);
			if (v.hasSymbols) ***REMOVED***
				O[Symbol.iterator] = true;
			***REMOVED***

			st.deepEqual(
				ES.GetOwnPropertyKeys(O, 'String').sort(),
				['a', 'b'].sort(),
				'works with Strings, enumerable or not'
			);

			st.end();
		***REMOVED***);

		t.deepEqual(
			ES.GetOwnPropertyKeys(***REMOVED*** a: 1, b: 2 ***REMOVED***, 'String').sort(),
			['a', 'b'].sort(),
			'works with enumerable keys'
		);

		t.end();
	***REMOVED***);

	test('SymbolDescriptiveString', function (t) ***REMOVED***
		forEach(v.nonSymbolPrimitives.concat(v.objects), function (nonSymbol) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.SymbolDescriptiveString(nonSymbol); ***REMOVED***,
				TypeError,
				debug(nonSymbol) + ' is not a Symbol'
			);
		***REMOVED***);

		t.test('Symbols', ***REMOVED*** skip: !v.hasSymbols ***REMOVED***, function (st) ***REMOVED***
			st.equal(ES.SymbolDescriptiveString(Symbol()), 'Symbol()', 'undefined description');
			st.equal(ES.SymbolDescriptiveString(Symbol('')), 'Symbol()', 'empty string description');
			st.equal(ES.SymbolDescriptiveString(Symbol.iterator), 'Symbol(Symbol.iterator)', 'well-known symbol');
			st.equal(ES.SymbolDescriptiveString(Symbol('foo')), 'Symbol(foo)', 'string description');

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('GetSubstitution', ***REMOVED*** skip: skips && skips.GetSubstitution ***REMOVED***, function (t) ***REMOVED***
		forEach(v.nonStrings, function (nonString) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.GetSubstitution(nonString, '', 0, [], ''); ***REMOVED***,
				TypeError,
				'`matched`: ' + debug(nonString) + ' is not a String'
			);

			t['throws'](
				function () ***REMOVED*** ES.GetSubstitution('', nonString, 0, [], ''); ***REMOVED***,
				TypeError,
				'`str`: ' + debug(nonString) + ' is not a String'
			);

			t['throws'](
				function () ***REMOVED*** ES.GetSubstitution('', '', 0, [], nonString); ***REMOVED***,
				TypeError,
				'`replacement`: ' + debug(nonString) + ' is not a String'
			);

			if (canDistinguishSparseFromUndefined || typeof nonString !== 'undefined') ***REMOVED***
				t['throws'](
					function () ***REMOVED*** ES.GetSubstitution('', '', 0, [nonString], ''); ***REMOVED***,
					TypeError,
					'`captures`: ' + debug([nonString]) + ' is not an Array of strings'
				);
			***REMOVED***
		***REMOVED***);

		forEach(v.nonIntegerNumbers.concat([-1, -42, -Infinity]), function (nonNonNegativeInteger) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.GetSubstitution('', '', nonNonNegativeInteger, [], ''); ***REMOVED***,
				TypeError,
				'`position`: ' + debug(nonNonNegativeInteger) + ' is not a non-negative integer'
			);
		***REMOVED***);

		forEach(v.nonArrays, function (nonArray) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.GetSubstitution('', '', 0, nonArray, ''); ***REMOVED***,
				TypeError,
				'`captures`: ' + debug(nonArray) + ' is not an Array'
			);
		***REMOVED***);

		t.equal(
			ES.GetSubstitution('def', 'abcdefghi', 3, [], '123'),
			'123',
			'returns the substitution'
		);
		t.equal(
			ES.GetSubstitution('abcdef', 'abcdefghi', 0, [], '$$2$'),
			'$2$',
			'supports $$, and trailing $'
		);

		t.equal(
			ES.GetSubstitution('abcdef', 'abcdefghi', 0, [], '>$&<'),
			'>abcdef<',
			'supports $&'
		);

		t.equal(
			ES.GetSubstitution('abcdef', 'abcdefghi', 0, [], '>$`<'),
			'><',
			'supports $` at position 0'
		);
		t.equal(
			ES.GetSubstitution('def', 'abcdefghi', 3, [], '>$`<'),
			'>ab<',
			'supports $` at position > 0'
		);

		t.equal(
			ES.GetSubstitution('def', 'abcdefghi', 7, [], ">$'<"),
			'><',
			"supports $' at a position where there's less than `matched.length` chars left"
		);
		t.equal(
			ES.GetSubstitution('def', 'abcdefghi', 3, [], ">$'<"),
			'>ghi<',
			"supports $' at a position where there's more than `matched.length` chars left"
		);

		for (var i = 0; i < 100; i += 1) ***REMOVED***
			var captures = [];
			captures[i] = 'test';
			if (i > 0) ***REMOVED***
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, [], '>$' + i + '<'),
					'>undefined<',
					'supports $' + i + ' with no captures'
				);
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, [], '>$' + i),
					'>undefined',
					'supports $' + i + ' at the end of the replacement, with no captures'
				);
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, captures, '>$' + i + '<'),
					'><',
					'supports $' + i + ' with a capture at that index'
				);
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, captures, '>$' + i),
					'>',
					'supports $' + i + ' at the end of the replacement, with a capture at that index'
				);
			***REMOVED***
			if (i < 10) ***REMOVED***
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, [], '>$0' + i + '<'),
					i === 0 ? '><' : '>undefined<',
					'supports $0' + i + ' with no captures'
				);
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, [], '>$0' + i),
					i === 0 ? '>' : '>undefined',
					'supports $0' + i + ' at the end of the replacement, with no captures'
				);
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, captures, '>$0' + i + '<'),
					'><',
					'supports $0' + i + ' with a capture at that index'
				);
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, captures, '>$0' + i),
					'>',
					'supports $0' + i + ' at the end of the replacement, with a capture at that index'
				);
			***REMOVED***
		***REMOVED***

		t.end();
	***REMOVED***);

	test('SecFromTime', function (t) ***REMOVED***
		var now = new Date();
		t.equal(ES.SecFromTime(now.getTime()), now.getUTCSeconds(), 'second from Date timestamp matches getUTCSeconds');
		t.end();
	***REMOVED***);

	test('MinFromTime', function (t) ***REMOVED***
		var now = new Date();
		t.equal(ES.MinFromTime(now.getTime()), now.getUTCMinutes(), 'minute from Date timestamp matches getUTCMinutes');
		t.end();
	***REMOVED***);

	test('HourFromTime', function (t) ***REMOVED***
		var now = new Date();
		t.equal(ES.HourFromTime(now.getTime()), now.getUTCHours(), 'hour from Date timestamp matches getUTCHours');
		t.end();
	***REMOVED***);

	test('msFromTime', function (t) ***REMOVED***
		var now = new Date();
		t.equal(ES.msFromTime(now.getTime()), now.getUTCMilliseconds(), 'ms from Date timestamp matches getUTCMilliseconds');
		t.end();
	***REMOVED***);

	var msPerSecond = 1e3;
	var msPerMinute = 60 * msPerSecond;
	var msPerHour = 60 * msPerMinute;
	var msPerDay = 24 * msPerHour;

	test('Day', function (t) ***REMOVED***
		var time = Date.UTC(2019, 8, 10, 2, 3, 4, 5);
		var add = 2.5;
		var later = new Date(time + (add * msPerDay));

		t.equal(ES.Day(later.getTime()), ES.Day(time) + Math.floor(add), 'adding 2.5 days worth of ms, gives a Day delta of 2');
		t.end();
	***REMOVED***);

	test('TimeWithinDay', function (t) ***REMOVED***
		var time = Date.UTC(2019, 8, 10, 2, 3, 4, 5);
		var add = 2.5;
		var later = new Date(time + (add * msPerDay));

		t.equal(ES.TimeWithinDay(later.getTime()), ES.TimeWithinDay(time) + (0.5 * msPerDay), 'adding 2.5 days worth of ms, gives a TimeWithinDay delta of +0.5');
		t.end();
	***REMOVED***);

	test('DayFromYear', function (t) ***REMOVED***
		t.equal(ES.DayFromYear(2021) - ES.DayFromYear(2020), 366, '2021 is a leap year, has 366 days');
		t.equal(ES.DayFromYear(2020) - ES.DayFromYear(2019), 365, '2020 is not a leap year, has 365 days');
		t.equal(ES.DayFromYear(2019) - ES.DayFromYear(2018), 365, '2019 is not a leap year, has 365 days');
		t.equal(ES.DayFromYear(2018) - ES.DayFromYear(2017), 365, '2018 is not a leap year, has 365 days');
		t.equal(ES.DayFromYear(2017) - ES.DayFromYear(2016), 366, '2017 is a leap year, has 366 days');

		t.end();
	***REMOVED***);

	test('TimeFromYear', function (t) ***REMOVED***
		for (var i = 1900; i < 2100; i += 1) ***REMOVED***
			t.equal(ES.TimeFromYear(i), Date.UTC(i, 0, 1), 'TimeFromYear matches a Date object’s year: ' + i);
		***REMOVED***
		t.end();
	***REMOVED***);

	test('YearFromTime', function (t) ***REMOVED***
		for (var i = 1900; i < 2100; i += 1) ***REMOVED***
			t.equal(ES.YearFromTime(Date.UTC(i, 0, 1)), i, 'YearFromTime matches a Date object’s year on 1/1: ' + i);
			t.equal(ES.YearFromTime(Date.UTC(i, 10, 1)), i, 'YearFromTime matches a Date object’s year on 10/1: ' + i);
		***REMOVED***
		t.end();
	***REMOVED***);

	test('WeekDay', function (t) ***REMOVED***
		var now = new Date();
		var today = now.getUTCDay();
		for (var i = 0; i < 7; i += 1) ***REMOVED***
			var weekDay = ES.WeekDay(now.getTime() + (i * msPerDay));
			t.equal(weekDay, (today + i) % 7, i + ' days after today (' + today + '), WeekDay is ' + weekDay);
		***REMOVED***
		t.end();
	***REMOVED***);

	test('DaysInYear', function (t) ***REMOVED***
		t.equal(ES.DaysInYear(2021), 365, '2021 is not a leap year');
		t.equal(ES.DaysInYear(2020), 366, '2020 is a leap year');
		t.equal(ES.DaysInYear(2019), 365, '2019 is not a leap year');
		t.equal(ES.DaysInYear(2018), 365, '2018 is not a leap year');
		t.equal(ES.DaysInYear(2017), 365, '2017 is not a leap year');
		t.equal(ES.DaysInYear(2016), 366, '2016 is a leap year');

		t.end();
	***REMOVED***);

	test('InLeapYear', function (t) ***REMOVED***
		t.equal(ES.InLeapYear(Date.UTC(2021, 0, 1)), 0, '2021 is not a leap year');
		t.equal(ES.InLeapYear(Date.UTC(2020, 0, 1)), 1, '2020 is a leap year');
		t.equal(ES.InLeapYear(Date.UTC(2019, 0, 1)), 0, '2019 is not a leap year');
		t.equal(ES.InLeapYear(Date.UTC(2018, 0, 1)), 0, '2018 is not a leap year');
		t.equal(ES.InLeapYear(Date.UTC(2017, 0, 1)), 0, '2017 is not a leap year');
		t.equal(ES.InLeapYear(Date.UTC(2016, 0, 1)), 1, '2016 is a leap year');

		t.end();
	***REMOVED***);

	test('DayWithinYear', function (t) ***REMOVED***
		t.equal(ES.DayWithinYear(Date.UTC(2019, 0, 1)), 0, '1/1 is the 1st day');
		t.equal(ES.DayWithinYear(Date.UTC(2019, 11, 31)), 364, '12/31 is the 365th day in a non leap year');
		t.equal(ES.DayWithinYear(Date.UTC(2016, 11, 31)), 365, '12/31 is the 366th day in a leap year');

		t.end();
	***REMOVED***);

	test('MonthFromTime', function (t) ***REMOVED***
		t.equal(ES.MonthFromTime(Date.UTC(2019, 0, 1)), 0, 'non-leap: 1/1 gives January');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 0, 31)), 0, 'non-leap: 1/31 gives January');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 1, 1)), 1, 'non-leap: 2/1 gives February');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 1, 28)), 1, 'non-leap: 2/28 gives February');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 1, 29)), 2, 'non-leap: 2/29 gives March');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 2, 1)), 2, 'non-leap: 3/1 gives March');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 2, 31)), 2, 'non-leap: 3/31 gives March');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 3, 1)), 3, 'non-leap: 4/1 gives April');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 3, 30)), 3, 'non-leap: 4/30 gives April');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 4, 1)), 4, 'non-leap: 5/1 gives May');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 4, 31)), 4, 'non-leap: 5/31 gives May');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 5, 1)), 5, 'non-leap: 6/1 gives June');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 5, 30)), 5, 'non-leap: 6/30 gives June');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 6, 1)), 6, 'non-leap: 7/1 gives July');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 6, 31)), 6, 'non-leap: 7/31 gives July');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 7, 1)), 7, 'non-leap: 8/1 gives August');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 7, 30)), 7, 'non-leap: 8/30 gives August');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 8, 1)), 8, 'non-leap: 9/1 gives September');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 8, 30)), 8, 'non-leap: 9/30 gives September');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 9, 1)), 9, 'non-leap: 10/1 gives October');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 9, 31)), 9, 'non-leap: 10/31 gives October');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 10, 1)), 10, 'non-leap: 11/1 gives November');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 10, 30)), 10, 'non-leap: 11/30 gives November');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 11, 1)), 11, 'non-leap: 12/1 gives December');
		t.equal(ES.MonthFromTime(Date.UTC(2019, 11, 31)), 11, 'non-leap: 12/31 gives December');

		t.equal(ES.MonthFromTime(Date.UTC(2016, 0, 1)), 0, 'leap: 1/1 gives January');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 0, 31)), 0, 'leap: 1/31 gives January');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 1, 1)), 1, 'leap: 2/1 gives February');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 1, 28)), 1, 'leap: 2/28 gives February');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 1, 29)), 1, 'leap: 2/29 gives February');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 2, 1)), 2, 'leap: 3/1 gives March');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 2, 31)), 2, 'leap: 3/31 gives March');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 3, 1)), 3, 'leap: 4/1 gives April');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 3, 30)), 3, 'leap: 4/30 gives April');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 4, 1)), 4, 'leap: 5/1 gives May');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 4, 31)), 4, 'leap: 5/31 gives May');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 5, 1)), 5, 'leap: 6/1 gives June');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 5, 30)), 5, 'leap: 6/30 gives June');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 6, 1)), 6, 'leap: 7/1 gives July');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 6, 31)), 6, 'leap: 7/31 gives July');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 7, 1)), 7, 'leap: 8/1 gives August');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 7, 30)), 7, 'leap: 8/30 gives August');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 8, 1)), 8, 'leap: 9/1 gives September');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 8, 30)), 8, 'leap: 9/30 gives September');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 9, 1)), 9, 'leap: 10/1 gives October');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 9, 31)), 9, 'leap: 10/31 gives October');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 10, 1)), 10, 'leap: 11/1 gives November');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 10, 30)), 10, 'leap: 11/30 gives November');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 11, 1)), 11, 'leap: 12/1 gives December');
		t.equal(ES.MonthFromTime(Date.UTC(2016, 11, 31)), 11, 'leap: 12/31 gives December');
		t.end();
	***REMOVED***);

	test('DateFromTime', function (t) ***REMOVED***
		var i;
		for (i = 1; i <= 28; i += 1) ***REMOVED***
			t.equal(ES.DateFromTime(Date.UTC(2019, 1, i)), i, '2019.02.' + i + ' is date ' + i);
		***REMOVED***
		for (i = 1; i <= 29; i += 1) ***REMOVED***
			t.equal(ES.DateFromTime(Date.UTC(2016, 1, i)), i, '2016.02.' + i + ' is date ' + i);
		***REMOVED***
		for (i = 1; i <= 30; i += 1) ***REMOVED***
			t.equal(ES.DateFromTime(Date.UTC(2019, 8, i)), i, '2019.09.' + i + ' is date ' + i);
		***REMOVED***
		for (i = 1; i <= 31; i += 1) ***REMOVED***
			t.equal(ES.DateFromTime(Date.UTC(2019, 9, i)), i, '2019.10.' + i + ' is date ' + i);
		***REMOVED***
		t.end();
	***REMOVED***);

	test('MakeDay', function (t) ***REMOVED***
		var day2015 = 16687;
		t.equal(ES.MakeDay(2015, 8, 9), day2015, '2015.09.09 is day 16687');
		var day2016 = day2015 + 366; // 2016 is a leap year
		t.equal(ES.MakeDay(2016, 8, 9), day2016, '2015.09.09 is day 17053');
		var day2017 = day2016 + 365;
		t.equal(ES.MakeDay(2017, 8, 9), day2017, '2017.09.09 is day 17418');
		var day2018 = day2017 + 365;
		t.equal(ES.MakeDay(2018, 8, 9), day2018, '2018.09.09 is day 17783');
		var day2019 = day2018 + 365;
		t.equal(ES.MakeDay(2019, 8, 9), day2019, '2019.09.09 is day 18148');
		t.end();
	***REMOVED***);

	test('MakeDate', function (t) ***REMOVED***
		forEach(v.infinities.concat(NaN), function (nonFiniteNumber) ***REMOVED***
			t.ok(is(ES.MakeDate(nonFiniteNumber, 0), NaN), debug(nonFiniteNumber) + ' is not a finite `day`');
			t.ok(is(ES.MakeDate(0, nonFiniteNumber), NaN), debug(nonFiniteNumber) + ' is not a finite `time`');
		***REMOVED***);
		t.equal(ES.MakeDate(0, 0), 0, 'zero day and zero time is zero date');
		t.equal(ES.MakeDate(0, 123), 123, 'zero day and nonzero time is a date of the "time"');
		t.equal(ES.MakeDate(1, 0), msPerDay, 'day of 1 and zero time is a date of "ms per day"');
		t.equal(ES.MakeDate(3, 0), 3 * msPerDay, 'day of 3 and zero time is a date of thrice "ms per day"');
		t.equal(ES.MakeDate(1, 123), msPerDay + 123, 'day of 1 and nonzero time is a date of "ms per day" plus the "time"');
		t.equal(ES.MakeDate(3, 123), (3 * msPerDay) + 123, 'day of 3 and nonzero time is a date of thrice "ms per day" plus the "time"');

		t.end();
	***REMOVED***);

	test('MakeTime', function (t) ***REMOVED***
		forEach(v.infinities.concat(NaN), function (nonFiniteNumber) ***REMOVED***
			t.ok(is(ES.MakeTime(nonFiniteNumber, 0, 0, 0), NaN), debug(nonFiniteNumber) + ' is not a finite `hour`');
			t.ok(is(ES.MakeTime(0, nonFiniteNumber, 0, 0), NaN), debug(nonFiniteNumber) + ' is not a finite `min`');
			t.ok(is(ES.MakeTime(0, 0, nonFiniteNumber, 0), NaN), debug(nonFiniteNumber) + ' is not a finite `sec`');
			t.ok(is(ES.MakeTime(0, 0, 0, nonFiniteNumber), NaN), debug(nonFiniteNumber) + ' is not a finite `ms`');
		***REMOVED***);

		t.equal(
			ES.MakeTime(1.2, 2.3, 3.4, 4.5),
			(1 * msPerHour) + (2 * msPerMinute) + (3 * msPerSecond) + 4,
			'all numbers are converted to integer, multiplied by the right number of ms, and summed'
		);

		t.end();
	***REMOVED***);

	test('TimeClip', function (t) ***REMOVED***
		forEach(v.infinities.concat(NaN), function (nonFiniteNumber) ***REMOVED***
			t.ok(is(ES.TimeClip(nonFiniteNumber), NaN), debug(nonFiniteNumber) + ' is not a finite `time`');
		***REMOVED***);
		t.ok(is(ES.TimeClip(8.64e15 + 1), NaN), '8.64e15 is the largest magnitude considered "finite"');
		t.ok(is(ES.TimeClip(-8.64e15 - 1), NaN), '-8.64e15 is the largest magnitude considered "finite"');

		forEach(v.zeroes.concat([-10, 10, +new Date()]), function (time) ***REMOVED***
			t.equal(ES.TimeClip(time), time, debug(time) + ' is a time of ' + debug(time));
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('modulo', function (t) ***REMOVED***
		t.equal(3 % 2, 1, '+3 % 2 is +1');
		t.equal(ES.modulo(3, 2), 1, '+3 mod 2 is +1');

		t.equal(-3 % 2, -1, '-3 % 2 is -1');
		t.equal(ES.modulo(-3, 2), 1, '-3 mod 2 is +1');
		t.end();
	***REMOVED***);

	test('ToDateString', function (t) ***REMOVED***
		forEach(v.nonNumbers, function (nonNumber) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.ToDateString(nonNumber); ***REMOVED***,
				TypeError,
				debug(nonNumber) + ' is not a Number'
			);
		***REMOVED***);

		t.equal(ES.ToDateString(NaN), 'Invalid Date', 'NaN becomes "Invalid Date"');
		var now = +new Date();
		t.equal(ES.ToDateString(now), Date(now), 'any timestamp becomes `Date(timestamp)`');
		t.end();
	***REMOVED***);

	test('CreateListFromArrayLike', function (t) ***REMOVED***
		forEach(v.primitives, function (nonObject) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.CreateListFromArrayLike(nonObject); ***REMOVED***,
				TypeError,
				debug(nonObject) + ' is not an Object'
			);
		***REMOVED***);
		forEach(v.nonArrays, function (nonArray) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.CreateListFromArrayLike(***REMOVED******REMOVED***, nonArray); ***REMOVED***,
				TypeError,
				debug(nonArray) + ' is not an Array'
			);
		***REMOVED***);

		t.deepEqual(
			ES.CreateListFromArrayLike(***REMOVED*** length: 2, 0: 'a', 1: 'b', 2: 'c' ***REMOVED***),
			['a', 'b'],
			'arraylike stops at the length'
		);

		t.end();
	***REMOVED***);

	test('GetPrototypeFromConstructor', function (t) ***REMOVED***
		forEach(v.nonFunctions, function (nonFunction) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.GetPrototypeFromConstructor(nonFunction, '%Array%'); ***REMOVED***,
				TypeError,
				debug(nonFunction) + ' is not a constructor'
			);
		***REMOVED***);

		forEach(arrowFns, function (arrowFn) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.GetPrototypeFromConstructor(arrowFn, '%Array%'); ***REMOVED***,
				TypeError,
				debug(arrowFn) + ' is not a constructor'
			);
		***REMOVED***);

		var f = function () ***REMOVED******REMOVED***;
		t.equal(
			ES.GetPrototypeFromConstructor(f, '%Array.prototype%'),
			f.prototype,
			'function with normal `prototype` property returns it'
		);
		forEach([true, 'foo', 42], function (truthyPrimitive) ***REMOVED***
			f.prototype = truthyPrimitive;
			t.equal(
				ES.GetPrototypeFromConstructor(f, '%Array.prototype%'),
				Array.prototype,
				'function with non-object `prototype` property (' + debug(truthyPrimitive) + ') returns default intrinsic'
			);
		***REMOVED***);

		t.end();
	***REMOVED***);

	var getNamelessFunction = function () ***REMOVED***
		var f = Object(function () ***REMOVED******REMOVED***);
		try ***REMOVED***
			delete f.name;
		***REMOVED*** catch (e) ***REMOVED*** /**/ ***REMOVED***
		return f;
	***REMOVED***;

	test('SetFunctionName', function (t) ***REMOVED***
		t.test('non-extensible function', ***REMOVED*** skip: !Object.preventExtensions ***REMOVED***, function (st) ***REMOVED***
			var f = getNamelessFunction();
			Object.preventExtensions(f);
			st['throws'](
				function () ***REMOVED*** ES.SetFunctionName(f, ''); ***REMOVED***,
				TypeError,
				'throws on a non-extensible function'
			);
			st.end();
		***REMOVED***);

		t.test('has an own name property', ***REMOVED*** skip: !functionsHaveNames ***REMOVED***, function (st) ***REMOVED***
			st['throws'](
				function () ***REMOVED*** ES.SetFunctionName(function g() ***REMOVED******REMOVED***, ''); ***REMOVED***,
				TypeError,
				'throws if function has an own `name` property'
			);
			st.end();
		***REMOVED***);

		forEach(v.nonPropertyKeys, function (nonPropertyKey) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.SetFunctionName(getNamelessFunction(), nonPropertyKey); ***REMOVED***,
				TypeError,
				debug(nonPropertyKey) + ' is not a Symbol or String'
			);
		***REMOVED***);

		t.test('symbols', ***REMOVED*** skip: !v.hasSymbols || has(getNamelessFunction(), 'name') ***REMOVED***, function (st) ***REMOVED***
			var pairs = [
				[Symbol(), ''],
				[Symbol(undefined), ''],
				[Symbol(null), '[null]'],
				[Symbol(''), getInferredName ? '[]' : ''],
				[Symbol.iterator, '[Symbol.iterator]'],
				[Symbol('foo'), '[foo]']
			];
			forEach(pairs, function (pair) ***REMOVED***
				var sym = pair[0];
				var desc = pair[1];
				var f = getNamelessFunction();
				ES.SetFunctionName(f, sym);
				st.equal(f.name, desc, debug(sym) + ' yields a name of ' + debug(desc));
			***REMOVED***);

			st.end();
		***REMOVED***);

		var f = getNamelessFunction();
		t.test('when names are configurable', ***REMOVED*** skip: !functionsHaveConfigurableNames || has(f, 'name') ***REMOVED***, function (st) ***REMOVED***
			// without prefix
			st.notEqual(f.name, 'foo', 'precondition');
			ES.SetFunctionName(f, 'foo');
			st.equal(f.name, 'foo', 'function name is set without a prefix');

			// with prefix
			var g = getNamelessFunction();
			st.notEqual(g.name, 'pre- foo', 'precondition');
			ES.SetFunctionName(g, 'foo', 'pre-');
			st.equal(g.name, 'pre- foo', 'function name is set with a prefix');

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);
***REMOVED***;

var es2016 = function ES2016(ES, ops, expectedMissing, skips) ***REMOVED***
	es2015(ES, ops, expectedMissing, skips);

	test('SameValueNonNumber', function (t) ***REMOVED***
		var willThrow = [
			[3, 4],
			[NaN, 4],
			[4, ''],
			['abc', true],
			[***REMOVED******REMOVED***, false]
		];
		forEach(willThrow, function (nums) ***REMOVED***
			t['throws'](function () ***REMOVED*** return ES.SameValueNonNumber.apply(ES, nums); ***REMOVED***, TypeError, 'value must be same type and non-number');
		***REMOVED***);

		forEach(v.objects.concat(v.nonNumberPrimitives), function (val) ***REMOVED***
			t.equal(val === val, ES.SameValueNonNumber(val, val), debug(val) + ' is SameValueNonNumber to itself');
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('IterableToArrayLike', ***REMOVED*** skip: skips && skips.IterableToArrayLike ***REMOVED***, function (t) ***REMOVED***
		t.test('custom iterables', ***REMOVED*** skip: !v.hasSymbols ***REMOVED***, function (st) ***REMOVED***
			var O = ***REMOVED******REMOVED***;
			O[Symbol.iterator] = function () ***REMOVED***
				var i = -1;
				return ***REMOVED***
					next: function () ***REMOVED***
						i += 1;
						return ***REMOVED***
							done: i >= 5,
							value: i
						***REMOVED***;
					***REMOVED***
				***REMOVED***;
			***REMOVED***;
			st.deepEqual(
				ES.IterableToArrayLike(O),
				[0, 1, 2, 3, 4],
				'Symbol.iterator method is called and values collected'
			);

			st.end();
		***REMOVED***);

		t.deepEqual(ES.IterableToArrayLike('abc'), ['a', 'b', 'c'], 'a string of code units spreads');
		t.deepEqual(ES.IterableToArrayLike('💩'), ['💩'], 'a string of code points spreads');
		t.deepEqual(ES.IterableToArrayLike('a💩c'), ['a', '💩', 'c'], 'a string of code points and units spreads');

		var arr = [1, 2, 3];
		t.deepEqual(ES.IterableToArrayLike(arr), arr, 'an array becomes a similar array');
		t.notEqual(ES.IterableToArrayLike(arr), arr, 'an array becomes a different, but similar, array');

		var O = ***REMOVED******REMOVED***;
		t.equal(ES.IterableToArrayLike(O), O, 'a non-iterable non-array non-string object is returned directly');

		t.end();
	***REMOVED***);

	test('OrdinaryGetPrototypeOf', function (t) ***REMOVED***
		t.test('values', ***REMOVED*** skip: !$getProto ***REMOVED***, function (st) ***REMOVED***
			st.equal(ES.OrdinaryGetPrototypeOf([]), Array.prototype, 'array [[Prototype]] is Array.prototype');
			st.equal(ES.OrdinaryGetPrototypeOf(***REMOVED******REMOVED***), Object.prototype, 'object [[Prototype]] is Object.prototype');
			st.equal(ES.OrdinaryGetPrototypeOf(/a/g), RegExp.prototype, 'regex [[Prototype]] is RegExp.prototype');
			st.equal(ES.OrdinaryGetPrototypeOf(Object('')), String.prototype, 'boxed string [[Prototype]] is String.prototype');
			st.equal(ES.OrdinaryGetPrototypeOf(Object(42)), Number.prototype, 'boxed number [[Prototype]] is Number.prototype');
			st.equal(ES.OrdinaryGetPrototypeOf(Object(true)), Boolean.prototype, 'boxed boolean [[Prototype]] is Boolean.prototype');
			if (v.hasSymbols) ***REMOVED***
				st.equal(ES.OrdinaryGetPrototypeOf(Object(Symbol.iterator)), Symbol.prototype, 'boxed symbol [[Prototype]] is Symbol.prototype');
			***REMOVED***
			st.end();
		***REMOVED***);

		forEach(v.primitives, function (primitive) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.OrdinaryGetPrototypeOf(primitive); ***REMOVED***,
				TypeError,
				debug(primitive) + ' is not an Object'
			);
		***REMOVED***);
		t.end();
	***REMOVED***);

	test('OrdinarySetPrototypeOf', ***REMOVED*** skip: !$getProto || !$setProto ***REMOVED***, function (t) ***REMOVED***
		var a = [];
		var proto = ***REMOVED******REMOVED***;

		t.equal(ES.OrdinaryGetPrototypeOf(a), Array.prototype, 'precondition');
		t.equal(ES.OrdinarySetPrototypeOf(a, proto), true, 'setting prototype is successful');
		t.equal(ES.OrdinaryGetPrototypeOf(a), proto, 'postcondition');

		t.end();
	***REMOVED***);
***REMOVED***;

var es2017 = function ES2017(ES, ops, expectedMissing, skips) ***REMOVED***
	es2016(ES, ops, expectedMissing, assign(***REMOVED******REMOVED***, skips, ***REMOVED***
		EnumerableOwnNames: true,
		IterableToArrayLike: true
	***REMOVED***));

	test('ToIndex', function (t) ***REMOVED***
		t.ok(is(ES.ToIndex(), 0), 'no value gives 0');
		t.ok(is(ES.ToIndex(undefined), 0), 'undefined value gives 0');

		t['throws'](function () ***REMOVED*** ES.ToIndex(-1); ***REMOVED***, RangeError, 'negative numbers throw');

		t['throws'](function () ***REMOVED*** ES.ToIndex(MAX_SAFE_INTEGER + 1); ***REMOVED***, RangeError, 'too large numbers throw');

		t.equal(ES.ToIndex(3), 3, 'numbers work');
		t.equal(ES.ToIndex(v.valueOfOnlyObject), 4, 'coercible objects are coerced');

		t.end();
	***REMOVED***);

	test('EnumerableOwnProperties', ***REMOVED*** skip: skips && skips.EnumerableOwnProperties ***REMOVED***, function (t) ***REMOVED***
		var obj = testEnumerableOwnNames(t, function (O) ***REMOVED***
			return ES.EnumerableOwnProperties(O, 'key');
		***REMOVED***);

		t.deepEqual(
			ES.EnumerableOwnProperties(obj, 'value'),
			[obj.own],
			'returns enumerable own values'
		);

		t.deepEqual(
			ES.EnumerableOwnProperties(obj, 'key+value'),
			[['own', obj.own]],
			'returns enumerable own entries'
		);

		t.end();
	***REMOVED***);

	test('IterableToList', function (t) ***REMOVED***
		var customIterator = function () ***REMOVED***
			var i = -1;
			return ***REMOVED***
				next: function () ***REMOVED***
					i += 1;
					return ***REMOVED***
						done: i >= 5,
						value: i
					***REMOVED***;
				***REMOVED***
			***REMOVED***;
		***REMOVED***;

		t.deepEqual(
			ES.IterableToList(***REMOVED******REMOVED***, customIterator),
			[0, 1, 2, 3, 4],
			'iterator method is called and values collected'
		);

		t.test('Symbol support', ***REMOVED*** skip: !v.hasSymbols ***REMOVED***, function (st) ***REMOVED***
			st.deepEqual(ES.IterableToList('abc', String.prototype[Symbol.iterator]), ['a', 'b', 'c'], 'a string of code units spreads');
			st.deepEqual(ES.IterableToList('☃', String.prototype[Symbol.iterator]), ['☃'], 'a string of code points spreads');

			var arr = [1, 2, 3];
			st.deepEqual(ES.IterableToList(arr, arr[Symbol.iterator]), arr, 'an array becomes a similar array');
			st.notEqual(ES.IterableToList(arr, arr[Symbol.iterator]), arr, 'an array becomes a different, but similar, array');

			st.end();
		***REMOVED***);

		t['throws'](
			function () ***REMOVED*** ES.IterableToList(***REMOVED******REMOVED***, void 0); ***REMOVED***,
			TypeError,
			'non-function iterator method'
		);

		t.end();
	***REMOVED***);
***REMOVED***;

var es2018 = function ES2018(ES, ops, expectedMissing, skips) ***REMOVED***
	es2017(ES, ops, expectedMissing, assign(***REMOVED******REMOVED***, skips, ***REMOVED***
		EnumerableOwnProperties: true,
		GetSubstitution: true,
		IsPropertyDescriptor: true
	***REMOVED***));

	test('thisSymbolValue', function (t) ***REMOVED***
		forEach(v.nonSymbolPrimitives.concat(v.objects), function (nonSymbol) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.thisSymbolValue(nonSymbol); ***REMOVED***,
				v.hasSymbols ? TypeError : SyntaxError,
				debug(nonSymbol) + ' is not a Symbol'
			);
		***REMOVED***);

		t.test('no native Symbols', ***REMOVED*** skip: v.hasSymbols ***REMOVED***, function (st) ***REMOVED***
			forEach(v.objects.concat(v.primitives), function (value) ***REMOVED***
				st['throws'](
					function () ***REMOVED*** ES.thisSymbolValue(value); ***REMOVED***,
					SyntaxError,
					'Symbols are not supported'
				);
			***REMOVED***);
			st.end();
		***REMOVED***);

		t.test('symbol values', ***REMOVED*** skip: !v.hasSymbols ***REMOVED***, function (st) ***REMOVED***
			forEach(v.symbols, function (symbol) ***REMOVED***
				st.equal(ES.thisSymbolValue(symbol), symbol, 'Symbol value of ' + debug(symbol) + ' is same symbol');

				st.equal(
					ES.thisSymbolValue(Object(symbol)),
					symbol,
					'Symbol value of ' + debug(Object(symbol)) + ' is ' + debug(symbol)
				);
			***REMOVED***);

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('IsStringPrefix', function (t) ***REMOVED***
		forEach(v.nonStrings, function (nonString) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.IsStringPrefix(nonString, 'a'); ***REMOVED***,
				TypeError,
				'first arg: ' + debug(nonString) + ' is not a string'
			);
			t['throws'](
				function () ***REMOVED*** ES.IsStringPrefix('a', nonString); ***REMOVED***,
				TypeError,
				'second arg: ' + debug(nonString) + ' is not a string'
			);
		***REMOVED***);

		forEach(v.strings, function (string) ***REMOVED***
			t.equal(ES.IsStringPrefix(string, string), true, debug(string) + ' is a prefix of itself');

			t.equal(ES.IsStringPrefix('', string), true, 'the empty string is a prefix of everything');
		***REMOVED***);

		t.equal(ES.IsStringPrefix('abc', 'abcd'), true, '"abc" is a prefix of "abcd"');
		t.equal(ES.IsStringPrefix('abcd', 'abc'), false, '"abcd" is not a prefix of "abc"');

		t.equal(ES.IsStringPrefix('a', 'bc'), false, '"a" is not a prefix of "bc"');

		t.end();
	***REMOVED***);

	test('NumberToString', function (t) ***REMOVED***
		forEach(v.nonNumbers, function (nonNumber) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.NumberToString(nonNumber); ***REMOVED***,
				TypeError,
				debug(nonNumber) + ' is not a Number'
			);
		***REMOVED***);

		forEach(v.numbers, function (number) ***REMOVED***
			t.equal(ES.NumberToString(number), String(number), debug(number) + ' stringifies to ' + number);
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('CopyDataProperties', function (t) ***REMOVED***
		t.test('first argument: target', function (st) ***REMOVED***
			forEach(v.primitives, function (primitive) ***REMOVED***
				st['throws'](
					function () ***REMOVED*** ES.CopyDataProperties(primitive, ***REMOVED******REMOVED***, []); ***REMOVED***,
					TypeError,
					debug(primitive) + ' is not an Object'
				);
			***REMOVED***);
			st.end();
		***REMOVED***);

		t.test('second argument: source', function (st) ***REMOVED***
			var frozenTarget = Object.freeze ? Object.freeze(***REMOVED******REMOVED***) : ***REMOVED******REMOVED***;
			forEach(v.nullPrimitives, function (nullish) ***REMOVED***
				st.equal(
					ES.CopyDataProperties(frozenTarget, nullish, []),
					frozenTarget,
					debug(nullish) + ' "source" yields identical, unmodified target'
				);
			***REMOVED***);

			forEach(v.nonNullPrimitives, function (objectCoercible) ***REMOVED***
				var target = ***REMOVED******REMOVED***;
				var result = ES.CopyDataProperties(target, objectCoercible, []);
				st.equal(result, target, 'result === target');
				st.deepEqual(keys(result), keys(Object(objectCoercible)), 'target ends up with keys of ' + debug(objectCoercible));
			***REMOVED***);

			st.test('enumerable accessor property', ***REMOVED*** skip: !defineProperty.oDP ***REMOVED***, function (s2t) ***REMOVED***
				var target = ***REMOVED******REMOVED***;
				var source = ***REMOVED******REMOVED***;
				defineProperty(source, 'a', ***REMOVED***
					enumerable: true,
					get: function () ***REMOVED*** return 42; ***REMOVED***
				***REMOVED***);
				var result = ES.CopyDataProperties(target, source, []);
				s2t.equal(result, target, 'result === target');
				s2t.deepEqual(result, ***REMOVED*** a: 42 ***REMOVED***, 'target ends up with enumerable accessor of source');
				s2t.end();
			***REMOVED***);

			st.end();
		***REMOVED***);

		t.test('third argument: excludedItems', function (st) ***REMOVED***
			forEach(v.objects.concat(v.primitives), function (nonArray) ***REMOVED***
				st['throws'](
					function () ***REMOVED*** ES.CopyDataProperties(***REMOVED******REMOVED***, ***REMOVED******REMOVED***, nonArray); ***REMOVED***,
					TypeError,
					debug(nonArray) + ' is not an Array'
				);
			***REMOVED***);

			forEach(v.nonPropertyKeys, function (nonPropertyKey) ***REMOVED***
				st['throws'](
					function () ***REMOVED*** ES.CopyDataProperties(***REMOVED******REMOVED***, ***REMOVED******REMOVED***, [nonPropertyKey]); ***REMOVED***,
					TypeError,
					debug(nonPropertyKey) + ' is not a Property Key'
				);
			***REMOVED***);

			var result = ES.CopyDataProperties(***REMOVED******REMOVED***, ***REMOVED*** a: 1, b: 2, c: 3 ***REMOVED***, ['b']);
			st.deepEqual(keys(result).sort(), ['a', 'c'].sort(), 'excluded string keys are excluded');

			st.test('excluding symbols', ***REMOVED*** skip: !v.hasSymbols ***REMOVED***, function (s2t) ***REMOVED***
				var source = ***REMOVED******REMOVED***;
				forEach(v.symbols, function (symbol) ***REMOVED***
					source[symbol] = true;
				***REMOVED***);

				var includedSymbols = v.symbols.slice(1);
				var excludedSymbols = v.symbols.slice(0, 1);
				var target = ES.CopyDataProperties(***REMOVED******REMOVED***, source, excludedSymbols);

				forEach(includedSymbols, function (symbol) ***REMOVED***
					s2t.equal(has(target, symbol), true, debug(symbol) + ' is included');
				***REMOVED***);

				forEach(excludedSymbols, function (symbol) ***REMOVED***
					s2t.equal(has(target, symbol), false, debug(symbol) + ' is excluded');
				***REMOVED***);

				s2t.end();
			***REMOVED***);

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('PromiseResolve', function (t) ***REMOVED***
		t.test('Promises unsupported', ***REMOVED*** skip: typeof Promise === 'function' ***REMOVED***, function (st) ***REMOVED***
			st['throws'](
				function () ***REMOVED*** ES.PromiseResolve(); ***REMOVED***,
				SyntaxError,
				'Promises are not supported'
			);
			st.end();
		***REMOVED***);

		t.test('Promises supported', ***REMOVED*** skip: typeof Promise !== 'function' ***REMOVED***, function (st) ***REMOVED***
			st.plan(2);

			var a = ***REMOVED******REMOVED***;
			var b = ***REMOVED******REMOVED***;
			var fulfilled = Promise.resolve(a);
			var rejected = Promise.reject(b);

			ES.PromiseResolve(Promise, fulfilled).then(function (x) ***REMOVED***
				st.equal(x, a, 'fulfilled promise resolves to fulfilled');
			***REMOVED***);

			ES.PromiseResolve(Promise, rejected)['catch'](function (e) ***REMOVED***
				st.equal(e, b, 'rejected promise resolves to rejected');
			***REMOVED***);
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('EnumerableOwnPropertyNames', ***REMOVED*** skip: skips && skips.EnumerableOwnPropertyNames ***REMOVED***, function (t) ***REMOVED***
		var obj = testEnumerableOwnNames(t, function (O) ***REMOVED***
			return ES.EnumerableOwnPropertyNames(O, 'key');
		***REMOVED***);

		t.deepEqual(
			ES.EnumerableOwnPropertyNames(obj, 'value'),
			[obj.own],
			'returns enumerable own values'
		);

		t.deepEqual(
			ES.EnumerableOwnPropertyNames(obj, 'key+value'),
			[['own', obj.own]],
			'returns enumerable own entries'
		);

		t.end();
	***REMOVED***);

	test('IsPromise', ***REMOVED*** skip: typeof Promise !== 'function' ***REMOVED***, function (t) ***REMOVED***
		forEach(v.objects.concat(v.primitives), function (nonPromise) ***REMOVED***
			t.equal(ES.IsPromise(nonPromise), false, debug(nonPromise) + ' is not a Promise');
		***REMOVED***);

		var thenable = ***REMOVED*** then: Promise.prototype.then ***REMOVED***;
		t.equal(ES.IsPromise(thenable), false, 'generic thenable is not a Promise');

		t.equal(ES.IsPromise(Promise.resolve()), true, 'Promise is a Promise');

		t.end();
	***REMOVED***);

	test('GetSubstitution (ES2018+)', function (t) ***REMOVED***
		forEach(v.nonStrings, function (nonString) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.GetSubstitution(nonString, '', 0, [], undefined, ''); ***REMOVED***,
				TypeError,
				'`matched`: ' + debug(nonString) + ' is not a String'
			);

			t['throws'](
				function () ***REMOVED*** ES.GetSubstitution('', nonString, 0, [], undefined, ''); ***REMOVED***,
				TypeError,
				'`str`: ' + debug(nonString) + ' is not a String'
			);

			t['throws'](
				function () ***REMOVED*** ES.GetSubstitution('', '', 0, [], undefined, nonString); ***REMOVED***,
				TypeError,
				'`replacement`: ' + debug(nonString) + ' is not a String'
			);

			t['throws'](
				function () ***REMOVED*** ES.GetSubstitution('', '', 0, [nonString], undefined, ''); ***REMOVED***,
				TypeError,
				'`captures`: ' + debug([nonString]) + ' is not an Array of strings'
			);
		***REMOVED***);

		forEach(v.nonIntegerNumbers.concat([-1, -42, -Infinity]), function (nonNonNegativeInteger) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.GetSubstitution('', '', nonNonNegativeInteger, [], undefined, ''); ***REMOVED***,
				TypeError,
				'`position`: ' + debug(nonNonNegativeInteger) + ' is not a non-negative integer'
			);
		***REMOVED***);

		forEach(v.nonArrays, function (nonArray) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.GetSubstitution('', '', 0, nonArray, undefined, ''); ***REMOVED***,
				TypeError,
				'`captures`: ' + debug(nonArray) + ' is not an Array'
			);
		***REMOVED***);

		t.equal(
			ES.GetSubstitution('def', 'abcdefghi', 3, [], undefined, '123'),
			'123',
			'returns the substitution'
		);
		t.equal(
			ES.GetSubstitution('abcdef', 'abcdefghi', 0, [], undefined, '$$2$'),
			'$2$',
			'supports $$, and trailing $'
		);

		t.equal(
			ES.GetSubstitution('abcdef', 'abcdefghi', 0, [], undefined, '>$&<'),
			'>abcdef<',
			'supports $&'
		);

		t.equal(
			ES.GetSubstitution('abcdef', 'abcdefghi', 0, [], undefined, '>$`<'),
			'><',
			'supports $` at position 0'
		);
		t.equal(
			ES.GetSubstitution('def', 'abcdefghi', 3, [], undefined, '>$`<'),
			'>ab<',
			'supports $` at position > 0'
		);

		t.equal(
			ES.GetSubstitution('def', 'abcdefghi', 7, [], undefined, ">$'<"),
			'><',
			"supports $' at a position where there's less than `matched.length` chars left"
		);
		t.equal(
			ES.GetSubstitution('def', 'abcdefghi', 3, [], undefined, ">$'<"),
			'>ghi<',
			"supports $' at a position where there's more than `matched.length` chars left"
		);

		for (var i = 0; i < 100; i += 1) ***REMOVED***
			var captures = [];
			captures[i] = 'test';
			if (i > 0) ***REMOVED***
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, [], undefined, '>$' + i + '<'),
					'>undefined<',
					'supports $' + i + ' with no captures'
				);
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, [], undefined, '>$' + i),
					'>undefined',
					'supports $' + i + ' at the end of the replacement, with no captures'
				);
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, captures, undefined, '>$' + i + '<'),
					'><',
					'supports $' + i + ' with a capture at that index'
				);
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, captures, undefined, '>$' + i),
					'>',
					'supports $' + i + ' at the end of the replacement, with a capture at that index'
				);
			***REMOVED***
			if (i < 10) ***REMOVED***
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, [], undefined, '>$0' + i + '<'),
					i === 0 ? '><' : '>undefined<',
					'supports $0' + i + ' with no captures'
				);
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, [], undefined, '>$0' + i),
					i === 0 ? '>' : '>undefined',
					'supports $0' + i + ' at the end of the replacement, with no captures'
				);
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, captures, undefined, '>$0' + i + '<'),
					'><',
					'supports $0' + i + ' with a capture at that index'
				);
				t.equal(
					ES.GetSubstitution('abcdef', 'abcdefghi', 0, captures, undefined, '>$0' + i),
					'>',
					'supports $0' + i + ' at the end of the replacement, with a capture at that index'
				);
			***REMOVED***
		***REMOVED***

		t.end();
	***REMOVED***);

	test('DateString', function (t) ***REMOVED***
		forEach(v.nonNumbers.concat(NaN), function (nonNumberOrNaN) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.DateString(nonNumberOrNaN); ***REMOVED***,
				TypeError,
				debug(nonNumberOrNaN) + ' is not a non-NaN Number'
			);
		***REMOVED***);

		t.equal(ES.DateString(Date.UTC(2019, 8, 10, 7, 8, 9)), 'Tue Sep 10 2019');
		t.equal(ES.DateString(Date.UTC(2016, 1, 29, 7, 8, 9)), 'Mon Feb 29 2016'); // leap day
		t.end();
	***REMOVED***);

	test('TimeString', function (t) ***REMOVED***
		forEach(v.nonNumbers.concat(NaN), function (nonNumberOrNaN) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.TimeString(nonNumberOrNaN); ***REMOVED***,
				TypeError,
				debug(nonNumberOrNaN) + ' is not a non-NaN Number'
			);
		***REMOVED***);

		var tv = Date.UTC(2019, 8, 10, 7, 8, 9);
		t.equal(ES.TimeString(tv), '07:08:09 GMT');
		t.end();
	***REMOVED***);
***REMOVED***;

var es2019 = function ES2018(ES, ops, expectedMissing, skips) ***REMOVED***
	es2018(ES, ops, expectedMissing, assign(***REMOVED******REMOVED***, skips, ***REMOVED***
	***REMOVED***));

	test('AddEntriesFromIterable', function (t) ***REMOVED***
		t['throws'](
			function () ***REMOVED*** ES.AddEntriesFromIterable(***REMOVED******REMOVED***, undefined, function () ***REMOVED******REMOVED***); ***REMOVED***,
			TypeError,
			'iterable must not be undefined'
		);
		t['throws'](
			function () ***REMOVED*** ES.AddEntriesFromIterable(***REMOVED******REMOVED***, null, function () ***REMOVED******REMOVED***); ***REMOVED***,
			TypeError,
			'iterable must not be null'
		);
		forEach(v.nonFunctions, function (nonFunction) ***REMOVED***
			t['throws'](
				function () ***REMOVED*** ES.AddEntriesFromIterable(***REMOVED******REMOVED***, ***REMOVED******REMOVED***, nonFunction); ***REMOVED***,
				TypeError,
				debug(nonFunction) + ' is not a function'
			);
		***REMOVED***);

		t.test('Symbol support', ***REMOVED*** skip: !v.hasSymbols ***REMOVED***, function (st) ***REMOVED***
			st.plan(4);

			var O = ***REMOVED******REMOVED***;
			st.equal(ES.AddEntriesFromIterable(O, [], function () ***REMOVED******REMOVED***), O, 'returns the target');

			var adder = function (key, value) ***REMOVED***
				st.equal(this, O, 'adder gets proper receiver');
				st.equal(key, 0, 'k is key');
				st.equal(value, 'a', 'v is value');
			***REMOVED***;
			ES.AddEntriesFromIterable(O, ['a'].entries(), adder);

			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('FlattenIntoArray', function (t) ***REMOVED***
		t.test('no mapper function', function (st) ***REMOVED***
			var testDepth = function testDepth(tt, depth, expected) ***REMOVED***
				var a = [];
				var o = [[1], 2, , [[3]], [], 4, [[[[5]]]]]; // eslint-disable-line no-sparse-arrays
				ES.FlattenIntoArray(a, o, o.length, 0, depth);
				tt.deepEqual(a, expected, 'depth: ' + depth);
			***REMOVED***;

			testDepth(st, 1, [1, 2, [3], 4, [[[5]]]]);
			testDepth(st, 2, [1, 2, 3, 4, [[5]]]);
			testDepth(st, 3, [1, 2, 3, 4, [5]]);
			testDepth(st, 4, [1, 2, 3, 4, 5]);
			testDepth(st, Infinity, [1, 2, 3, 4, 5]);
			st.end();
		***REMOVED***);

		t.test('mapper function', function (st) ***REMOVED***
			var testMapper = function testMapper(tt, mapper, expected, thisArg) ***REMOVED***
				var a = [];
				var o = [[1], 2, , [[3]], [], 4, [[[[5]]]]]; // eslint-disable-line no-sparse-arrays
				ES.FlattenIntoArray(a, o, o.length, 0, 1, mapper, thisArg);
				tt.deepEqual(a, expected);
			***REMOVED***;

			var double = function double(x) ***REMOVED***
				return typeof x === 'number' ? 2 * x : x;
			***REMOVED***;
			testMapper(
				st,
				double,
				[1, 4, [3], 8, [[[5]]]]
			);
			var receiver = hasStrictMode ? 42 : Object(42);
			testMapper(
				st,
				function (x) ***REMOVED*** return [this, double(x)]; ***REMOVED***,
				[receiver, [1], receiver, 4, receiver, [[3]], receiver, [], receiver, 8, receiver, [[[[5]]]]],
				42
			);
			st.end();
		***REMOVED***);

		t.end();
	***REMOVED***);

	test('TrimString', function (t) ***REMOVED***
		t.test('non-object string', function (st) ***REMOVED***
			forEach(v.nullPrimitives, function (nullish) ***REMOVED***
				st['throws'](
					function () ***REMOVED*** ES.TrimString(nullish); ***REMOVED***,
					debug(nullish) + ' is not an Object'
				);
			***REMOVED***);
			st.end();
		***REMOVED***);

		var string = ' \n abc  \n ';
		t.equal(ES.TrimString(string, 'start'), string.slice(string.indexOf('a')));
		t.equal(ES.TrimString(string, 'end'), string.slice(0, string.lastIndexOf('c') + 1));
		t.equal(ES.TrimString(string, 'start+end'), string.slice(string.indexOf('a'), string.lastIndexOf('c') + 1));

		t.end();
	***REMOVED***);
***REMOVED***;

module.exports = ***REMOVED***
	es2015: es2015,
	es2016: es2016,
	es2017: es2017,
	es2018: es2018,
	es2019: es2019
***REMOVED***;
