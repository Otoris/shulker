/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */
"use strict"

const ***REMOVED*** isOpeningBracketToken, isClosingBracketToken ***REMOVED*** = require("eslint-utils")

module.exports = ***REMOVED***
    meta: ***REMOVED***
        docs: ***REMOVED***
            description: "disallow property shorthands.",
            category: "ES2015",
            recommended: false,
            url:
                "http://mysticatea.github.io/eslint-plugin-es/rules/no-property-shorthands.html",
        ***REMOVED***,
        fixable: "code",
        messages: ***REMOVED***
            forbidden: "ES2015 property shorthands are forbidden.",
        ***REMOVED***,
        schema: [],
        type: "problem",
    ***REMOVED***,
    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode()

        /**
         * Fixes a FunctionExpression node by making it into a longform property.
         * @param ***REMOVED***SourceCodeFixer***REMOVED*** fixer The fixer object
         * @param ***REMOVED***ASTNode***REMOVED*** node A `Property` node that has a `FunctionExpression` as its value
         * @returns ***REMOVED***object***REMOVED*** A fix for this node
         */
        function makeFunctionLongform(fixer, node) ***REMOVED***
            const firstKeyToken = node.computed
                ? sourceCode.getTokenBefore(node.key, isOpeningBracketToken)
                : sourceCode.getFirstToken(node.key)
            const lastKeyToken = node.computed
                ? sourceCode.getTokenAfter(node.key, isClosingBracketToken)
                : sourceCode.getLastToken(node.key)
            const keyText = sourceCode.text.slice(
                firstKeyToken.range[0],
                lastKeyToken.range[1]
            )
            let functionHeader = "function"

            if (node.value.async) ***REMOVED***
                functionHeader = `async $***REMOVED***functionHeader***REMOVED***`
            ***REMOVED***
            if (node.value.generator) ***REMOVED***
                functionHeader = `$***REMOVED***functionHeader***REMOVED****`
            ***REMOVED***

            return fixer.replaceTextRange(
                [node.range[0], lastKeyToken.range[1]],
                `$***REMOVED***keyText***REMOVED***: $***REMOVED***functionHeader***REMOVED***`
            )
        ***REMOVED***

        return ***REMOVED***
            "ObjectExpression > :matches(Property[method=true], Property[shorthand=true])"(
                node
            ) ***REMOVED***
                context.report(***REMOVED***
                    node,
                    messageId: "forbidden",
                    fix: node.method
                        ? fixer => makeFunctionLongform(fixer, node)
                        : fixer =>
                              fixer.insertTextAfter(
                                  node.key,
                                  `: $***REMOVED***node.key.name***REMOVED***`
                              ),
                ***REMOVED***)
            ***REMOVED***,
        ***REMOVED***
    ***REMOVED***,
***REMOVED***
