/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */
"use strict"

const ***REMOVED*** isArrowToken, isParenthesized ***REMOVED*** = require("eslint-utils")

module.exports = ***REMOVED***
    meta: ***REMOVED***
        docs: ***REMOVED***
            description: "disallow arrow function expressions.",
            category: "ES2015",
            recommended: false,
            url:
                "http://mysticatea.github.io/eslint-plugin-es/rules/no-arrow-functions.html",
        ***REMOVED***,
        fixable: "code",
        messages: ***REMOVED***
            forbidden: "ES2015 arrow function expressions are forbidden.",
        ***REMOVED***,
        schema: [],
        type: "problem",
    ***REMOVED***,
    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode()

        /**
         * ArrowFunctionExpression to FunctionExpression
         * @param  ***REMOVED***Node***REMOVED*** node ArrowFunctionExpression Node
         * @param  ***REMOVED***boolean***REMOVED*** hasThis `true` if the function has `this`.
         * @returns ***REMOVED***string***REMOVED*** function expression text
         */
        function toFunctionExpression(node, hasThis) ***REMOVED***
            const params = node.params
            const paramText = params.length
                ? sourceCode.text.slice(
                      params[0].range[0],
                      params[params.length - 1].range[1]
                  )
                : ""

            const arrowToken = sourceCode.getTokenBefore(
                node.body,
                isArrowToken
            )
            const preText = sourceCode.text.slice(
                arrowToken.range[1],
                node.body.range[0]
            )
            const bodyText = sourceCode.text
                .slice(arrowToken.range[1], node.range[1])
                .trim()

            let resultText =
                /*eslint-disable @mysticatea/prettier */
                node.body.type === "BlockStatement" ? (
                    `function($***REMOVED***paramText***REMOVED***) $***REMOVED***bodyText***REMOVED***`
                ) : preText.includes("\n") ? (
                    `function($***REMOVED***paramText***REMOVED***) ***REMOVED*** return ($***REMOVED***bodyText***REMOVED***) ***REMOVED***`
                ) : (
                    `function($***REMOVED***paramText***REMOVED***) ***REMOVED*** return $***REMOVED***bodyText***REMOVED*** ***REMOVED***`
                )
                /*eslint-enable @mysticatea/prettier */

            if (hasThis) ***REMOVED***
                resultText += ".bind(this)"
            ***REMOVED***
            if (
                node.parent.type === "ExpressionStatement" &&
                !isParenthesized(node, sourceCode)
            ) ***REMOVED***
                resultText = `($***REMOVED***resultText***REMOVED***)`
            ***REMOVED***

            return resultText
        ***REMOVED***

        /**
         * Report that ArrowFunctionExpression is being used
         * @param ***REMOVED***Node***REMOVED*** node ArrowFunctionExpression Node
         * @param ***REMOVED***boolean***REMOVED*** hasThis Whether `this` is referenced in` function` scope
         * @param ***REMOVED***boolean***REMOVED*** hasSuper Whether `super` is referenced in` function` scope
         * @returns ***REMOVED***void***REMOVED***
         */
        function report(node, hasThis, hasSuper) ***REMOVED***
            context.report(***REMOVED***
                node,
                messageId: "forbidden",
                fix(fixer) ***REMOVED***
                    if (hasSuper) ***REMOVED***
                        return undefined
                    ***REMOVED***
                    return fixer.replaceText(
                        node,
                        toFunctionExpression(node, hasThis)
                    )
                ***REMOVED***,
            ***REMOVED***)
        ***REMOVED***

        let stack = ***REMOVED*** upper: null, hasThis: false, hasSuper: false ***REMOVED***
        return ***REMOVED***
            ":function"() ***REMOVED***
                stack = ***REMOVED*** upper: stack, hasThis: false, hasSuper: false ***REMOVED***
            ***REMOVED***,
            ":function:exit"(node) ***REMOVED***
                const ***REMOVED*** hasThis, hasSuper ***REMOVED*** = stack
                stack = stack.upper

                if (node.type === "ArrowFunctionExpression") ***REMOVED***
                    report(node, hasThis, hasSuper)

                    stack.hasThis = stack.hasThis || hasThis
                    stack.hasSuper = stack.hasSuper || hasSuper
                ***REMOVED***
            ***REMOVED***,
            ThisExpression() ***REMOVED***
                stack.hasThis = true
            ***REMOVED***,
            Super() ***REMOVED***
                stack.hasSuper = true
            ***REMOVED***,
        ***REMOVED***
    ***REMOVED***,
***REMOVED***
