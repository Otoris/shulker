'use strict';
var util = require('util'),
  Match = require ('../match');

/**
 * This class matches UTF-16 and UTF-32, both big- and little-endian. The
 * BOM will be used if it is present.
 */
module.exports.UTF_16BE = function() ***REMOVED***
  this.name = function() ***REMOVED***
    return 'UTF-16BE';
  ***REMOVED***;
  this.match = function(det) ***REMOVED***
    var input = det.fRawInput;

    if (input.length >= 2 && ((input[0] & 0xff) == 0xfe && (input[1] & 0xff) == 0xff)) ***REMOVED***
      return new Match(det, this, 100); // confidence = 100
    ***REMOVED***

    // TODO: Do some statistics to check for unsigned UTF-16BE
    return null;
  ***REMOVED***;
***REMOVED***;

module.exports.UTF_16LE = function() ***REMOVED***
  this.name = function() ***REMOVED***
    return 'UTF-16LE';
  ***REMOVED***;
  this.match = function(det) ***REMOVED***
    var input = det.fRawInput;

    if (input.length >= 2 && ((input[0] & 0xff) == 0xff && (input[1] & 0xff) == 0xfe)) ***REMOVED***
      // LE BOM is present.
      if (input.length >= 4 && input[2] == 0x00 && input[3] == 0x00) ***REMOVED***
        // It is probably UTF-32 LE, not UTF-16
        return null;
      ***REMOVED***
      return new Match(det, this, 100); // confidence = 100
    ***REMOVED***

    // TODO: Do some statistics to check for unsigned UTF-16LE
    return null;
  ***REMOVED***
***REMOVED***;

function UTF_32() ***REMOVED******REMOVED***;
UTF_32.prototype.match = function(det) ***REMOVED***
  var input      = det.fRawInput,
    limit      = (det.fRawLength / 4) * 4,
    numValid   = 0,
    numInvalid = 0,
    hasBOM     = false,
    confidence = 0;

  if (limit == 0) ***REMOVED***
    return null;
  ***REMOVED***

  if (this.getChar(input, 0) == 0x0000FEFF) ***REMOVED***
    hasBOM = true;
  ***REMOVED***

  for (var i = 0; i < limit; i += 4) ***REMOVED***
    var ch = this.getChar(input, i);

    if (ch < 0 || ch >= 0x10FFFF || (ch >= 0xD800 && ch <= 0xDFFF)) ***REMOVED***
      numInvalid += 1;
    ***REMOVED*** else ***REMOVED***
      numValid += 1;
    ***REMOVED***
  ***REMOVED***

  // Cook up some sort of confidence score, based on presence of a BOM
  //    and the existence of valid and/or invalid multi-byte sequences.
  if (hasBOM && numInvalid == 0) ***REMOVED***
    confidence = 100;
  ***REMOVED*** else if (hasBOM && numValid > numInvalid * 10) ***REMOVED***
    confidence = 80;
  ***REMOVED*** else if (numValid > 3 && numInvalid == 0) ***REMOVED***
    confidence = 100;
  ***REMOVED*** else if (numValid > 0 && numInvalid == 0) ***REMOVED***
    confidence = 80;
  ***REMOVED*** else if (numValid > numInvalid * 10) ***REMOVED***
    // Probably corrupt UTF-32BE data.  Valid sequences aren't likely by chance.
    confidence = 25;
  ***REMOVED***

  // return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
  return confidence == 0 ? null : new Match(det, this, confidence);
***REMOVED***;

module.exports.UTF_32BE = function() ***REMOVED***
  this.name = function() ***REMOVED***
    return 'UTF-32BE';
  ***REMOVED***;
  this.getChar = function(input, index) ***REMOVED***
    return (input[index + 0] & 0xff) << 24 | (input[index + 1] & 0xff) << 16 |
         (input[index + 2] & 0xff) <<  8 | (input[index + 3] & 0xff);
  ***REMOVED***;
***REMOVED***;
util.inherits(module.exports.UTF_32BE, UTF_32);

module.exports.UTF_32LE = function() ***REMOVED***
  this.name = function() ***REMOVED***
    return 'UTF-32LE';
  ***REMOVED***;
  this.getChar = function(input, index) ***REMOVED***
    return (input[index + 3] & 0xff) << 24 | (input[index + 2] & 0xff) << 16 |
         (input[index + 1] & 0xff) <<  8 | (input[index + 0] & 0xff);
  ***REMOVED***;
***REMOVED***;
util.inherits(module.exports.UTF_32LE, UTF_32);
