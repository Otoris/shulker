const ***REMOVED*** Transform ***REMOVED*** = require('stream');

const OGG_PAGE_HEADER_SIZE = 26;
const STREAM_STRUCTURE_VERSION = 0;

const OGGS_HEADER = Buffer.from('OggS'.split('').map(x => x.charCodeAt(0)));
const OPUS_HEAD = Buffer.from('OpusHead'.split('').map(x => x.charCodeAt(0)));
const OPUS_TAGS = Buffer.from('OpusTags'.split('').map(x => x.charCodeAt(0)));

class OggOpusTransform extends Transform ***REMOVED***
  constructor() ***REMOVED***
    super();
    this._remainder = null;
    this._head = null;
  ***REMOVED***

  _transform(chunk, encoding, done) ***REMOVED***
    if (this._remainder) ***REMOVED***
      chunk = Buffer.concat([this._remainder, chunk]);
      this._remainder = null;
    ***REMOVED***

    while (chunk) ***REMOVED***
      try ***REMOVED***
        const result = this.readPage(chunk);
        if (result) chunk = result;
        else break;
      ***REMOVED*** catch (err) ***REMOVED***
        this.emit('error', err);
      ***REMOVED***
    ***REMOVED***
    this._remainder = chunk;
    done();
  ***REMOVED***

  /**
   * Reads a page from a buffer
   * @param ***REMOVED***Buffer***REMOVED*** chunk The chunk containing the page
   * @returns ***REMOVED***boolean|Buffer***REMOVED***
   */
  readPage(chunk) ***REMOVED***
    if (chunk.length < OGG_PAGE_HEADER_SIZE) ***REMOVED***
      return false;
    ***REMOVED***
    if (!chunk.slice(0, 4).equals(OGGS_HEADER)) ***REMOVED***
      throw Error(`capture_pattern is not $***REMOVED***OGGS_HEADER***REMOVED***`);
    ***REMOVED***
    if (chunk.readUInt8(4) !== STREAM_STRUCTURE_VERSION) ***REMOVED***
      throw Error(`stream_structure_version is not $***REMOVED***STREAM_STRUCTURE_VERSION***REMOVED***`);
    ***REMOVED***

    const pageSegments = chunk.readUInt8(26),
      table = chunk.slice(27, 27 + pageSegments);

    let sizes = [], totalSize = 0;

    for (let i = 0; i < pageSegments;) ***REMOVED***
      let size = 0, x = 255;
      while (x === 255) ***REMOVED***
        x = table.readUInt8(i);
        i++;
        size += x;
      ***REMOVED***
      sizes.push(size);
      totalSize += size;
    ***REMOVED***

    if (chunk.length < 27 + pageSegments + totalSize) ***REMOVED***
      return false;
    ***REMOVED***

    let start = 27 + pageSegments;
    for (const size of sizes) ***REMOVED***
      const segment = chunk.slice(start, start + size);
      const header = segment.slice(0, 8);
      if (this._head) ***REMOVED***
        if (header.equals(OPUS_TAGS)) this.emit('opusTags', segment);
        else this.push(segment);
      ***REMOVED*** else if (header.equals(OPUS_HEAD)) ***REMOVED***
        this._head = segment;
      ***REMOVED*** else ***REMOVED***
        throw Error(`Invalid segment $***REMOVED***segment***REMOVED***`);
      ***REMOVED***
      start += size;
    ***REMOVED***
    return chunk.slice(start);
  ***REMOVED***
***REMOVED***

module.exports = OggOpusTransform;
