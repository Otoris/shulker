// Generated by CoffeeScript 2.4.1
var Tail, environment, events, fs,
  boundMethodCheck = function(instance, Constructor) ***REMOVED*** if (!(instance instanceof Constructor)) ***REMOVED*** throw new Error('Bound instance method accessed before binding'); ***REMOVED*** ***REMOVED***;

events = require("events");

fs = require('fs');

environment = process.env['NODE_ENV'] || 'development';

Tail = class Tail extends events.EventEmitter ***REMOVED***
  readBlock() ***REMOVED***
    var block, stream;
    boundMethodCheck(this, Tail);
    if (this.queue.length >= 1) ***REMOVED***
      block = this.queue[0];
      if (block.end > block.start) ***REMOVED***
        stream = fs.createReadStream(this.filename, ***REMOVED***
          start: block.start,
          end: block.end - 1,
          encoding: this.encoding
        ***REMOVED***);
        stream.on('error', (error) => ***REMOVED***
          if (this.logger) ***REMOVED***
            this.logger.error(`Tail error: $***REMOVED***error***REMOVED***`);
          ***REMOVED***
          return this.emit('error', error);
        ***REMOVED***);
        stream.on('end', () => ***REMOVED***
          var x;
          x = this.queue.shift();
          if (this.queue.length > 0) ***REMOVED***
            this.internalDispatcher.emit("next");
          ***REMOVED***
          if (this.flushAtEOF && this.buffer.length > 0) ***REMOVED***
            this.emit("line", this.buffer);
            return this.buffer = '';
          ***REMOVED***
        ***REMOVED***);
        return stream.on('data', (data) => ***REMOVED***
          var chunk, i, len, parts, results;
          if (this.separator === null) ***REMOVED***
            return this.emit("line", data);
          ***REMOVED*** else ***REMOVED***
            this.buffer += data;
            parts = this.buffer.split(this.separator);
            this.buffer = parts.pop();
            results = [];
            for (i = 0, len = parts.length; i < len; i++) ***REMOVED***
              chunk = parts[i];
              results.push(this.emit("line", chunk));
            ***REMOVED***
            return results;
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  constructor(filename, options = ***REMOVED******REMOVED***) ***REMOVED***
    var err, fromBeginning;
    super(filename, options);
    this.readBlock = this.readBlock.bind(this);
    this.change = this.change.bind(this);
    this.filename = filename;
    (***REMOVED***separator: this.separator = /[\r]***REMOVED***0,1***REMOVED***\n/, fsWatchOptions: this.fsWatchOptions = ***REMOVED******REMOVED***, follow: this.follow = true, logger: this.logger, useWatchFile: this.useWatchFile = false, flushAtEOF: this.flushAtEOF = false, encoding: this.encoding = "utf-8", fromBeginning = false***REMOVED*** = options);
    if (this.logger) ***REMOVED***
      this.logger.info("Tail starting...");
      this.logger.info(`filename: $***REMOVED***this.filename***REMOVED***`);
      this.logger.info(`encoding: $***REMOVED***this.encoding***REMOVED***`);
      try ***REMOVED***
        fs.accessSync(this.filename, fs.constants.F_OK);
      ***REMOVED*** catch (error1) ***REMOVED***
        err = error1;
        if (err.code === 'ENOENT') ***REMOVED***
          throw err;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    this.buffer = '';
    this.internalDispatcher = new events.EventEmitter();
    this.queue = [];
    this.isWatching = false;
    this.internalDispatcher.on('next', () => ***REMOVED***
      return this.readBlock();
    ***REMOVED***);
    this.watch(fromBeginning);
  ***REMOVED***

  change(filename) ***REMOVED***
    var err, stats;
    boundMethodCheck(this, Tail);
    try ***REMOVED***
      stats = fs.statSync(filename);
    ***REMOVED*** catch (error1) ***REMOVED***
      err = error1;
      if (this.logger) ***REMOVED***
        this.logger.error(`change event for $***REMOVED***filename***REMOVED*** failed: $***REMOVED***err***REMOVED***`);
      ***REMOVED***
      this.emit("error", `change event for $***REMOVED***filename***REMOVED*** failed: $***REMOVED***err***REMOVED***`);
      return;
    ***REMOVED***
    if (stats.size < this.pos) ***REMOVED*** //scenario where texts is not appended but it's actually a w+
      this.pos = stats.size;
    ***REMOVED***
    if (stats.size > this.pos) ***REMOVED***
      this.queue.push(***REMOVED***
        start: this.pos,
        end: stats.size
      ***REMOVED***);
      this.pos = stats.size;
      if (this.queue.length === 1) ***REMOVED***
        return this.internalDispatcher.emit("next");
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  watch(fromBeginning) ***REMOVED***
    var err, stats;
    if (this.isWatching) ***REMOVED***
      return;
    ***REMOVED***
    if (this.logger) ***REMOVED***
      this.logger.info(`filesystem.watch present? $***REMOVED***fs.watch !== void 0***REMOVED***`);
      this.logger.info(`useWatchFile: $***REMOVED***this.useWatchFile***REMOVED***`);
      this.logger.info(`fromBeginning: $***REMOVED***fromBeginning***REMOVED***`);
    ***REMOVED***
    this.isWatching = true;
    try ***REMOVED***
      stats = fs.statSync(this.filename);
    ***REMOVED*** catch (error1) ***REMOVED***
      err = error1;
      if (this.logger) ***REMOVED***
        this.logger.error(`watch for $***REMOVED***this.filename***REMOVED*** failed: $***REMOVED***err***REMOVED***`);
      ***REMOVED***
      this.emit("error", `watch for $***REMOVED***this.filename***REMOVED*** failed: $***REMOVED***err***REMOVED***`);
      return;
    ***REMOVED***
    this.pos = fromBeginning ? 0 : stats.size;
    if (this.pos === 0) ***REMOVED***
      this.change(this.filename);
    ***REMOVED***
    if (!this.useWatchFile && fs.watch) ***REMOVED***
      if (this.logger) ***REMOVED***
        this.logger.info("watch strategy: watch");
      ***REMOVED***
      return this.watcher = fs.watch(this.filename, this.fsWatchOptions, (e, filename) => ***REMOVED***
        return this.watchEvent(e, filename);
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      if (this.logger) ***REMOVED***
        this.logger.info("watch strategy: watchFile");
      ***REMOVED***
      return fs.watchFile(this.filename, this.fsWatchOptions, (curr, prev) => ***REMOVED***
        return this.watchFileEvent(curr, prev);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  rename(filename) ***REMOVED***
    //MacOS sometimes throws a rename event for no reason.
    //Different platforms might behave differently.
    //see https://nodejs.org/api/fs.html#fs_fs_watch_filename_options_listener
    //filename might not be present.
    //https://nodejs.org/api/fs.html#fs_filename_argument
    //Better solution would be check inode but it will require a timeout and
    // a sync file read.
    if (filename === void 0 || filename !== this.filename) ***REMOVED***
      this.unwatch();
      if (this.follow) ***REMOVED***
        return setTimeout((() => ***REMOVED***
          return this.watch();
        ***REMOVED***), 1000);
      ***REMOVED*** else ***REMOVED***
        if (this.logger) ***REMOVED***
          this.logger.error(`'rename' event for $***REMOVED***this.filename***REMOVED***. File not available.`);
        ***REMOVED***
        return this.emit("error", `'rename' event for $***REMOVED***this.filename***REMOVED***. File not available.`);
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***

    ***REMOVED***
  ***REMOVED***

  // @logger.info("rename event but same filename")
  watchEvent(e, evtFilename) ***REMOVED***
    if (e === 'change') ***REMOVED***
      return this.change(this.filename);
    ***REMOVED*** else if (e === 'rename') ***REMOVED***
      return this.rename(evtFilename);
    ***REMOVED***
  ***REMOVED***

  watchFileEvent(curr, prev) ***REMOVED***
    if (curr.size > prev.size) ***REMOVED***
      this.pos = curr.size; // Update @pos so that a consumer can determine if entire file has been handled
      this.queue.push(***REMOVED***
        start: prev.size,
        end: curr.size
      ***REMOVED***);
      if (this.queue.length === 1) ***REMOVED***
        return this.internalDispatcher.emit("next");
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  unwatch() ***REMOVED***
    if (this.watcher) ***REMOVED***
      this.watcher.close();
    ***REMOVED*** else ***REMOVED***
      fs.unwatchFile(this.filename);
    ***REMOVED***
    this.isWatching = false;
    this.queue = [];
    if (this.logger) ***REMOVED***
      return this.logger.info("Unwatch ", this.filename);
    ***REMOVED***
  ***REMOVED***

***REMOVED***;

exports.Tail = Tail;
