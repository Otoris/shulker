"use strict";

function _toConsumableArray(arr) ***REMOVED*** return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); ***REMOVED***

function _nonIterableSpread() ***REMOVED*** throw new TypeError("Invalid attempt to spread non-iterable instance"); ***REMOVED***

function _iterableToArray(iter) ***REMOVED*** if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); ***REMOVED***

function _arrayWithoutHoles(arr) ***REMOVED*** if (Array.isArray(arr)) ***REMOVED*** for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) ***REMOVED*** arr2[i] = arr[i]; ***REMOVED*** return arr2; ***REMOVED*** ***REMOVED***

function _typeof(obj) ***REMOVED*** if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") ***REMOVED*** _typeof = function _typeof(obj) ***REMOVED*** return typeof obj; ***REMOVED***; ***REMOVED*** else ***REMOVED*** _typeof = function _typeof(obj) ***REMOVED*** return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; ***REMOVED***; ***REMOVED*** return _typeof(obj); ***REMOVED***

(function (f) ***REMOVED***
  if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") ***REMOVED***
    module.exports = f();
  ***REMOVED*** else if (typeof define === "function" && define.amd) ***REMOVED***
    define([], f);
  ***REMOVED*** else ***REMOVED***
    var g;

    if (typeof window !== "undefined") ***REMOVED***
      g = window;
    ***REMOVED*** else if (typeof global !== "undefined") ***REMOVED***
      g = global;
    ***REMOVED*** else if (typeof self !== "undefined") ***REMOVED***
      g = self;
    ***REMOVED*** else ***REMOVED***
      g = this;
    ***REMOVED***

    g.debug = f();
  ***REMOVED***
***REMOVED***)(function () ***REMOVED***
  var define, module, exports;
  return function () ***REMOVED***
    function r(e, n, t) ***REMOVED***
      function o(i, f) ***REMOVED***
        if (!n[i]) ***REMOVED***
          if (!e[i]) ***REMOVED***
            var c = "function" == typeof require && require;
            if (!f && c) return c(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw a.code = "MODULE_NOT_FOUND", a;
          ***REMOVED***

          var p = n[i] = ***REMOVED***
            exports: ***REMOVED******REMOVED***
          ***REMOVED***;
          e[i][0].call(p.exports, function (r) ***REMOVED***
            var n = e[i][1][r];
            return o(n || r);
          ***REMOVED***, p, p.exports, r, e, n, t);
        ***REMOVED***

        return n[i].exports;
      ***REMOVED***

      for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) ***REMOVED***
        o(t[i]);
      ***REMOVED***

      return o;
    ***REMOVED***

    return r;
  ***REMOVED***()(***REMOVED***
    1: [function (require, module, exports) ***REMOVED***
      /**
       * Helpers.
       */
      var s = 1000;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      /**
       * Parse or format the given `val`.
       *
       * Options:
       *
       *  - `long` verbose formatting [false]
       *
       * @param ***REMOVED***String|Number***REMOVED*** val
       * @param ***REMOVED***Object***REMOVED*** [options]
       * @throws ***REMOVED***Error***REMOVED*** throw an error if val is not a non-empty string or a number
       * @return ***REMOVED***String|Number***REMOVED***
       * @api public
       */

      module.exports = function (val, options) ***REMOVED***
        options = options || ***REMOVED******REMOVED***;

        var type = _typeof(val);

        if (type === 'string' && val.length > 0) ***REMOVED***
          return parse(val);
        ***REMOVED*** else if (type === 'number' && isNaN(val) === false) ***REMOVED***
          return options.long ? fmtLong(val) : fmtShort(val);
        ***REMOVED***

        throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
      ***REMOVED***;
      /**
       * Parse the given `str` and return milliseconds.
       *
       * @param ***REMOVED***String***REMOVED*** str
       * @return ***REMOVED***Number***REMOVED***
       * @api private
       */


      function parse(str) ***REMOVED***
        str = String(str);

        if (str.length > 100) ***REMOVED***
          return;
        ***REMOVED***

        var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

        if (!match) ***REMOVED***
          return;
        ***REMOVED***

        var n = parseFloat(match[1]);
        var type = (match[2] || 'ms').toLowerCase();

        switch (type) ***REMOVED***
          case 'years':
          case 'year':
          case 'yrs':
          case 'yr':
          case 'y':
            return n * y;

          case 'weeks':
          case 'week':
          case 'w':
            return n * w;

          case 'days':
          case 'day':
          case 'd':
            return n * d;

          case 'hours':
          case 'hour':
          case 'hrs':
          case 'hr':
          case 'h':
            return n * h;

          case 'minutes':
          case 'minute':
          case 'mins':
          case 'min':
          case 'm':
            return n * m;

          case 'seconds':
          case 'second':
          case 'secs':
          case 'sec':
          case 's':
            return n * s;

          case 'milliseconds':
          case 'millisecond':
          case 'msecs':
          case 'msec':
          case 'ms':
            return n;

          default:
            return undefined;
        ***REMOVED***
      ***REMOVED***
      /**
       * Short format for `ms`.
       *
       * @param ***REMOVED***Number***REMOVED*** ms
       * @return ***REMOVED***String***REMOVED***
       * @api private
       */


      function fmtShort(ms) ***REMOVED***
        var msAbs = Math.abs(ms);

        if (msAbs >= d) ***REMOVED***
          return Math.round(ms / d) + 'd';
        ***REMOVED***

        if (msAbs >= h) ***REMOVED***
          return Math.round(ms / h) + 'h';
        ***REMOVED***

        if (msAbs >= m) ***REMOVED***
          return Math.round(ms / m) + 'm';
        ***REMOVED***

        if (msAbs >= s) ***REMOVED***
          return Math.round(ms / s) + 's';
        ***REMOVED***

        return ms + 'ms';
      ***REMOVED***
      /**
       * Long format for `ms`.
       *
       * @param ***REMOVED***Number***REMOVED*** ms
       * @return ***REMOVED***String***REMOVED***
       * @api private
       */


      function fmtLong(ms) ***REMOVED***
        var msAbs = Math.abs(ms);

        if (msAbs >= d) ***REMOVED***
          return plural(ms, msAbs, d, 'day');
        ***REMOVED***

        if (msAbs >= h) ***REMOVED***
          return plural(ms, msAbs, h, 'hour');
        ***REMOVED***

        if (msAbs >= m) ***REMOVED***
          return plural(ms, msAbs, m, 'minute');
        ***REMOVED***

        if (msAbs >= s) ***REMOVED***
          return plural(ms, msAbs, s, 'second');
        ***REMOVED***

        return ms + ' ms';
      ***REMOVED***
      /**
       * Pluralization helper.
       */


      function plural(ms, msAbs, n, name) ***REMOVED***
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
      ***REMOVED***
    ***REMOVED***, ***REMOVED******REMOVED***],
    2: [function (require, module, exports) ***REMOVED***
      // shim for using process in browser
      var process = module.exports = ***REMOVED******REMOVED***; // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;

      function defaultSetTimout() ***REMOVED***
        throw new Error('setTimeout has not been defined');
      ***REMOVED***

      function defaultClearTimeout() ***REMOVED***
        throw new Error('clearTimeout has not been defined');
      ***REMOVED***

      (function () ***REMOVED***
        try ***REMOVED***
          if (typeof setTimeout === 'function') ***REMOVED***
            cachedSetTimeout = setTimeout;
          ***REMOVED*** else ***REMOVED***
            cachedSetTimeout = defaultSetTimout;
          ***REMOVED***
        ***REMOVED*** catch (e) ***REMOVED***
          cachedSetTimeout = defaultSetTimout;
        ***REMOVED***

        try ***REMOVED***
          if (typeof clearTimeout === 'function') ***REMOVED***
            cachedClearTimeout = clearTimeout;
          ***REMOVED*** else ***REMOVED***
            cachedClearTimeout = defaultClearTimeout;
          ***REMOVED***
        ***REMOVED*** catch (e) ***REMOVED***
          cachedClearTimeout = defaultClearTimeout;
        ***REMOVED***
      ***REMOVED***)();

      function runTimeout(fun) ***REMOVED***
        if (cachedSetTimeout === setTimeout) ***REMOVED***
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        ***REMOVED*** // if setTimeout wasn't available but was latter defined


        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) ***REMOVED***
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        ***REMOVED***

        try ***REMOVED***
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        ***REMOVED*** catch (e) ***REMOVED***
          try ***REMOVED***
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          ***REMOVED*** catch (e) ***REMOVED***
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      function runClearTimeout(marker) ***REMOVED***
        if (cachedClearTimeout === clearTimeout) ***REMOVED***
          //normal enviroments in sane situations
          return clearTimeout(marker);
        ***REMOVED*** // if clearTimeout wasn't available but was latter defined


        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) ***REMOVED***
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        ***REMOVED***

        try ***REMOVED***
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        ***REMOVED*** catch (e) ***REMOVED***
          try ***REMOVED***
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          ***REMOVED*** catch (e) ***REMOVED***
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;

      function cleanUpNextTick() ***REMOVED***
        if (!draining || !currentQueue) ***REMOVED***
          return;
        ***REMOVED***

        draining = false;

        if (currentQueue.length) ***REMOVED***
          queue = currentQueue.concat(queue);
        ***REMOVED*** else ***REMOVED***
          queueIndex = -1;
        ***REMOVED***

        if (queue.length) ***REMOVED***
          drainQueue();
        ***REMOVED***
      ***REMOVED***

      function drainQueue() ***REMOVED***
        if (draining) ***REMOVED***
          return;
        ***REMOVED***

        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;

        while (len) ***REMOVED***
          currentQueue = queue;
          queue = [];

          while (++queueIndex < len) ***REMOVED***
            if (currentQueue) ***REMOVED***
              currentQueue[queueIndex].run();
            ***REMOVED***
          ***REMOVED***

          queueIndex = -1;
          len = queue.length;
        ***REMOVED***

        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      ***REMOVED***

      process.nextTick = function (fun) ***REMOVED***
        var args = new Array(arguments.length - 1);

        if (arguments.length > 1) ***REMOVED***
          for (var i = 1; i < arguments.length; i++) ***REMOVED***
            args[i - 1] = arguments[i];
          ***REMOVED***
        ***REMOVED***

        queue.push(new Item(fun, args));

        if (queue.length === 1 && !draining) ***REMOVED***
          runTimeout(drainQueue);
        ***REMOVED***
      ***REMOVED***; // v8 likes predictible objects


      function Item(fun, array) ***REMOVED***
        this.fun = fun;
        this.array = array;
      ***REMOVED***

      Item.prototype.run = function () ***REMOVED***
        this.fun.apply(null, this.array);
      ***REMOVED***;

      process.title = 'browser';
      process.browser = true;
      process.env = ***REMOVED******REMOVED***;
      process.argv = [];
      process.version = ''; // empty string to avoid regexp issues

      process.versions = ***REMOVED******REMOVED***;

      function noop() ***REMOVED******REMOVED***

      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;

      process.listeners = function (name) ***REMOVED***
        return [];
      ***REMOVED***;

      process.binding = function (name) ***REMOVED***
        throw new Error('process.binding is not supported');
      ***REMOVED***;

      process.cwd = function () ***REMOVED***
        return '/';
      ***REMOVED***;

      process.chdir = function (dir) ***REMOVED***
        throw new Error('process.chdir is not supported');
      ***REMOVED***;

      process.umask = function () ***REMOVED***
        return 0;
      ***REMOVED***;
    ***REMOVED***, ***REMOVED******REMOVED***],
    3: [function (require, module, exports) ***REMOVED***
      /**
       * This is the common logic for both the Node.js and web browser
       * implementations of `debug()`.
       */
      function setup(env) ***REMOVED***
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require('ms');
        Object.keys(env).forEach(function (key) ***REMOVED***
          createDebug[key] = env[key];
        ***REMOVED***);
        /**
        * Active `debug` instances.
        */

        createDebug.instances = [];
        /**
        * The currently active debug mode names, and names to skip.
        */

        createDebug.names = [];
        createDebug.skips = [];
        /**
        * Map of special "%n" handling functions, for the debug "format" argument.
        *
        * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
        */

        createDebug.formatters = ***REMOVED******REMOVED***;
        /**
        * Selects a color for a debug namespace
        * @param ***REMOVED***String***REMOVED*** namespace The namespace string for the for the debug instance to be colored
        * @return ***REMOVED***Number|String***REMOVED*** An ANSI color code for the given namespace
        * @api private
        */

        function selectColor(namespace) ***REMOVED***
          var hash = 0;

          for (var i = 0; i < namespace.length; i++) ***REMOVED***
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
          ***REMOVED***

          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        ***REMOVED***

        createDebug.selectColor = selectColor;
        /**
        * Create a debugger with the given `namespace`.
        *
        * @param ***REMOVED***String***REMOVED*** namespace
        * @return ***REMOVED***Function***REMOVED***
        * @api public
        */

        function createDebug(namespace) ***REMOVED***
          var prevTime;

          function debug() ***REMOVED***
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) ***REMOVED***
              args[_key] = arguments[_key];
            ***REMOVED***

            // Disabled?
            if (!debug.enabled) ***REMOVED***
              return;
            ***REMOVED***

            var self = debug; // Set `diff` timestamp

            var curr = Number(new Date());
            var ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);

            if (typeof args[0] !== 'string') ***REMOVED***
              // Anything else let's inspect with %O
              args.unshift('%O');
            ***REMOVED*** // Apply any `formatters` transformations


            var index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) ***REMOVED***
              // If we encounter an escaped % then don't increase the array index
              if (match === '%%') ***REMOVED***
                return match;
              ***REMOVED***

              index++;
              var formatter = createDebug.formatters[format];

              if (typeof formatter === 'function') ***REMOVED***
                var val = args[index];
                match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

                args.splice(index, 1);
                index--;
              ***REMOVED***

              return match;
            ***REMOVED***); // Apply env-specific formatting (colors, etc.)

            createDebug.formatArgs.call(self, args);
            var logFn = self.log || createDebug.log;
            logFn.apply(self, args);
          ***REMOVED***

          debug.namespace = namespace;
          debug.enabled = createDebug.enabled(namespace);
          debug.useColors = createDebug.useColors();
          debug.color = selectColor(namespace);
          debug.destroy = destroy;
          debug.extend = extend; // Debug.formatArgs = formatArgs;
          // debug.rawLog = rawLog;
          // env-specific initialization logic for debug instances

          if (typeof createDebug.init === 'function') ***REMOVED***
            createDebug.init(debug);
          ***REMOVED***

          createDebug.instances.push(debug);
          return debug;
        ***REMOVED***

        function destroy() ***REMOVED***
          var index = createDebug.instances.indexOf(this);

          if (index !== -1) ***REMOVED***
            createDebug.instances.splice(index, 1);
            return true;
          ***REMOVED***

          return false;
        ***REMOVED***

        function extend(namespace, delimiter) ***REMOVED***
          var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        ***REMOVED***
        /**
        * Enables a debug mode by namespaces. This can include modes
        * separated by a colon and wildcards.
        *
        * @param ***REMOVED***String***REMOVED*** namespaces
        * @api public
        */


        function enable(namespaces) ***REMOVED***
          createDebug.save(namespaces);
          createDebug.names = [];
          createDebug.skips = [];
          var i;
          var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
          var len = split.length;

          for (i = 0; i < len; i++) ***REMOVED***
            if (!split[i]) ***REMOVED***
              // ignore empty strings
              continue;
            ***REMOVED***

            namespaces = split[i].replace(/\*/g, '.*?');

            if (namespaces[0] === '-') ***REMOVED***
              createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
            ***REMOVED*** else ***REMOVED***
              createDebug.names.push(new RegExp('^' + namespaces + '$'));
            ***REMOVED***
          ***REMOVED***

          for (i = 0; i < createDebug.instances.length; i++) ***REMOVED***
            var instance = createDebug.instances[i];
            instance.enabled = createDebug.enabled(instance.namespace);
          ***REMOVED***
        ***REMOVED***
        /**
        * Disable debug output.
        *
        * @return ***REMOVED***String***REMOVED*** namespaces
        * @api public
        */


        function disable() ***REMOVED***
          var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) ***REMOVED***
            return '-' + namespace;
          ***REMOVED***))).join(',');
          createDebug.enable('');
          return namespaces;
        ***REMOVED***
        /**
        * Returns true if the given mode name is enabled, false otherwise.
        *
        * @param ***REMOVED***String***REMOVED*** name
        * @return ***REMOVED***Boolean***REMOVED***
        * @api public
        */


        function enabled(name) ***REMOVED***
          if (name[name.length - 1] === '*') ***REMOVED***
            return true;
          ***REMOVED***

          var i;
          var len;

          for (i = 0, len = createDebug.skips.length; i < len; i++) ***REMOVED***
            if (createDebug.skips[i].test(name)) ***REMOVED***
              return false;
            ***REMOVED***
          ***REMOVED***

          for (i = 0, len = createDebug.names.length; i < len; i++) ***REMOVED***
            if (createDebug.names[i].test(name)) ***REMOVED***
              return true;
            ***REMOVED***
          ***REMOVED***

          return false;
        ***REMOVED***
        /**
        * Convert regexp to namespace
        *
        * @param ***REMOVED***RegExp***REMOVED*** regxep
        * @return ***REMOVED***String***REMOVED*** namespace
        * @api private
        */


        function toNamespace(regexp) ***REMOVED***
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
        ***REMOVED***
        /**
        * Coerce `val`.
        *
        * @param ***REMOVED***Mixed***REMOVED*** val
        * @return ***REMOVED***Mixed***REMOVED***
        * @api private
        */


        function coerce(val) ***REMOVED***
          if (val instanceof Error) ***REMOVED***
            return val.stack || val.message;
          ***REMOVED***

          return val;
        ***REMOVED***

        createDebug.enable(createDebug.load());
        return createDebug;
      ***REMOVED***

      module.exports = setup;
    ***REMOVED***, ***REMOVED***
      "ms": 1
    ***REMOVED***],
    4: [function (require, module, exports) ***REMOVED***
      (function (process) ***REMOVED***
        /* eslint-env browser */

        /**
         * This is the web browser implementation of `debug()`.
         */
        exports.log = log;
        exports.formatArgs = formatArgs;
        exports.save = save;
        exports.load = load;
        exports.useColors = useColors;
        exports.storage = localstorage();
        /**
         * Colors.
         */

        exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
        /**
         * Currently only WebKit-based Web Inspectors, Firefox >= v31,
         * and the Firebug extension (any Firefox version) are known
         * to support "%c" CSS customizations.
         *
         * TODO: add a `localStorage` variable to explicitly enable/disable colors
         */
        // eslint-disable-next-line complexity

        function useColors() ***REMOVED***
          // NB: In an Electron preload script, document will be defined but not fully
          // initialized. Since we know we're in Chrome, we'll just detect this case
          // explicitly
          if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) ***REMOVED***
            return true;
          ***REMOVED*** // Internet Explorer and Edge do not support colors.


          if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) ***REMOVED***
            return false;
          ***REMOVED*** // Is webkit? http://stackoverflow.com/a/16459606/376773
          // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


          return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
          typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
          // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
          typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
          typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
        ***REMOVED***
        /**
         * Colorize log arguments if enabled.
         *
         * @api public
         */


        function formatArgs(args) ***REMOVED***
          args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

          if (!this.useColors) ***REMOVED***
            return;
          ***REMOVED***

          var c = 'color: ' + this.color;
          args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
          // arguments passed either before or after the %c, so we need to
          // figure out the correct index to insert the CSS into

          var index = 0;
          var lastC = 0;
          args[0].replace(/%[a-zA-Z%]/g, function (match) ***REMOVED***
            if (match === '%%') ***REMOVED***
              return;
            ***REMOVED***

            index++;

            if (match === '%c') ***REMOVED***
              // We only are interested in the *last* %c
              // (the user may have provided their own)
              lastC = index;
            ***REMOVED***
          ***REMOVED***);
          args.splice(lastC, 0, c);
        ***REMOVED***
        /**
         * Invokes `console.log()` when available.
         * No-op when `console.log` is not a "function".
         *
         * @api public
         */


        function log() ***REMOVED***
          var _console;

          // This hackery is required for IE8/9, where
          // the `console.log` function doesn't have 'apply'
          return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
        ***REMOVED***
        /**
         * Save `namespaces`.
         *
         * @param ***REMOVED***String***REMOVED*** namespaces
         * @api private
         */


        function save(namespaces) ***REMOVED***
          try ***REMOVED***
            if (namespaces) ***REMOVED***
              exports.storage.setItem('debug', namespaces);
            ***REMOVED*** else ***REMOVED***
              exports.storage.removeItem('debug');
            ***REMOVED***
          ***REMOVED*** catch (error) ***REMOVED***// Swallow
            // XXX (@Qix-) should we be logging these?
          ***REMOVED***
        ***REMOVED***
        /**
         * Load `namespaces`.
         *
         * @return ***REMOVED***String***REMOVED*** returns the previously persisted debug modes
         * @api private
         */


        function load() ***REMOVED***
          var r;

          try ***REMOVED***
            r = exports.storage.getItem('debug');
          ***REMOVED*** catch (error) ***REMOVED******REMOVED*** // Swallow
          // XXX (@Qix-) should we be logging these?
          // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


          if (!r && typeof process !== 'undefined' && 'env' in process) ***REMOVED***
            r = process.env.DEBUG;
          ***REMOVED***

          return r;
        ***REMOVED***
        /**
         * Localstorage attempts to return the localstorage.
         *
         * This is necessary because safari throws
         * when a user disables cookies/localstorage
         * and you attempt to access it.
         *
         * @return ***REMOVED***LocalStorage***REMOVED***
         * @api private
         */


        function localstorage() ***REMOVED***
          try ***REMOVED***
            // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
            // The Browser also has localStorage in the global context.
            return localStorage;
          ***REMOVED*** catch (error) ***REMOVED***// Swallow
            // XXX (@Qix-) should we be logging these?
          ***REMOVED***
        ***REMOVED***

        module.exports = require('./common')(exports);
        var formatters = module.exports.formatters;
        /**
         * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
         */

        formatters.j = function (v) ***REMOVED***
          try ***REMOVED***
            return JSON.stringify(v);
          ***REMOVED*** catch (error) ***REMOVED***
            return '[UnexpectedJSONParseError]: ' + error.message;
          ***REMOVED***
        ***REMOVED***;
      ***REMOVED***).call(this, require('_process'));
    ***REMOVED***, ***REMOVED***
      "./common": 3,
      "_process": 2
    ***REMOVED***]
  ***REMOVED***, ***REMOVED******REMOVED***, [4])(4);
***REMOVED***);
