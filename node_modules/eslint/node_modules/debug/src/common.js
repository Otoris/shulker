
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) ***REMOVED***
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = require('ms');

	Object.keys(env).forEach(key => ***REMOVED***
		createDebug[key] = env[key];
	***REMOVED***);

	/**
	* Active `debug` instances.
	*/
	createDebug.instances = [];

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = ***REMOVED******REMOVED***;

	/**
	* Selects a color for a debug namespace
	* @param ***REMOVED***String***REMOVED*** namespace The namespace string for the for the debug instance to be colored
	* @return ***REMOVED***Number|String***REMOVED*** An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) ***REMOVED***
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) ***REMOVED***
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		***REMOVED***

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	***REMOVED***
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param ***REMOVED***String***REMOVED*** namespace
	* @return ***REMOVED***Function***REMOVED***
	* @api public
	*/
	function createDebug(namespace) ***REMOVED***
		let prevTime;

		function debug(...args) ***REMOVED***
			// Disabled?
			if (!debug.enabled) ***REMOVED***
				return;
			***REMOVED***

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') ***REMOVED***
				// Anything else let's inspect with %O
				args.unshift('%O');
			***REMOVED***

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => ***REMOVED***
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') ***REMOVED***
					return match;
				***REMOVED***
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') ***REMOVED***
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				***REMOVED***
				return match;
			***REMOVED***);

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		***REMOVED***

		debug.namespace = namespace;
		debug.enabled = createDebug.enabled(namespace);
		debug.useColors = createDebug.useColors();
		debug.color = selectColor(namespace);
		debug.destroy = destroy;
		debug.extend = extend;
		// Debug.formatArgs = formatArgs;
		// debug.rawLog = rawLog;

		// env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') ***REMOVED***
			createDebug.init(debug);
		***REMOVED***

		createDebug.instances.push(debug);

		return debug;
	***REMOVED***

	function destroy() ***REMOVED***
		const index = createDebug.instances.indexOf(this);
		if (index !== -1) ***REMOVED***
			createDebug.instances.splice(index, 1);
			return true;
		***REMOVED***
		return false;
	***REMOVED***

	function extend(namespace, delimiter) ***REMOVED***
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	***REMOVED***

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param ***REMOVED***String***REMOVED*** namespaces
	* @api public
	*/
	function enable(namespaces) ***REMOVED***
		createDebug.save(namespaces);

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) ***REMOVED***
			if (!split[i]) ***REMOVED***
				// ignore empty strings
				continue;
			***REMOVED***

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') ***REMOVED***
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			***REMOVED*** else ***REMOVED***
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			***REMOVED***
		***REMOVED***

		for (i = 0; i < createDebug.instances.length; i++) ***REMOVED***
			const instance = createDebug.instances[i];
			instance.enabled = createDebug.enabled(instance.namespace);
		***REMOVED***
	***REMOVED***

	/**
	* Disable debug output.
	*
	* @return ***REMOVED***String***REMOVED*** namespaces
	* @api public
	*/
	function disable() ***REMOVED***
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	***REMOVED***

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param ***REMOVED***String***REMOVED*** name
	* @return ***REMOVED***Boolean***REMOVED***
	* @api public
	*/
	function enabled(name) ***REMOVED***
		if (name[name.length - 1] === '*') ***REMOVED***
			return true;
		***REMOVED***

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) ***REMOVED***
			if (createDebug.skips[i].test(name)) ***REMOVED***
				return false;
			***REMOVED***
		***REMOVED***

		for (i = 0, len = createDebug.names.length; i < len; i++) ***REMOVED***
			if (createDebug.names[i].test(name)) ***REMOVED***
				return true;
			***REMOVED***
		***REMOVED***

		return false;
	***REMOVED***

	/**
	* Convert regexp to namespace
	*
	* @param ***REMOVED***RegExp***REMOVED*** regxep
	* @return ***REMOVED***String***REMOVED*** namespace
	* @api private
	*/
	function toNamespace(regexp) ***REMOVED***
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	***REMOVED***

	/**
	* Coerce `val`.
	*
	* @param ***REMOVED***Mixed***REMOVED*** val
	* @return ***REMOVED***Mixed***REMOVED***
	* @api private
	*/
	function coerce(val) ***REMOVED***
		if (val instanceof Error) ***REMOVED***
			return val.stack || val.message;
		***REMOVED***
		return val;
	***REMOVED***

	createDebug.enable(createDebug.load());

	return createDebug;
***REMOVED***

module.exports = setup;
