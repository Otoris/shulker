/**
 * @fileoverview Used for creating a suggested configuration based on project code.
 * @author Ian VanSchooten
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const lodash = require("lodash"),
    recConfig = require("../../conf/eslint-recommended"),
    ConfigOps = require("../shared/config-ops"),
    ***REMOVED*** Linter ***REMOVED*** = require("../linter"),
    configRule = require("./config-rule");

const debug = require("debug")("eslint:autoconfig");
const linter = new Linter();

//------------------------------------------------------------------------------
// Data
//------------------------------------------------------------------------------

const MAX_CONFIG_COMBINATIONS = 17, // 16 combinations + 1 for severity only
    RECOMMENDED_CONFIG_NAME = "eslint:recommended";

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

/**
 * Information about a rule configuration, in the context of a Registry.
 *
 * @typedef ***REMOVED***Object***REMOVED***     registryItem
 * @param   ***REMOVED***ruleConfig***REMOVED*** config        A valid configuration for the rule
 * @param   ***REMOVED***number***REMOVED***     specificity   The number of elements in the ruleConfig array
 * @param   ***REMOVED***number***REMOVED***     errorCount    The number of errors encountered when linting with the config
 */

/**
 * This callback is used to measure execution status in a progress bar
 * @callback progressCallback
 * @param ***REMOVED***number***REMOVED*** The total number of times the callback will be called.
 */

/**
 * Create registryItems for rules
 * @param   ***REMOVED***rulesConfig***REMOVED*** rulesConfig Hash of rule names and arrays of ruleConfig items
 * @returns ***REMOVED***Object***REMOVED***                  registryItems for each rule in provided rulesConfig
 */
function makeRegistryItems(rulesConfig) ***REMOVED***
    return Object.keys(rulesConfig).reduce((accumulator, ruleId) => ***REMOVED***
        accumulator[ruleId] = rulesConfig[ruleId].map(config => (***REMOVED***
            config,
            specificity: config.length || 1,
            errorCount: void 0
        ***REMOVED***));
        return accumulator;
    ***REMOVED***, ***REMOVED******REMOVED***);
***REMOVED***

/**
 * Creates an object in which to store rule configs and error counts
 *
 * Unless a rulesConfig is provided at construction, the registry will not contain
 * any rules, only methods.  This will be useful for building up registries manually.
 *
 * Registry class
 */
class Registry ***REMOVED***

    /**
     * @param ***REMOVED***rulesConfig***REMOVED*** [rulesConfig] Hash of rule names and arrays of possible configurations
     */
    constructor(rulesConfig) ***REMOVED***
        this.rules = (rulesConfig) ? makeRegistryItems(rulesConfig) : ***REMOVED******REMOVED***;
    ***REMOVED***

    /**
     * Populate the registry with core rule configs.
     *
     * It will set the registry's `rule` property to an object having rule names
     * as keys and an array of registryItems as values.
     *
     * @returns ***REMOVED***void***REMOVED***
     */
    populateFromCoreRules() ***REMOVED***
        const rulesConfig = configRule.createCoreRuleConfigs();

        this.rules = makeRegistryItems(rulesConfig);
    ***REMOVED***

    /**
     * Creates sets of rule configurations which can be used for linting
     * and initializes registry errors to zero for those configurations (side effect).
     *
     * This combines as many rules together as possible, such that the first sets
     * in the array will have the highest number of rules configured, and later sets
     * will have fewer and fewer, as not all rules have the same number of possible
     * configurations.
     *
     * The length of the returned array will be <= MAX_CONFIG_COMBINATIONS.
     *
     * @returns ***REMOVED***Object[]***REMOVED***          "rules" configurations to use for linting
     */
    buildRuleSets() ***REMOVED***
        let idx = 0;
        const ruleIds = Object.keys(this.rules),
            ruleSets = [];

        /**
         * Add a rule configuration from the registry to the ruleSets
         *
         * This is broken out into its own function so that it doesn't need to be
         * created inside of the while loop.
         *
         * @param   ***REMOVED***string***REMOVED*** rule The ruleId to add.
         * @returns ***REMOVED***void***REMOVED***
         */
        const addRuleToRuleSet = function(rule) ***REMOVED***

            /*
             * This check ensures that there is a rule configuration and that
             * it has fewer than the max combinations allowed.
             * If it has too many configs, we will only use the most basic of
             * the possible configurations.
             */
            const hasFewCombos = (this.rules[rule].length <= MAX_CONFIG_COMBINATIONS);

            if (this.rules[rule][idx] && (hasFewCombos || this.rules[rule][idx].specificity <= 2)) ***REMOVED***

                /*
                 * If the rule has too many possible combinations, only take
                 * simple ones, avoiding objects.
                 */
                if (!hasFewCombos && typeof this.rules[rule][idx].config[1] === "object") ***REMOVED***
                    return;
                ***REMOVED***

                ruleSets[idx] = ruleSets[idx] || ***REMOVED******REMOVED***;
                ruleSets[idx][rule] = this.rules[rule][idx].config;

                /*
                 * Initialize errorCount to zero, since this is a config which
                 * will be linted.
                 */
                this.rules[rule][idx].errorCount = 0;
            ***REMOVED***
        ***REMOVED***.bind(this);

        while (ruleSets.length === idx) ***REMOVED***
            ruleIds.forEach(addRuleToRuleSet);
            idx += 1;
        ***REMOVED***

        return ruleSets;
    ***REMOVED***

    /**
     * Remove all items from the registry with a non-zero number of errors
     *
     * Note: this also removes rule configurations which were not linted
     * (meaning, they have an undefined errorCount).
     *
     * @returns ***REMOVED***void***REMOVED***
     */
    stripFailingConfigs() ***REMOVED***
        const ruleIds = Object.keys(this.rules),
            newRegistry = new Registry();

        newRegistry.rules = Object.assign(***REMOVED******REMOVED***, this.rules);
        ruleIds.forEach(ruleId => ***REMOVED***
            const errorFreeItems = newRegistry.rules[ruleId].filter(registryItem => (registryItem.errorCount === 0));

            if (errorFreeItems.length > 0) ***REMOVED***
                newRegistry.rules[ruleId] = errorFreeItems;
            ***REMOVED*** else ***REMOVED***
                delete newRegistry.rules[ruleId];
            ***REMOVED***
        ***REMOVED***);

        return newRegistry;
    ***REMOVED***

    /**
     * Removes rule configurations which were not included in a ruleSet
     *
     * @returns ***REMOVED***void***REMOVED***
     */
    stripExtraConfigs() ***REMOVED***
        const ruleIds = Object.keys(this.rules),
            newRegistry = new Registry();

        newRegistry.rules = Object.assign(***REMOVED******REMOVED***, this.rules);
        ruleIds.forEach(ruleId => ***REMOVED***
            newRegistry.rules[ruleId] = newRegistry.rules[ruleId].filter(registryItem => (typeof registryItem.errorCount !== "undefined"));
        ***REMOVED***);

        return newRegistry;
    ***REMOVED***

    /**
     * Creates a registry of rules which had no error-free configs.
     * The new registry is intended to be analyzed to determine whether its rules
     * should be disabled or set to warning.
     *
     * @returns ***REMOVED***Registry***REMOVED***  A registry of failing rules.
     */
    getFailingRulesRegistry() ***REMOVED***
        const ruleIds = Object.keys(this.rules),
            failingRegistry = new Registry();

        ruleIds.forEach(ruleId => ***REMOVED***
            const failingConfigs = this.rules[ruleId].filter(registryItem => (registryItem.errorCount > 0));

            if (failingConfigs && failingConfigs.length === this.rules[ruleId].length) ***REMOVED***
                failingRegistry.rules[ruleId] = failingConfigs;
            ***REMOVED***
        ***REMOVED***);

        return failingRegistry;
    ***REMOVED***

    /**
     * Create an eslint config for any rules which only have one configuration
     * in the registry.
     *
     * @returns ***REMOVED***Object***REMOVED*** An eslint config with rules section populated
     */
    createConfig() ***REMOVED***
        const ruleIds = Object.keys(this.rules),
            config = ***REMOVED*** rules: ***REMOVED******REMOVED*** ***REMOVED***;

        ruleIds.forEach(ruleId => ***REMOVED***
            if (this.rules[ruleId].length === 1) ***REMOVED***
                config.rules[ruleId] = this.rules[ruleId][0].config;
            ***REMOVED***
        ***REMOVED***);

        return config;
    ***REMOVED***

    /**
     * Return a cloned registry containing only configs with a desired specificity
     *
     * @param   ***REMOVED***number***REMOVED*** specificity Only keep configs with this specificity
     * @returns ***REMOVED***Registry***REMOVED***           A registry of rules
     */
    filterBySpecificity(specificity) ***REMOVED***
        const ruleIds = Object.keys(this.rules),
            newRegistry = new Registry();

        newRegistry.rules = Object.assign(***REMOVED******REMOVED***, this.rules);
        ruleIds.forEach(ruleId => ***REMOVED***
            newRegistry.rules[ruleId] = this.rules[ruleId].filter(registryItem => (registryItem.specificity === specificity));
        ***REMOVED***);

        return newRegistry;
    ***REMOVED***

    /**
     * Lint SourceCodes against all configurations in the registry, and record results
     *
     * @param   ***REMOVED***Object[]***REMOVED*** sourceCodes  SourceCode objects for each filename
     * @param   ***REMOVED***Object***REMOVED***   config       ESLint config object
     * @param   ***REMOVED***progressCallback***REMOVED*** [cb] Optional callback for reporting execution status
     * @returns ***REMOVED***Registry***REMOVED***              New registry with errorCount populated
     */
    lintSourceCode(sourceCodes, config, cb) ***REMOVED***
        let lintedRegistry = new Registry();

        lintedRegistry.rules = Object.assign(***REMOVED******REMOVED***, this.rules);

        const ruleSets = lintedRegistry.buildRuleSets();

        lintedRegistry = lintedRegistry.stripExtraConfigs();

        debug("Linting with all possible rule combinations");

        const filenames = Object.keys(sourceCodes);
        const totalFilesLinting = filenames.length * ruleSets.length;

        filenames.forEach(filename => ***REMOVED***
            debug(`Linting file: $***REMOVED***filename***REMOVED***`);

            let ruleSetIdx = 0;

            ruleSets.forEach(ruleSet => ***REMOVED***
                const lintConfig = Object.assign(***REMOVED******REMOVED***, config, ***REMOVED*** rules: ruleSet ***REMOVED***);
                const lintResults = linter.verify(sourceCodes[filename], lintConfig);

                lintResults.forEach(result => ***REMOVED***

                    /*
                     * It is possible that the error is from a configuration comment
                     * in a linted file, in which case there may not be a config
                     * set in this ruleSetIdx.
                     * (https://github.com/eslint/eslint/issues/5992)
                     * (https://github.com/eslint/eslint/issues/7860)
                     */
                    if (
                        lintedRegistry.rules[result.ruleId] &&
                        lintedRegistry.rules[result.ruleId][ruleSetIdx]
                    ) ***REMOVED***
                        lintedRegistry.rules[result.ruleId][ruleSetIdx].errorCount += 1;
                    ***REMOVED***
                ***REMOVED***);

                ruleSetIdx += 1;

                if (cb) ***REMOVED***
                    cb(totalFilesLinting); // eslint-disable-line callback-return
                ***REMOVED***
            ***REMOVED***);

            // Deallocate for GC
            sourceCodes[filename] = null;
        ***REMOVED***);

        return lintedRegistry;
    ***REMOVED***
***REMOVED***

/**
 * Extract rule configuration into eslint:recommended where possible.
 *
 * This will return a new config with `"extends": "eslint:recommended"` and
 * only the rules which have configurations different from the recommended config.
 *
 * @param   ***REMOVED***Object***REMOVED*** config config object
 * @returns ***REMOVED***Object***REMOVED***        config object using `"extends": "eslint:recommended"`
 */
function extendFromRecommended(config) ***REMOVED***
    const newConfig = Object.assign(***REMOVED******REMOVED***, config);

    ConfigOps.normalizeToStrings(newConfig);

    const recRules = Object.keys(recConfig.rules).filter(ruleId => ConfigOps.isErrorSeverity(recConfig.rules[ruleId]));

    recRules.forEach(ruleId => ***REMOVED***
        if (lodash.isEqual(recConfig.rules[ruleId], newConfig.rules[ruleId])) ***REMOVED***
            delete newConfig.rules[ruleId];
        ***REMOVED***
    ***REMOVED***);
    newConfig.extends = RECOMMENDED_CONFIG_NAME;
    return newConfig;
***REMOVED***


//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    Registry,
    extendFromRecommended
***REMOVED***;
