/**
 * @fileoverview Create configurations for a rule
 * @author Ian VanSchooten
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const builtInRules = require("../rules");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Wrap all of the elements of an array into arrays.
 * @param   ***REMOVED****[]***REMOVED***     xs Any array.
 * @returns ***REMOVED***Array[]***REMOVED***    An array of arrays.
 */
function explodeArray(xs) ***REMOVED***
    return xs.reduce((accumulator, x) => ***REMOVED***
        accumulator.push([x]);
        return accumulator;
    ***REMOVED***, []);
***REMOVED***

/**
 * Mix two arrays such that each element of the second array is concatenated
 * onto each element of the first array.
 *
 * For example:
 * combineArrays([a, [b, c]], [x, y]); // -> [[a, x], [a, y], [b, c, x], [b, c, y]]
 *
 * @param   ***REMOVED***Array***REMOVED*** arr1 The first array to combine.
 * @param   ***REMOVED***Array***REMOVED*** arr2 The second array to combine.
 * @returns ***REMOVED***Array***REMOVED***      A mixture of the elements of the first and second arrays.
 */
function combineArrays(arr1, arr2) ***REMOVED***
    const res = [];

    if (arr1.length === 0) ***REMOVED***
        return explodeArray(arr2);
    ***REMOVED***
    if (arr2.length === 0) ***REMOVED***
        return explodeArray(arr1);
    ***REMOVED***
    arr1.forEach(x1 => ***REMOVED***
        arr2.forEach(x2 => ***REMOVED***
            res.push([].concat(x1, x2));
        ***REMOVED***);
    ***REMOVED***);
    return res;
***REMOVED***

/**
 * Group together valid rule configurations based on object properties
 *
 * e.g.:
 * groupByProperty([
 *     ***REMOVED***before: true***REMOVED***,
 *     ***REMOVED***before: false***REMOVED***,
 *     ***REMOVED***after: true***REMOVED***,
 *     ***REMOVED***after: false***REMOVED***
 * ]);
 *
 * will return:
 * [
 *     [***REMOVED***before: true***REMOVED***, ***REMOVED***before: false***REMOVED***],
 *     [***REMOVED***after: true***REMOVED***, ***REMOVED***after: false***REMOVED***]
 * ]
 *
 * @param   ***REMOVED***Object[]***REMOVED*** objects Array of objects, each with one property/value pair
 * @returns ***REMOVED***Array[]***REMOVED***          Array of arrays of objects grouped by property
 */
function groupByProperty(objects) ***REMOVED***
    const groupedObj = objects.reduce((accumulator, obj) => ***REMOVED***
        const prop = Object.keys(obj)[0];

        accumulator[prop] = accumulator[prop] ? accumulator[prop].concat(obj) : [obj];
        return accumulator;
    ***REMOVED***, ***REMOVED******REMOVED***);

    return Object.keys(groupedObj).map(prop => groupedObj[prop]);
***REMOVED***


//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

/**
 * Configuration settings for a rule.
 *
 * A configuration can be a single number (severity), or an array where the first
 * element in the array is the severity, and is the only required element.
 * Configs may also have one or more additional elements to specify rule
 * configuration or options.
 *
 * @typedef ***REMOVED***array|number***REMOVED*** ruleConfig
 * @param ***REMOVED***number***REMOVED***  0  The rule's severity (0, 1, 2).
 */

/**
 * Object whose keys are rule names and values are arrays of valid ruleConfig items
 * which should be linted against the target source code to determine error counts.
 * (a ruleConfigSet.ruleConfigs).
 *
 * e.g. rulesConfig = ***REMOVED***
 *     "comma-dangle": [2, [2, "always"], [2, "always-multiline"], [2, "never"]],
 *     "no-console": [2]
 * ***REMOVED***
 * @typedef rulesConfig
 */


/**
 * Create valid rule configurations by combining two arrays,
 * with each array containing multiple objects each with a
 * single property/value pair and matching properties.
 *
 * e.g.:
 * combinePropertyObjects(
 *     [***REMOVED***before: true***REMOVED***, ***REMOVED***before: false***REMOVED***],
 *     [***REMOVED***after: true***REMOVED***, ***REMOVED***after: false***REMOVED***]
 * );
 *
 * will return:
 * [
 *     ***REMOVED***before: true, after: true***REMOVED***,
 *     ***REMOVED***before: true, after: false***REMOVED***,
 *     ***REMOVED***before: false, after: true***REMOVED***,
 *     ***REMOVED***before: false, after: false***REMOVED***
 * ]
 *
 * @param   ***REMOVED***Object[]***REMOVED*** objArr1 Single key/value objects, all with the same key
 * @param   ***REMOVED***Object[]***REMOVED*** objArr2 Single key/value objects, all with another key
 * @returns ***REMOVED***Object[]***REMOVED***         Combined objects for each combination of input properties and values
 */
function combinePropertyObjects(objArr1, objArr2) ***REMOVED***
    const res = [];

    if (objArr1.length === 0) ***REMOVED***
        return objArr2;
    ***REMOVED***
    if (objArr2.length === 0) ***REMOVED***
        return objArr1;
    ***REMOVED***
    objArr1.forEach(obj1 => ***REMOVED***
        objArr2.forEach(obj2 => ***REMOVED***
            const combinedObj = ***REMOVED******REMOVED***;
            const obj1Props = Object.keys(obj1);
            const obj2Props = Object.keys(obj2);

            obj1Props.forEach(prop1 => ***REMOVED***
                combinedObj[prop1] = obj1[prop1];
            ***REMOVED***);
            obj2Props.forEach(prop2 => ***REMOVED***
                combinedObj[prop2] = obj2[prop2];
            ***REMOVED***);
            res.push(combinedObj);
        ***REMOVED***);
    ***REMOVED***);
    return res;
***REMOVED***

/**
 * Creates a new instance of a rule configuration set
 *
 * A rule configuration set is an array of configurations that are valid for a
 * given rule.  For example, the configuration set for the "semi" rule could be:
 *
 * ruleConfigSet.ruleConfigs // -> [[2], [2, "always"], [2, "never"]]
 *
 * Rule configuration set class
 */
class RuleConfigSet ***REMOVED***

    /**
     * @param ***REMOVED***ruleConfig[]***REMOVED*** configs Valid rule configurations
     */
    constructor(configs) ***REMOVED***

        /**
         * Stored valid rule configurations for this instance
         * @type ***REMOVED***array***REMOVED***
         */
        this.ruleConfigs = configs || [];
    ***REMOVED***

    /**
     * Add a severity level to the front of all configs in the instance.
     * This should only be called after all configs have been added to the instance.
     *
     * @returns ***REMOVED***void***REMOVED***
     */
    addErrorSeverity() ***REMOVED***
        const severity = 2;

        this.ruleConfigs = this.ruleConfigs.map(config => ***REMOVED***
            config.unshift(severity);
            return config;
        ***REMOVED***);

        // Add a single config at the beginning consisting of only the severity
        this.ruleConfigs.unshift(severity);
    ***REMOVED***

    /**
     * Add rule configs from an array of strings (schema enums)
     * @param  ***REMOVED***string[]***REMOVED*** enums Array of valid rule options (e.g. ["always", "never"])
     * @returns ***REMOVED***void***REMOVED***
     */
    addEnums(enums) ***REMOVED***
        this.ruleConfigs = this.ruleConfigs.concat(combineArrays(this.ruleConfigs, enums));
    ***REMOVED***

    /**
     * Add rule configurations from a schema object
     * @param  ***REMOVED***Object***REMOVED*** obj Schema item with type === "object"
     * @returns ***REMOVED***boolean***REMOVED*** true if at least one schema for the object could be generated, false otherwise
     */
    addObject(obj) ***REMOVED***
        const objectConfigSet = ***REMOVED***
            objectConfigs: [],
            add(property, values) ***REMOVED***
                for (let idx = 0; idx < values.length; idx++) ***REMOVED***
                    const optionObj = ***REMOVED******REMOVED***;

                    optionObj[property] = values[idx];
                    this.objectConfigs.push(optionObj);
                ***REMOVED***
            ***REMOVED***,

            combine() ***REMOVED***
                this.objectConfigs = groupByProperty(this.objectConfigs).reduce((accumulator, objArr) => combinePropertyObjects(accumulator, objArr), []);
            ***REMOVED***
        ***REMOVED***;

        /*
         * The object schema could have multiple independent properties.
         * If any contain enums or booleans, they can be added and then combined
         */
        Object.keys(obj.properties).forEach(prop => ***REMOVED***
            if (obj.properties[prop].enum) ***REMOVED***
                objectConfigSet.add(prop, obj.properties[prop].enum);
            ***REMOVED***
            if (obj.properties[prop].type && obj.properties[prop].type === "boolean") ***REMOVED***
                objectConfigSet.add(prop, [true, false]);
            ***REMOVED***
        ***REMOVED***);
        objectConfigSet.combine();

        if (objectConfigSet.objectConfigs.length > 0) ***REMOVED***
            this.ruleConfigs = this.ruleConfigs.concat(combineArrays(this.ruleConfigs, objectConfigSet.objectConfigs));
            return true;
        ***REMOVED***

        return false;
    ***REMOVED***
***REMOVED***

/**
 * Generate valid rule configurations based on a schema object
 * @param   ***REMOVED***Object***REMOVED*** schema  A rule's schema object
 * @returns ***REMOVED***Array[]***REMOVED***        Valid rule configurations
 */
function generateConfigsFromSchema(schema) ***REMOVED***
    const configSet = new RuleConfigSet();

    if (Array.isArray(schema)) ***REMOVED***
        for (const opt of schema) ***REMOVED***
            if (opt.enum) ***REMOVED***
                configSet.addEnums(opt.enum);
            ***REMOVED*** else if (opt.type && opt.type === "object") ***REMOVED***
                if (!configSet.addObject(opt)) ***REMOVED***
                    break;
                ***REMOVED***

            // TODO (IanVS): support oneOf
            ***REMOVED*** else ***REMOVED***

                // If we don't know how to fill in this option, don't fill in any of the following options.
                break;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    configSet.addErrorSeverity();
    return configSet.ruleConfigs;
***REMOVED***

/**
 * Generate possible rule configurations for all of the core rules
 * @param ***REMOVED***boolean***REMOVED*** noDeprecated Indicates whether ignores deprecated rules or not.
 * @returns ***REMOVED***rulesConfig***REMOVED*** Hash of rule names and arrays of possible configurations
 */
function createCoreRuleConfigs(noDeprecated = false) ***REMOVED***
    return Array.from(builtInRules).reduce((accumulator, [id, rule]) => ***REMOVED***
        const schema = (typeof rule === "function") ? rule.schema : rule.meta.schema;
        const isDeprecated = (typeof rule === "function") ? rule.deprecated : rule.meta.deprecated;

        if (noDeprecated && isDeprecated) ***REMOVED***
            return accumulator;
        ***REMOVED***

        accumulator[id] = generateConfigsFromSchema(schema);
        return accumulator;
    ***REMOVED***, ***REMOVED******REMOVED***);
***REMOVED***


//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    generateConfigsFromSchema,
    createCoreRuleConfigs
***REMOVED***;
