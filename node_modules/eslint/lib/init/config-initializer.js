/**
 * @fileoverview Config initialization wizard.
 * @author Ilya Volodin
 */


"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const util = require("util"),
    path = require("path"),
    inquirer = require("inquirer"),
    ProgressBar = require("progress"),
    semver = require("semver"),
    recConfig = require("../../conf/eslint-recommended"),
    ConfigOps = require("../shared/config-ops"),
    log = require("../shared/logging"),
    naming = require("../shared/naming"),
    ModuleResolver = require("../shared/relative-module-resolver"),
    autoconfig = require("./autoconfig.js"),
    ConfigFile = require("./config-file"),
    npmUtils = require("./npm-utils"),
    ***REMOVED*** getSourceCodeOfFiles ***REMOVED*** = require("./source-code-utils");

const debug = require("debug")("eslint:config-initializer");

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

const DEFAULT_ECMA_VERSION = 2018;

/* istanbul ignore next: hard to test fs function */
/**
 * Create .eslintrc file in the current working directory
 * @param ***REMOVED***Object***REMOVED*** config object that contains user's answers
 * @param ***REMOVED***string***REMOVED*** format The file format to write to.
 * @returns ***REMOVED***void***REMOVED***
 */
function writeFile(config, format) ***REMOVED***

    // default is .js
    let extname = ".js";

    if (format === "YAML") ***REMOVED***
        extname = ".yml";
    ***REMOVED*** else if (format === "JSON") ***REMOVED***
        extname = ".json";
    ***REMOVED***

    const installedESLint = config.installedESLint;

    delete config.installedESLint;

    ConfigFile.write(config, `./.eslintrc$***REMOVED***extname***REMOVED***`);
    log.info(`Successfully created .eslintrc$***REMOVED***extname***REMOVED*** file in $***REMOVED***process.cwd()***REMOVED***`);

    if (installedESLint) ***REMOVED***
        log.info("ESLint was installed locally. We recommend using this local copy instead of your globally-installed copy.");
    ***REMOVED***
***REMOVED***

/**
 * Get the peer dependencies of the given module.
 * This adds the gotten value to cache at the first time, then reuses it.
 * In a process, this function is called twice, but `npmUtils.fetchPeerDependencies` needs to access network which is relatively slow.
 * @param ***REMOVED***string***REMOVED*** moduleName The module name to get.
 * @returns ***REMOVED***Object***REMOVED*** The peer dependencies of the given module.
 * This object is the object of `peerDependencies` field of `package.json`.
 * Returns null if npm was not found.
 */
function getPeerDependencies(moduleName) ***REMOVED***
    let result = getPeerDependencies.cache.get(moduleName);

    if (!result) ***REMOVED***
        log.info(`Checking peerDependencies of $***REMOVED***moduleName***REMOVED***`);

        result = npmUtils.fetchPeerDependencies(moduleName);
        getPeerDependencies.cache.set(moduleName, result);
    ***REMOVED***

    return result;
***REMOVED***
getPeerDependencies.cache = new Map();

/**
 * Return necessary plugins, configs, parsers, etc. based on the config
 * @param   ***REMOVED***Object***REMOVED*** config  config object
 * @param   ***REMOVED***boolean***REMOVED*** [installESLint=true]  If `false` is given, it does not install eslint.
 * @returns ***REMOVED***string[]***REMOVED*** An array of modules to be installed.
 */
function getModulesList(config, installESLint) ***REMOVED***
    const modules = ***REMOVED******REMOVED***;

    // Create a list of modules which should be installed based on config
    if (config.plugins) ***REMOVED***
        for (const plugin of config.plugins) ***REMOVED***
            const moduleName = naming.normalizePackageName(plugin, "eslint-plugin");

            modules[moduleName] = "latest";
        ***REMOVED***
    ***REMOVED***
    if (config.extends) ***REMOVED***
        const extendList = Array.isArray(config.extends) ? config.extends : [config.extends];

        for (const extend of extendList) ***REMOVED***
            if (extend.startsWith("eslint:") || extend.startsWith("plugin:")) ***REMOVED***
                continue;
            ***REMOVED***
            const moduleName = naming.normalizePackageName(extend, "eslint-config");

            modules[moduleName] = "latest";
            Object.assign(
                modules,
                getPeerDependencies(`$***REMOVED***moduleName***REMOVED***@latest`)
            );
        ***REMOVED***
    ***REMOVED***

    const parser = config.parser || (config.parserOptions && config.parserOptions.parser);

    if (parser) ***REMOVED***
        modules[parser] = "latest";
    ***REMOVED***

    if (installESLint === false) ***REMOVED***
        delete modules.eslint;
    ***REMOVED*** else ***REMOVED***
        const installStatus = npmUtils.checkDevDeps(["eslint"]);

        // Mark to show messages if it's new installation of eslint.
        if (installStatus.eslint === false) ***REMOVED***
            log.info("Local ESLint installation not found.");
            modules.eslint = modules.eslint || "latest";
            config.installedESLint = true;
        ***REMOVED***
    ***REMOVED***

    return Object.keys(modules).map(name => `$***REMOVED***name***REMOVED***@$***REMOVED***modules[name]***REMOVED***`);
***REMOVED***

/**
 * Set the `rules` of a config by examining a user's source code
 *
 * Note: This clones the config object and returns a new config to avoid mutating
 * the original config parameter.
 *
 * @param   ***REMOVED***Object***REMOVED*** answers  answers received from inquirer
 * @param   ***REMOVED***Object***REMOVED*** config   config object
 * @returns ***REMOVED***Object***REMOVED***          config object with configured rules
 */
function configureRules(answers, config) ***REMOVED***
    const BAR_TOTAL = 20,
        BAR_SOURCE_CODE_TOTAL = 4,
        newConfig = Object.assign(***REMOVED******REMOVED***, config),
        disabledConfigs = ***REMOVED******REMOVED***;
    let sourceCodes,
        registry;

    // Set up a progress bar, as this process can take a long time
    const bar = new ProgressBar("Determining Config: :percent [:bar] :elapseds elapsed, eta :etas ", ***REMOVED***
        width: 30,
        total: BAR_TOTAL
    ***REMOVED***);

    bar.tick(0); // Shows the progress bar

    // Get the SourceCode of all chosen files
    const patterns = answers.patterns.split(/[\s]+/u);

    try ***REMOVED***
        sourceCodes = getSourceCodeOfFiles(patterns, ***REMOVED*** baseConfig: newConfig, useEslintrc: false ***REMOVED***, total => ***REMOVED***
            bar.tick((BAR_SOURCE_CODE_TOTAL / total));
        ***REMOVED***);
    ***REMOVED*** catch (e) ***REMOVED***
        log.info("\n");
        throw e;
    ***REMOVED***
    const fileQty = Object.keys(sourceCodes).length;

    if (fileQty === 0) ***REMOVED***
        log.info("\n");
        throw new Error("Automatic Configuration failed.  No files were able to be parsed.");
    ***REMOVED***

    // Create a registry of rule configs
    registry = new autoconfig.Registry();
    registry.populateFromCoreRules();

    // Lint all files with each rule config in the registry
    registry = registry.lintSourceCode(sourceCodes, newConfig, total => ***REMOVED***
        bar.tick((BAR_TOTAL - BAR_SOURCE_CODE_TOTAL) / total); // Subtract out ticks used at beginning
    ***REMOVED***);
    debug(`\nRegistry: $***REMOVED***util.inspect(registry.rules, ***REMOVED*** depth: null ***REMOVED***)***REMOVED***`);

    // Create a list of recommended rules, because we don't want to disable them
    const recRules = Object.keys(recConfig.rules).filter(ruleId => ConfigOps.isErrorSeverity(recConfig.rules[ruleId]));

    // Find and disable rules which had no error-free configuration
    const failingRegistry = registry.getFailingRulesRegistry();

    Object.keys(failingRegistry.rules).forEach(ruleId => ***REMOVED***

        // If the rule is recommended, set it to error, otherwise disable it
        disabledConfigs[ruleId] = (recRules.indexOf(ruleId) !== -1) ? 2 : 0;
    ***REMOVED***);

    // Now that we know which rules to disable, strip out configs with errors
    registry = registry.stripFailingConfigs();

    /*
     * If there is only one config that results in no errors for a rule, we should use it.
     * createConfig will only add rules that have one configuration in the registry.
     */
    const singleConfigs = registry.createConfig().rules;

    /*
     * The "sweet spot" for number of options in a config seems to be two (severity plus one option).
     * Very often, a third option (usually an object) is available to address
     * edge cases, exceptions, or unique situations. We will prefer to use a config with
     * specificity of two.
     */
    const specTwoConfigs = registry.filterBySpecificity(2).createConfig().rules;

    // Maybe a specific combination using all three options works
    const specThreeConfigs = registry.filterBySpecificity(3).createConfig().rules;

    // If all else fails, try to use the default (severity only)
    const defaultConfigs = registry.filterBySpecificity(1).createConfig().rules;

    // Combine configs in reverse priority order (later take precedence)
    newConfig.rules = Object.assign(***REMOVED******REMOVED***, disabledConfigs, defaultConfigs, specThreeConfigs, specTwoConfigs, singleConfigs);

    // Make sure progress bar has finished (floating point rounding)
    bar.update(BAR_TOTAL);

    // Log out some stats to let the user know what happened
    const finalRuleIds = Object.keys(newConfig.rules);
    const totalRules = finalRuleIds.length;
    const enabledRules = finalRuleIds.filter(ruleId => (newConfig.rules[ruleId] !== 0)).length;
    const resultMessage = [
        `\nEnabled $***REMOVED***enabledRules***REMOVED*** out of $***REMOVED***totalRules***REMOVED***`,
        `rules based on $***REMOVED***fileQty***REMOVED***`,
        `file$***REMOVED***(fileQty === 1) ? "." : "s."***REMOVED***`
    ].join(" ");

    log.info(resultMessage);

    ConfigOps.normalizeToStrings(newConfig);
    return newConfig;
***REMOVED***

/**
 * process user's answers and create config object
 * @param ***REMOVED***Object***REMOVED*** answers answers received from inquirer
 * @returns ***REMOVED***Object***REMOVED*** config object
 */
function processAnswers(answers) ***REMOVED***
    let config = ***REMOVED***
        rules: ***REMOVED******REMOVED***,
        env: ***REMOVED******REMOVED***,
        parserOptions: ***REMOVED******REMOVED***,
        extends: []
    ***REMOVED***;

    // set the latest ECMAScript version
    config.parserOptions.ecmaVersion = DEFAULT_ECMA_VERSION;
    config.env.es6 = true;
    config.globals = ***REMOVED***
        Atomics: "readonly",
        SharedArrayBuffer: "readonly"
    ***REMOVED***;

    // set the module type
    if (answers.moduleType === "esm") ***REMOVED***
        config.parserOptions.sourceType = "module";
    ***REMOVED*** else if (answers.moduleType === "commonjs") ***REMOVED***
        config.env.commonjs = true;
    ***REMOVED***

    // add in browser and node environments if necessary
    answers.env.forEach(env => ***REMOVED***
        config.env[env] = true;
    ***REMOVED***);

    // add in library information
    if (answers.framework === "react") ***REMOVED***
        config.parserOptions.ecmaFeatures = ***REMOVED***
            jsx: true
        ***REMOVED***;
        config.plugins = ["react"];
    ***REMOVED*** else if (answers.framework === "vue") ***REMOVED***
        config.plugins = ["vue"];
        config.extends.push("plugin:vue/essential");
    ***REMOVED***

    if (answers.typescript) ***REMOVED***
        if (answers.framework === "vue") ***REMOVED***
            config.parserOptions.parser = "@typescript-eslint/parser";
        ***REMOVED*** else ***REMOVED***
            config.parser = "@typescript-eslint/parser";
        ***REMOVED***

        if (Array.isArray(config.plugins)) ***REMOVED***
            config.plugins.push("@typescript-eslint");
        ***REMOVED*** else ***REMOVED***
            config.plugins = ["@typescript-eslint"];
        ***REMOVED***
    ***REMOVED***

    // setup rules based on problems/style enforcement preferences
    if (answers.purpose === "problems") ***REMOVED***
        config.extends.unshift("eslint:recommended");
    ***REMOVED*** else if (answers.purpose === "style") ***REMOVED***
        if (answers.source === "prompt") ***REMOVED***
            config.extends.unshift("eslint:recommended");
            config.rules.indent = ["error", answers.indent];
            config.rules.quotes = ["error", answers.quotes];
            config.rules["linebreak-style"] = ["error", answers.linebreak];
            config.rules.semi = ["error", answers.semi ? "always" : "never"];
        ***REMOVED*** else if (answers.source === "auto") ***REMOVED***
            config = configureRules(answers, config);
            config = autoconfig.extendFromRecommended(config);
        ***REMOVED***
    ***REMOVED***
    if (answers.typescript && config.extends.includes("eslint:recommended")) ***REMOVED***
        config.extends.push("plugin:@typescript-eslint/eslint-recommended");
    ***REMOVED***

    // normalize extends
    if (config.extends.length === 0) ***REMOVED***
        delete config.extends;
    ***REMOVED*** else if (config.extends.length === 1) ***REMOVED***
        config.extends = config.extends[0];
    ***REMOVED***

    ConfigOps.normalizeToStrings(config);
    return config;
***REMOVED***

/**
 * Get the version of the local ESLint.
 * @returns ***REMOVED***string|null***REMOVED*** The version. If the local ESLint was not found, returns null.
 */
function getLocalESLintVersion() ***REMOVED***
    try ***REMOVED***
        const eslintPath = ModuleResolver.resolve("eslint", path.join(process.cwd(), "__placeholder__.js"));
        const eslint = require(eslintPath);

        return eslint.linter.version || null;
    ***REMOVED*** catch (_err) ***REMOVED***
        return null;
    ***REMOVED***
***REMOVED***

/**
 * Get the shareable config name of the chosen style guide.
 * @param ***REMOVED***Object***REMOVED*** answers The answers object.
 * @returns ***REMOVED***string***REMOVED*** The shareable config name.
 */
function getStyleGuideName(answers) ***REMOVED***
    if (answers.styleguide === "airbnb" && answers.framework !== "react") ***REMOVED***
        return "airbnb-base";
    ***REMOVED***
    return answers.styleguide;
***REMOVED***

/**
 * Check whether the local ESLint version conflicts with the required version of the chosen shareable config.
 * @param ***REMOVED***Object***REMOVED*** answers The answers object.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the local ESLint is found then it conflicts with the required version of the chosen shareable config.
 */
function hasESLintVersionConflict(answers) ***REMOVED***

    // Get the local ESLint version.
    const localESLintVersion = getLocalESLintVersion();

    if (!localESLintVersion) ***REMOVED***
        return false;
    ***REMOVED***

    // Get the required range of ESLint version.
    const configName = getStyleGuideName(answers);
    const moduleName = `eslint-config-$***REMOVED***configName***REMOVED***@latest`;
    const peerDependencies = getPeerDependencies(moduleName) || ***REMOVED******REMOVED***;
    const requiredESLintVersionRange = peerDependencies.eslint;

    if (!requiredESLintVersionRange) ***REMOVED***
        return false;
    ***REMOVED***

    answers.localESLintVersion = localESLintVersion;
    answers.requiredESLintVersionRange = requiredESLintVersionRange;

    // Check the version.
    if (semver.satisfies(localESLintVersion, requiredESLintVersionRange)) ***REMOVED***
        answers.installESLint = false;
        return false;
    ***REMOVED***

    return true;
***REMOVED***

/**
 * Install modules.
 * @param   ***REMOVED***string[]***REMOVED*** modules Modules to be installed.
 * @returns ***REMOVED***void***REMOVED***
 */
function installModules(modules) ***REMOVED***
    log.info(`Installing $***REMOVED***modules.join(", ")***REMOVED***`);
    npmUtils.installSyncSaveDev(modules);
***REMOVED***

/* istanbul ignore next: no need to test inquirer */
/**
 * Ask user to install modules.
 * @param   ***REMOVED***string[]***REMOVED*** modules Array of modules to be installed.
 * @param   ***REMOVED***boolean***REMOVED*** packageJsonExists Indicates if package.json is existed.
 * @returns ***REMOVED***Promise***REMOVED*** Answer that indicates if user wants to install.
 */
function askInstallModules(modules, packageJsonExists) ***REMOVED***

    // If no modules, do nothing.
    if (modules.length === 0) ***REMOVED***
        return Promise.resolve();
    ***REMOVED***

    log.info("The config that you've selected requires the following dependencies:\n");
    log.info(modules.join(" "));
    return inquirer.prompt([
        ***REMOVED***
            type: "confirm",
            name: "executeInstallation",
            message: "Would you like to install them now with npm?",
            default: true,
            when() ***REMOVED***
                return modules.length && packageJsonExists;
            ***REMOVED***
        ***REMOVED***
    ]).then((***REMOVED*** executeInstallation ***REMOVED***) => ***REMOVED***
        if (executeInstallation) ***REMOVED***
            installModules(modules);
        ***REMOVED***
    ***REMOVED***);
***REMOVED***

/* istanbul ignore next: no need to test inquirer */
/**
 * Ask use a few questions on command prompt
 * @returns ***REMOVED***Promise***REMOVED*** The promise with the result of the prompt
 */
function promptUser() ***REMOVED***

    return inquirer.prompt([
        ***REMOVED***
            type: "list",
            name: "purpose",
            message: "How would you like to use ESLint?",
            default: "problems",
            choices: [
                ***REMOVED*** name: "To check syntax only", value: "syntax" ***REMOVED***,
                ***REMOVED*** name: "To check syntax and find problems", value: "problems" ***REMOVED***,
                ***REMOVED*** name: "To check syntax, find problems, and enforce code style", value: "style" ***REMOVED***
            ]
        ***REMOVED***,
        ***REMOVED***
            type: "list",
            name: "moduleType",
            message: "What type of modules does your project use?",
            default: "esm",
            choices: [
                ***REMOVED*** name: "JavaScript modules (import/export)", value: "esm" ***REMOVED***,
                ***REMOVED*** name: "CommonJS (require/exports)", value: "commonjs" ***REMOVED***,
                ***REMOVED*** name: "None of these", value: "none" ***REMOVED***
            ]
        ***REMOVED***,
        ***REMOVED***
            type: "list",
            name: "framework",
            message: "Which framework does your project use?",
            default: "react",
            choices: [
                ***REMOVED*** name: "React", value: "react" ***REMOVED***,
                ***REMOVED*** name: "Vue.js", value: "vue" ***REMOVED***,
                ***REMOVED*** name: "None of these", value: "none" ***REMOVED***
            ]
        ***REMOVED***,
        ***REMOVED***
            type: "confirm",
            name: "typescript",
            message: "Does your project use TypeScript?",
            default: false
        ***REMOVED***,
        ***REMOVED***
            type: "checkbox",
            name: "env",
            message: "Where does your code run?",
            default: ["browser"],
            choices: [
                ***REMOVED*** name: "Browser", value: "browser" ***REMOVED***,
                ***REMOVED*** name: "Node", value: "node" ***REMOVED***
            ]
        ***REMOVED***,
        ***REMOVED***
            type: "list",
            name: "source",
            message: "How would you like to define a style for your project?",
            default: "guide",
            choices: [
                ***REMOVED*** name: "Use a popular style guide", value: "guide" ***REMOVED***,
                ***REMOVED*** name: "Answer questions about your style", value: "prompt" ***REMOVED***,
                ***REMOVED*** name: "Inspect your JavaScript file(s)", value: "auto" ***REMOVED***
            ],
            when(answers) ***REMOVED***
                return answers.purpose === "style";
            ***REMOVED***
        ***REMOVED***,
        ***REMOVED***
            type: "list",
            name: "styleguide",
            message: "Which style guide do you want to follow?",
            choices: [
                ***REMOVED*** name: "Airbnb (https://github.com/airbnb/javascript)", value: "airbnb" ***REMOVED***,
                ***REMOVED*** name: "Standard (https://github.com/standard/standard)", value: "standard" ***REMOVED***,
                ***REMOVED*** name: "Google (https://github.com/google/eslint-config-google)", value: "google" ***REMOVED***
            ],
            when(answers) ***REMOVED***
                answers.packageJsonExists = npmUtils.checkPackageJson();
                return answers.source === "guide" && answers.packageJsonExists;
            ***REMOVED***
        ***REMOVED***,
        ***REMOVED***
            type: "input",
            name: "patterns",
            message: "Which file(s), path(s), or glob(s) should be examined?",
            when(answers) ***REMOVED***
                return (answers.source === "auto");
            ***REMOVED***,
            validate(input) ***REMOVED***
                if (input.trim().length === 0 && input.trim() !== ",") ***REMOVED***
                    return "You must tell us what code to examine. Try again.";
                ***REMOVED***
                return true;
            ***REMOVED***
        ***REMOVED***,
        ***REMOVED***
            type: "list",
            name: "format",
            message: "What format do you want your config file to be in?",
            default: "JavaScript",
            choices: ["JavaScript", "YAML", "JSON"]
        ***REMOVED***,
        ***REMOVED***
            type: "confirm",
            name: "installESLint",
            message(answers) ***REMOVED***
                const verb = semver.ltr(answers.localESLintVersion, answers.requiredESLintVersionRange)
                    ? "upgrade"
                    : "downgrade";

                return `The style guide "$***REMOVED***answers.styleguide***REMOVED***" requires eslint@$***REMOVED***answers.requiredESLintVersionRange***REMOVED***. You are currently using eslint@$***REMOVED***answers.localESLintVersion***REMOVED***.\n  Do you want to $***REMOVED***verb***REMOVED***?`;
            ***REMOVED***,
            default: true,
            when(answers) ***REMOVED***
                return answers.source === "guide" && answers.packageJsonExists && hasESLintVersionConflict(answers);
            ***REMOVED***
        ***REMOVED***
    ]).then(earlyAnswers => ***REMOVED***

        // early exit if no style guide is necessary
        if (earlyAnswers.purpose !== "style") ***REMOVED***
            const config = processAnswers(earlyAnswers);
            const modules = getModulesList(config);

            return askInstallModules(modules, earlyAnswers.packageJsonExists)
                .then(() => writeFile(config, earlyAnswers.format));
        ***REMOVED***

        // early exit if you are using a style guide
        if (earlyAnswers.source === "guide") ***REMOVED***
            if (!earlyAnswers.packageJsonExists) ***REMOVED***
                log.info("A package.json is necessary to install plugins such as style guides. Run `npm init` to create a package.json file and try again.");
                return void 0;
            ***REMOVED***
            if (earlyAnswers.installESLint === false && !semver.satisfies(earlyAnswers.localESLintVersion, earlyAnswers.requiredESLintVersionRange)) ***REMOVED***
                log.info(`Note: it might not work since ESLint's version is mismatched with the $***REMOVED***earlyAnswers.styleguide***REMOVED*** config.`);
            ***REMOVED***
            if (earlyAnswers.styleguide === "airbnb" && earlyAnswers.framework !== "react") ***REMOVED***
                earlyAnswers.styleguide = "airbnb-base";
            ***REMOVED***

            const config = processAnswers(earlyAnswers);

            if (Array.isArray(config.extends)) ***REMOVED***
                config.extends.push(earlyAnswers.styleguide);
            ***REMOVED*** else if (config.extends) ***REMOVED***
                config.extends = [config.extends, earlyAnswers.styleguide];
            ***REMOVED*** else ***REMOVED***
                config.extends = [earlyAnswers.styleguide];
            ***REMOVED***

            const modules = getModulesList(config);

            return askInstallModules(modules, earlyAnswers.packageJsonExists)
                .then(() => writeFile(config, earlyAnswers.format));

        ***REMOVED***

        if (earlyAnswers.source === "auto") ***REMOVED***
            const combinedAnswers = Object.assign(***REMOVED******REMOVED***, earlyAnswers);
            const config = processAnswers(combinedAnswers);
            const modules = getModulesList(config);

            return askInstallModules(modules).then(() => writeFile(config, earlyAnswers.format));
        ***REMOVED***

        // continue with the style questions otherwise...
        return inquirer.prompt([
            ***REMOVED***
                type: "list",
                name: "indent",
                message: "What style of indentation do you use?",
                default: "tab",
                choices: [***REMOVED*** name: "Tabs", value: "tab" ***REMOVED***, ***REMOVED*** name: "Spaces", value: 4 ***REMOVED***]
            ***REMOVED***,
            ***REMOVED***
                type: "list",
                name: "quotes",
                message: "What quotes do you use for strings?",
                default: "double",
                choices: [***REMOVED*** name: "Double", value: "double" ***REMOVED***, ***REMOVED*** name: "Single", value: "single" ***REMOVED***]
            ***REMOVED***,
            ***REMOVED***
                type: "list",
                name: "linebreak",
                message: "What line endings do you use?",
                default: "unix",
                choices: [***REMOVED*** name: "Unix", value: "unix" ***REMOVED***, ***REMOVED*** name: "Windows", value: "windows" ***REMOVED***]
            ***REMOVED***,
            ***REMOVED***
                type: "confirm",
                name: "semi",
                message: "Do you require semicolons?",
                default: true
            ***REMOVED***
        ]).then(answers => ***REMOVED***
            const totalAnswers = Object.assign(***REMOVED******REMOVED***, earlyAnswers, answers);

            const config = processAnswers(totalAnswers);
            const modules = getModulesList(config);

            return askInstallModules(modules).then(() => writeFile(config, earlyAnswers.format));
        ***REMOVED***);
    ***REMOVED***);
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

const init = ***REMOVED***
    getModulesList,
    hasESLintVersionConflict,
    installModules,
    processAnswers,
    /* istanbul ignore next */initializeConfig() ***REMOVED***
        return promptUser();
    ***REMOVED***
***REMOVED***;

module.exports = init;
