/**
 * @fileoverview Validates configs.
 * @author Brandon Mills
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const
    path = require("path"),
    util = require("util"),
    lodash = require("lodash"),
    configSchema = require("../../conf/config-schema"),
    BuiltInEnvironments = require("../../conf/environments"),
    BuiltInRules = require("../rules"),
    ConfigOps = require("./config-ops");

const ajv = require("./ajv")();
const ruleValidators = new WeakMap();
const noop = Function.prototype;

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------
let validateSchema;

// Defitions for deprecation warnings.
const deprecationWarningMessages = ***REMOVED***
    ESLINT_LEGACY_ECMAFEATURES: "The 'ecmaFeatures' config file property is deprecated, and has no effect."
***REMOVED***;
const severityMap = ***REMOVED***
    error: 2,
    warn: 1,
    off: 0
***REMOVED***;

/**
 * Gets a complete options schema for a rule.
 * @param ***REMOVED******REMOVED***create: Function, schema: (Array|null)***REMOVED******REMOVED*** rule A new-style rule object
 * @returns ***REMOVED***Object***REMOVED*** JSON Schema for the rule's options.
 */
function getRuleOptionsSchema(rule) ***REMOVED***
    if (!rule) ***REMOVED***
        return null;
    ***REMOVED***

    const schema = rule.schema || rule.meta && rule.meta.schema;

    // Given a tuple of schemas, insert warning level at the beginning
    if (Array.isArray(schema)) ***REMOVED***
        if (schema.length) ***REMOVED***
            return ***REMOVED***
                type: "array",
                items: schema,
                minItems: 0,
                maxItems: schema.length
            ***REMOVED***;
        ***REMOVED***
        return ***REMOVED***
            type: "array",
            minItems: 0,
            maxItems: 0
        ***REMOVED***;

    ***REMOVED***

    // Given a full schema, leave it alone
    return schema || null;
***REMOVED***

/**
 * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.
 * @param ***REMOVED***options***REMOVED*** options The given options for the rule.
 * @returns ***REMOVED***number|string***REMOVED*** The rule's severity value
 */
function validateRuleSeverity(options) ***REMOVED***
    const severity = Array.isArray(options) ? options[0] : options;
    const normSeverity = typeof severity === "string" ? severityMap[severity.toLowerCase()] : severity;

    if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) ***REMOVED***
        return normSeverity;
    ***REMOVED***

    throw new Error(`\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '$***REMOVED***util.inspect(severity).replace(/'/gu, "\"").replace(/\n/gu, "")***REMOVED***').\n`);

***REMOVED***

/**
 * Validates the non-severity options passed to a rule, based on its schema.
 * @param ***REMOVED******REMOVED***create: Function***REMOVED******REMOVED*** rule The rule to validate
 * @param ***REMOVED***Array***REMOVED*** localOptions The options for the rule, excluding severity
 * @returns ***REMOVED***void***REMOVED***
 */
function validateRuleSchema(rule, localOptions) ***REMOVED***
    if (!ruleValidators.has(rule)) ***REMOVED***
        const schema = getRuleOptionsSchema(rule);

        if (schema) ***REMOVED***
            ruleValidators.set(rule, ajv.compile(schema));
        ***REMOVED***
    ***REMOVED***

    const validateRule = ruleValidators.get(rule);

    if (validateRule) ***REMOVED***
        validateRule(localOptions);
        if (validateRule.errors) ***REMOVED***
            throw new Error(validateRule.errors.map(
                error => `\tValue $***REMOVED***JSON.stringify(error.data)***REMOVED*** $***REMOVED***error.message***REMOVED***.\n`
            ).join(""));
        ***REMOVED***
    ***REMOVED***
***REMOVED***

/**
 * Validates a rule's options against its schema.
 * @param ***REMOVED******REMOVED***create: Function***REMOVED***|null***REMOVED*** rule The rule that the config is being validated for
 * @param ***REMOVED***string***REMOVED*** ruleId The rule's unique name.
 * @param ***REMOVED***Array|number***REMOVED*** options The given options for the rule.
 * @param ***REMOVED***string|null***REMOVED*** source The name of the configuration source to report in any errors. If null or undefined,
 * no source is prepended to the message.
 * @returns ***REMOVED***void***REMOVED***
 */
function validateRuleOptions(rule, ruleId, options, source = null) ***REMOVED***
    try ***REMOVED***
        const severity = validateRuleSeverity(options);

        if (severity !== 0) ***REMOVED***
            validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);
        ***REMOVED***
    ***REMOVED*** catch (err) ***REMOVED***
        const enhancedMessage = `Configuration for rule "$***REMOVED***ruleId***REMOVED***" is invalid:\n$***REMOVED***err.message***REMOVED***`;

        if (typeof source === "string") ***REMOVED***
            throw new Error(`$***REMOVED***source***REMOVED***:\n\t$***REMOVED***enhancedMessage***REMOVED***`);
        ***REMOVED*** else ***REMOVED***
            throw new Error(enhancedMessage);
        ***REMOVED***
    ***REMOVED***
***REMOVED***

/**
 * Validates an environment object
 * @param ***REMOVED***Object***REMOVED*** environment The environment config object to validate.
 * @param ***REMOVED***string***REMOVED*** source The name of the configuration source to report in any errors.
 * @param ***REMOVED***function(envId:string): Object***REMOVED*** [getAdditionalEnv] A map from strings to loaded environments.
 * @returns ***REMOVED***void***REMOVED***
 */
function validateEnvironment(
    environment,
    source,
    getAdditionalEnv = noop
) ***REMOVED***

    // not having an environment is ok
    if (!environment) ***REMOVED***
        return;
    ***REMOVED***

    Object.keys(environment).forEach(id => ***REMOVED***
        const env = getAdditionalEnv(id) || BuiltInEnvironments.get(id) || null;

        if (!env) ***REMOVED***
            const message = `$***REMOVED***source***REMOVED***:\n\tEnvironment key "$***REMOVED***id***REMOVED***" is unknown\n`;

            throw new Error(message);
        ***REMOVED***
    ***REMOVED***);
***REMOVED***

/**
 * Validates a rules config object
 * @param ***REMOVED***Object***REMOVED*** rulesConfig The rules config object to validate.
 * @param ***REMOVED***string***REMOVED*** source The name of the configuration source to report in any errors.
 * @param ***REMOVED***function(ruleId:string): Object***REMOVED*** getAdditionalRule A map from strings to loaded rules
 * @returns ***REMOVED***void***REMOVED***
 */
function validateRules(
    rulesConfig,
    source,
    getAdditionalRule = noop
) ***REMOVED***
    if (!rulesConfig) ***REMOVED***
        return;
    ***REMOVED***

    Object.keys(rulesConfig).forEach(id => ***REMOVED***
        const rule = getAdditionalRule(id) || BuiltInRules.get(id) || null;

        validateRuleOptions(rule, id, rulesConfig[id], source);
    ***REMOVED***);
***REMOVED***

/**
 * Validates a `globals` section of a config file
 * @param ***REMOVED***Object***REMOVED*** globalsConfig The `glboals` section
 * @param ***REMOVED***string|null***REMOVED*** source The name of the configuration source to report in the event of an error.
 * @returns ***REMOVED***void***REMOVED***
 */
function validateGlobals(globalsConfig, source = null) ***REMOVED***
    if (!globalsConfig) ***REMOVED***
        return;
    ***REMOVED***

    Object.entries(globalsConfig)
        .forEach(([configuredGlobal, configuredValue]) => ***REMOVED***
            try ***REMOVED***
                ConfigOps.normalizeConfigGlobal(configuredValue);
            ***REMOVED*** catch (err) ***REMOVED***
                throw new Error(`ESLint configuration of global '$***REMOVED***configuredGlobal***REMOVED***' in $***REMOVED***source***REMOVED*** is invalid:\n$***REMOVED***err.message***REMOVED***`);
            ***REMOVED***
        ***REMOVED***);
***REMOVED***

/**
 * Validate `processor` configuration.
 * @param ***REMOVED***string|undefined***REMOVED*** processorName The processor name.
 * @param ***REMOVED***string***REMOVED*** source The name of config file.
 * @param ***REMOVED***function(id:string): Processor***REMOVED*** getProcessor The getter of defined processors.
 * @returns ***REMOVED***void***REMOVED***
 */
function validateProcessor(processorName, source, getProcessor) ***REMOVED***
    if (processorName && !getProcessor(processorName)) ***REMOVED***
        throw new Error(`ESLint configuration of processor in '$***REMOVED***source***REMOVED***' is invalid: '$***REMOVED***processorName***REMOVED***' was not found.`);
    ***REMOVED***
***REMOVED***

/**
 * Formats an array of schema validation errors.
 * @param ***REMOVED***Array***REMOVED*** errors An array of error messages to format.
 * @returns ***REMOVED***string***REMOVED*** Formatted error message
 */
function formatErrors(errors) ***REMOVED***
    return errors.map(error => ***REMOVED***
        if (error.keyword === "additionalProperties") ***REMOVED***
            const formattedPropertyPath = error.dataPath.length ? `$***REMOVED***error.dataPath.slice(1)***REMOVED***.$***REMOVED***error.params.additionalProperty***REMOVED***` : error.params.additionalProperty;

            return `Unexpected top-level property "$***REMOVED***formattedPropertyPath***REMOVED***"`;
        ***REMOVED***
        if (error.keyword === "type") ***REMOVED***
            const formattedField = error.dataPath.slice(1);
            const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join("/") : error.schema;
            const formattedValue = JSON.stringify(error.data);

            return `Property "$***REMOVED***formattedField***REMOVED***" is the wrong type (expected $***REMOVED***formattedExpectedType***REMOVED*** but got \`$***REMOVED***formattedValue***REMOVED***\`)`;
        ***REMOVED***

        const field = error.dataPath[0] === "." ? error.dataPath.slice(1) : error.dataPath;

        return `"$***REMOVED***field***REMOVED***" $***REMOVED***error.message***REMOVED***. Value: $***REMOVED***JSON.stringify(error.data)***REMOVED***`;
    ***REMOVED***).map(message => `\t- $***REMOVED***message***REMOVED***.\n`).join("");
***REMOVED***

/**
 * Emits a deprecation warning containing a given filepath. A new deprecation warning is emitted
 * for each unique file path, but repeated invocations with the same file path have no effect.
 * No warnings are emitted if the `--no-deprecation` or `--no-warnings` Node runtime flags are active.
 * @param ***REMOVED***string***REMOVED*** source The name of the configuration source to report the warning for.
 * @param ***REMOVED***string***REMOVED*** errorCode The warning message to show.
 * @returns ***REMOVED***void***REMOVED***
 */
const emitDeprecationWarning = lodash.memoize((source, errorCode) => ***REMOVED***
    const rel = path.relative(process.cwd(), source);
    const message = deprecationWarningMessages[errorCode];

    process.emitWarning(
        `$***REMOVED***message***REMOVED*** (found in "$***REMOVED***rel***REMOVED***")`,
        "DeprecationWarning",
        errorCode
    );
***REMOVED***);

/**
 * Validates the top level properties of the config object.
 * @param ***REMOVED***Object***REMOVED*** config The config object to validate.
 * @param ***REMOVED***string***REMOVED*** source The name of the configuration source to report in any errors.
 * @returns ***REMOVED***void***REMOVED***
 */
function validateConfigSchema(config, source = null) ***REMOVED***
    validateSchema = validateSchema || ajv.compile(configSchema);

    if (!validateSchema(config)) ***REMOVED***
        throw new Error(`ESLint configuration in $***REMOVED***source***REMOVED*** is invalid:\n$***REMOVED***formatErrors(validateSchema.errors)***REMOVED***`);
    ***REMOVED***

    if (Object.hasOwnProperty.call(config, "ecmaFeatures")) ***REMOVED***
        emitDeprecationWarning(source, "ESLINT_LEGACY_ECMAFEATURES");
    ***REMOVED***
***REMOVED***

/**
 * Validates an entire config object.
 * @param ***REMOVED***Object***REMOVED*** config The config object to validate.
 * @param ***REMOVED***string***REMOVED*** source The name of the configuration source to report in any errors.
 * @param ***REMOVED***function(ruleId:string): Object***REMOVED*** [getAdditionalRule] A map from strings to loaded rules.
 * @param ***REMOVED***function(envId:string): Object***REMOVED*** [getAdditionalEnv] A map from strings to loaded envs.
 * @returns ***REMOVED***void***REMOVED***
 */
function validate(config, source, getAdditionalRule, getAdditionalEnv) ***REMOVED***
    validateConfigSchema(config, source);
    validateRules(config.rules, source, getAdditionalRule);
    validateEnvironment(config.env, source, getAdditionalEnv);
    validateGlobals(config.globals, source);

    for (const override of config.overrides || []) ***REMOVED***
        validateRules(override.rules, source, getAdditionalRule);
        validateEnvironment(override.env, source, getAdditionalEnv);
        validateGlobals(config.globals, source);
    ***REMOVED***
***REMOVED***

const validated = new WeakSet();

/**
 * Validate config array object.
 * @param ***REMOVED***ConfigArray***REMOVED*** configArray The config array to validate.
 * @returns ***REMOVED***void***REMOVED***
 */
function validateConfigArray(configArray) ***REMOVED***
    const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);
    const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);
    const getPluginRule = Map.prototype.get.bind(configArray.pluginRules);

    // Validate.
    for (const element of configArray) ***REMOVED***
        if (validated.has(element)) ***REMOVED***
            continue;
        ***REMOVED***
        validated.add(element);

        validateEnvironment(element.env, element.name, getPluginEnv);
        validateGlobals(element.globals, element.name);
        validateProcessor(element.processor, element.name, getPluginProcessor);
        validateRules(element.rules, element.name, getPluginRule);
    ***REMOVED***
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    getRuleOptionsSchema,
    validate,
    validateConfigArray,
    validateConfigSchema,
    validateRuleOptions
***REMOVED***;
