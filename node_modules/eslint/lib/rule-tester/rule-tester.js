/**
 * @fileoverview Mocha test wrapper
 * @author Ilya Volodin
 */
"use strict";

/* global describe, it */

/*
 * This is a wrapper around mocha to allow for DRY unittests for eslint
 * Format:
 * RuleTester.run("***REMOVED***ruleName***REMOVED***", ***REMOVED***
 *      valid: [
 *          "***REMOVED***code***REMOVED***",
 *          ***REMOVED*** code: "***REMOVED***code***REMOVED***", options: ***REMOVED***options***REMOVED***, globals: ***REMOVED***globals***REMOVED***, parser: "***REMOVED***parser***REMOVED***", settings: ***REMOVED***settings***REMOVED*** ***REMOVED***
 *      ],
 *      invalid: [
 *          ***REMOVED*** code: "***REMOVED***code***REMOVED***", errors: ***REMOVED***numErrors***REMOVED*** ***REMOVED***,
 *          ***REMOVED*** code: "***REMOVED***code***REMOVED***", errors: ["***REMOVED***errorMessage***REMOVED***"] ***REMOVED***,
 *          ***REMOVED*** code: "***REMOVED***code***REMOVED***", options: ***REMOVED***options***REMOVED***, globals: ***REMOVED***globals***REMOVED***, parser: "***REMOVED***parser***REMOVED***", settings: ***REMOVED***settings***REMOVED***, errors: [***REMOVED*** message: "***REMOVED***errorMessage***REMOVED***", type: "***REMOVED***errorNodeType***REMOVED***"***REMOVED***] ***REMOVED***
 *      ]
 *  ***REMOVED***);
 *
 * Variables:
 * ***REMOVED***code***REMOVED*** - String that represents the code to be tested
 * ***REMOVED***options***REMOVED*** - Arguments that are passed to the configurable rules.
 * ***REMOVED***globals***REMOVED*** - An object representing a list of variables that are
 *             registered as globals
 * ***REMOVED***parser***REMOVED*** - String representing the parser to use
 * ***REMOVED***settings***REMOVED*** - An object representing global settings for all rules
 * ***REMOVED***numErrors***REMOVED*** - If failing case doesn't need to check error message,
 *               this integer will specify how many errors should be
 *               received
 * ***REMOVED***errorMessage***REMOVED*** - Message that is returned by the rule on failure
 * ***REMOVED***errorNodeType***REMOVED*** - AST node type that is returned by they rule as
 *                   a cause of the failure.
 */

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const
    assert = require("assert"),
    path = require("path"),
    util = require("util"),
    lodash = require("lodash"),
    ***REMOVED*** getRuleOptionsSchema, validate ***REMOVED*** = require("../shared/config-validator"),
    ***REMOVED*** Linter, SourceCodeFixer, interpolate ***REMOVED*** = require("../linter");

const ajv = require("../shared/ajv")(***REMOVED*** strictDefaults: true ***REMOVED***);

//------------------------------------------------------------------------------
// Private Members
//------------------------------------------------------------------------------

/*
 * testerDefaultConfig must not be modified as it allows to reset the tester to
 * the initial default configuration
 */
const testerDefaultConfig = ***REMOVED*** rules: ***REMOVED******REMOVED*** ***REMOVED***;
let defaultConfig = ***REMOVED*** rules: ***REMOVED******REMOVED*** ***REMOVED***;

/*
 * List every parameters possible on a test case that are not related to eslint
 * configuration
 */
const RuleTesterParameters = [
    "code",
    "filename",
    "options",
    "errors",
    "output"
];

const hasOwnProperty = Function.call.bind(Object.hasOwnProperty);

/**
 * Clones a given value deeply.
 * Note: This ignores `parent` property.
 *
 * @param ***REMOVED***any***REMOVED*** x - A value to clone.
 * @returns ***REMOVED***any***REMOVED*** A cloned value.
 */
function cloneDeeplyExcludesParent(x) ***REMOVED***
    if (typeof x === "object" && x !== null) ***REMOVED***
        if (Array.isArray(x)) ***REMOVED***
            return x.map(cloneDeeplyExcludesParent);
        ***REMOVED***

        const retv = ***REMOVED******REMOVED***;

        for (const key in x) ***REMOVED***
            if (key !== "parent" && hasOwnProperty(x, key)) ***REMOVED***
                retv[key] = cloneDeeplyExcludesParent(x[key]);
            ***REMOVED***
        ***REMOVED***

        return retv;
    ***REMOVED***

    return x;
***REMOVED***

/**
 * Freezes a given value deeply.
 *
 * @param ***REMOVED***any***REMOVED*** x - A value to freeze.
 * @returns ***REMOVED***void***REMOVED***
 */
function freezeDeeply(x) ***REMOVED***
    if (typeof x === "object" && x !== null) ***REMOVED***
        if (Array.isArray(x)) ***REMOVED***
            x.forEach(freezeDeeply);
        ***REMOVED*** else ***REMOVED***
            for (const key in x) ***REMOVED***
                if (key !== "parent" && hasOwnProperty(x, key)) ***REMOVED***
                    freezeDeeply(x[key]);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        Object.freeze(x);
    ***REMOVED***
***REMOVED***

/**
 * Replace control characters by `\u00xx` form.
 * @param ***REMOVED***string***REMOVED*** text The text to sanitize.
 * @returns ***REMOVED***string***REMOVED*** The sanitized text.
 */
function sanitize(text) ***REMOVED***
    return text.replace(
        /[\u0000-\u001f]/gu, // eslint-disable-line no-control-regex
        c => `\\u$***REMOVED***c.codePointAt(0).toString(16).padStart(4, "0")***REMOVED***`
    );
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

// default separators for testing
const DESCRIBE = Symbol("describe");
const IT = Symbol("it");

/**
 * This is `it` default handler if `it` don't exist.
 * @this ***REMOVED***Mocha***REMOVED***
 * @param ***REMOVED***string***REMOVED*** text - The description of the test case.
 * @param ***REMOVED***Function***REMOVED*** method - The logic of the test case.
 * @returns ***REMOVED***any***REMOVED*** Returned value of `method`.
 */
function itDefaultHandler(text, method) ***REMOVED***
    try ***REMOVED***
        return method.call(this);
    ***REMOVED*** catch (err) ***REMOVED***
        if (err instanceof assert.AssertionError) ***REMOVED***
            err.message += ` ($***REMOVED***util.inspect(err.actual)***REMOVED*** $***REMOVED***err.operator***REMOVED*** $***REMOVED***util.inspect(err.expected)***REMOVED***)`;
        ***REMOVED***
        throw err;
    ***REMOVED***
***REMOVED***

/**
 * This is `describe` default handler if `describe` don't exist.
 * @this ***REMOVED***Mocha***REMOVED***
 * @param ***REMOVED***string***REMOVED*** text - The description of the test case.
 * @param ***REMOVED***Function***REMOVED*** method - The logic of the test case.
 * @returns ***REMOVED***any***REMOVED*** Returned value of `method`.
 */
function describeDefaultHandler(text, method) ***REMOVED***
    return method.call(this);
***REMOVED***

class RuleTester ***REMOVED***

    /**
     * Creates a new instance of RuleTester.
     * @param ***REMOVED***Object***REMOVED*** [testerConfig] Optional, extra configuration for the tester
     * @constructor
     */
    constructor(testerConfig) ***REMOVED***

        /**
         * The configuration to use for this tester. Combination of the tester
         * configuration and the default configuration.
         * @type ***REMOVED***Object***REMOVED***
         */
        this.testerConfig = lodash.merge(

            // we have to clone because merge uses the first argument for recipient
            lodash.cloneDeep(defaultConfig),
            testerConfig,
            ***REMOVED*** rules: ***REMOVED*** "rule-tester/validate-ast": "error" ***REMOVED*** ***REMOVED***
        );

        /**
         * Rule definitions to define before tests.
         * @type ***REMOVED***Object***REMOVED***
         */
        this.rules = ***REMOVED******REMOVED***;
        this.linter = new Linter();
    ***REMOVED***

    /**
     * Set the configuration to use for all future tests
     * @param ***REMOVED***Object***REMOVED*** config the configuration to use.
     * @returns ***REMOVED***void***REMOVED***
     */
    static setDefaultConfig(config) ***REMOVED***
        if (typeof config !== "object") ***REMOVED***
            throw new TypeError("RuleTester.setDefaultConfig: config must be an object");
        ***REMOVED***
        defaultConfig = config;

        // Make sure the rules object exists since it is assumed to exist later
        defaultConfig.rules = defaultConfig.rules || ***REMOVED******REMOVED***;
    ***REMOVED***

    /**
     * Get the current configuration used for all tests
     * @returns ***REMOVED***Object***REMOVED*** the current configuration
     */
    static getDefaultConfig() ***REMOVED***
        return defaultConfig;
    ***REMOVED***

    /**
     * Reset the configuration to the initial configuration of the tester removing
     * any changes made until now.
     * @returns ***REMOVED***void***REMOVED***
     */
    static resetDefaultConfig() ***REMOVED***
        defaultConfig = lodash.cloneDeep(testerDefaultConfig);
    ***REMOVED***


    /*
     * If people use `mocha test.js --watch` command, `describe` and `it` function
     * instances are different for each execution. So `describe` and `it` should get fresh instance
     * always.
     */
    static get describe() ***REMOVED***
        return (
            this[DESCRIBE] ||
            (typeof describe === "function" ? describe : describeDefaultHandler)
        );
    ***REMOVED***

    static set describe(value) ***REMOVED***
        this[DESCRIBE] = value;
    ***REMOVED***

    static get it() ***REMOVED***
        return (
            this[IT] ||
            (typeof it === "function" ? it : itDefaultHandler)
        );
    ***REMOVED***

    static set it(value) ***REMOVED***
        this[IT] = value;
    ***REMOVED***

    /**
     * Define a rule for one particular run of tests.
     * @param ***REMOVED***string***REMOVED*** name The name of the rule to define.
     * @param ***REMOVED***Function***REMOVED*** rule The rule definition.
     * @returns ***REMOVED***void***REMOVED***
     */
    defineRule(name, rule) ***REMOVED***
        this.rules[name] = rule;
    ***REMOVED***

    /**
     * Adds a new rule test to execute.
     * @param ***REMOVED***string***REMOVED*** ruleName The name of the rule to run.
     * @param ***REMOVED***Function***REMOVED*** rule The rule to test.
     * @param ***REMOVED***Object***REMOVED*** test The collection of tests to run.
     * @returns ***REMOVED***void***REMOVED***
     */
    run(ruleName, rule, test) ***REMOVED***

        const testerConfig = this.testerConfig,
            requiredScenarios = ["valid", "invalid"],
            scenarioErrors = [],
            linter = this.linter;

        if (lodash.isNil(test) || typeof test !== "object") ***REMOVED***
            throw new TypeError(`Test Scenarios for rule $***REMOVED***ruleName***REMOVED*** : Could not find test scenario object`);
        ***REMOVED***

        requiredScenarios.forEach(scenarioType => ***REMOVED***
            if (lodash.isNil(test[scenarioType])) ***REMOVED***
                scenarioErrors.push(`Could not find any $***REMOVED***scenarioType***REMOVED*** test scenarios`);
            ***REMOVED***
        ***REMOVED***);

        if (scenarioErrors.length > 0) ***REMOVED***
            throw new Error([
                `Test Scenarios for rule $***REMOVED***ruleName***REMOVED*** is invalid:`
            ].concat(scenarioErrors).join("\n"));
        ***REMOVED***


        linter.defineRule(ruleName, Object.assign(***REMOVED******REMOVED***, rule, ***REMOVED***

            // Create a wrapper rule that freezes the `context` properties.
            create(context) ***REMOVED***
                freezeDeeply(context.options);
                freezeDeeply(context.settings);
                freezeDeeply(context.parserOptions);

                return (typeof rule === "function" ? rule : rule.create)(context);
            ***REMOVED***
        ***REMOVED***));

        linter.defineRules(this.rules);

        /**
         * Run the rule for the given item
         * @param ***REMOVED***string|Object***REMOVED*** item Item to run the rule against
         * @returns ***REMOVED***Object***REMOVED*** Eslint run result
         * @private
         */
        function runRuleForItem(item) ***REMOVED***
            let config = lodash.cloneDeep(testerConfig),
                code, filename, output, beforeAST, afterAST;

            if (typeof item === "string") ***REMOVED***
                code = item;
            ***REMOVED*** else ***REMOVED***
                code = item.code;

                /*
                 * Assumes everything on the item is a config except for the
                 * parameters used by this tester
                 */
                const itemConfig = lodash.omit(item, RuleTesterParameters);

                /*
                 * Create the config object from the tester config and this item
                 * specific configurations.
                 */
                config = lodash.merge(
                    config,
                    itemConfig
                );
            ***REMOVED***

            if (item.filename) ***REMOVED***
                filename = item.filename;
            ***REMOVED***

            if (Object.prototype.hasOwnProperty.call(item, "options")) ***REMOVED***
                assert(Array.isArray(item.options), "options must be an array");
                config.rules[ruleName] = [1].concat(item.options);
            ***REMOVED*** else ***REMOVED***
                config.rules[ruleName] = 1;
            ***REMOVED***

            const schema = getRuleOptionsSchema(rule);

            /*
             * Setup AST getters.
             * The goal is to check whether or not AST was modified when
             * running the rule under test.
             */
            linter.defineRule("rule-tester/validate-ast", () => (***REMOVED***
                Program(node) ***REMOVED***
                    beforeAST = cloneDeeplyExcludesParent(node);
                ***REMOVED***,
                "Program:exit"(node) ***REMOVED***
                    afterAST = node;
                ***REMOVED***
            ***REMOVED***));

            if (typeof config.parser === "string") ***REMOVED***
                assert(path.isAbsolute(config.parser), "Parsers provided as strings to RuleTester must be absolute paths");
                linter.defineParser(config.parser, require(config.parser));
            ***REMOVED***

            if (schema) ***REMOVED***
                ajv.validateSchema(schema);

                if (ajv.errors) ***REMOVED***
                    const errors = ajv.errors.map(error => ***REMOVED***
                        const field = error.dataPath[0] === "." ? error.dataPath.slice(1) : error.dataPath;

                        return `\t$***REMOVED***field***REMOVED***: $***REMOVED***error.message***REMOVED***`;
                    ***REMOVED***).join("\n");

                    throw new Error([`Schema for rule $***REMOVED***ruleName***REMOVED*** is invalid:`, errors]);
                ***REMOVED***

                /*
                 * `ajv.validateSchema` checks for errors in the structure of the schema (by comparing the schema against a "meta-schema"),
                 * and it reports those errors individually. However, there are other types of schema errors that only occur when compiling
                 * the schema (e.g. using invalid defaults in a schema), and only one of these errors can be reported at a time. As a result,
                 * the schema is compiled here separately from checking for `validateSchema` errors.
                 */
                try ***REMOVED***
                    ajv.compile(schema);
                ***REMOVED*** catch (err) ***REMOVED***
                    throw new Error(`Schema for rule $***REMOVED***ruleName***REMOVED*** is invalid: $***REMOVED***err.message***REMOVED***`);
                ***REMOVED***
            ***REMOVED***

            validate(config, "rule-tester", id => (id === ruleName ? rule : null));

            // Verify the code.
            const messages = linter.verify(code, config, filename);

            // Ignore syntax errors for backward compatibility if `errors` is a number.
            if (typeof item.errors !== "number") ***REMOVED***
                const errorMessage = messages.find(m => m.fatal);

                assert(!errorMessage, `A fatal parsing error occurred: $***REMOVED***errorMessage && errorMessage.message***REMOVED***`);
            ***REMOVED***

            // Verify if autofix makes a syntax error or not.
            if (messages.some(m => m.fix)) ***REMOVED***
                output = SourceCodeFixer.applyFixes(code, messages).output;
                const errorMessageInFix = linter.verify(output, config, filename).find(m => m.fatal);

                assert(!errorMessageInFix, `A fatal parsing error occurred in autofix: $***REMOVED***errorMessageInFix && errorMessageInFix.message***REMOVED***`);
            ***REMOVED*** else ***REMOVED***
                output = code;
            ***REMOVED***

            return ***REMOVED***
                messages,
                output,
                beforeAST,
                afterAST: cloneDeeplyExcludesParent(afterAST)
            ***REMOVED***;
        ***REMOVED***

        /**
         * Check if the AST was changed
         * @param ***REMOVED***ASTNode***REMOVED*** beforeAST AST node before running
         * @param ***REMOVED***ASTNode***REMOVED*** afterAST AST node after running
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function assertASTDidntChange(beforeAST, afterAST) ***REMOVED***
            if (!lodash.isEqual(beforeAST, afterAST)) ***REMOVED***
                assert.fail("Rule should not modify AST.");
            ***REMOVED***
        ***REMOVED***

        /**
         * Check if the template is valid or not
         * all valid cases go through this
         * @param ***REMOVED***string|Object***REMOVED*** item Item to run the rule against
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function testValidTemplate(item) ***REMOVED***
            const result = runRuleForItem(item);
            const messages = result.messages;

            assert.strictEqual(messages.length, 0, util.format("Should have no errors but had %d: %s",
                messages.length, util.inspect(messages)));

            assertASTDidntChange(result.beforeAST, result.afterAST);
        ***REMOVED***

        /**
         * Asserts that the message matches its expected value. If the expected
         * value is a regular expression, it is checked against the actual
         * value.
         * @param ***REMOVED***string***REMOVED*** actual Actual value
         * @param ***REMOVED***string|RegExp***REMOVED*** expected Expected value
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function assertMessageMatches(actual, expected) ***REMOVED***
            if (expected instanceof RegExp) ***REMOVED***

                // assert.js doesn't have a built-in RegExp match function
                assert.ok(
                    expected.test(actual),
                    `Expected '$***REMOVED***actual***REMOVED***' to match $***REMOVED***expected***REMOVED***`
                );
            ***REMOVED*** else ***REMOVED***
                assert.strictEqual(actual, expected);
            ***REMOVED***
        ***REMOVED***

        /**
         * Check if the template is invalid or not
         * all invalid cases go through this.
         * @param ***REMOVED***string|Object***REMOVED*** item Item to run the rule against
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function testInvalidTemplate(item) ***REMOVED***
            assert.ok(item.errors || item.errors === 0,
                `Did not specify errors for an invalid test of $***REMOVED***ruleName***REMOVED***`);

            const result = runRuleForItem(item);
            const messages = result.messages;


            if (typeof item.errors === "number") ***REMOVED***
                assert.strictEqual(messages.length, item.errors, util.format("Should have %d error%s but had %d: %s",
                    item.errors, item.errors === 1 ? "" : "s", messages.length, util.inspect(messages)));
            ***REMOVED*** else ***REMOVED***
                assert.strictEqual(
                    messages.length, item.errors.length,
                    util.format(
                        "Should have %d error%s but had %d: %s",
                        item.errors.length, item.errors.length === 1 ? "" : "s", messages.length, util.inspect(messages)
                    )
                );

                const hasMessageOfThisRule = messages.some(m => m.ruleId === ruleName);

                for (let i = 0, l = item.errors.length; i < l; i++) ***REMOVED***
                    const error = item.errors[i];
                    const message = messages[i];

                    assert(hasMessageOfThisRule, "Error rule name should be the same as the name of the rule being tested");

                    if (typeof error === "string" || error instanceof RegExp) ***REMOVED***

                        // Just an error message.
                        assertMessageMatches(message.message, error);
                    ***REMOVED*** else if (typeof error === "object") ***REMOVED***

                        /*
                         * Error object.
                         * This may have a message, messageId, data, node type, line, and/or
                         * column.
                         */
                        if (hasOwnProperty(error, "message")) ***REMOVED***
                            assert.ok(!hasOwnProperty(error, "messageId"), "Error should not specify both 'message' and a 'messageId'.");
                            assert.ok(!hasOwnProperty(error, "data"), "Error should not specify both 'data' and 'message'.");
                            assertMessageMatches(message.message, error.message);
                        ***REMOVED*** else if (hasOwnProperty(error, "messageId")) ***REMOVED***
                            assert.ok(
                                hasOwnProperty(rule, "meta") && hasOwnProperty(rule.meta, "messages"),
                                "Error can not use 'messageId' if rule under test doesn't define 'meta.messages'."
                            );
                            if (!hasOwnProperty(rule.meta.messages, error.messageId)) ***REMOVED***
                                const friendlyIDList = `[$***REMOVED***Object.keys(rule.meta.messages).map(key => `'$***REMOVED***key***REMOVED***'`).join(", ")***REMOVED***]`;

                                assert(false, `Invalid messageId '$***REMOVED***error.messageId***REMOVED***'. Expected one of $***REMOVED***friendlyIDList***REMOVED***.`);
                            ***REMOVED***
                            assert.strictEqual(
                                message.messageId,
                                error.messageId,
                                `messageId '$***REMOVED***message.messageId***REMOVED***' does not match expected messageId '$***REMOVED***error.messageId***REMOVED***'.`
                            );
                            if (hasOwnProperty(error, "data")) ***REMOVED***

                                /*
                                 *  if data was provided, then directly compare the returned message to a synthetic
                                 *  interpolated message using the same message ID and data provided in the test.
                                 *  See https://github.com/eslint/eslint/issues/9890 for context.
                                 */
                                const unformattedOriginalMessage = rule.meta.messages[error.messageId];
                                const rehydratedMessage = interpolate(unformattedOriginalMessage, error.data);

                                assert.strictEqual(
                                    message.message,
                                    rehydratedMessage,
                                    `Hydrated message "$***REMOVED***rehydratedMessage***REMOVED***" does not match "$***REMOVED***message.message***REMOVED***"`
                                );
                            ***REMOVED***
                        ***REMOVED***

                        assert.ok(
                            hasOwnProperty(error, "data") ? hasOwnProperty(error, "messageId") : true,
                            "Error must specify 'messageId' if 'data' is used."
                        );

                        if (error.type) ***REMOVED***
                            assert.strictEqual(message.nodeType, error.type, `Error type should be $***REMOVED***error.type***REMOVED***, found $***REMOVED***message.nodeType***REMOVED***`);
                        ***REMOVED***

                        if (Object.prototype.hasOwnProperty.call(error, "line")) ***REMOVED***
                            assert.strictEqual(message.line, error.line, `Error line should be $***REMOVED***error.line***REMOVED***`);
                        ***REMOVED***

                        if (Object.prototype.hasOwnProperty.call(error, "column")) ***REMOVED***
                            assert.strictEqual(message.column, error.column, `Error column should be $***REMOVED***error.column***REMOVED***`);
                        ***REMOVED***

                        if (Object.prototype.hasOwnProperty.call(error, "endLine")) ***REMOVED***
                            assert.strictEqual(message.endLine, error.endLine, `Error endLine should be $***REMOVED***error.endLine***REMOVED***`);
                        ***REMOVED***

                        if (Object.prototype.hasOwnProperty.call(error, "endColumn")) ***REMOVED***
                            assert.strictEqual(message.endColumn, error.endColumn, `Error endColumn should be $***REMOVED***error.endColumn***REMOVED***`);
                        ***REMOVED***
                    ***REMOVED*** else ***REMOVED***

                        // Message was an unexpected type
                        assert.fail(`Error should be a string, object, or RegExp, but found ($***REMOVED***util.inspect(message)***REMOVED***)`);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***

            if (Object.prototype.hasOwnProperty.call(item, "output")) ***REMOVED***
                if (item.output === null) ***REMOVED***
                    assert.strictEqual(
                        result.output,
                        item.code,
                        "Expected no autofixes to be suggested"
                    );
                ***REMOVED*** else ***REMOVED***
                    assert.strictEqual(result.output, item.output, "Output is incorrect.");
                ***REMOVED***
            ***REMOVED***

            assertASTDidntChange(result.beforeAST, result.afterAST);
        ***REMOVED***

        /*
         * This creates a mocha test suite and pipes all supplied info through
         * one of the templates above.
         */
        RuleTester.describe(ruleName, () => ***REMOVED***
            RuleTester.describe("valid", () => ***REMOVED***
                test.valid.forEach(valid => ***REMOVED***
                    RuleTester.it(sanitize(typeof valid === "object" ? valid.code : valid), () => ***REMOVED***
                        testValidTemplate(valid);
                    ***REMOVED***);
                ***REMOVED***);
            ***REMOVED***);

            RuleTester.describe("invalid", () => ***REMOVED***
                test.invalid.forEach(invalid => ***REMOVED***
                    RuleTester.it(sanitize(invalid.code), () => ***REMOVED***
                        testInvalidTemplate(invalid);
                    ***REMOVED***);
                ***REMOVED***);
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***
***REMOVED***

RuleTester[DESCRIBE] = RuleTester[IT] = null;

module.exports = RuleTester;
