/**
 * @fileoverview Rule to suggest using "Reflect" api over Function/Object methods
 * @author Keith Cirkel <http://keithcirkel.co.uk>
 * @deprecated in ESLint v3.9.0
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "require `Reflect` methods where applicable",
            category: "ECMAScript 6",
            recommended: false,
            url: "https://eslint.org/docs/rules/prefer-reflect"
        ***REMOVED***,

        deprecated: true,

        replacedBy: [],

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    exceptions: ***REMOVED***
                        type: "array",
                        items: ***REMOVED***
                            enum: [
                                "apply",
                                "call",
                                "delete",
                                "defineProperty",
                                "getOwnPropertyDescriptor",
                                "getPrototypeOf",
                                "setPrototypeOf",
                                "isExtensible",
                                "getOwnPropertyNames",
                                "preventExtensions"
                            ]
                        ***REMOVED***,
                        uniqueItems: true
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***
        const existingNames = ***REMOVED***
            apply: "Function.prototype.apply",
            call: "Function.prototype.call",
            defineProperty: "Object.defineProperty",
            getOwnPropertyDescriptor: "Object.getOwnPropertyDescriptor",
            getPrototypeOf: "Object.getPrototypeOf",
            setPrototypeOf: "Object.setPrototypeOf",
            isExtensible: "Object.isExtensible",
            getOwnPropertyNames: "Object.getOwnPropertyNames",
            preventExtensions: "Object.preventExtensions"
        ***REMOVED***;

        const reflectSubsitutes = ***REMOVED***
            apply: "Reflect.apply",
            call: "Reflect.apply",
            defineProperty: "Reflect.defineProperty",
            getOwnPropertyDescriptor: "Reflect.getOwnPropertyDescriptor",
            getPrototypeOf: "Reflect.getPrototypeOf",
            setPrototypeOf: "Reflect.setPrototypeOf",
            isExtensible: "Reflect.isExtensible",
            getOwnPropertyNames: "Reflect.getOwnPropertyNames",
            preventExtensions: "Reflect.preventExtensions"
        ***REMOVED***;

        const exceptions = (context.options[0] || ***REMOVED******REMOVED***).exceptions || [];

        /**
         * Reports the Reflect violation based on the `existing` and `substitute`
         * @param ***REMOVED***Object***REMOVED*** node The node that violates the rule.
         * @param ***REMOVED***string***REMOVED*** existing The existing method name that has been used.
         * @param ***REMOVED***string***REMOVED*** substitute The Reflect substitute that should be used.
         * @returns ***REMOVED***void***REMOVED***
         */
        function report(node, existing, substitute) ***REMOVED***
            context.report(***REMOVED***
                node,
                message: "Avoid using ***REMOVED******REMOVED***existing***REMOVED******REMOVED***, instead use ***REMOVED******REMOVED***substitute***REMOVED******REMOVED***.",
                data: ***REMOVED***
                    existing,
                    substitute
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        return ***REMOVED***
            CallExpression(node) ***REMOVED***
                const methodName = (node.callee.property || ***REMOVED******REMOVED***).name;
                const isReflectCall = (node.callee.object || ***REMOVED******REMOVED***).name === "Reflect";
                const hasReflectSubsitute = Object.prototype.hasOwnProperty.call(reflectSubsitutes, methodName);
                const userConfiguredException = exceptions.indexOf(methodName) !== -1;

                if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) ***REMOVED***
                    report(node, existingNames[methodName], reflectSubsitutes[methodName]);
                ***REMOVED***
            ***REMOVED***,
            UnaryExpression(node) ***REMOVED***
                const isDeleteOperator = node.operator === "delete";
                const targetsIdentifier = node.argument.type === "Identifier";
                const userConfiguredException = exceptions.indexOf("delete") !== -1;

                if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) ***REMOVED***
                    report(node, "the delete keyword", "Reflect.deleteProperty");
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
