/**
 * @fileoverview Rule to flag use of variables before they are defined
 * @author Ilya Volodin
 */

"use strict";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;
const FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;

/**
 * Parses a given value as options.
 *
 * @param ***REMOVED***any***REMOVED*** options - A value to parse.
 * @returns ***REMOVED***Object***REMOVED*** The parsed options.
 */
function parseOptions(options) ***REMOVED***
    let functions = true;
    let classes = true;
    let variables = true;

    if (typeof options === "string") ***REMOVED***
        functions = (options !== "nofunc");
    ***REMOVED*** else if (typeof options === "object" && options !== null) ***REMOVED***
        functions = options.functions !== false;
        classes = options.classes !== false;
        variables = options.variables !== false;
    ***REMOVED***

    return ***REMOVED*** functions, classes, variables ***REMOVED***;
***REMOVED***

/**
 * Checks whether or not a given variable is a function declaration.
 *
 * @param ***REMOVED***eslint-scope.Variable***REMOVED*** variable - A variable to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the variable is a function declaration.
 */
function isFunction(variable) ***REMOVED***
    return variable.defs[0].type === "FunctionName";
***REMOVED***

/**
 * Checks whether or not a given variable is a class declaration in an upper function scope.
 *
 * @param ***REMOVED***eslint-scope.Variable***REMOVED*** variable - A variable to check.
 * @param ***REMOVED***eslint-scope.Reference***REMOVED*** reference - A reference to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the variable is a class declaration.
 */
function isOuterClass(variable, reference) ***REMOVED***
    return (
        variable.defs[0].type === "ClassName" &&
        variable.scope.variableScope !== reference.from.variableScope
    );
***REMOVED***

/**
 * Checks whether or not a given variable is a variable declaration in an upper function scope.
 * @param ***REMOVED***eslint-scope.Variable***REMOVED*** variable - A variable to check.
 * @param ***REMOVED***eslint-scope.Reference***REMOVED*** reference - A reference to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the variable is a variable declaration.
 */
function isOuterVariable(variable, reference) ***REMOVED***
    return (
        variable.defs[0].type === "Variable" &&
        variable.scope.variableScope !== reference.from.variableScope
    );
***REMOVED***

/**
 * Checks whether or not a given location is inside of the range of a given node.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - An node to check.
 * @param ***REMOVED***number***REMOVED*** location - A location to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the location is inside of the range of the node.
 */
function isInRange(node, location) ***REMOVED***
    return node && node.range[0] <= location && location <= node.range[1];
***REMOVED***

/**
 * Checks whether or not a given reference is inside of the initializers of a given variable.
 *
 * This returns `true` in the following cases:
 *
 *     var a = a
 *     var [a = a] = list
 *     var ***REMOVED***a = a***REMOVED*** = obj
 *     for (var a in a) ***REMOVED******REMOVED***
 *     for (var a of a) ***REMOVED******REMOVED***
 *
 * @param ***REMOVED***Variable***REMOVED*** variable - A variable to check.
 * @param ***REMOVED***Reference***REMOVED*** reference - A reference to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the reference is inside of the initializers.
 */
function isInInitializer(variable, reference) ***REMOVED***
    if (variable.scope !== reference.from) ***REMOVED***
        return false;
    ***REMOVED***

    let node = variable.identifiers[0].parent;
    const location = reference.identifier.range[1];

    while (node) ***REMOVED***
        if (node.type === "VariableDeclarator") ***REMOVED***
            if (isInRange(node.init, location)) ***REMOVED***
                return true;
            ***REMOVED***
            if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&
                isInRange(node.parent.parent.right, location)
            ) ***REMOVED***
                return true;
            ***REMOVED***
            break;
        ***REMOVED*** else if (node.type === "AssignmentPattern") ***REMOVED***
            if (isInRange(node.right, location)) ***REMOVED***
                return true;
            ***REMOVED***
        ***REMOVED*** else if (SENTINEL_TYPE.test(node.type)) ***REMOVED***
            break;
        ***REMOVED***

        node = node.parent;
    ***REMOVED***

    return false;
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "problem",

        docs: ***REMOVED***
            description: "disallow the use of variables before they are defined",
            category: "Variables",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-use-before-define"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                oneOf: [
                    ***REMOVED***
                        enum: ["nofunc"]
                    ***REMOVED***,
                    ***REMOVED***
                        type: "object",
                        properties: ***REMOVED***
                            functions: ***REMOVED*** type: "boolean" ***REMOVED***,
                            classes: ***REMOVED*** type: "boolean" ***REMOVED***,
                            variables: ***REMOVED*** type: "boolean" ***REMOVED***
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***
                ]
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***
        const options = parseOptions(context.options[0]);

        /**
         * Determines whether a given use-before-define case should be reported according to the options.
         * @param ***REMOVED***eslint-scope.Variable***REMOVED*** variable The variable that gets used before being defined
         * @param ***REMOVED***eslint-scope.Reference***REMOVED*** reference The reference to the variable
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the usage should be reported
         */
        function isForbidden(variable, reference) ***REMOVED***
            if (isFunction(variable)) ***REMOVED***
                return options.functions;
            ***REMOVED***
            if (isOuterClass(variable, reference)) ***REMOVED***
                return options.classes;
            ***REMOVED***
            if (isOuterVariable(variable, reference)) ***REMOVED***
                return options.variables;
            ***REMOVED***
            return true;
        ***REMOVED***

        /**
         * Finds and validates all variables in a given scope.
         * @param ***REMOVED***Scope***REMOVED*** scope The scope object.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function findVariablesInScope(scope) ***REMOVED***
            scope.references.forEach(reference => ***REMOVED***
                const variable = reference.resolved;

                /*
                 * Skips when the reference is:
                 * - initialization's.
                 * - referring to an undefined variable.
                 * - referring to a global environment variable (there're no identifiers).
                 * - located preceded by the variable (except in initializers).
                 * - allowed by options.
                 */
                if (reference.init ||
                    !variable ||
                    variable.identifiers.length === 0 ||
                    (variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference)) ||
                    !isForbidden(variable, reference)
                ) ***REMOVED***
                    return;
                ***REMOVED***

                // Reports.
                context.report(***REMOVED***
                    node: reference.identifier,
                    message: "'***REMOVED******REMOVED***name***REMOVED******REMOVED***' was used before it was defined.",
                    data: reference.identifier
                ***REMOVED***);
            ***REMOVED***);

            scope.childScopes.forEach(findVariablesInScope);
        ***REMOVED***

        return ***REMOVED***
            Program() ***REMOVED***
                findVariablesInScope(context.getScope());
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
