/**
 * @fileoverview Rule to flag consistent return values
 * @author Nicholas C. Zakas
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const lodash = require("lodash");

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given node is an `Identifier` node which was named a given name.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @param ***REMOVED***string***REMOVED*** name - An expected name of the node.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is an `Identifier` node which was named as expected.
 */
function isIdentifier(node, name) ***REMOVED***
    return node.type === "Identifier" && node.name === name;
***REMOVED***

/**
 * Checks whether or not a given code path segment is unreachable.
 * @param ***REMOVED***CodePathSegment***REMOVED*** segment - A CodePathSegment to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the segment is unreachable.
 */
function isUnreachable(segment) ***REMOVED***
    return !segment.reachable;
***REMOVED***

/**
 * Checks whether a given node is a `constructor` method in an ES6 class
 * @param ***REMOVED***ASTNode***REMOVED*** node A node to check
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a `constructor` method
 */
function isClassConstructor(node) ***REMOVED***
    return node.type === "FunctionExpression" &&
        node.parent &&
        node.parent.type === "MethodDefinition" &&
        node.parent.kind === "constructor";
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "require `return` statements to either always or never specify values",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/consistent-return"
        ***REMOVED***,

        schema: [***REMOVED***
            type: "object",
            properties: ***REMOVED***
                treatUndefinedAsUnspecified: ***REMOVED***
                    type: "boolean",
                    default: false
                ***REMOVED***
            ***REMOVED***,
            additionalProperties: false
        ***REMOVED***],

        messages: ***REMOVED***
            missingReturn: "Expected to return a value at the end of ***REMOVED******REMOVED***name***REMOVED******REMOVED***.",
            missingReturnValue: "***REMOVED******REMOVED***name***REMOVED******REMOVED*** expected a return value.",
            unexpectedReturnValue: "***REMOVED******REMOVED***name***REMOVED******REMOVED*** expected no return value."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const options = context.options[0] || ***REMOVED******REMOVED***;
        const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;
        let funcInfo = null;

        /**
         * Checks whether of not the implicit returning is consistent if the last
         * code path segment is reachable.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node - A program/function node to check.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkLastSegment(node) ***REMOVED***
            let loc, name;

            /*
             * Skip if it expected no return value or unreachable.
             * When unreachable, all paths are returned or thrown.
             */
            if (!funcInfo.hasReturnValue ||
                funcInfo.codePath.currentSegments.every(isUnreachable) ||
                astUtils.isES5Constructor(node) ||
                isClassConstructor(node)
            ) ***REMOVED***
                return;
            ***REMOVED***

            // Adjust a location and a message.
            if (node.type === "Program") ***REMOVED***

                // The head of program.
                loc = ***REMOVED*** line: 1, column: 0 ***REMOVED***;
                name = "program";
            ***REMOVED*** else if (node.type === "ArrowFunctionExpression") ***REMOVED***

                // `=>` token
                loc = context.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc.start;
            ***REMOVED*** else if (
                node.parent.type === "MethodDefinition" ||
                (node.parent.type === "Property" && node.parent.method)
            ) ***REMOVED***

                // Method name.
                loc = node.parent.key.loc.start;
            ***REMOVED*** else ***REMOVED***

                // Function name or `function` keyword.
                loc = (node.id || node).loc.start;
            ***REMOVED***

            if (!name) ***REMOVED***
                name = astUtils.getFunctionNameWithKind(node);
            ***REMOVED***

            // Reports.
            context.report(***REMOVED***
                node,
                loc,
                messageId: "missingReturn",
                data: ***REMOVED*** name ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        return ***REMOVED***

            // Initializes/Disposes state of each code path.
            onCodePathStart(codePath, node) ***REMOVED***
                funcInfo = ***REMOVED***
                    upper: funcInfo,
                    codePath,
                    hasReturn: false,
                    hasReturnValue: false,
                    messageId: "",
                    node
                ***REMOVED***;
            ***REMOVED***,
            onCodePathEnd() ***REMOVED***
                funcInfo = funcInfo.upper;
            ***REMOVED***,

            // Reports a given return statement if it's inconsistent.
            ReturnStatement(node) ***REMOVED***
                const argument = node.argument;
                let hasReturnValue = Boolean(argument);

                if (treatUndefinedAsUnspecified && hasReturnValue) ***REMOVED***
                    hasReturnValue = !isIdentifier(argument, "undefined") && argument.operator !== "void";
                ***REMOVED***

                if (!funcInfo.hasReturn) ***REMOVED***
                    funcInfo.hasReturn = true;
                    funcInfo.hasReturnValue = hasReturnValue;
                    funcInfo.messageId = hasReturnValue ? "missingReturnValue" : "unexpectedReturnValue";
                    funcInfo.data = ***REMOVED***
                        name: funcInfo.node.type === "Program"
                            ? "Program"
                            : lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))
                    ***REMOVED***;
                ***REMOVED*** else if (funcInfo.hasReturnValue !== hasReturnValue) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        messageId: funcInfo.messageId,
                        data: funcInfo.data
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***,

            // Reports a given program/function if the implicit returning is not consistent.
            "Program:exit": checkLastSegment,
            "FunctionDeclaration:exit": checkLastSegment,
            "FunctionExpression:exit": checkLastSegment,
            "ArrowFunctionExpression:exit": checkLastSegment
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
