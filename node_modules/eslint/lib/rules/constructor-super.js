/**
 * @fileoverview A rule to verify `super()` callings in constructor.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether a given code path segment is reachable or not.
 *
 * @param ***REMOVED***CodePathSegment***REMOVED*** segment - A code path segment to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the segment is reachable.
 */
function isReachable(segment) ***REMOVED***
    return segment.reachable;
***REMOVED***

/**
 * Checks whether or not a given node is a constructor.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check. This node type is one of
 *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and
 *   `ArrowFunctionExpression`.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a constructor.
 */
function isConstructorFunction(node) ***REMOVED***
    return (
        node.type === "FunctionExpression" &&
        node.parent.type === "MethodDefinition" &&
        node.parent.kind === "constructor"
    );
***REMOVED***

/**
 * Checks whether a given node can be a constructor or not.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node can be a constructor.
 */
function isPossibleConstructor(node) ***REMOVED***
    if (!node) ***REMOVED***
        return false;
    ***REMOVED***

    switch (node.type) ***REMOVED***
        case "ClassExpression":
        case "FunctionExpression":
        case "ThisExpression":
        case "MemberExpression":
        case "CallExpression":
        case "NewExpression":
        case "YieldExpression":
        case "TaggedTemplateExpression":
        case "MetaProperty":
            return true;

        case "Identifier":
            return node.name !== "undefined";

        case "AssignmentExpression":
            return isPossibleConstructor(node.right);

        case "LogicalExpression":
            return (
                isPossibleConstructor(node.left) ||
                isPossibleConstructor(node.right)
            );

        case "ConditionalExpression":
            return (
                isPossibleConstructor(node.alternate) ||
                isPossibleConstructor(node.consequent)
            );

        case "SequenceExpression": ***REMOVED***
            const lastExpression = node.expressions[node.expressions.length - 1];

            return isPossibleConstructor(lastExpression);
        ***REMOVED***

        default:
            return false;
    ***REMOVED***
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "problem",

        docs: ***REMOVED***
            description: "require `super()` calls in constructors",
            category: "ECMAScript 6",
            recommended: true,
            url: "https://eslint.org/docs/rules/constructor-super"
        ***REMOVED***,

        schema: [],

        messages: ***REMOVED***
            missingSome: "Lacked a call of 'super()' in some code paths.",
            missingAll: "Expected to call 'super()'.",

            duplicate: "Unexpected duplicate 'super()'.",
            badSuper: "Unexpected 'super()' because 'super' is not a constructor.",
            unexpected: "Unexpected 'super()'."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        /*
         * ***REMOVED******REMOVED***hasExtends: boolean, scope: Scope, codePath: CodePath***REMOVED***[]***REMOVED***
         * Information for each constructor.
         * - upper:      Information of the upper constructor.
         * - hasExtends: A flag which shows whether own class has a valid `extends`
         *               part.
         * - scope:      The scope of own class.
         * - codePath:   The code path object of the constructor.
         */
        let funcInfo = null;

        /*
         * ***REMOVED***Map<string, ***REMOVED***calledInSomePaths: boolean, calledInEveryPaths: boolean***REMOVED***>***REMOVED***
         * Information for each code path segment.
         * - calledInSomePaths:  A flag of be called `super()` in some code paths.
         * - calledInEveryPaths: A flag of be called `super()` in all code paths.
         * - validNodes:
         */
        let segInfoMap = Object.create(null);

        /**
         * Gets the flag which shows `super()` is called in some paths.
         * @param ***REMOVED***CodePathSegment***REMOVED*** segment - A code path segment to get.
         * @returns ***REMOVED***boolean***REMOVED*** The flag which shows `super()` is called in some paths
         */
        function isCalledInSomePath(segment) ***REMOVED***
            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;
        ***REMOVED***

        /**
         * Gets the flag which shows `super()` is called in all paths.
         * @param ***REMOVED***CodePathSegment***REMOVED*** segment - A code path segment to get.
         * @returns ***REMOVED***boolean***REMOVED*** The flag which shows `super()` is called in all paths.
         */
        function isCalledInEveryPath(segment) ***REMOVED***

            /*
             * If specific segment is the looped segment of the current segment,
             * skip the segment.
             * If not skipped, this never becomes true after a loop.
             */
            if (segment.nextSegments.length === 1 &&
                segment.nextSegments[0].isLoopedPrevSegment(segment)
            ) ***REMOVED***
                return true;
            ***REMOVED***
            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;
        ***REMOVED***

        return ***REMOVED***

            /**
             * Stacks a constructor information.
             * @param ***REMOVED***CodePath***REMOVED*** codePath - A code path which was started.
             * @param ***REMOVED***ASTNode***REMOVED*** node - The current node.
             * @returns ***REMOVED***void***REMOVED***
             */
            onCodePathStart(codePath, node) ***REMOVED***
                if (isConstructorFunction(node)) ***REMOVED***

                    // Class > ClassBody > MethodDefinition > FunctionExpression
                    const classNode = node.parent.parent.parent;
                    const superClass = classNode.superClass;

                    funcInfo = ***REMOVED***
                        upper: funcInfo,
                        isConstructor: true,
                        hasExtends: Boolean(superClass),
                        superIsConstructor: isPossibleConstructor(superClass),
                        codePath
                    ***REMOVED***;
                ***REMOVED*** else ***REMOVED***
                    funcInfo = ***REMOVED***
                        upper: funcInfo,
                        isConstructor: false,
                        hasExtends: false,
                        superIsConstructor: false,
                        codePath
                    ***REMOVED***;
                ***REMOVED***
            ***REMOVED***,

            /**
             * Pops a constructor information.
             * And reports if `super()` lacked.
             * @param ***REMOVED***CodePath***REMOVED*** codePath - A code path which was ended.
             * @param ***REMOVED***ASTNode***REMOVED*** node - The current node.
             * @returns ***REMOVED***void***REMOVED***
             */
            onCodePathEnd(codePath, node) ***REMOVED***
                const hasExtends = funcInfo.hasExtends;

                // Pop.
                funcInfo = funcInfo.upper;

                if (!hasExtends) ***REMOVED***
                    return;
                ***REMOVED***

                // Reports if `super()` lacked.
                const segments = codePath.returnedSegments;
                const calledInEveryPaths = segments.every(isCalledInEveryPath);
                const calledInSomePaths = segments.some(isCalledInSomePath);

                if (!calledInEveryPaths) ***REMOVED***
                    context.report(***REMOVED***
                        messageId: calledInSomePaths
                            ? "missingSome"
                            : "missingAll",
                        node: node.parent
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***,

            /**
             * Initialize information of a given code path segment.
             * @param ***REMOVED***CodePathSegment***REMOVED*** segment - A code path segment to initialize.
             * @returns ***REMOVED***void***REMOVED***
             */
            onCodePathSegmentStart(segment) ***REMOVED***
                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) ***REMOVED***
                    return;
                ***REMOVED***

                // Initialize info.
                const info = segInfoMap[segment.id] = ***REMOVED***
                    calledInSomePaths: false,
                    calledInEveryPaths: false,
                    validNodes: []
                ***REMOVED***;

                // When there are previous segments, aggregates these.
                const prevSegments = segment.prevSegments;

                if (prevSegments.length > 0) ***REMOVED***
                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
                ***REMOVED***
            ***REMOVED***,

            /**
             * Update information of the code path segment when a code path was
             * looped.
             * @param ***REMOVED***CodePathSegment***REMOVED*** fromSegment - The code path segment of the
             *      end of a loop.
             * @param ***REMOVED***CodePathSegment***REMOVED*** toSegment - A code path segment of the head
             *      of a loop.
             * @returns ***REMOVED***void***REMOVED***
             */
            onCodePathSegmentLoop(fromSegment, toSegment) ***REMOVED***
                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) ***REMOVED***
                    return;
                ***REMOVED***

                // Update information inside of the loop.
                const isRealLoop = toSegment.prevSegments.length >= 2;

                funcInfo.codePath.traverseSegments(
                    ***REMOVED*** first: toSegment, last: fromSegment ***REMOVED***,
                    segment => ***REMOVED***
                        const info = segInfoMap[segment.id];
                        const prevSegments = segment.prevSegments;

                        // Updates flags.
                        info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
                        info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);

                        // If flags become true anew, reports the valid nodes.
                        if (info.calledInSomePaths || isRealLoop) ***REMOVED***
                            const nodes = info.validNodes;

                            info.validNodes = [];

                            for (let i = 0; i < nodes.length; ++i) ***REMOVED***
                                const node = nodes[i];

                                context.report(***REMOVED***
                                    messageId: "duplicate",
                                    node
                                ***REMOVED***);
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***
                );
            ***REMOVED***,

            /**
             * Checks for a call of `super()`.
             * @param ***REMOVED***ASTNode***REMOVED*** node - A CallExpression node to check.
             * @returns ***REMOVED***void***REMOVED***
             */
            "CallExpression:exit"(node) ***REMOVED***
                if (!(funcInfo && funcInfo.isConstructor)) ***REMOVED***
                    return;
                ***REMOVED***

                // Skips except `super()`.
                if (node.callee.type !== "Super") ***REMOVED***
                    return;
                ***REMOVED***

                // Reports if needed.
                if (funcInfo.hasExtends) ***REMOVED***
                    const segments = funcInfo.codePath.currentSegments;
                    let duplicate = false;
                    let info = null;

                    for (let i = 0; i < segments.length; ++i) ***REMOVED***
                        const segment = segments[i];

                        if (segment.reachable) ***REMOVED***
                            info = segInfoMap[segment.id];

                            duplicate = duplicate || info.calledInSomePaths;
                            info.calledInSomePaths = info.calledInEveryPaths = true;
                        ***REMOVED***
                    ***REMOVED***

                    if (info) ***REMOVED***
                        if (duplicate) ***REMOVED***
                            context.report(***REMOVED***
                                messageId: "duplicate",
                                node
                            ***REMOVED***);
                        ***REMOVED*** else if (!funcInfo.superIsConstructor) ***REMOVED***
                            context.report(***REMOVED***
                                messageId: "badSuper",
                                node
                            ***REMOVED***);
                        ***REMOVED*** else ***REMOVED***
                            info.validNodes.push(node);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED*** else if (funcInfo.codePath.currentSegments.some(isReachable)) ***REMOVED***
                    context.report(***REMOVED***
                        messageId: "unexpected",
                        node
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***,

            /**
             * Set the mark to the returned path as `super()` was called.
             * @param ***REMOVED***ASTNode***REMOVED*** node - A ReturnStatement node to check.
             * @returns ***REMOVED***void***REMOVED***
             */
            ReturnStatement(node) ***REMOVED***
                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) ***REMOVED***
                    return;
                ***REMOVED***

                // Skips if no argument.
                if (!node.argument) ***REMOVED***
                    return;
                ***REMOVED***

                // Returning argument is a substitute of 'super()'.
                const segments = funcInfo.codePath.currentSegments;

                for (let i = 0; i < segments.length; ++i) ***REMOVED***
                    const segment = segments[i];

                    if (segment.reachable) ***REMOVED***
                        const info = segInfoMap[segment.id];

                        info.calledInSomePaths = info.calledInEveryPaths = true;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***,

            /**
             * Resets state.
             * @returns ***REMOVED***void***REMOVED***
             */
            "Program:exit"() ***REMOVED***
                segInfoMap = Object.create(null);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
