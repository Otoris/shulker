/**
 * @fileoverview Rule to enforce consistent naming of "this" context variables
 * @author Raphael Pigulla
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "enforce consistent naming when capturing the current execution context",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/consistent-this"
        ***REMOVED***,

        schema: ***REMOVED***
            type: "array",
            items: ***REMOVED***
                type: "string",
                minLength: 1
            ***REMOVED***,
            uniqueItems: true
        ***REMOVED***,

        messages: ***REMOVED***
            aliasNotAssignedToThis: "Designated alias '***REMOVED******REMOVED***name***REMOVED******REMOVED***' is not assigned to 'this'.",
            unexpectedAlias: "Unexpected alias '***REMOVED******REMOVED***name***REMOVED******REMOVED***' for 'this'."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        let aliases = [];

        if (context.options.length === 0) ***REMOVED***
            aliases.push("that");
        ***REMOVED*** else ***REMOVED***
            aliases = context.options;
        ***REMOVED***

        /**
         * Reports that a variable declarator or assignment expression is assigning
         * a non-'this' value to the specified alias.
         * @param ***REMOVED***ASTNode***REMOVED*** node - The assigning node.
         * @param ***REMOVED***string***REMOVED***  name - the name of the alias that was incorrectly used.
         * @returns ***REMOVED***void***REMOVED***
         */
        function reportBadAssignment(node, name) ***REMOVED***
            context.report(***REMOVED*** node, messageId: "aliasNotAssignedToThis", data: ***REMOVED*** name ***REMOVED*** ***REMOVED***);
        ***REMOVED***

        /**
         * Checks that an assignment to an identifier only assigns 'this' to the
         * appropriate alias, and the alias is only assigned to 'this'.
         * @param ***REMOVED***ASTNode***REMOVED*** node - The assigning node.
         * @param ***REMOVED***Identifier***REMOVED*** name - The name of the variable assigned to.
         * @param ***REMOVED***Expression***REMOVED*** value - The value of the assignment.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkAssignment(node, name, value) ***REMOVED***
            const isThis = value.type === "ThisExpression";

            if (aliases.indexOf(name) !== -1) ***REMOVED***
                if (!isThis || node.operator && node.operator !== "=") ***REMOVED***
                    reportBadAssignment(node, name);
                ***REMOVED***
            ***REMOVED*** else if (isThis) ***REMOVED***
                context.report(***REMOVED*** node, messageId: "unexpectedAlias", data: ***REMOVED*** name ***REMOVED*** ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Ensures that a variable declaration of the alias in a program or function
         * is assigned to the correct value.
         * @param ***REMOVED***string***REMOVED*** alias alias the check the assignment of.
         * @param ***REMOVED***Object***REMOVED*** scope scope of the current code we are checking.
         * @private
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkWasAssigned(alias, scope) ***REMOVED***
            const variable = scope.set.get(alias);

            if (!variable) ***REMOVED***
                return;
            ***REMOVED***

            if (variable.defs.some(def => def.node.type === "VariableDeclarator" &&
                def.node.init !== null)) ***REMOVED***
                return;
            ***REMOVED***

            /*
             * The alias has been declared and not assigned: check it was
             * assigned later in the same scope.
             */
            if (!variable.references.some(reference => ***REMOVED***
                const write = reference.writeExpr;

                return (
                    reference.from === scope &&
                    write && write.type === "ThisExpression" &&
                    write.parent.operator === "="
                );
            ***REMOVED***)) ***REMOVED***
                variable.defs.map(def => def.node).forEach(node => ***REMOVED***
                    reportBadAssignment(node, alias);
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Check each alias to ensure that is was assinged to the correct value.
         * @returns ***REMOVED***void***REMOVED***
         */
        function ensureWasAssigned() ***REMOVED***
            const scope = context.getScope();

            aliases.forEach(alias => ***REMOVED***
                checkWasAssigned(alias, scope);
            ***REMOVED***);
        ***REMOVED***

        return ***REMOVED***
            "Program:exit": ensureWasAssigned,
            "FunctionExpression:exit": ensureWasAssigned,
            "FunctionDeclaration:exit": ensureWasAssigned,

            VariableDeclarator(node) ***REMOVED***
                const id = node.id;
                const isDestructuring =
                    id.type === "ArrayPattern" || id.type === "ObjectPattern";

                if (node.init !== null && !isDestructuring) ***REMOVED***
                    checkAssignment(node, id.name, node.init);
                ***REMOVED***
            ***REMOVED***,

            AssignmentExpression(node) ***REMOVED***
                if (node.left.type === "Identifier") ***REMOVED***
                    checkAssignment(node, node.left.name, node.right);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
