/**
 * @fileoverview Disallow trailing spaces at the end of lines.
 * @author Nodeca Team <https://github.com/nodeca>
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "disallow trailing whitespace at the end of lines",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-trailing-spaces"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    skipBlankLines: ***REMOVED***
                        type: "boolean",
                        default: false
                    ***REMOVED***,
                    ignoreComments: ***REMOVED***
                        type: "boolean",
                        default: false
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();

        const BLANK_CLASS = "[ \t\u00a0\u2000-\u200b\u3000]",
            SKIP_BLANK = `^$***REMOVED***BLANK_CLASS***REMOVED****$`,
            NONBLANK = `$***REMOVED***BLANK_CLASS***REMOVED***+$`;

        const options = context.options[0] || ***REMOVED******REMOVED***,
            skipBlankLines = options.skipBlankLines || false,
            ignoreComments = options.ignoreComments || false;

        /**
         * Report the error message
         * @param ***REMOVED***ASTNode***REMOVED*** node node to report
         * @param ***REMOVED***int[]***REMOVED*** location range information
         * @param ***REMOVED***int[]***REMOVED*** fixRange Range based on the whole program
         * @returns ***REMOVED***void***REMOVED***
         */
        function report(node, location, fixRange) ***REMOVED***

            /*
             * Passing node is a bit dirty, because message data will contain big
             * text in `source`. But... who cares :) ?
             * One more kludge will not make worse the bloody wizardry of this
             * plugin.
             */
            context.report(***REMOVED***
                node,
                loc: location,
                message: "Trailing spaces not allowed.",
                fix(fixer) ***REMOVED***
                    return fixer.removeRange(fixRange);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        /**
         * Given a list of comment nodes, return the line numbers for those comments.
         * @param ***REMOVED***Array***REMOVED*** comments An array of comment nodes.
         * @returns ***REMOVED***number[]***REMOVED*** An array of line numbers containing comments.
         */
        function getCommentLineNumbers(comments) ***REMOVED***
            const lines = new Set();

            comments.forEach(comment => ***REMOVED***
                for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) ***REMOVED***
                    lines.add(i);
                ***REMOVED***
            ***REMOVED***);

            return lines;
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***

            Program: function checkTrailingSpaces(node) ***REMOVED***

                /*
                 * Let's hack. Since Espree does not return whitespace nodes,
                 * fetch the source code and do matching via regexps.
                 */

                const re = new RegExp(NONBLANK, "u"),
                    skipMatch = new RegExp(SKIP_BLANK, "u"),
                    lines = sourceCode.lines,
                    linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()),
                    comments = sourceCode.getAllComments(),
                    commentLineNumbers = getCommentLineNumbers(comments);

                let totalLength = 0,
                    fixRange = [];

                for (let i = 0, ii = lines.length; i < ii; i++) ***REMOVED***
                    const matches = re.exec(lines[i]);

                    /*
                     * Always add linebreak length to line length to accommodate for line break (\n or \r\n)
                     * Because during the fix time they also reserve one spot in the array.
                     * Usually linebreak length is 2 for \r\n (CRLF) and 1 for \n (LF)
                     */
                    const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;
                    const lineLength = lines[i].length + linebreakLength;

                    if (matches) ***REMOVED***
                        const location = ***REMOVED***
                            line: i + 1,
                            column: matches.index
                        ***REMOVED***;

                        const rangeStart = totalLength + location.column;
                        const rangeEnd = totalLength + lineLength - linebreakLength;
                        const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);

                        if (containingNode && containingNode.type === "TemplateElement" &&
                          rangeStart > containingNode.parent.range[0] &&
                          rangeEnd < containingNode.parent.range[1]) ***REMOVED***
                            totalLength += lineLength;
                            continue;
                        ***REMOVED***

                        /*
                         * If the line has only whitespace, and skipBlankLines
                         * is true, don't report it
                         */
                        if (skipBlankLines && skipMatch.test(lines[i])) ***REMOVED***
                            totalLength += lineLength;
                            continue;
                        ***REMOVED***

                        fixRange = [rangeStart, rangeEnd];

                        if (!ignoreComments || !commentLineNumbers.has(location.line)) ***REMOVED***
                            report(node, location, fixRange);
                        ***REMOVED***
                    ***REMOVED***

                    totalLength += lineLength;
                ***REMOVED***
            ***REMOVED***

        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
