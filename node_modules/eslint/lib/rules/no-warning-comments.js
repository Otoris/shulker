/**
 * @fileoverview Rule that warns about used warning comments
 * @author Alexander Schmidt <https://github.com/lxanders>
 */

"use strict";

const ***REMOVED*** escapeRegExp ***REMOVED*** = require("lodash");
const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow specified warning terms in comments",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-warning-comments"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    terms: ***REMOVED***
                        type: "array",
                        items: ***REMOVED***
                            type: "string"
                        ***REMOVED***
                    ***REMOVED***,
                    location: ***REMOVED***
                        enum: ["start", "anywhere"]
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***

        const sourceCode = context.getSourceCode(),
            configuration = context.options[0] || ***REMOVED******REMOVED***,
            warningTerms = configuration.terms || ["todo", "fixme", "xxx"],
            location = configuration.location || "start",
            selfConfigRegEx = /\bno-warning-comments\b/u;

        /**
         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified
         * location ("start" or "anywhere"). If the term starts or ends with non word characters, then the match will not
         * require word boundaries on that side.
         *
         * @param ***REMOVED***string***REMOVED*** term A term to convert to a RegExp
         * @returns ***REMOVED***RegExp***REMOVED*** The term converted to a RegExp
         */
        function convertToRegExp(term) ***REMOVED***
            const escaped = escapeRegExp(term);
            const wordBoundary = "\\b";
            const eitherOrWordBoundary = `|$***REMOVED***wordBoundary***REMOVED***`;
            let prefix;

            /*
             * If the term ends in a word character (a-z0-9_), ensure a word
             * boundary at the end, so that substrings do not get falsely
             * matched. eg "todo" in a string such as "mastodon".
             * If the term ends in a non-word character, then \b won't match on
             * the boundary to the next non-word character, which would likely
             * be a space. For example `/\bFIX!\b/.test('FIX! blah') === false`.
             * In these cases, use no bounding match. Same applies for the
             * prefix, handled below.
             */
            const suffix = /\w$/u.test(term) ? "\\b" : "";

            if (location === "start") ***REMOVED***

                /*
                 * When matching at the start, ignore leading whitespace, and
                 * there's no need to worry about word boundaries.
                 */
                prefix = "^\\s*";
            ***REMOVED*** else if (/^\w/u.test(term)) ***REMOVED***
                prefix = wordBoundary;
            ***REMOVED*** else ***REMOVED***
                prefix = "";
            ***REMOVED***

            if (location === "start") ***REMOVED***

                /*
                 * For location "start" the regex should be
                 * ^\s*TERM\b.  This checks the word boundary
                 * at the beginning of the comment.
                 */
                return new RegExp(prefix + escaped + suffix, "iu");
            ***REMOVED***

            /*
             * For location "anywhere" the regex should be
             * \bTERM\b|\bTERM\b, this checks the entire comment
             * for the term.
             */
            return new RegExp(prefix + escaped + suffix + eitherOrWordBoundary + term + wordBoundary, "iu");
        ***REMOVED***

        const warningRegExps = warningTerms.map(convertToRegExp);

        /**
         * Checks the specified comment for matches of the configured warning terms and returns the matches.
         * @param ***REMOVED***string***REMOVED*** comment The comment which is checked.
         * @returns ***REMOVED***Array***REMOVED*** All matched warning terms for this comment.
         */
        function commentContainsWarningTerm(comment) ***REMOVED***
            const matches = [];

            warningRegExps.forEach((regex, index) => ***REMOVED***
                if (regex.test(comment)) ***REMOVED***
                    matches.push(warningTerms[index]);
                ***REMOVED***
            ***REMOVED***);

            return matches;
        ***REMOVED***

        /**
         * Checks the specified node for matching warning comments and reports them.
         * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
         * @returns ***REMOVED***void***REMOVED*** undefined.
         */
        function checkComment(node) ***REMOVED***
            if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) ***REMOVED***
                return;
            ***REMOVED***

            const matches = commentContainsWarningTerm(node.value);

            matches.forEach(matchedTerm => ***REMOVED***
                context.report(***REMOVED***
                    node,
                    message: "Unexpected '***REMOVED******REMOVED***matchedTerm***REMOVED******REMOVED***' comment.",
                    data: ***REMOVED***
                        matchedTerm
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***);
        ***REMOVED***

        return ***REMOVED***
            Program() ***REMOVED***
                const comments = sourceCode.getAllComments();

                comments.filter(token => token.type !== "Shebang").forEach(checkComment);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
