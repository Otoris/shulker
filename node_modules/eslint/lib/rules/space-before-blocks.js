/**
 * @fileoverview A rule to ensure whitespace before blocks.
 * @author Mathias Schreck <https://github.com/lo1tuma>
 */

"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "enforce consistent spacing before blocks",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/space-before-blocks"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            ***REMOVED***
                oneOf: [
                    ***REMOVED***
                        enum: ["always", "never"]
                    ***REMOVED***,
                    ***REMOVED***
                        type: "object",
                        properties: ***REMOVED***
                            keywords: ***REMOVED***
                                enum: ["always", "never", "off"]
                            ***REMOVED***,
                            functions: ***REMOVED***
                                enum: ["always", "never", "off"]
                            ***REMOVED***,
                            classes: ***REMOVED***
                                enum: ["always", "never", "off"]
                            ***REMOVED***
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***
                ]
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***
        const config = context.options[0],
            sourceCode = context.getSourceCode();
        let alwaysFunctions = true,
            alwaysKeywords = true,
            alwaysClasses = true,
            neverFunctions = false,
            neverKeywords = false,
            neverClasses = false;

        if (typeof config === "object") ***REMOVED***
            alwaysFunctions = config.functions === "always";
            alwaysKeywords = config.keywords === "always";
            alwaysClasses = config.classes === "always";
            neverFunctions = config.functions === "never";
            neverKeywords = config.keywords === "never";
            neverClasses = config.classes === "never";
        ***REMOVED*** else if (config === "never") ***REMOVED***
            alwaysFunctions = false;
            alwaysKeywords = false;
            alwaysClasses = false;
            neverFunctions = true;
            neverKeywords = true;
            neverClasses = true;
        ***REMOVED***

        /**
         * Checks whether or not a given token is an arrow operator (=>) or a keyword
         * in order to avoid to conflict with `arrow-spacing` and `keyword-spacing`.
         *
         * @param ***REMOVED***Token***REMOVED*** token - A token to check.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is an arrow operator.
         */
        function isConflicted(token) ***REMOVED***
            return (token.type === "Punctuator" && token.value === "=>") || token.type === "Keyword";
        ***REMOVED***

        /**
         * Checks the given BlockStatement node has a preceding space if it doesnâ€™t start on a new line.
         * @param ***REMOVED***ASTNode|Token***REMOVED*** node The AST node of a BlockStatement.
         * @returns ***REMOVED***void***REMOVED*** undefined.
         */
        function checkPrecedingSpace(node) ***REMOVED***
            const precedingToken = sourceCode.getTokenBefore(node);

            if (precedingToken && !isConflicted(precedingToken) && astUtils.isTokenOnSameLine(precedingToken, node)) ***REMOVED***
                const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);
                const parent = context.getAncestors().pop();
                let requireSpace;
                let requireNoSpace;

                if (parent.type === "FunctionExpression" || parent.type === "FunctionDeclaration") ***REMOVED***
                    requireSpace = alwaysFunctions;
                    requireNoSpace = neverFunctions;
                ***REMOVED*** else if (node.type === "ClassBody") ***REMOVED***
                    requireSpace = alwaysClasses;
                    requireNoSpace = neverClasses;
                ***REMOVED*** else ***REMOVED***
                    requireSpace = alwaysKeywords;
                    requireNoSpace = neverKeywords;
                ***REMOVED***

                if (requireSpace && !hasSpace) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        message: "Missing space before opening brace.",
                        fix(fixer) ***REMOVED***
                            return fixer.insertTextBefore(node, " ");
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED*** else if (requireNoSpace && hasSpace) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        message: "Unexpected space before opening brace.",
                        fix(fixer) ***REMOVED***
                            return fixer.removeRange([precedingToken.range[1], node.range[0]]);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node of a SwitchStatement.
         * @returns ***REMOVED***void***REMOVED*** undefined.
         */
        function checkSpaceBeforeCaseBlock(node) ***REMOVED***
            const cases = node.cases;
            let openingBrace;

            if (cases.length > 0) ***REMOVED***
                openingBrace = sourceCode.getTokenBefore(cases[0]);
            ***REMOVED*** else ***REMOVED***
                openingBrace = sourceCode.getLastToken(node, 1);
            ***REMOVED***

            checkPrecedingSpace(openingBrace);
        ***REMOVED***

        return ***REMOVED***
            BlockStatement: checkPrecedingSpace,
            ClassBody: checkPrecedingSpace,
            SwitchStatement: checkSpaceBeforeCaseBlock
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
