/**
 * @fileoverview Rule to flag updates of imported bindings.
 * @author Toru Nagashima <https://github.com/mysticatea>
 */

"use strict";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const ***REMOVED*** findVariable, getPropertyName ***REMOVED*** = require("eslint-utils");

const MutationMethods = ***REMOVED***
    Object: new Set([
        "assign", "defineProperties", "defineProperty", "freeze",
        "setPrototypeOf"
    ]),
    Reflect: new Set([
        "defineProperty", "deleteProperty", "set", "setPrototypeOf"
    ])
***REMOVED***;

/**
 * Check if a given node is LHS of an assignment node.
 * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is LHS.
 */
function isAssignmentLeft(node) ***REMOVED***
    const ***REMOVED*** parent ***REMOVED*** = node;

    return (
        (
            parent.type === "AssignmentExpression" &&
            parent.left === node
        ) ||

        // Destructuring assignments
        parent.type === "ArrayPattern" ||
        (
            parent.type === "Property" &&
            parent.value === node &&
            parent.parent.type === "ObjectPattern"
        ) ||
        parent.type === "RestElement" ||
        (
            parent.type === "AssignmentPattern" &&
            parent.left === node
        )
    );
***REMOVED***

/**
 * Check if a given node is the operand of mutation unary operator.
 * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is the operand of mutation unary operator.
 */
function isOperandOfMutationUnaryOperator(node) ***REMOVED***
    const ***REMOVED*** parent ***REMOVED*** = node;

    return (
        (
            parent.type === "UpdateExpression" &&
            parent.argument === node
        ) ||
        (
            parent.type === "UnaryExpression" &&
            parent.operator === "delete" &&
            parent.argument === node
        )
    );
***REMOVED***

/**
 * Check if a given node is the iteration variable of `for-in`/`for-of` syntax.
 * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is the iteration variable.
 */
function isIterationVariable(node) ***REMOVED***
    const ***REMOVED*** parent ***REMOVED*** = node;

    return (
        (
            parent.type === "ForInStatement" &&
            parent.left === node
        ) ||
        (
            parent.type === "ForOfStatement" &&
            parent.left === node
        )
    );
***REMOVED***

/**
 * Check if a given node is the iteration variable of `for-in`/`for-of` syntax.
 * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
 * @param ***REMOVED***Scope***REMOVED*** scope A `escope.Scope` object to find variable (whichever).
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is the iteration variable.
 */
function isArgumentOfWellKnownMutationFunction(node, scope) ***REMOVED***
    const ***REMOVED*** parent ***REMOVED*** = node;

    if (
        parent.type === "CallExpression" &&
        parent.arguments[0] === node &&
        parent.callee.type === "MemberExpression" &&
        parent.callee.object.type === "Identifier"
    ) ***REMOVED***
        const ***REMOVED*** callee ***REMOVED*** = parent;
        const ***REMOVED*** object ***REMOVED*** = callee;

        if (Object.keys(MutationMethods).includes(object.name)) ***REMOVED***
            const variable = findVariable(scope, object);

            return (
                variable !== null &&
                variable.scope.type === "global" &&
                MutationMethods[object.name].has(getPropertyName(callee, scope))
            );
        ***REMOVED***
    ***REMOVED***

    return false;
***REMOVED***

/**
 * Check if the identifier node is placed at to update members.
 * @param ***REMOVED***ASTNode***REMOVED*** id The Identifier node to check.
 * @param ***REMOVED***Scope***REMOVED*** scope A `escope.Scope` object to find variable (whichever).
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the member of `id` was updated.
 */
function isMemberWrite(id, scope) ***REMOVED***
    const ***REMOVED*** parent ***REMOVED*** = id;

    return (
        (
            parent.type === "MemberExpression" &&
            parent.object === id &&
            (
                isAssignmentLeft(parent) ||
                isOperandOfMutationUnaryOperator(parent) ||
                isIterationVariable(parent)
            )
        ) ||
        isArgumentOfWellKnownMutationFunction(id, scope)
    );
***REMOVED***

/**
 * Get the mutation node.
 * @param ***REMOVED***ASTNode***REMOVED*** id The Identifier node to get.
 * @returns ***REMOVED***ASTNode***REMOVED*** The mutation node.
 */
function getWriteNode(id) ***REMOVED***
    let node = id.parent;

    while (
        node &&
        node.type !== "AssignmentExpression" &&
        node.type !== "UpdateExpression" &&
        node.type !== "UnaryExpression" &&
        node.type !== "CallExpression" &&
        node.type !== "ForInStatement" &&
        node.type !== "ForOfStatement"
    ) ***REMOVED***
        node = node.parent;
    ***REMOVED***

    return node || id;
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "problem",

        docs: ***REMOVED***
            description: "disallow assigning to imported bindings",
            category: "Possible Errors",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-import-assign"
        ***REMOVED***,

        schema: [],

        messages: ***REMOVED***
            readonly: "'***REMOVED******REMOVED***name***REMOVED******REMOVED***' is read-only.",
            readonlyMember: "The members of '***REMOVED******REMOVED***name***REMOVED******REMOVED***' are read-only."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        return ***REMOVED***
            ImportDeclaration(node) ***REMOVED***
                const scope = context.getScope();

                for (const variable of context.getDeclaredVariables(node)) ***REMOVED***
                    const shouldCheckMembers = variable.defs.some(
                        d => d.node.type === "ImportNamespaceSpecifier"
                    );
                    let prevIdNode = null;

                    for (const reference of variable.references) ***REMOVED***
                        const idNode = reference.identifier;

                        /*
                         * AssignmentPattern (e.g. `[a = 0] = b`) makes two write
                         * references for the same identifier. This should skip
                         * the one of the two in order to prevent redundant reports.
                         */
                        if (idNode === prevIdNode) ***REMOVED***
                            continue;
                        ***REMOVED***
                        prevIdNode = idNode;

                        if (reference.isWrite()) ***REMOVED***
                            context.report(***REMOVED***
                                node: getWriteNode(idNode),
                                messageId: "readonly",
                                data: ***REMOVED*** name: idNode.name ***REMOVED***
                            ***REMOVED***);
                        ***REMOVED*** else if (shouldCheckMembers && isMemberWrite(idNode, scope)) ***REMOVED***
                            context.report(***REMOVED***
                                node: getWriteNode(idNode),
                                messageId: "readonlyMember",
                                data: ***REMOVED*** name: idNode.name ***REMOVED***
                            ***REMOVED***);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
