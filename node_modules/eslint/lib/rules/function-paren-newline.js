/**
 * @fileoverview enforce consistent line breaks inside function parentheses
 * @author Teddy Katz
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "enforce consistent line breaks inside function parentheses",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/function-paren-newline"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            ***REMOVED***
                oneOf: [
                    ***REMOVED***
                        enum: ["always", "never", "consistent", "multiline", "multiline-arguments"]
                    ***REMOVED***,
                    ***REMOVED***
                        type: "object",
                        properties: ***REMOVED***
                            minItems: ***REMOVED***
                                type: "integer",
                                minimum: 0
                            ***REMOVED***
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***
                ]
            ***REMOVED***
        ],

        messages: ***REMOVED***
            expectedBefore: "Expected newline before ')'.",
            expectedAfter: "Expected newline after '('.",
            expectedBetween: "Expected newline between arguments/params.",
            unexpectedBefore: "Unexpected newline before ')'.",
            unexpectedAfter: "Unexpected newline after '('."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();
        const rawOption = context.options[0] || "multiline";
        const multilineOption = rawOption === "multiline";
        const multilineArgumentsOption = rawOption === "multiline-arguments";
        const consistentOption = rawOption === "consistent";
        let minItems;

        if (typeof rawOption === "object") ***REMOVED***
            minItems = rawOption.minItems;
        ***REMOVED*** else if (rawOption === "always") ***REMOVED***
            minItems = 0;
        ***REMOVED*** else if (rawOption === "never") ***REMOVED***
            minItems = Infinity;
        ***REMOVED*** else ***REMOVED***
            minItems = null;
        ***REMOVED***

        //----------------------------------------------------------------------
        // Helpers
        //----------------------------------------------------------------------

        /**
         * Determines whether there should be newlines inside function parens
         * @param ***REMOVED***ASTNode[]***REMOVED*** elements The arguments or parameters in the list
         * @param ***REMOVED***boolean***REMOVED*** hasLeftNewline `true` if the left paren has a newline in the current code.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if there should be newlines inside the function parens
         */
        function shouldHaveNewlines(elements, hasLeftNewline) ***REMOVED***
            if (multilineArgumentsOption && elements.length === 1) ***REMOVED***
                return hasLeftNewline;
            ***REMOVED***
            if (multilineOption || multilineArgumentsOption) ***REMOVED***
                return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);
            ***REMOVED***
            if (consistentOption) ***REMOVED***
                return hasLeftNewline;
            ***REMOVED***
            return elements.length >= minItems;
        ***REMOVED***

        /**
         * Validates parens
         * @param ***REMOVED***Object***REMOVED*** parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token
         * @param ***REMOVED***ASTNode[]***REMOVED*** elements The arguments or parameters in the list
         * @returns ***REMOVED***void***REMOVED***
         */
        function validateParens(parens, elements) ***REMOVED***
            const leftParen = parens.leftParen;
            const rightParen = parens.rightParen;
            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
            const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);
            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);
            const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);
            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);

            if (hasLeftNewline && !needsNewlines) ***REMOVED***
                context.report(***REMOVED***
                    node: leftParen,
                    messageId: "unexpectedAfter",
                    fix(fixer) ***REMOVED***
                        return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim()

                            // If there is a comment between the ( and the first element, don't do a fix.
                            ? null
                            : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED*** else if (!hasLeftNewline && needsNewlines) ***REMOVED***
                context.report(***REMOVED***
                    node: leftParen,
                    messageId: "expectedAfter",
                    fix: fixer => fixer.insertTextAfter(leftParen, "\n")
                ***REMOVED***);
            ***REMOVED***

            if (hasRightNewline && !needsNewlines) ***REMOVED***
                context.report(***REMOVED***
                    node: rightParen,
                    messageId: "unexpectedBefore",
                    fix(fixer) ***REMOVED***
                        return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim()

                            // If there is a comment between the last element and the ), don't do a fix.
                            ? null
                            : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED*** else if (!hasRightNewline && needsNewlines) ***REMOVED***
                context.report(***REMOVED***
                    node: rightParen,
                    messageId: "expectedBefore",
                    fix: fixer => fixer.insertTextBefore(rightParen, "\n")
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Validates a list of arguments or parameters
         * @param ***REMOVED***Object***REMOVED*** parens An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token
         * @param ***REMOVED***ASTNode[]***REMOVED*** elements The arguments or parameters in the list
         * @returns ***REMOVED***void***REMOVED***
         */
        function validateArguments(parens, elements) ***REMOVED***
            const leftParen = parens.leftParen;
            const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
            const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);
            const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);

            for (let i = 0; i <= elements.length - 2; i++) ***REMOVED***
                const currentElement = elements[i];
                const nextElement = elements[i + 1];
                const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;

                if (!hasNewLine && needsNewlines) ***REMOVED***
                    context.report(***REMOVED***
                        node: currentElement,
                        messageId: "expectedBetween",
                        fix: fixer => fixer.insertTextBefore(nextElement, "\n")
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Gets the left paren and right paren tokens of a node.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node with parens
         * @returns ***REMOVED***Object***REMOVED*** An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token.
         * Can also return `null` if an expression has no parens (e.g. a NewExpression with no arguments, or an ArrowFunctionExpression
         * with a single parameter)
         */
        function getParenTokens(node) ***REMOVED***
            switch (node.type) ***REMOVED***
                case "NewExpression":
                    if (!node.arguments.length && !(
                        astUtils.isOpeningParenToken(sourceCode.getLastToken(node, ***REMOVED*** skip: 1 ***REMOVED***)) &&
                        astUtils.isClosingParenToken(sourceCode.getLastToken(node))
                    )) ***REMOVED***

                        // If the NewExpression does not have parens (e.g. `new Foo`), return null.
                        return null;
                    ***REMOVED***

                    // falls through

                case "CallExpression":
                    return ***REMOVED***
                        leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),
                        rightParen: sourceCode.getLastToken(node)
                    ***REMOVED***;

                case "FunctionDeclaration":
                case "FunctionExpression": ***REMOVED***
                    const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
                    const rightParen = node.params.length
                        ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken)
                        : sourceCode.getTokenAfter(leftParen);

                    return ***REMOVED*** leftParen, rightParen ***REMOVED***;
                ***REMOVED***

                case "ArrowFunctionExpression": ***REMOVED***
                    const firstToken = sourceCode.getFirstToken(node);

                    if (!astUtils.isOpeningParenToken(firstToken)) ***REMOVED***

                        // If the ArrowFunctionExpression has a single param without parens, return null.
                        return null;
                    ***REMOVED***

                    return ***REMOVED***
                        leftParen: firstToken,
                        rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)
                    ***REMOVED***;
                ***REMOVED***

                case "ImportExpression": ***REMOVED***
                    const leftParen = sourceCode.getFirstToken(node, 1);
                    const rightParen = sourceCode.getLastToken(node);

                    return ***REMOVED*** leftParen, rightParen ***REMOVED***;
                ***REMOVED***

                default:
                    throw new TypeError(`unexpected node with type $***REMOVED***node.type***REMOVED***`);
            ***REMOVED***
        ***REMOVED***

        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------

        return ***REMOVED***
            [[
                "ArrowFunctionExpression",
                "CallExpression",
                "FunctionDeclaration",
                "FunctionExpression",
                "ImportExpression",
                "NewExpression"
            ]](node) ***REMOVED***
                const parens = getParenTokens(node);
                let params;

                if (node.type === "ImportExpression") ***REMOVED***
                    params = [node.source];
                ***REMOVED*** else if (astUtils.isFunction(node)) ***REMOVED***
                    params = node.params;
                ***REMOVED*** else ***REMOVED***
                    params = node.arguments;
                ***REMOVED***

                if (parens) ***REMOVED***
                    validateParens(parens, params);

                    if (multilineArgumentsOption) ***REMOVED***
                        validateArguments(parens, params);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
