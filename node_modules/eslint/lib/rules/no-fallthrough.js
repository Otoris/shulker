/**
 * @fileoverview Rule to flag fall-through cases in switch statements.
 * @author Matt DuVall <http://mattduvall.com/>
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const lodash = require("lodash");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const DEFAULT_FALLTHROUGH_COMMENT = /falls?\s?through/iu;

/**
 * Checks whether or not a given node has a fallthrough comment.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A SwitchCase node to get comments.
 * @param ***REMOVED***RuleContext***REMOVED*** context - A rule context which stores comments.
 * @param ***REMOVED***RegExp***REMOVED*** fallthroughCommentPattern - A pattern to match comment to.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node has a valid fallthrough comment.
 */
function hasFallthroughComment(node, context, fallthroughCommentPattern) ***REMOVED***
    const sourceCode = context.getSourceCode();
    const comment = lodash.last(sourceCode.getCommentsBefore(node));

    return Boolean(comment && fallthroughCommentPattern.test(comment.value));
***REMOVED***

/**
 * Checks whether or not a given code path segment is reachable.
 * @param ***REMOVED***CodePathSegment***REMOVED*** segment - A CodePathSegment to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the segment is reachable.
 */
function isReachable(segment) ***REMOVED***
    return segment.reachable;
***REMOVED***

/**
 * Checks whether a node and a token are separated by blank lines
 * @param ***REMOVED***ASTNode***REMOVED*** node - The node to check
 * @param ***REMOVED***Token***REMOVED*** token - The token to compare against
 * @returns ***REMOVED***boolean***REMOVED*** `true` if there are blank lines between node and token
 */
function hasBlankLinesBetween(node, token) ***REMOVED***
    return token.loc.start.line > node.loc.end.line + 1;
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "problem",

        docs: ***REMOVED***
            description: "disallow fallthrough of `case` statements",
            category: "Best Practices",
            recommended: true,
            url: "https://eslint.org/docs/rules/no-fallthrough"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    commentPattern: ***REMOVED***
                        type: "string",
                        default: ""
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],
        messages: ***REMOVED***
            case: "Expected a 'break' statement before 'case'.",
            default: "Expected a 'break' statement before 'default'."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const options = context.options[0] || ***REMOVED******REMOVED***;
        let currentCodePath = null;
        const sourceCode = context.getSourceCode();

        /*
         * We need to use leading comments of the next SwitchCase node because
         * trailing comments is wrong if semicolons are omitted.
         */
        let fallthroughCase = null;
        let fallthroughCommentPattern = null;

        if (options.commentPattern) ***REMOVED***
            fallthroughCommentPattern = new RegExp(options.commentPattern, "u");
        ***REMOVED*** else ***REMOVED***
            fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;
        ***REMOVED***

        return ***REMOVED***
            onCodePathStart(codePath) ***REMOVED***
                currentCodePath = codePath;
            ***REMOVED***,
            onCodePathEnd() ***REMOVED***
                currentCodePath = currentCodePath.upper;
            ***REMOVED***,

            SwitchCase(node) ***REMOVED***

                /*
                 * Checks whether or not there is a fallthrough comment.
                 * And reports the previous fallthrough node if that does not exist.
                 */
                if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) ***REMOVED***
                    context.report(***REMOVED***
                        messageId: node.test ? "case" : "default",
                        node
                    ***REMOVED***);
                ***REMOVED***
                fallthroughCase = null;
            ***REMOVED***,

            "SwitchCase:exit"(node) ***REMOVED***
                const nextToken = sourceCode.getTokenAfter(node);

                /*
                 * `reachable` meant fall through because statements preceded by
                 * `break`, `return`, or `throw` are unreachable.
                 * And allows empty cases and the last case.
                 */
                if (currentCodePath.currentSegments.some(isReachable) &&
                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&
                    lodash.last(node.parent.cases) !== node) ***REMOVED***
                    fallthroughCase = node;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
