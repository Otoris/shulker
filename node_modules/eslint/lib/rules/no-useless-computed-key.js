/**
 * @fileoverview Rule to disallow unnecessary computed property keys in object literals
 * @author Burak Yigit Kaya
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const MESSAGE_UNNECESSARY_COMPUTED = "Unnecessarily computed property [***REMOVED******REMOVED***property***REMOVED******REMOVED***] found.";

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow unnecessary computed property keys in object literals",
            category: "ECMAScript 6",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-useless-computed-key"
        ***REMOVED***,

        schema: [],
        fixable: "code"
    ***REMOVED***,
    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();

        return ***REMOVED***
            Property(node) ***REMOVED***
                if (!node.computed) ***REMOVED***
                    return;
                ***REMOVED***

                const key = node.key,
                    nodeType = typeof key.value;

                if (key.type === "Literal" && (nodeType === "string" || nodeType === "number") && key.value !== "__proto__") ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        message: MESSAGE_UNNECESSARY_COMPUTED,
                        data: ***REMOVED*** property: sourceCode.getText(key) ***REMOVED***,
                        fix(fixer) ***REMOVED***
                            const leftSquareBracket = sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken);
                            const rightSquareBracket = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken);
                            const tokensBetween = sourceCode.getTokensBetween(leftSquareBracket, rightSquareBracket, 1);

                            if (tokensBetween.slice(0, -1).some((token, index) =>
                                sourceCode.getText().slice(token.range[1], tokensBetween[index + 1].range[0]).trim())) ***REMOVED***

                                // If there are comments between the brackets and the property name, don't do a fix.
                                return null;
                            ***REMOVED***

                            const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);

                            // Insert a space before the key to avoid changing identifiers, e.g. (***REMOVED*** get[2]() ***REMOVED******REMOVED*** ***REMOVED***) to (***REMOVED*** get2() ***REMOVED******REMOVED*** ***REMOVED***)
                            const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] &&
                                !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));

                            const replacementKey = (needsSpaceBeforeKey ? " " : "") + key.raw;

                            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
