/**
 * @fileoverview Restrict usage of specified node modules.
 * @author Christian Schulz
 */
"use strict";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const DEFAULT_MESSAGE_TEMPLATE = "'***REMOVED******REMOVED***moduleName***REMOVED******REMOVED***' module is restricted from being used.";
const CUSTOM_MESSAGE_TEMPLATE = "'***REMOVED******REMOVED***moduleName***REMOVED******REMOVED***' module is restricted from being used. ***REMOVED******REMOVED***customMessage***REMOVED******REMOVED***";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const ignore = require("ignore");

const arrayOfStrings = ***REMOVED***
    type: "array",
    items: ***REMOVED*** type: "string" ***REMOVED***,
    uniqueItems: true
***REMOVED***;

const arrayOfStringsOrObjects = ***REMOVED***
    type: "array",
    items: ***REMOVED***
        anyOf: [
            ***REMOVED*** type: "string" ***REMOVED***,
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    name: ***REMOVED*** type: "string" ***REMOVED***,
                    message: ***REMOVED***
                        type: "string",
                        minLength: 1
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false,
                required: ["name"]
            ***REMOVED***
        ]
    ***REMOVED***,
    uniqueItems: true
***REMOVED***;

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow specified modules when loaded by `require`",
            category: "Node.js and CommonJS",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-restricted-modules"
        ***REMOVED***,

        schema: ***REMOVED***
            anyOf: [
                arrayOfStringsOrObjects,
                ***REMOVED***
                    type: "array",
                    items: ***REMOVED***
                        type: "object",
                        properties: ***REMOVED***
                            paths: arrayOfStringsOrObjects,
                            patterns: arrayOfStrings
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***,
                    additionalItems: false
                ***REMOVED***
            ]
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const options = Array.isArray(context.options) ? context.options : [];
        const isPathAndPatternsObject =
            typeof options[0] === "object" &&
            (Object.prototype.hasOwnProperty.call(options[0], "paths") || Object.prototype.hasOwnProperty.call(options[0], "patterns"));

        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
        const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];

        const restrictedPathMessages = restrictedPaths.reduce((memo, importName) => ***REMOVED***
            if (typeof importName === "string") ***REMOVED***
                memo[importName] = null;
            ***REMOVED*** else ***REMOVED***
                memo[importName.name] = importName.message;
            ***REMOVED***
            return memo;
        ***REMOVED***, ***REMOVED******REMOVED***);

        // if no imports are restricted we don"t need to check
        if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) ***REMOVED***
            return ***REMOVED******REMOVED***;
        ***REMOVED***

        const ig = ignore().add(restrictedPatterns);


        /**
         * Function to check if a node is a string literal.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
         * @returns ***REMOVED***boolean***REMOVED*** If the node is a string literal.
         */
        function isString(node) ***REMOVED***
            return node && node.type === "Literal" && typeof node.value === "string";
        ***REMOVED***

        /**
         * Function to check if a node is a require call.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
         * @returns ***REMOVED***boolean***REMOVED*** If the node is a require call.
         */
        function isRequireCall(node) ***REMOVED***
            return node.callee.type === "Identifier" && node.callee.name === "require";
        ***REMOVED***

        /**
         * Report a restricted path.
         * @param ***REMOVED***node***REMOVED*** node representing the restricted path reference
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function reportPath(node) ***REMOVED***
            const moduleName = node.arguments[0].value.trim();
            const customMessage = restrictedPathMessages[moduleName];
            const message = customMessage
                ? CUSTOM_MESSAGE_TEMPLATE
                : DEFAULT_MESSAGE_TEMPLATE;

            context.report(***REMOVED***
                node,
                message,
                data: ***REMOVED***
                    moduleName,
                    customMessage
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        /**
         * Check if the given name is a restricted path name
         * @param ***REMOVED***string***REMOVED*** name name of a variable
         * @returns ***REMOVED***boolean***REMOVED*** whether the variable is a restricted path or not
         * @private
         */
        function isRestrictedPath(name) ***REMOVED***
            return Object.prototype.hasOwnProperty.call(restrictedPathMessages, name);
        ***REMOVED***

        return ***REMOVED***
            CallExpression(node) ***REMOVED***
                if (isRequireCall(node)) ***REMOVED***

                    // node has arguments and first argument is string
                    if (node.arguments.length && isString(node.arguments[0])) ***REMOVED***
                        const moduleName = node.arguments[0].value.trim();

                        // check if argument value is in restricted modules array
                        if (isRestrictedPath(moduleName)) ***REMOVED***
                            reportPath(node);
                        ***REMOVED***

                        if (restrictedPatterns.length > 0 && ig.ignores(moduleName)) ***REMOVED***
                            context.report(***REMOVED***
                                node,
                                message: "'***REMOVED******REMOVED***moduleName***REMOVED******REMOVED***' module is restricted from being used by a pattern.",
                                data: ***REMOVED*** moduleName ***REMOVED***
                            ***REMOVED***);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
