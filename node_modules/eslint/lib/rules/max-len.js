/**
 * @fileoverview Rule to check for max length on a line.
 * @author Matt DuVall <http://www.mattduvall.com>
 */

"use strict";

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const OPTIONS_SCHEMA = ***REMOVED***
    type: "object",
    properties: ***REMOVED***
        code: ***REMOVED***
            type: "integer",
            minimum: 0
        ***REMOVED***,
        comments: ***REMOVED***
            type: "integer",
            minimum: 0
        ***REMOVED***,
        tabWidth: ***REMOVED***
            type: "integer",
            minimum: 0
        ***REMOVED***,
        ignorePattern: ***REMOVED***
            type: "string"
        ***REMOVED***,
        ignoreComments: ***REMOVED***
            type: "boolean"
        ***REMOVED***,
        ignoreStrings: ***REMOVED***
            type: "boolean"
        ***REMOVED***,
        ignoreUrls: ***REMOVED***
            type: "boolean"
        ***REMOVED***,
        ignoreTemplateLiterals: ***REMOVED***
            type: "boolean"
        ***REMOVED***,
        ignoreRegExpLiterals: ***REMOVED***
            type: "boolean"
        ***REMOVED***,
        ignoreTrailingComments: ***REMOVED***
            type: "boolean"
        ***REMOVED***
    ***REMOVED***,
    additionalProperties: false
***REMOVED***;

const OPTIONS_OR_INTEGER_SCHEMA = ***REMOVED***
    anyOf: [
        OPTIONS_SCHEMA,
        ***REMOVED***
            type: "integer",
            minimum: 0
        ***REMOVED***
    ]
***REMOVED***;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "enforce a maximum line length",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/max-len"
        ***REMOVED***,

        schema: [
            OPTIONS_OR_INTEGER_SCHEMA,
            OPTIONS_OR_INTEGER_SCHEMA,
            OPTIONS_SCHEMA
        ],
        messages: ***REMOVED***
            max: "This line has a length of ***REMOVED******REMOVED***lineLength***REMOVED******REMOVED***. Maximum allowed is ***REMOVED******REMOVED***maxLength***REMOVED******REMOVED***.",
            maxComment: "This line has a comment length of ***REMOVED******REMOVED***lineLength***REMOVED******REMOVED***. Maximum allowed is ***REMOVED******REMOVED***maxCommentLength***REMOVED******REMOVED***."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        /*
         * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:
         * - They're matching an entire string that we know is a URI
         * - We're matching part of a string where we think there *might* be a URL
         * - We're only concerned about URLs, as picking out any URI would cause
         *   too many false positives
         * - We don't care about matching the entire URL, any small segment is fine
         */
        const URL_REGEXP = /[^:/?#]:\/\/[^?#]/u;

        const sourceCode = context.getSourceCode();

        /**
         * Computes the length of a line that may contain tabs. The width of each
         * tab will be the number of spaces to the next tab stop.
         * @param ***REMOVED***string***REMOVED*** line The line.
         * @param ***REMOVED***int***REMOVED*** tabWidth The width of each tab stop in spaces.
         * @returns ***REMOVED***int***REMOVED*** The computed line length.
         * @private
         */
        function computeLineLength(line, tabWidth) ***REMOVED***
            let extraCharacterCount = 0;

            line.replace(/\t/gu, (match, offset) => ***REMOVED***
                const totalOffset = offset + extraCharacterCount,
                    previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,
                    spaceCount = tabWidth - previousTabStopOffset;

                extraCharacterCount += spaceCount - 1; // -1 for the replaced tab
            ***REMOVED***);
            return Array.from(line).length + extraCharacterCount;
        ***REMOVED***

        // The options object must be the last option specified…
        const options = Object.assign(***REMOVED******REMOVED***, context.options[context.options.length - 1]);

        // …but max code length…
        if (typeof context.options[0] === "number") ***REMOVED***
            options.code = context.options[0];
        ***REMOVED***

        // …and tabWidth can be optionally specified directly as integers.
        if (typeof context.options[1] === "number") ***REMOVED***
            options.tabWidth = context.options[1];
        ***REMOVED***

        const maxLength = typeof options.code === "number" ? options.code : 80,
            tabWidth = typeof options.tabWidth === "number" ? options.tabWidth : 4,
            ignoreComments = !!options.ignoreComments,
            ignoreStrings = !!options.ignoreStrings,
            ignoreTemplateLiterals = !!options.ignoreTemplateLiterals,
            ignoreRegExpLiterals = !!options.ignoreRegExpLiterals,
            ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments,
            ignoreUrls = !!options.ignoreUrls,
            maxCommentLength = options.comments;
        let ignorePattern = options.ignorePattern || null;

        if (ignorePattern) ***REMOVED***
            ignorePattern = new RegExp(ignorePattern, "u");
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Tells if a given comment is trailing: it starts on the current line and
         * extends to or past the end of the current line.
         * @param ***REMOVED***string***REMOVED*** line The source line we want to check for a trailing comment on
         * @param ***REMOVED***number***REMOVED*** lineNumber The one-indexed line number for line
         * @param ***REMOVED***ASTNode***REMOVED*** comment The comment to inspect
         * @returns ***REMOVED***boolean***REMOVED*** If the comment is trailing on the given line
         */
        function isTrailingComment(line, lineNumber, comment) ***REMOVED***
            return comment &&
                (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) &&
                (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);
        ***REMOVED***

        /**
         * Tells if a comment encompasses the entire line.
         * @param ***REMOVED***string***REMOVED*** line The source line with a trailing comment
         * @param ***REMOVED***number***REMOVED*** lineNumber The one-indexed line number this is on
         * @param ***REMOVED***ASTNode***REMOVED*** comment The comment to remove
         * @returns ***REMOVED***boolean***REMOVED*** If the comment covers the entire line
         */
        function isFullLineComment(line, lineNumber, comment) ***REMOVED***
            const start = comment.loc.start,
                end = comment.loc.end,
                isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();

            return comment &&
                (start.line < lineNumber || (start.line === lineNumber && isFirstTokenOnLine)) &&
                (end.line > lineNumber || (end.line === lineNumber && end.column === line.length));
        ***REMOVED***

        /**
         * Gets the line after the comment and any remaining trailing whitespace is
         * stripped.
         * @param ***REMOVED***string***REMOVED*** line The source line with a trailing comment
         * @param ***REMOVED***ASTNode***REMOVED*** comment The comment to remove
         * @returns ***REMOVED***string***REMOVED*** Line without comment and trailing whitepace
         */
        function stripTrailingComment(line, comment) ***REMOVED***

            // loc.column is zero-indexed
            return line.slice(0, comment.loc.start.column).replace(/\s+$/u, "");
        ***REMOVED***

        /**
         * Ensure that an array exists at [key] on `object`, and add `value` to it.
         *
         * @param ***REMOVED***Object***REMOVED*** object the object to mutate
         * @param ***REMOVED***string***REMOVED*** key the object's key
         * @param ***REMOVED*******REMOVED*** value the value to add
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function ensureArrayAndPush(object, key, value) ***REMOVED***
            if (!Array.isArray(object[key])) ***REMOVED***
                object[key] = [];
            ***REMOVED***
            object[key].push(value);
        ***REMOVED***

        /**
         * Retrieves an array containing all strings (" or ') in the source code.
         *
         * @returns ***REMOVED***ASTNode[]***REMOVED*** An array of string nodes.
         */
        function getAllStrings() ***REMOVED***
            return sourceCode.ast.tokens.filter(token => (token.type === "String" ||
                (token.type === "JSXText" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === "JSXAttribute")));
        ***REMOVED***

        /**
         * Retrieves an array containing all template literals in the source code.
         *
         * @returns ***REMOVED***ASTNode[]***REMOVED*** An array of template literal nodes.
         */
        function getAllTemplateLiterals() ***REMOVED***
            return sourceCode.ast.tokens.filter(token => token.type === "Template");
        ***REMOVED***


        /**
         * Retrieves an array containing all RegExp literals in the source code.
         *
         * @returns ***REMOVED***ASTNode[]***REMOVED*** An array of RegExp literal nodes.
         */
        function getAllRegExpLiterals() ***REMOVED***
            return sourceCode.ast.tokens.filter(token => token.type === "RegularExpression");
        ***REMOVED***


        /**
         * A reducer to group an AST node by line number, both start and end.
         *
         * @param ***REMOVED***Object***REMOVED*** acc the accumulator
         * @param ***REMOVED***ASTNode***REMOVED*** node the AST node in question
         * @returns ***REMOVED***Object***REMOVED*** the modified accumulator
         * @private
         */
        function groupByLineNumber(acc, node) ***REMOVED***
            for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) ***REMOVED***
                ensureArrayAndPush(acc, i, node);
            ***REMOVED***
            return acc;
        ***REMOVED***

        /**
         * Check the program for max length
         * @param ***REMOVED***ASTNode***REMOVED*** node Node to examine
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkProgramForMaxLength(node) ***REMOVED***

            // split (honors line-ending)
            const lines = sourceCode.lines,

                // list of comments to ignore
                comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? sourceCode.getAllComments() : [];

            // we iterate over comments in parallel with the lines
            let commentsIndex = 0;

            const strings = getAllStrings();
            const stringsByLine = strings.reduce(groupByLineNumber, ***REMOVED******REMOVED***);

            const templateLiterals = getAllTemplateLiterals();
            const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, ***REMOVED******REMOVED***);

            const regExpLiterals = getAllRegExpLiterals();
            const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, ***REMOVED******REMOVED***);

            lines.forEach((line, i) => ***REMOVED***

                // i is zero-indexed, line numbers are one-indexed
                const lineNumber = i + 1;

                /*
                 * if we're checking comment length; we need to know whether this
                 * line is a comment
                 */
                let lineIsComment = false;
                let textToMeasure;

                /*
                 * We can short-circuit the comment checks if we're already out of
                 * comments to check.
                 */
                if (commentsIndex < comments.length) ***REMOVED***
                    let comment = null;

                    // iterate over comments until we find one past the current line
                    do ***REMOVED***
                        comment = comments[++commentsIndex];
                    ***REMOVED*** while (comment && comment.loc.start.line <= lineNumber);

                    // and step back by one
                    comment = comments[--commentsIndex];

                    if (isFullLineComment(line, lineNumber, comment)) ***REMOVED***
                        lineIsComment = true;
                        textToMeasure = line;
                    ***REMOVED*** else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) ***REMOVED***
                        textToMeasure = stripTrailingComment(line, comment);

                        // ignore multiple trailing comments in the same line
                        let lastIndex = commentsIndex;

                        while (isTrailingComment(textToMeasure, lineNumber, comments[--lastIndex])) ***REMOVED***
                            textToMeasure = stripTrailingComment(textToMeasure, comments[lastIndex]);
                        ***REMOVED***
                    ***REMOVED*** else ***REMOVED***
                        textToMeasure = line;
                    ***REMOVED***
                ***REMOVED*** else ***REMOVED***
                    textToMeasure = line;
                ***REMOVED***
                if (ignorePattern && ignorePattern.test(textToMeasure) ||
                    ignoreUrls && URL_REGEXP.test(textToMeasure) ||
                    ignoreStrings && stringsByLine[lineNumber] ||
                    ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] ||
                    ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]
                ) ***REMOVED***

                    // ignore this line
                    return;
                ***REMOVED***

                const lineLength = computeLineLength(textToMeasure, tabWidth);
                const commentLengthApplies = lineIsComment && maxCommentLength;

                if (lineIsComment && ignoreComments) ***REMOVED***
                    return;
                ***REMOVED***

                if (commentLengthApplies) ***REMOVED***
                    if (lineLength > maxCommentLength) ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            loc: ***REMOVED*** line: lineNumber, column: 0 ***REMOVED***,
                            messageId: "maxComment",
                            data: ***REMOVED***
                                lineLength,
                                maxCommentLength
                            ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED***
                ***REMOVED*** else if (lineLength > maxLength) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        loc: ***REMOVED*** line: lineNumber, column: 0 ***REMOVED***,
                        messageId: "max",
                        data: ***REMOVED***
                            lineLength,
                            maxLength
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***


        //--------------------------------------------------------------------------
        // Public API
        //--------------------------------------------------------------------------

        return ***REMOVED***
            Program: checkProgramForMaxLength
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
