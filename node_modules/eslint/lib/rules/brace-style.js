/**
 * @fileoverview Rule to flag block statements that do not use the one true brace style
 * @author Ian Christian Myers
 */

"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "enforce consistent brace style for blocks",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/brace-style"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                enum: ["1tbs", "stroustrup", "allman"]
            ***REMOVED***,
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    allowSingleLine: ***REMOVED***
                        type: "boolean",
                        default: false
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],

        fixable: "whitespace",

        messages: ***REMOVED***
            nextLineOpen: "Opening curly brace does not appear on the same line as controlling statement.",
            sameLineOpen: "Opening curly brace appears on the same line as controlling statement.",
            blockSameLine: "Statement inside of curly braces should be on next line.",
            nextLineClose: "Closing curly brace does not appear on the same line as the subsequent block.",
            singleLineClose: "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
            sameLineClose: "Closing curly brace appears on the same line as the subsequent block."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const style = context.options[0] || "1tbs",
            params = context.options[1] || ***REMOVED******REMOVED***,
            sourceCode = context.getSourceCode();

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Fixes a place where a newline unexpectedly appears
         * @param ***REMOVED***Token***REMOVED*** firstToken The token before the unexpected newline
         * @param ***REMOVED***Token***REMOVED*** secondToken The token after the unexpected newline
         * @returns ***REMOVED***Function***REMOVED*** A fixer function to remove the newlines between the tokens
         */
        function removeNewlineBetween(firstToken, secondToken) ***REMOVED***
            const textRange = [firstToken.range[1], secondToken.range[0]];
            const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);

            // Don't do a fix if there is a comment between the tokens
            if (textBetween.trim()) ***REMOVED***
                return null;
            ***REMOVED***
            return fixer => fixer.replaceTextRange(textRange, " ");
        ***REMOVED***

        /**
         * Validates a pair of curly brackets based on the user's config
         * @param ***REMOVED***Token***REMOVED*** openingCurly The opening curly bracket
         * @param ***REMOVED***Token***REMOVED*** closingCurly The closing curly bracket
         * @returns ***REMOVED***void***REMOVED***
         */
        function validateCurlyPair(openingCurly, closingCurly) ***REMOVED***
            const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);
            const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);
            const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);
            const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);

            if (style !== "allman" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) ***REMOVED***
                context.report(***REMOVED***
                    node: openingCurly,
                    messageId: "nextLineOpen",
                    fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)
                ***REMOVED***);
            ***REMOVED***

            if (style === "allman" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) ***REMOVED***
                context.report(***REMOVED***
                    node: openingCurly,
                    messageId: "sameLineOpen",
                    fix: fixer => fixer.insertTextBefore(openingCurly, "\n")
                ***REMOVED***);
            ***REMOVED***

            if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) ***REMOVED***
                context.report(***REMOVED***
                    node: openingCurly,
                    messageId: "blockSameLine",
                    fix: fixer => fixer.insertTextAfter(openingCurly, "\n")
                ***REMOVED***);
            ***REMOVED***

            if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) ***REMOVED***
                context.report(***REMOVED***
                    node: closingCurly,
                    messageId: "singleLineClose",
                    fix: fixer => fixer.insertTextBefore(closingCurly, "\n")
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Validates the location of a token that appears before a keyword (e.g. a newline before `else`)
         * @param ***REMOVED***Token***REMOVED*** curlyToken The closing curly token. This is assumed to precede a keyword token (such as `else` or `finally`).
         * @returns ***REMOVED***void***REMOVED***
         */
        function validateCurlyBeforeKeyword(curlyToken) ***REMOVED***
            const keywordToken = sourceCode.getTokenAfter(curlyToken);

            if (style === "1tbs" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) ***REMOVED***
                context.report(***REMOVED***
                    node: curlyToken,
                    messageId: "nextLineClose",
                    fix: removeNewlineBetween(curlyToken, keywordToken)
                ***REMOVED***);
            ***REMOVED***

            if (style !== "1tbs" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) ***REMOVED***
                context.report(***REMOVED***
                    node: curlyToken,
                    messageId: "sameLineClose",
                    fix: fixer => fixer.insertTextAfter(curlyToken, "\n")
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public API
        //--------------------------------------------------------------------------

        return ***REMOVED***
            BlockStatement(node) ***REMOVED***
                if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) ***REMOVED***
                    validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
                ***REMOVED***
            ***REMOVED***,
            ClassBody(node) ***REMOVED***
                validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
            ***REMOVED***,
            SwitchStatement(node) ***REMOVED***
                const closingCurly = sourceCode.getLastToken(node);
                const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);

                validateCurlyPair(openingCurly, closingCurly);
            ***REMOVED***,
            IfStatement(node) ***REMOVED***
                if (node.consequent.type === "BlockStatement" && node.alternate) ***REMOVED***

                    // Handle the keyword after the `if` block (before `else`)
                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));
                ***REMOVED***
            ***REMOVED***,
            TryStatement(node) ***REMOVED***

                // Handle the keyword after the `try` block (before `catch` or `finally`)
                validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));

                if (node.handler && node.finalizer) ***REMOVED***

                    // Handle the keyword after the `catch` block (before `finally`)
                    validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
