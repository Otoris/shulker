/**
 * @fileoverview enforce or disallow capitalization of the first letter of a comment
 * @author Kevin Partington
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const LETTER_PATTERN = require("./utils/patterns/letters");
const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN,
    WHITESPACE = /\s/gu,
    MAYBE_URL = /^\s*[^:/?#\s]+:\/\/[^?#]/u; // TODO: Combine w/ max-len pattern?

/*
 * Base schema body for defining the basic capitalization rule, ignorePattern,
 * and ignoreInlineComments values.
 * This can be used in a few different ways in the actual schema.
 */
const SCHEMA_BODY = ***REMOVED***
    type: "object",
    properties: ***REMOVED***
        ignorePattern: ***REMOVED***
            type: "string"
        ***REMOVED***,
        ignoreInlineComments: ***REMOVED***
            type: "boolean"
        ***REMOVED***,
        ignoreConsecutiveComments: ***REMOVED***
            type: "boolean"
        ***REMOVED***
    ***REMOVED***,
    additionalProperties: false
***REMOVED***;
const DEFAULTS = ***REMOVED***
    ignorePattern: "",
    ignoreInlineComments: false,
    ignoreConsecutiveComments: false
***REMOVED***;

/**
 * Get normalized options for either block or line comments from the given
 * user-provided options.
 * - If the user-provided options is just a string, returns a normalized
 *   set of options using default values for all other options.
 * - If the user-provided options is an object, then a normalized option
 *   set is returned. Options specified in overrides will take priority
 *   over options specified in the main options object, which will in
 *   turn take priority over the rule's defaults.
 *
 * @param ***REMOVED***Object|string***REMOVED*** rawOptions The user-provided options.
 * @param ***REMOVED***string***REMOVED*** which Either "line" or "block".
 * @returns ***REMOVED***Object***REMOVED*** The normalized options.
 */
function getNormalizedOptions(rawOptions = ***REMOVED******REMOVED***, which) ***REMOVED***
    return Object.assign(***REMOVED******REMOVED***, DEFAULTS, rawOptions[which] || rawOptions);
***REMOVED***

/**
 * Get normalized options for block and line comments.
 *
 * @param ***REMOVED***Object|string***REMOVED*** rawOptions The user-provided options.
 * @returns ***REMOVED***Object***REMOVED*** An object with "Line" and "Block" keys and corresponding
 * normalized options objects.
 */
function getAllNormalizedOptions(rawOptions) ***REMOVED***
    return ***REMOVED***
        Line: getNormalizedOptions(rawOptions, "line"),
        Block: getNormalizedOptions(rawOptions, "block")
    ***REMOVED***;
***REMOVED***

/**
 * Creates a regular expression for each ignorePattern defined in the rule
 * options.
 *
 * This is done in order to avoid invoking the RegExp constructor repeatedly.
 *
 * @param ***REMOVED***Object***REMOVED*** normalizedOptions The normalized rule options.
 * @returns ***REMOVED***void***REMOVED***
 */
function createRegExpForIgnorePatterns(normalizedOptions) ***REMOVED***
    Object.keys(normalizedOptions).forEach(key => ***REMOVED***
        const ignorePatternStr = normalizedOptions[key].ignorePattern;

        if (ignorePatternStr) ***REMOVED***
            const regExp = RegExp(`^\\s*(?:$***REMOVED***ignorePatternStr***REMOVED***)`, "u");

            normalizedOptions[key].ignorePatternRegExp = regExp;
        ***REMOVED***
    ***REMOVED***);
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "enforce or disallow capitalization of the first letter of a comment",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/capitalized-comments"
        ***REMOVED***,

        fixable: "code",

        schema: [
            ***REMOVED*** enum: ["always", "never"] ***REMOVED***,
            ***REMOVED***
                oneOf: [
                    SCHEMA_BODY,
                    ***REMOVED***
                        type: "object",
                        properties: ***REMOVED***
                            line: SCHEMA_BODY,
                            block: SCHEMA_BODY
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***
                ]
            ***REMOVED***
        ],

        messages: ***REMOVED***
            unexpectedLowercaseComment: "Comments should not begin with a lowercase character.",
            unexpectedUppercaseComment: "Comments should not begin with an uppercase character."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        const capitalize = context.options[0] || "always",
            normalizedOptions = getAllNormalizedOptions(context.options[1]),
            sourceCode = context.getSourceCode();

        createRegExpForIgnorePatterns(normalizedOptions);

        //----------------------------------------------------------------------
        // Helpers
        //----------------------------------------------------------------------

        /**
         * Checks whether a comment is an inline comment.
         *
         * For the purpose of this rule, a comment is inline if:
         * 1. The comment is preceded by a token on the same line; and
         * 2. The command is followed by a token on the same line.
         *
         * Note that the comment itself need not be single-line!
         *
         * Also, it follows from this definition that only block comments can
         * be considered as possibly inline. This is because line comments
         * would consume any following tokens on the same line as the comment.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** comment The comment node to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the comment is an inline comment, false
         * otherwise.
         */
        function isInlineComment(comment) ***REMOVED***
            const previousToken = sourceCode.getTokenBefore(comment, ***REMOVED*** includeComments: true ***REMOVED***),
                nextToken = sourceCode.getTokenAfter(comment, ***REMOVED*** includeComments: true ***REMOVED***);

            return Boolean(
                previousToken &&
                nextToken &&
                comment.loc.start.line === previousToken.loc.end.line &&
                comment.loc.end.line === nextToken.loc.start.line
            );
        ***REMOVED***

        /**
         * Determine if a comment follows another comment.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** comment The comment to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the comment follows a valid comment.
         */
        function isConsecutiveComment(comment) ***REMOVED***
            const previousTokenOrComment = sourceCode.getTokenBefore(comment, ***REMOVED*** includeComments: true ***REMOVED***);

            return Boolean(
                previousTokenOrComment &&
                ["Block", "Line"].indexOf(previousTokenOrComment.type) !== -1
            );
        ***REMOVED***

        /**
         * Check a comment to determine if it is valid for this rule.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** comment The comment node to process.
         * @param ***REMOVED***Object***REMOVED*** options The options for checking this comment.
         * @returns ***REMOVED***boolean***REMOVED*** True if the comment is valid, false otherwise.
         */
        function isCommentValid(comment, options) ***REMOVED***

            // 1. Check for default ignore pattern.
            if (DEFAULT_IGNORE_PATTERN.test(comment.value)) ***REMOVED***
                return true;
            ***REMOVED***

            // 2. Check for custom ignore pattern.
            const commentWithoutAsterisks = comment.value
                .replace(/\*/gu, "");

            if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) ***REMOVED***
                return true;
            ***REMOVED***

            // 3. Check for inline comments.
            if (options.ignoreInlineComments && isInlineComment(comment)) ***REMOVED***
                return true;
            ***REMOVED***

            // 4. Is this a consecutive comment (and are we tolerating those)?
            if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) ***REMOVED***
                return true;
            ***REMOVED***

            // 5. Does the comment start with a possible URL?
            if (MAYBE_URL.test(commentWithoutAsterisks)) ***REMOVED***
                return true;
            ***REMOVED***

            // 6. Is the initial word character a letter?
            const commentWordCharsOnly = commentWithoutAsterisks
                .replace(WHITESPACE, "");

            if (commentWordCharsOnly.length === 0) ***REMOVED***
                return true;
            ***REMOVED***

            const firstWordChar = commentWordCharsOnly[0];

            if (!LETTER_PATTERN.test(firstWordChar)) ***REMOVED***
                return true;
            ***REMOVED***

            // 7. Check the case of the initial word character.
            const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(),
                isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();

            if (capitalize === "always" && isLowercase) ***REMOVED***
                return false;
            ***REMOVED***
            if (capitalize === "never" && isUppercase) ***REMOVED***
                return false;
            ***REMOVED***

            return true;
        ***REMOVED***

        /**
         * Process a comment to determine if it needs to be reported.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** comment The comment node to process.
         * @returns ***REMOVED***void***REMOVED***
         */
        function processComment(comment) ***REMOVED***
            const options = normalizedOptions[comment.type],
                commentValid = isCommentValid(comment, options);

            if (!commentValid) ***REMOVED***
                const messageId = capitalize === "always"
                    ? "unexpectedLowercaseComment"
                    : "unexpectedUppercaseComment";

                context.report(***REMOVED***
                    node: null, // Intentionally using loc instead
                    loc: comment.loc,
                    messageId,
                    fix(fixer) ***REMOVED***
                        const match = comment.value.match(LETTER_PATTERN);

                        return fixer.replaceTextRange(

                            // Offset match.index by 2 to account for the first 2 characters that start the comment (// or /*)
                            [comment.range[0] + match.index + 2, comment.range[0] + match.index + 3],
                            capitalize === "always" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase()
                        );
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------

        return ***REMOVED***
            Program() ***REMOVED***
                const comments = sourceCode.getAllComments();

                comments.filter(token => token.type !== "Shebang").forEach(processComment);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
