/**
 * @fileoverview Rule to enforce location of semicolons.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const SELECTOR = `:matches($***REMOVED***
    [
        "BreakStatement", "ContinueStatement", "DebuggerStatement",
        "DoWhileStatement", "ExportAllDeclaration",
        "ExportDefaultDeclaration", "ExportNamedDeclaration",
        "ExpressionStatement", "ImportDeclaration", "ReturnStatement",
        "ThrowStatement", "VariableDeclaration"
    ].join(",")
***REMOVED***)`;

/**
 * Get the child node list of a given node.
 * This returns `Program#body`, `BlockStatement#body`, or `SwitchCase#consequent`.
 * This is used to check whether a node is the first/last child.
 * @param ***REMOVED***Node***REMOVED*** node A node to get child node list.
 * @returns ***REMOVED***Node[]|null***REMOVED*** The child node list.
 */
function getChildren(node) ***REMOVED***
    const t = node.type;

    if (t === "BlockStatement" || t === "Program") ***REMOVED***
        return node.body;
    ***REMOVED***
    if (t === "SwitchCase") ***REMOVED***
        return node.consequent;
    ***REMOVED***
    return null;
***REMOVED***

/**
 * Check whether a given node is the last statement in the parent block.
 * @param ***REMOVED***Node***REMOVED*** node A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is the last statement in the parent block.
 */
function isLastChild(node) ***REMOVED***
    const t = node.parent.type;

    if (t === "IfStatement" && node.parent.consequent === node && node.parent.alternate) ***REMOVED*** // before `else` keyword.
        return true;
    ***REMOVED***
    if (t === "DoWhileStatement") ***REMOVED*** // before `while` keyword.
        return true;
    ***REMOVED***
    const nodeList = getChildren(node.parent);

    return nodeList !== null && nodeList[nodeList.length - 1] === node; // before `***REMOVED***` or etc.
***REMOVED***

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "enforce location of semicolons",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/semi-style"
        ***REMOVED***,

        schema: [***REMOVED*** enum: ["last", "first"] ***REMOVED***],
        fixable: "whitespace"
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();
        const option = context.options[0] || "last";

        /**
         * Check the given semicolon token.
         * @param ***REMOVED***Token***REMOVED*** semiToken The semicolon token to check.
         * @param ***REMOVED***"first"|"last"***REMOVED*** expected The expected location to check.
         * @returns ***REMOVED***void***REMOVED***
         */
        function check(semiToken, expected) ***REMOVED***
            const prevToken = sourceCode.getTokenBefore(semiToken);
            const nextToken = sourceCode.getTokenAfter(semiToken);
            const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);
            const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);

            if ((expected === "last" && !prevIsSameLine) || (expected === "first" && !nextIsSameLine)) ***REMOVED***
                context.report(***REMOVED***
                    loc: semiToken.loc,
                    message: "Expected this semicolon to be at ***REMOVED******REMOVED***pos***REMOVED******REMOVED***.",
                    data: ***REMOVED***
                        pos: (expected === "last")
                            ? "the end of the previous line"
                            : "the beginning of the next line"
                    ***REMOVED***,
                    fix(fixer) ***REMOVED***
                        if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) ***REMOVED***
                            return null;
                        ***REMOVED***

                        const start = prevToken ? prevToken.range[1] : semiToken.range[0];
                        const end = nextToken ? nextToken.range[0] : semiToken.range[1];
                        const text = (expected === "last") ? ";\n" : "\n;";

                        return fixer.replaceTextRange([start, end], text);
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            [SELECTOR](node) ***REMOVED***
                if (option === "first" && isLastChild(node)) ***REMOVED***
                    return;
                ***REMOVED***

                const lastToken = sourceCode.getLastToken(node);

                if (astUtils.isSemicolonToken(lastToken)) ***REMOVED***
                    check(lastToken, option);
                ***REMOVED***
            ***REMOVED***,

            ForStatement(node) ***REMOVED***
                const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);
                const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);

                if (firstSemi) ***REMOVED***
                    check(firstSemi, "last");
                ***REMOVED***
                if (secondSemi) ***REMOVED***
                    check(secondSemi, "last");
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
