/**
 * @fileoverview Rule to disallow use of the `RegExp` constructor in favor of regular expression literals
 * @author Milos Djermanovic
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");
const ***REMOVED*** CALL, CONSTRUCT, ReferenceTracker, findVariable ***REMOVED*** = require("eslint-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Determines whether the given node is a string literal.
 * @param ***REMOVED***ASTNode***REMOVED*** node Node to check.
 * @returns ***REMOVED***boolean***REMOVED*** True if the node is a string literal.
 */
function isStringLiteral(node) ***REMOVED***
    return node.type === "Literal" && typeof node.value === "string";
***REMOVED***

/**
 * Determines whether the given node is a template literal without expressions.
 * @param ***REMOVED***ASTNode***REMOVED*** node Node to check.
 * @returns ***REMOVED***boolean***REMOVED*** True if the node is a template literal without expressions.
 */
function isStaticTemplateLiteral(node) ***REMOVED***
    return node.type === "TemplateLiteral" && node.expressions.length === 0;
***REMOVED***


//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow use of the `RegExp` constructor in favor of regular expression literals",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/prefer-regex-literals"
        ***REMOVED***,

        schema: [],

        messages: ***REMOVED***
            unexpectedRegExp: "Use a regular expression literal instead of the 'RegExp' constructor."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        /**
         * Determines whether the given identifier node is a reference to a global variable.
         * @param ***REMOVED***ASTNode***REMOVED*** node `Identifier` node to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the identifier is a reference to a global variable.
         */
        function isGlobalReference(node) ***REMOVED***
            const scope = context.getScope();
            const variable = findVariable(scope, node);

            return variable !== null && variable.scope.type === "global" && variable.defs.length === 0;
        ***REMOVED***

        /**
         * Determines whether the given node is a String.raw`` tagged template expression
         * with a static template literal.
         * @param ***REMOVED***ASTNode***REMOVED*** node Node to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is String.raw`` with a static template.
         */
        function isStringRawTaggedStaticTemplateLiteral(node) ***REMOVED***
            return node.type === "TaggedTemplateExpression" &&
                node.tag.type === "MemberExpression" &&
                node.tag.object.type === "Identifier" &&
                node.tag.object.name === "String" &&
                isGlobalReference(node.tag.object) &&
                astUtils.getStaticPropertyName(node.tag) === "raw" &&
                isStaticTemplateLiteral(node.quasi);
        ***REMOVED***

        /**
         * Determines whether the given node is considered to be a static string by the logic of this rule.
         * @param ***REMOVED***ASTNode***REMOVED*** node Node to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is a static string.
         */
        function isStaticString(node) ***REMOVED***
            return isStringLiteral(node) ||
                isStaticTemplateLiteral(node) ||
                isStringRawTaggedStaticTemplateLiteral(node);
        ***REMOVED***

        return ***REMOVED***
            Program() ***REMOVED***
                const scope = context.getScope();
                const tracker = new ReferenceTracker(scope);
                const traceMap = ***REMOVED***
                    RegExp: ***REMOVED***
                        [CALL]: true,
                        [CONSTRUCT]: true
                    ***REMOVED***
                ***REMOVED***;

                for (const ***REMOVED*** node ***REMOVED*** of tracker.iterateGlobalReferences(traceMap)) ***REMOVED***
                    const args = node.arguments;

                    if (
                        (args.length === 1 || args.length === 2) &&
                        args.every(isStaticString)
                    ) ***REMOVED***
                        context.report(***REMOVED*** node, messageId: "unexpectedRegExp" ***REMOVED***);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
