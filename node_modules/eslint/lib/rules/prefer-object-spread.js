/**
 * @fileoverview Prefers object spread property over Object.assign
 * @author Sharmila Jesupaul
 * See LICENSE file in root directory for full license.
 */

"use strict";

const ***REMOVED*** CALL, ReferenceTracker ***REMOVED*** = require("eslint-utils");
const ***REMOVED***
    isCommaToken,
    isOpeningParenToken,
    isClosingParenToken,
    isParenthesised
***REMOVED*** = require("./utils/ast-utils");

const ANY_SPACE = /\s/u;

/**
 * Helper that checks if the Object.assign call has array spread
 * @param ***REMOVED***ASTNode***REMOVED*** node - The node that the rule warns on
 * @returns ***REMOVED***boolean***REMOVED*** - Returns true if the Object.assign call has array spread
 */
function hasArraySpread(node) ***REMOVED***
    return node.arguments.some(arg => arg.type === "SpreadElement");
***REMOVED***

/**
 * Helper that checks if the node needs parentheses to be valid JS.
 * The default is to wrap the node in parentheses to avoid parsing errors.
 * @param ***REMOVED***ASTNode***REMOVED*** node - The node that the rule warns on
 * @param ***REMOVED***Object***REMOVED*** sourceCode - in context sourcecode object
 * @returns ***REMOVED***boolean***REMOVED*** - Returns true if the node needs parentheses
 */
function needsParens(node, sourceCode) ***REMOVED***
    const parent = node.parent;

    switch (parent.type) ***REMOVED***
        case "VariableDeclarator":
        case "ArrayExpression":
        case "ReturnStatement":
        case "CallExpression":
        case "Property":
            return false;
        case "AssignmentExpression":
            return parent.left === node && !isParenthesised(sourceCode, node);
        default:
            return !isParenthesised(sourceCode, node);
    ***REMOVED***
***REMOVED***

/**
 * Determines if an argument needs parentheses. The default is to not add parens.
 * @param ***REMOVED***ASTNode***REMOVED*** node - The node to be checked.
 * @param ***REMOVED***Object***REMOVED*** sourceCode - in context sourcecode object
 * @returns ***REMOVED***boolean***REMOVED*** True if the node needs parentheses
 */
function argNeedsParens(node, sourceCode) ***REMOVED***
    switch (node.type) ***REMOVED***
        case "AssignmentExpression":
        case "ArrowFunctionExpression":
        case "ConditionalExpression":
            return !isParenthesised(sourceCode, node);
        default:
            return false;
    ***REMOVED***
***REMOVED***

/**
 * Get the parenthesis tokens of a given ObjectExpression node.
 * This incldues the braces of the object literal and enclosing parentheses.
 * @param ***REMOVED***ASTNode***REMOVED*** node The node to get.
 * @param ***REMOVED***Token***REMOVED*** leftArgumentListParen The opening paren token of the argument list.
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode The source code object to get tokens.
 * @returns ***REMOVED***Token[]***REMOVED*** The parenthesis tokens of the node. This is sorted by the location.
 */
function getParenTokens(node, leftArgumentListParen, sourceCode) ***REMOVED***
    const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];
    let leftNext = sourceCode.getTokenBefore(node);
    let rightNext = sourceCode.getTokenAfter(node);

    // Note: don't include the parens of the argument list.
    while (
        leftNext &&
        rightNext &&
        leftNext.range[0] > leftArgumentListParen.range[0] &&
        isOpeningParenToken(leftNext) &&
        isClosingParenToken(rightNext)
    ) ***REMOVED***
        parens.push(leftNext, rightNext);
        leftNext = sourceCode.getTokenBefore(leftNext);
        rightNext = sourceCode.getTokenAfter(rightNext);
    ***REMOVED***

    return parens.sort((a, b) => a.range[0] - b.range[0]);
***REMOVED***

/**
 * Get the range of a given token and around whitespaces.
 * @param ***REMOVED***Token***REMOVED*** token The token to get range.
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode The source code object to get tokens.
 * @returns ***REMOVED***number***REMOVED*** The end of the range of the token and around whitespaces.
 */
function getStartWithSpaces(token, sourceCode) ***REMOVED***
    const text = sourceCode.text;
    let start = token.range[0];

    // If the previous token is a line comment then skip this step to avoid commenting this token out.
    ***REMOVED***
        const prevToken = sourceCode.getTokenBefore(token, ***REMOVED*** includeComments: true ***REMOVED***);

        if (prevToken && prevToken.type === "Line") ***REMOVED***
            return start;
        ***REMOVED***
    ***REMOVED***

    // Detect spaces before the token.
    while (ANY_SPACE.test(text[start - 1] || "")) ***REMOVED***
        start -= 1;
    ***REMOVED***

    return start;
***REMOVED***

/**
 * Get the range of a given token and around whitespaces.
 * @param ***REMOVED***Token***REMOVED*** token The token to get range.
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode The source code object to get tokens.
 * @returns ***REMOVED***number***REMOVED*** The start of the range of the token and around whitespaces.
 */
function getEndWithSpaces(token, sourceCode) ***REMOVED***
    const text = sourceCode.text;
    let end = token.range[1];

    // Detect spaces after the token.
    while (ANY_SPACE.test(text[end] || "")) ***REMOVED***
        end += 1;
    ***REMOVED***

    return end;
***REMOVED***

/**
 * Autofixes the Object.assign call to use an object spread instead.
 * @param ***REMOVED***ASTNode|null***REMOVED*** node - The node that the rule warns on, i.e. the Object.assign call
 * @param ***REMOVED***string***REMOVED*** sourceCode - sourceCode of the Object.assign call
 * @returns ***REMOVED***Function***REMOVED*** autofixer - replaces the Object.assign with a spread object.
 */
function defineFixer(node, sourceCode) ***REMOVED***
    return function *(fixer) ***REMOVED***
        const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);
        const rightParen = sourceCode.getLastToken(node);

        // Remove the callee `Object.assign`
        yield fixer.remove(node.callee);

        // Replace the parens of argument list to braces.
        if (needsParens(node, sourceCode)) ***REMOVED***
            yield fixer.replaceText(leftParen, "(***REMOVED***");
            yield fixer.replaceText(rightParen, "***REMOVED***)");
        ***REMOVED*** else ***REMOVED***
            yield fixer.replaceText(leftParen, "***REMOVED***");
            yield fixer.replaceText(rightParen, "***REMOVED***");
        ***REMOVED***

        // Process arguments.
        for (const argNode of node.arguments) ***REMOVED***
            const innerParens = getParenTokens(argNode, leftParen, sourceCode);
            const left = innerParens.shift();
            const right = innerParens.pop();

            if (argNode.type === "ObjectExpression") ***REMOVED***
                const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);
                const maybeArgumentComma = sourceCode.getTokenAfter(right);

                /*
                 * Make bare this object literal.
                 * And remove spaces inside of the braces for better formatting.
                 */
                for (const innerParen of innerParens) ***REMOVED***
                    yield fixer.remove(innerParen);
                ***REMOVED***
                const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];
                const rightRange = [
                    Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]), // Ensure ranges don't overlap
                    right.range[1]
                ];

                yield fixer.removeRange(leftRange);
                yield fixer.removeRange(rightRange);

                // Remove the comma of this argument if it's duplication.
                if (
                    (argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) &&
                    isCommaToken(maybeArgumentComma)
                ) ***REMOVED***
                    yield fixer.remove(maybeArgumentComma);
                ***REMOVED***
            ***REMOVED*** else ***REMOVED***

                // Make spread.
                if (argNeedsParens(argNode, sourceCode)) ***REMOVED***
                    yield fixer.insertTextBefore(left, "...(");
                    yield fixer.insertTextAfter(right, ")");
                ***REMOVED*** else ***REMOVED***
                    yield fixer.insertTextBefore(left, "...");
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***;
***REMOVED***

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description:
                "disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/prefer-object-spread"
        ***REMOVED***,

        schema: [],
        fixable: "code",

        messages: ***REMOVED***
            useSpreadMessage: "Use an object spread instead of `Object.assign` eg: `***REMOVED*** ...foo ***REMOVED***`.",
            useLiteralMessage: "Use an object literal instead of `Object.assign`. eg: `***REMOVED*** foo: bar ***REMOVED***`."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();

        return ***REMOVED***
            Program() ***REMOVED***
                const scope = context.getScope();
                const tracker = new ReferenceTracker(scope);
                const trackMap = ***REMOVED***
                    Object: ***REMOVED***
                        assign: ***REMOVED*** [CALL]: true ***REMOVED***
                    ***REMOVED***
                ***REMOVED***;

                // Iterate all calls of `Object.assign` (only of the global variable `Object`).
                for (const ***REMOVED*** node ***REMOVED*** of tracker.iterateGlobalReferences(trackMap)) ***REMOVED***
                    if (
                        node.arguments.length >= 1 &&
                        node.arguments[0].type === "ObjectExpression" &&
                        !hasArraySpread(node)
                    ) ***REMOVED***
                        const messageId = node.arguments.length === 1
                            ? "useLiteralMessage"
                            : "useSpreadMessage";
                        const fix = defineFixer(node, sourceCode);

                        context.report(***REMOVED*** node, messageId, fix ***REMOVED***);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
