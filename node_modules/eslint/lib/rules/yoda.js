/**
 * @fileoverview Rule to require or disallow yoda comparisons
 * @author Nicholas C. Zakas
 */
"use strict";

//--------------------------------------------------------------------------
// Requirements
//--------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//--------------------------------------------------------------------------
// Helpers
//--------------------------------------------------------------------------

/**
 * Determines whether an operator is a comparison operator.
 * @param ***REMOVED***string***REMOVED*** operator The operator to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not it is a comparison operator.
 */
function isComparisonOperator(operator) ***REMOVED***
    return (/^(==|===|!=|!==|<|>|<=|>=)$/u).test(operator);
***REMOVED***

/**
 * Determines whether an operator is an equality operator.
 * @param ***REMOVED***string***REMOVED*** operator The operator to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not it is an equality operator.
 */
function isEqualityOperator(operator) ***REMOVED***
    return (/^(==|===)$/u).test(operator);
***REMOVED***

/**
 * Determines whether an operator is one used in a range test.
 * Allowed operators are `<` and `<=`.
 * @param ***REMOVED***string***REMOVED*** operator The operator to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether the operator is used in range tests.
 */
function isRangeTestOperator(operator) ***REMOVED***
    return ["<", "<="].indexOf(operator) >= 0;
***REMOVED***

/**
 * Determines whether a non-Literal node is a negative number that should be
 * treated as if it were a single Literal node.
 * @param ***REMOVED***ASTNode***REMOVED*** node Node to test.
 * @returns ***REMOVED***boolean***REMOVED*** True if the node is a negative number that looks like a
 *                    real literal and should be treated as such.
 */
function looksLikeLiteral(node) ***REMOVED***
    return (node.type === "UnaryExpression" &&
        node.operator === "-" &&
        node.prefix &&
        node.argument.type === "Literal" &&
        typeof node.argument.value === "number");
***REMOVED***

/**
 * Attempts to derive a Literal node from nodes that are treated like literals.
 * @param ***REMOVED***ASTNode***REMOVED*** node Node to normalize.
 * @param ***REMOVED***number***REMOVED*** [defaultValue] The default value to be returned if the node
 *                                is not a Literal.
 * @returns ***REMOVED***ASTNode***REMOVED*** One of the following options.
 *  1. The original node if the node is already a Literal
 *  2. A normalized Literal node with the negative number as the value if the
 *     node represents a negative number literal.
 *  3. The Literal node which has the `defaultValue` argument if it exists.
 *  4. Otherwise `null`.
 */
function getNormalizedLiteral(node, defaultValue) ***REMOVED***
    if (node.type === "Literal") ***REMOVED***
        return node;
    ***REMOVED***

    if (looksLikeLiteral(node)) ***REMOVED***
        return ***REMOVED***
            type: "Literal",
            value: -node.argument.value,
            raw: `-$***REMOVED***node.argument.value***REMOVED***`
        ***REMOVED***;
    ***REMOVED***

    if (defaultValue) ***REMOVED***
        return ***REMOVED***
            type: "Literal",
            value: defaultValue,
            raw: String(defaultValue)
        ***REMOVED***;
    ***REMOVED***

    return null;
***REMOVED***

/**
 * Checks whether two expressions reference the same value. For example:
 *     a = a
 *     a.b = a.b
 *     a[0] = a[0]
 *     a['b'] = a['b']
 * @param   ***REMOVED***ASTNode***REMOVED*** a Left side of the comparison.
 * @param   ***REMOVED***ASTNode***REMOVED*** b Right side of the comparison.
 * @returns ***REMOVED***boolean***REMOVED***   True if both sides match and reference the same value.
 */
function same(a, b) ***REMOVED***
    if (a.type !== b.type) ***REMOVED***
        return false;
    ***REMOVED***

    switch (a.type) ***REMOVED***
        case "Identifier":
            return a.name === b.name;

        case "Literal":
            return a.value === b.value;

        case "MemberExpression": ***REMOVED***
            const nameA = astUtils.getStaticPropertyName(a);

            // x.y = x["y"]
            if (nameA !== null) ***REMOVED***
                return (
                    same(a.object, b.object) &&
                    nameA === astUtils.getStaticPropertyName(b)
                );
            ***REMOVED***

            /*
             * x[0] = x[0]
             * x[y] = x[y]
             * x.y = x.y
             */
            return (
                a.computed === b.computed &&
                same(a.object, b.object) &&
                same(a.property, b.property)
            );
        ***REMOVED***

        case "ThisExpression":
            return true;

        default:
            return false;
    ***REMOVED***
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "require or disallow \"Yoda\" conditions",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/yoda"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                enum: ["always", "never"]
            ***REMOVED***,
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    exceptRange: ***REMOVED***
                        type: "boolean",
                        default: false
                    ***REMOVED***,
                    onlyEquality: ***REMOVED***
                        type: "boolean",
                        default: false
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],

        fixable: "code",
        messages: ***REMOVED***
            expected: "Expected literal to be on the ***REMOVED******REMOVED***expectedSide***REMOVED******REMOVED*** side of ***REMOVED******REMOVED***operator***REMOVED******REMOVED***."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        // Default to "never" (!always) if no option
        const always = (context.options[0] === "always");
        const exceptRange = (context.options[1] && context.options[1].exceptRange);
        const onlyEquality = (context.options[1] && context.options[1].onlyEquality);

        const sourceCode = context.getSourceCode();

        /**
         * Determines whether node represents a range test.
         * A range test is a "between" test like `(0 <= x && x < 1)` or an "outside"
         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and
         * both operators must be `<` or `<=`. Finally, the literal on the left side
         * must be less than or equal to the literal on the right side so that the
         * test makes any sense.
         * @param ***REMOVED***ASTNode***REMOVED*** node LogicalExpression node to test.
         * @returns ***REMOVED***boolean***REMOVED*** Whether node is a range test.
         */
        function isRangeTest(node) ***REMOVED***
            const left = node.left,
                right = node.right;

            /**
             * Determines whether node is of the form `0 <= x && x < 1`.
             * @returns ***REMOVED***boolean***REMOVED*** Whether node is a "between" range test.
             */
            function isBetweenTest() ***REMOVED***
                let leftLiteral, rightLiteral;

                return (node.operator === "&&" &&
                    (leftLiteral = getNormalizedLiteral(left.left)) &&
                    (rightLiteral = getNormalizedLiteral(right.right, Number.POSITIVE_INFINITY)) &&
                    leftLiteral.value <= rightLiteral.value &&
                    same(left.right, right.left));
            ***REMOVED***

            /**
             * Determines whether node is of the form `x < 0 || 1 <= x`.
             * @returns ***REMOVED***boolean***REMOVED*** Whether node is an "outside" range test.
             */
            function isOutsideTest() ***REMOVED***
                let leftLiteral, rightLiteral;

                return (node.operator === "||" &&
                    (leftLiteral = getNormalizedLiteral(left.right, Number.NEGATIVE_INFINITY)) &&
                    (rightLiteral = getNormalizedLiteral(right.left)) &&
                    leftLiteral.value <= rightLiteral.value &&
                    same(left.left, right.right));
            ***REMOVED***

            /**
             * Determines whether node is wrapped in parentheses.
             * @returns ***REMOVED***boolean***REMOVED*** Whether node is preceded immediately by an open
             *                    paren token and followed immediately by a close
             *                    paren token.
             */
            function isParenWrapped() ***REMOVED***
                return astUtils.isParenthesised(sourceCode, node);
            ***REMOVED***

            return (node.type === "LogicalExpression" &&
                left.type === "BinaryExpression" &&
                right.type === "BinaryExpression" &&
                isRangeTestOperator(left.operator) &&
                isRangeTestOperator(right.operator) &&
                (isBetweenTest() || isOutsideTest()) &&
                isParenWrapped());
        ***REMOVED***

        const OPERATOR_FLIP_MAP = ***REMOVED***
            "===": "===",
            "!==": "!==",
            "==": "==",
            "!=": "!=",
            "<": ">",
            ">": "<",
            "<=": ">=",
            ">=": "<="
        ***REMOVED***;

        /**
         * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.
         * @param ***REMOVED***ASTNode***REMOVED*** node The BinaryExpression node
         * @returns ***REMOVED***string***REMOVED*** A string representation of the node with the sides and operator flipped
         */
        function getFlippedString(node) ***REMOVED***
            const tokenBefore = sourceCode.getTokenBefore(node);
            const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
            const textBeforeOperator = sourceCode.getText().slice(sourceCode.getTokenBefore(operatorToken).range[1], operatorToken.range[0]);
            const textAfterOperator = sourceCode.getText().slice(operatorToken.range[1], sourceCode.getTokenAfter(operatorToken).range[0]);
            const leftText = sourceCode.getText().slice(node.range[0], sourceCode.getTokenBefore(operatorToken).range[1]);
            const firstRightToken = sourceCode.getTokenAfter(operatorToken);
            const rightText = sourceCode.getText().slice(firstRightToken.range[0], node.range[1]);

            let prefix = "";

            if (tokenBefore && tokenBefore.range[1] === node.range[0] &&
                    !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)) ***REMOVED***
                prefix = " ";
            ***REMOVED***

            return prefix + rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText;
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***
            BinaryExpression(node) ***REMOVED***
                const expectedLiteral = always ? node.left : node.right;
                const expectedNonLiteral = always ? node.right : node.left;

                // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.
                if (
                    (expectedNonLiteral.type === "Literal" || looksLikeLiteral(expectedNonLiteral)) &&
                    !(expectedLiteral.type === "Literal" || looksLikeLiteral(expectedLiteral)) &&
                    !(!isEqualityOperator(node.operator) && onlyEquality) &&
                    isComparisonOperator(node.operator) &&
                    !(exceptRange && isRangeTest(context.getAncestors().pop()))
                ) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        messageId: "expected",
                        data: ***REMOVED***
                            operator: node.operator,
                            expectedSide: always ? "left" : "right"
                        ***REMOVED***,
                        fix: fixer => fixer.replaceText(node, getFlippedString(node))
                    ***REMOVED***);
                ***REMOVED***

            ***REMOVED***
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
