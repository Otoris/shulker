/**
 * @fileoverview Rule to flag `else` after a `return` in `if`
 * @author Ian Christian Myers
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");
const FixTracker = require("./utils/fix-tracker");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow `else` blocks after `return` statements in `if` statements",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-else-return"
        ***REMOVED***,

        schema: [***REMOVED***
            type: "object",
            properties: ***REMOVED***
                allowElseIf: ***REMOVED***
                    type: "boolean",
                    default: true
                ***REMOVED***
            ***REMOVED***,
            additionalProperties: false
        ***REMOVED***],

        fixable: "code",

        messages: ***REMOVED***
            unexpected: "Unnecessary 'else' after 'return'."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Checks whether the given names can be safely used to declare block-scoped variables
         * in the given scope. Name collisions can produce redeclaration syntax errors,
         * or silently change references and modify behavior of the original code.
         *
         * This is not a generic function. In particular, it is assumed that the scope is a function scope or
         * a function's inner scope, and that the names can be valid identifiers in the given scope.
         *
         * @param ***REMOVED***string[]***REMOVED*** names Array of variable names.
         * @param ***REMOVED***eslint-scope.Scope***REMOVED*** scope Function scope or a function's inner scope.
         * @returns ***REMOVED***boolean***REMOVED*** True if all names can be safely declared, false otherwise.
         */
        function isSafeToDeclare(names, scope) ***REMOVED***

            if (names.length === 0) ***REMOVED***
                return true;
            ***REMOVED***

            const functionScope = scope.variableScope;

            /*
             * If this is a function scope, scope.variables will contain parameters, implicit variables such as "arguments",
             * all function-scoped variables ('var'), and block-scoped variables defined in the scope.
             * If this is an inner scope, scope.variables will contain block-scoped variables defined in the scope.
             *
             * Redeclaring any of these would cause a syntax error, except for the implicit variables.
             */
            const declaredVariables = scope.variables.filter((***REMOVED*** defs ***REMOVED***) => defs.length > 0);

            if (declaredVariables.some((***REMOVED*** name ***REMOVED***) => names.includes(name))) ***REMOVED***
                return false;
            ***REMOVED***

            // Redeclaring a catch variable would also cause a syntax error.
            if (scope !== functionScope && scope.upper.type === "catch") ***REMOVED***
                if (scope.upper.variables.some((***REMOVED*** name ***REMOVED***) => names.includes(name))) ***REMOVED***
                    return false;
                ***REMOVED***
            ***REMOVED***

            /*
             * Redeclaring an implicit variable, such as "arguments", would not cause a syntax error.
             * However, if the variable was used, declaring a new one with the same name would change references
             * and modify behavior.
             */
            const usedImplicitVariables = scope.variables.filter((***REMOVED*** defs, references ***REMOVED***) =>
                defs.length === 0 && references.length > 0);

            if (usedImplicitVariables.some((***REMOVED*** name ***REMOVED***) => names.includes(name))) ***REMOVED***
                return false;
            ***REMOVED***

            /*
             * Declaring a variable with a name that was already used to reference a variable from an upper scope
             * would change references and modify behavior.
             */
            if (scope.through.some(t => names.includes(t.identifier.name))) ***REMOVED***
                return false;
            ***REMOVED***

            /*
             * If the scope is an inner scope (not the function scope), an uninitialized `var` variable declared inside
             * the scope node (directly or in one of its descendants) is neither declared nor 'through' in the scope.
             *
             * For example, this would be a syntax error "Identifier 'a' has already been declared":
             * function foo() ***REMOVED*** if (bar) ***REMOVED*** let a; if (baz) ***REMOVED*** var a; ***REMOVED*** ***REMOVED*** ***REMOVED***
             */
            if (scope !== functionScope) ***REMOVED***
                const scopeNodeRange = scope.block.range;
                const variablesToCheck = functionScope.variables.filter((***REMOVED*** name ***REMOVED***) => names.includes(name));

                if (variablesToCheck.some(v => v.defs.some((***REMOVED*** node: ***REMOVED*** range ***REMOVED*** ***REMOVED***) =>
                    scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1]))) ***REMOVED***
                    return false;
                ***REMOVED***
            ***REMOVED***

            return true;
        ***REMOVED***


        /**
         * Checks whether the removal of `else` and its braces is safe from variable name collisions.
         *
         * @param ***REMOVED***Node***REMOVED*** node The 'else' node.
         * @param ***REMOVED***eslint-scope.Scope***REMOVED*** scope The scope in which the node and the whole 'if' statement is.
         * @returns ***REMOVED***boolean***REMOVED*** True if it is safe, false otherwise.
         */
        function isSafeFromNameCollisions(node, scope) ***REMOVED***

            if (node.type === "FunctionDeclaration") ***REMOVED***

                // Conditional function declaration. Scope and hoisting are unpredictable, different engines work differently.
                return false;
            ***REMOVED***

            if (node.type !== "BlockStatement") ***REMOVED***
                return true;
            ***REMOVED***

            const elseBlockScope = scope.childScopes.find((***REMOVED*** block ***REMOVED***) => block === node);

            if (!elseBlockScope) ***REMOVED***

                // ecmaVersion < 6, `else` block statement cannot have its own scope, no possible collisions.
                return true;
            ***REMOVED***

            /*
             * elseBlockScope is supposed to merge into its upper scope. elseBlockScope.variables array contains
             * only block-scoped variables (such as let and const variables or class and function declarations)
             * defined directly in the elseBlockScope. These are exactly the only names that could cause collisions.
             */
            const namesToCheck = elseBlockScope.variables.map((***REMOVED*** name ***REMOVED***) => name);

            return isSafeToDeclare(namesToCheck, scope);
        ***REMOVED***

        /**
         * Display the context report if rule is violated
         *
         * @param ***REMOVED***Node***REMOVED*** node The 'else' node
         * @returns ***REMOVED***void***REMOVED***
         */
        function displayReport(node) ***REMOVED***
            const currentScope = context.getScope();

            context.report(***REMOVED***
                node,
                messageId: "unexpected",
                fix: fixer => ***REMOVED***

                    if (!isSafeFromNameCollisions(node, currentScope)) ***REMOVED***
                        return null;
                    ***REMOVED***

                    const sourceCode = context.getSourceCode();
                    const startToken = sourceCode.getFirstToken(node);
                    const elseToken = sourceCode.getTokenBefore(startToken);
                    const source = sourceCode.getText(node);
                    const lastIfToken = sourceCode.getTokenBefore(elseToken);
                    let fixedSource, firstTokenOfElseBlock;

                    if (startToken.type === "Punctuator" && startToken.value === "***REMOVED***") ***REMOVED***
                        firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);
                    ***REMOVED*** else ***REMOVED***
                        firstTokenOfElseBlock = startToken;
                    ***REMOVED***

                    /*
                     * If the if block does not have curly braces and does not end in a semicolon
                     * and the else block starts with (, [, /, +, ` or -, then it is not
                     * safe to remove the else keyword, because ASI will not add a semicolon
                     * after the if block
                     */
                    const ifBlockMaybeUnsafe = node.parent.consequent.type !== "BlockStatement" && lastIfToken.value !== ";";
                    const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);

                    if (ifBlockMaybeUnsafe && elseBlockUnsafe) ***REMOVED***
                        return null;
                    ***REMOVED***

                    const endToken = sourceCode.getLastToken(node);
                    const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);

                    if (lastTokenOfElseBlock.value !== ";") ***REMOVED***
                        const nextToken = sourceCode.getTokenAfter(endToken);

                        const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);
                        const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;

                        /*
                         * If the else block contents does not end in a semicolon,
                         * and the else block starts with (, [, /, +, ` or -, then it is not
                         * safe to remove the else block, because ASI will not add a semicolon
                         * after the remaining else block contents
                         */
                        if (nextTokenUnsafe || (nextTokenOnSameLine && nextToken.value !== "***REMOVED***")) ***REMOVED***
                            return null;
                        ***REMOVED***
                    ***REMOVED***

                    if (startToken.type === "Punctuator" && startToken.value === "***REMOVED***") ***REMOVED***
                        fixedSource = source.slice(1, -1);
                    ***REMOVED*** else ***REMOVED***
                        fixedSource = source;
                    ***REMOVED***

                    /*
                     * Extend the replacement range to include the entire
                     * function to avoid conflicting with no-useless-return.
                     * https://github.com/eslint/eslint/issues/8026
                     *
                     * Also, to avoid name collisions between two else blocks.
                     */
                    return new FixTracker(fixer, sourceCode)
                        .retainEnclosingFunction(node)
                        .replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        /**
         * Check to see if the node is a ReturnStatement
         *
         * @param ***REMOVED***Node***REMOVED*** node The node being evaluated
         * @returns ***REMOVED***boolean***REMOVED*** True if node is a return
         */
        function checkForReturn(node) ***REMOVED***
            return node.type === "ReturnStatement";
        ***REMOVED***

        /**
         * Naive return checking, does not iterate through the whole
         * BlockStatement because we make the assumption that the ReturnStatement
         * will be the last node in the body of the BlockStatement.
         *
         * @param ***REMOVED***Node***REMOVED*** node The consequent/alternate node
         * @returns ***REMOVED***boolean***REMOVED*** True if it has a return
         */
        function naiveHasReturn(node) ***REMOVED***
            if (node.type === "BlockStatement") ***REMOVED***
                const body = node.body,
                    lastChildNode = body[body.length - 1];

                return lastChildNode && checkForReturn(lastChildNode);
            ***REMOVED***
            return checkForReturn(node);
        ***REMOVED***

        /**
         * Check to see if the node is valid for evaluation,
         * meaning it has an else.
         *
         * @param ***REMOVED***Node***REMOVED*** node The node being evaluated
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is valid
         */
        function hasElse(node) ***REMOVED***
            return node.alternate && node.consequent;
        ***REMOVED***

        /**
         * If the consequent is an IfStatement, check to see if it has an else
         * and both its consequent and alternate path return, meaning this is
         * a nested case of rule violation.  If-Else not considered currently.
         *
         * @param ***REMOVED***Node***REMOVED*** node The consequent node
         * @returns ***REMOVED***boolean***REMOVED*** True if this is a nested rule violation
         */
        function checkForIf(node) ***REMOVED***
            return node.type === "IfStatement" && hasElse(node) &&
                naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);
        ***REMOVED***

        /**
         * Check the consequent/body node to make sure it is not
         * a ReturnStatement or an IfStatement that returns on both
         * code paths.
         *
         * @param ***REMOVED***Node***REMOVED*** node The consequent or body node
         * @returns ***REMOVED***boolean***REMOVED*** `true` if it is a Return/If node that always returns.
         */
        function checkForReturnOrIf(node) ***REMOVED***
            return checkForReturn(node) || checkForIf(node);
        ***REMOVED***


        /**
         * Check whether a node returns in every codepath.
         * @param ***REMOVED***Node***REMOVED*** node The node to be checked
         * @returns ***REMOVED***boolean***REMOVED*** `true` if it returns on every codepath.
         */
        function alwaysReturns(node) ***REMOVED***
            if (node.type === "BlockStatement") ***REMOVED***

                // If we have a BlockStatement, check each consequent body node.
                return node.body.some(checkForReturnOrIf);
            ***REMOVED***

            /*
             * If not a block statement, make sure the consequent isn't a
             * ReturnStatement or an IfStatement with returns on both paths.
             */
            return checkForReturnOrIf(node);
        ***REMOVED***


        /**
         * Check the if statement, but don't catch else-if blocks.
         * @returns ***REMOVED***void***REMOVED***
         * @param ***REMOVED***Node***REMOVED*** node The node for the if statement to check
         * @private
         */
        function checkIfWithoutElse(node) ***REMOVED***
            const parent = node.parent;

            /*
             * Fixing this would require splitting one statement into two, so no error should
             * be reported if this node is in a position where only one statement is allowed.
             */
            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) ***REMOVED***
                return;
            ***REMOVED***

            const consequents = [];
            let alternate;

            for (let currentNode = node; currentNode.type === "IfStatement"; currentNode = currentNode.alternate) ***REMOVED***
                if (!currentNode.alternate) ***REMOVED***
                    return;
                ***REMOVED***
                consequents.push(currentNode.consequent);
                alternate = currentNode.alternate;
            ***REMOVED***

            if (consequents.every(alwaysReturns)) ***REMOVED***
                displayReport(alternate);
            ***REMOVED***
        ***REMOVED***

        /**
         * Check the if statement
         * @returns ***REMOVED***void***REMOVED***
         * @param ***REMOVED***Node***REMOVED*** node The node for the if statement to check
         * @private
         */
        function checkIfWithElse(node) ***REMOVED***
            const parent = node.parent;


            /*
             * Fixing this would require splitting one statement into two, so no error should
             * be reported if this node is in a position where only one statement is allowed.
             */
            if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) ***REMOVED***
                return;
            ***REMOVED***

            const alternate = node.alternate;

            if (alternate && alwaysReturns(node.consequent)) ***REMOVED***
                displayReport(alternate);
            ***REMOVED***
        ***REMOVED***

        const allowElseIf = !(context.options[0] && context.options[0].allowElseIf === false);

        //--------------------------------------------------------------------------
        // Public API
        //--------------------------------------------------------------------------

        return ***REMOVED***

            "IfStatement:exit": allowElseIf ? checkIfWithoutElse : checkIfWithElse

        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
