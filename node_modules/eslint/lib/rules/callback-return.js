/**
 * @fileoverview Enforce return after a callback.
 * @author Jamund Ferguson
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "require `return` statements after callbacks",
            category: "Node.js and CommonJS",
            recommended: false,
            url: "https://eslint.org/docs/rules/callback-return"
        ***REMOVED***,

        schema: [***REMOVED***
            type: "array",
            items: ***REMOVED*** type: "string" ***REMOVED***
        ***REMOVED***],

        messages: ***REMOVED***
            missingReturn: "Expected return with your callback function."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        const callbacks = context.options[0] || ["callback", "cb", "next"],
            sourceCode = context.getSourceCode();

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Find the closest parent matching a list of types.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node whose parents we are searching
         * @param ***REMOVED***Array***REMOVED*** types The node types to match
         * @returns ***REMOVED***ASTNode***REMOVED*** The matched node or undefined.
         */
        function findClosestParentOfType(node, types) ***REMOVED***
            if (!node.parent) ***REMOVED***
                return null;
            ***REMOVED***
            if (types.indexOf(node.parent.type) === -1) ***REMOVED***
                return findClosestParentOfType(node.parent, types);
            ***REMOVED***
            return node.parent;
        ***REMOVED***

        /**
         * Check to see if a node contains only identifers
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not the node contains only identifers
         */
        function containsOnlyIdentifiers(node) ***REMOVED***
            if (node.type === "Identifier") ***REMOVED***
                return true;
            ***REMOVED***

            if (node.type === "MemberExpression") ***REMOVED***
                if (node.object.type === "Identifier") ***REMOVED***
                    return true;
                ***REMOVED***
                if (node.object.type === "MemberExpression") ***REMOVED***
                    return containsOnlyIdentifiers(node.object);
                ***REMOVED***
            ***REMOVED***

            return false;
        ***REMOVED***

        /**
         * Check to see if a CallExpression is in our callback list.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check against our callback names list.
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not this function matches our callback name.
         */
        function isCallback(node) ***REMOVED***
            return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;
        ***REMOVED***

        /**
         * Determines whether or not the callback is part of a callback expression.
         * @param ***REMOVED***ASTNode***REMOVED*** node The callback node
         * @param ***REMOVED***ASTNode***REMOVED*** parentNode The expression node
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not this is part of a callback expression
         */
        function isCallbackExpression(node, parentNode) ***REMOVED***

            // ensure the parent node exists and is an expression
            if (!parentNode || parentNode.type !== "ExpressionStatement") ***REMOVED***
                return false;
            ***REMOVED***

            // cb()
            if (parentNode.expression === node) ***REMOVED***
                return true;
            ***REMOVED***

            // special case for cb && cb() and similar
            if (parentNode.expression.type === "BinaryExpression" || parentNode.expression.type === "LogicalExpression") ***REMOVED***
                if (parentNode.expression.right === node) ***REMOVED***
                    return true;
                ***REMOVED***
            ***REMOVED***

            return false;
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***
            CallExpression(node) ***REMOVED***

                // if we're not a callback we can return
                if (!isCallback(node)) ***REMOVED***
                    return;
                ***REMOVED***

                // find the closest block, return or loop
                const closestBlock = findClosestParentOfType(node, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || ***REMOVED******REMOVED***;

                // if our parent is a return we know we're ok
                if (closestBlock.type === "ReturnStatement") ***REMOVED***
                    return;
                ***REMOVED***

                // arrow functions don't always have blocks and implicitly return
                if (closestBlock.type === "ArrowFunctionExpression") ***REMOVED***
                    return;
                ***REMOVED***

                // block statements are part of functions and most if statements
                if (closestBlock.type === "BlockStatement") ***REMOVED***

                    // find the last item in the block
                    const lastItem = closestBlock.body[closestBlock.body.length - 1];

                    // if the callback is the last thing in a block that might be ok
                    if (isCallbackExpression(node, lastItem)) ***REMOVED***

                        const parentType = closestBlock.parent.type;

                        // but only if the block is part of a function
                        if (parentType === "FunctionExpression" ||
                            parentType === "FunctionDeclaration" ||
                            parentType === "ArrowFunctionExpression"
                        ) ***REMOVED***
                            return;
                        ***REMOVED***

                    ***REMOVED***

                    // ending a block with a return is also ok
                    if (lastItem.type === "ReturnStatement") ***REMOVED***

                        // but only if the callback is immediately before
                        if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) ***REMOVED***
                            return;
                        ***REMOVED***
                    ***REMOVED***

                ***REMOVED***

                // as long as you're the child of a function at this point you should be asked to return
                if (findClosestParentOfType(node, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"])) ***REMOVED***
                    context.report(***REMOVED*** node, messageId: "missingReturn" ***REMOVED***);
                ***REMOVED***

            ***REMOVED***

        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
