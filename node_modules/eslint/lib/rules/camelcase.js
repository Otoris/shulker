/**
 * @fileoverview Rule to flag non-camelcased identifiers
 * @author Nicholas C. Zakas
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "enforce camelcase naming convention",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/camelcase"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    ignoreDestructuring: ***REMOVED***
                        type: "boolean",
                        default: false
                    ***REMOVED***,
                    properties: ***REMOVED***
                        enum: ["always", "never"]
                    ***REMOVED***,
                    allow: ***REMOVED***
                        type: "array",
                        items: [
                            ***REMOVED***
                                type: "string"
                            ***REMOVED***
                        ],
                        minItems: 0,
                        uniqueItems: true
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],

        messages: ***REMOVED***
            notCamelCase: "Identifier '***REMOVED******REMOVED***name***REMOVED******REMOVED***' is not in camel case."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        const options = context.options[0] || ***REMOVED******REMOVED***;
        let properties = options.properties || "";
        const ignoreDestructuring = options.ignoreDestructuring;
        const allow = options.allow || [];

        if (properties !== "always" && properties !== "never") ***REMOVED***
            properties = "always";
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation
        const reported = [];
        const ALLOWED_PARENT_TYPES = new Set(["CallExpression", "NewExpression"]);

        /**
         * Checks if a string contains an underscore and isn't all upper-case
         * @param ***REMOVED***string***REMOVED*** name The string to check.
         * @returns ***REMOVED***boolean***REMOVED*** if the string is underscored
         * @private
         */
        function isUnderscored(name) ***REMOVED***

            // if there's an underscore, it might be A_CONSTANT, which is okay
            return name.indexOf("_") > -1 && name !== name.toUpperCase();
        ***REMOVED***

        /**
         * Checks if a string match the ignore list
         * @param ***REMOVED***string***REMOVED*** name The string to check.
         * @returns ***REMOVED***boolean***REMOVED*** if the string is ignored
         * @private
         */
        function isAllowed(name) ***REMOVED***
            return allow.findIndex(
                entry => name === entry || name.match(new RegExp(entry, "u"))
            ) !== -1;
        ***REMOVED***

        /**
         * Checks if a parent of a node is an ObjectPattern.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
         * @returns ***REMOVED***boolean***REMOVED*** if the node is inside an ObjectPattern
         * @private
         */
        function isInsideObjectPattern(node) ***REMOVED***
            let current = node;

            while (current) ***REMOVED***
                const parent = current.parent;

                if (parent && parent.type === "Property" && parent.computed && parent.key === current) ***REMOVED***
                    return false;
                ***REMOVED***

                if (current.type === "ObjectPattern") ***REMOVED***
                    return true;
                ***REMOVED***

                current = parent;
            ***REMOVED***

            return false;
        ***REMOVED***

        /**
         * Reports an AST node as a rule violation.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to report.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function report(node) ***REMOVED***
            if (reported.indexOf(node) < 0) ***REMOVED***
                reported.push(node);
                context.report(***REMOVED*** node, messageId: "notCamelCase", data: ***REMOVED*** name: node.name ***REMOVED*** ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***

            Identifier(node) ***REMOVED***

                /*
                 * Leading and trailing underscores are commonly used to flag
                 * private/protected identifiers, strip them before checking if underscored
                 */
                const name = node.name,
                    nameIsUnderscored = isUnderscored(name.replace(/^_+|_+$/gu, "")),
                    effectiveParent = (node.parent.type === "MemberExpression") ? node.parent.parent : node.parent;

                // First, we ignore the node if it match the ignore list
                if (isAllowed(name)) ***REMOVED***
                    return;
                ***REMOVED***

                // MemberExpressions get special rules
                if (node.parent.type === "MemberExpression") ***REMOVED***

                    // "never" check properties
                    if (properties === "never") ***REMOVED***
                        return;
                    ***REMOVED***

                    // Always report underscored object names
                    if (node.parent.object.type === "Identifier" && node.parent.object.name === node.name && nameIsUnderscored) ***REMOVED***
                        report(node);

                    // Report AssignmentExpressions only if they are the left side of the assignment
                    ***REMOVED*** else if (effectiveParent.type === "AssignmentExpression" && nameIsUnderscored && (effectiveParent.right.type !== "MemberExpression" || effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === node.name)) ***REMOVED***
                        report(node);
                    ***REMOVED***

                /*
                 * Properties have their own rules, and
                 * AssignmentPattern nodes can be treated like Properties:
                 * e.g.: const ***REMOVED*** no_camelcased = false ***REMOVED*** = bar;
                 */
                ***REMOVED*** else if (node.parent.type === "Property" || node.parent.type === "AssignmentPattern") ***REMOVED***

                    if (node.parent.parent && node.parent.parent.type === "ObjectPattern") ***REMOVED***
                        if (node.parent.shorthand && node.parent.value.left && nameIsUnderscored) ***REMOVED***
                            report(node);
                        ***REMOVED***

                        const assignmentKeyEqualsValue = node.parent.key.name === node.parent.value.name;

                        if (isUnderscored(name) && node.parent.computed) ***REMOVED***
                            report(node);
                        ***REMOVED***

                        // prevent checking righthand side of destructured object
                        if (node.parent.key === node && node.parent.value !== node) ***REMOVED***
                            return;
                        ***REMOVED***

                        const valueIsUnderscored = node.parent.value.name && nameIsUnderscored;

                        // ignore destructuring if the option is set, unless a new identifier is created
                        if (valueIsUnderscored && !(assignmentKeyEqualsValue && ignoreDestructuring)) ***REMOVED***
                            report(node);
                        ***REMOVED***
                    ***REMOVED***

                    // "never" check properties or always ignore destructuring
                    if (properties === "never" || (ignoreDestructuring && isInsideObjectPattern(node))) ***REMOVED***
                        return;
                    ***REMOVED***

                    // don't check right hand side of AssignmentExpression to prevent duplicate warnings
                    if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && !(node.parent.right === node)) ***REMOVED***
                        report(node);
                    ***REMOVED***

                // Check if it's an import specifier
                ***REMOVED*** else if (["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"].indexOf(node.parent.type) >= 0) ***REMOVED***

                    // Report only if the local imported identifier is underscored
                    if (node.parent.local && node.parent.local.name === node.name && nameIsUnderscored) ***REMOVED***
                        report(node);
                    ***REMOVED***

                // Report anything that is underscored that isn't a CallExpression
                ***REMOVED*** else if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) ***REMOVED***
                    report(node);
                ***REMOVED***
            ***REMOVED***

        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
