/**
 * @fileoverview Rule to flag statements without curly braces
 * @author Nicholas C. Zakas
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "enforce consistent brace style for all control statements",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/curly"
        ***REMOVED***,

        schema: ***REMOVED***
            anyOf: [
                ***REMOVED***
                    type: "array",
                    items: [
                        ***REMOVED***
                            enum: ["all"]
                        ***REMOVED***
                    ],
                    minItems: 0,
                    maxItems: 1
                ***REMOVED***,
                ***REMOVED***
                    type: "array",
                    items: [
                        ***REMOVED***
                            enum: ["multi", "multi-line", "multi-or-nest"]
                        ***REMOVED***,
                        ***REMOVED***
                            enum: ["consistent"]
                        ***REMOVED***
                    ],
                    minItems: 0,
                    maxItems: 2
                ***REMOVED***
            ]
        ***REMOVED***,

        fixable: "code",

        messages: ***REMOVED***
            missingCurlyAfter: "Expected ***REMOVED*** after '***REMOVED******REMOVED***name***REMOVED******REMOVED***'.",
            missingCurlyAfterCondition: "Expected ***REMOVED*** after '***REMOVED******REMOVED***name***REMOVED******REMOVED***' condition.",
            unexpectedCurlyAfter: "Unnecessary ***REMOVED*** after '***REMOVED******REMOVED***name***REMOVED******REMOVED***'.",
            unexpectedCurlyAfterCondition: "Unnecessary ***REMOVED*** after '***REMOVED******REMOVED***name***REMOVED******REMOVED***' condition."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        const multiOnly = (context.options[0] === "multi");
        const multiLine = (context.options[0] === "multi-line");
        const multiOrNest = (context.options[0] === "multi-or-nest");
        const consistent = (context.options[1] === "consistent");

        const sourceCode = context.getSourceCode();

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Determines if a given node is a one-liner that's on the same line as it's preceding code.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is a one-liner that's on the same line as it's preceding code.
         * @private
         */
        function isCollapsedOneLiner(node) ***REMOVED***
            const before = sourceCode.getTokenBefore(node);
            const last = sourceCode.getLastToken(node);
            const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;

            return before.loc.start.line === lastExcludingSemicolon.loc.end.line;
        ***REMOVED***

        /**
         * Determines if a given node is a one-liner.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is a one-liner.
         * @private
         */
        function isOneLiner(node) ***REMOVED***
            const first = sourceCode.getFirstToken(node),
                last = sourceCode.getLastToken(node);

            return first.loc.start.line === last.loc.end.line;
        ***REMOVED***

        /**
         * Determines if the given node is a lexical declaration (let, const, function, or class)
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is a lexical declaration
         * @private
         */
        function isLexicalDeclaration(node) ***REMOVED***
            if (node.type === "VariableDeclaration") ***REMOVED***
                return node.kind === "const" || node.kind === "let";
            ***REMOVED***

            return node.type === "FunctionDeclaration" || node.type === "ClassDeclaration";
        ***REMOVED***

        /**
         * Checks if the given token is an `else` token or not.
         *
         * @param ***REMOVED***Token***REMOVED*** token - The token to check.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is an `else` token.
         */
        function isElseKeywordToken(token) ***REMOVED***
            return token.value === "else" && token.type === "Keyword";
        ***REMOVED***

        /**
         * Gets the `else` keyword token of a given `IfStatement` node.
         * @param ***REMOVED***ASTNode***REMOVED*** node - A `IfStatement` node to get.
         * @returns ***REMOVED***Token***REMOVED*** The `else` keyword token.
         */
        function getElseKeyword(node) ***REMOVED***
            return node.alternate && sourceCode.getFirstTokenBetween(node.consequent, node.alternate, isElseKeywordToken);
        ***REMOVED***

        /**
         * Checks a given IfStatement node requires braces of the consequent chunk.
         * This returns `true` when below:
         *
         * 1. The given node has the `alternate` node.
         * 2. There is a `IfStatement` which doesn't have `alternate` node in the
         *    trailing statement chain of the `consequent` node.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node - A IfStatement node to check.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the node requires braces of the consequent chunk.
         */
        function requiresBraceOfConsequent(node) ***REMOVED***
            if (node.alternate && node.consequent.type === "BlockStatement") ***REMOVED***
                if (node.consequent.body.length >= 2) ***REMOVED***
                    return true;
                ***REMOVED***

                for (
                    let currentNode = node.consequent.body[0];
                    currentNode;
                    currentNode = astUtils.getTrailingStatement(currentNode)
                ) ***REMOVED***
                    if (currentNode.type === "IfStatement" && !currentNode.alternate) ***REMOVED***
                        return true;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***

            return false;
        ***REMOVED***

        /**
         * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.
         * @param ***REMOVED***Token***REMOVED*** closingBracket The ***REMOVED*** token
         * @returns ***REMOVED***boolean***REMOVED*** `true` if a semicolon needs to be inserted after the last statement in the block.
         */
        function needsSemicolon(closingBracket) ***REMOVED***
            const tokenBefore = sourceCode.getTokenBefore(closingBracket);
            const tokenAfter = sourceCode.getTokenAfter(closingBracket);
            const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);

            if (astUtils.isSemicolonToken(tokenBefore)) ***REMOVED***

                // If the last statement already has a semicolon, don't add another one.
                return false;
            ***REMOVED***

            if (!tokenAfter) ***REMOVED***

                // If there are no statements after this block, there is no need to add a semicolon.
                return false;
            ***REMOVED***

            if (lastBlockNode.type === "BlockStatement" && lastBlockNode.parent.type !== "FunctionExpression" && lastBlockNode.parent.type !== "ArrowFunctionExpression") ***REMOVED***

                /*
                 * If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),
                 * don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause
                 * a SyntaxError if it was followed by `else`.
                 */
                return false;
            ***REMOVED***

            if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) ***REMOVED***

                // If the next token is on the same line, insert a semicolon.
                return true;
            ***REMOVED***

            if (/^[([/`+-]/u.test(tokenAfter.value)) ***REMOVED***

                // If the next token starts with a character that would disrupt ASI, insert a semicolon.
                return true;
            ***REMOVED***

            if (tokenBefore.type === "Punctuator" && (tokenBefore.value === "++" || tokenBefore.value === "--")) ***REMOVED***

                // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.
                return true;
            ***REMOVED***

            // Otherwise, do not insert a semicolon.
            return false;
        ***REMOVED***

        /**
         * Prepares to check the body of a node to see if it's a block statement.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to report if there's a problem.
         * @param ***REMOVED***ASTNode***REMOVED*** body The body node to check for blocks.
         * @param ***REMOVED***string***REMOVED*** name The name to report if there's a problem.
         * @param ***REMOVED******REMOVED*** condition: boolean ***REMOVED******REMOVED*** opts Options to pass to the report functions
         * @returns ***REMOVED***Object***REMOVED*** a prepared check object, with "actual", "expected", "check" properties.
         *   "actual" will be `true` or `false` whether the body is already a block statement.
         *   "expected" will be `true` or `false` if the body should be a block statement or not, or
         *   `null` if it doesn't matter, depending on the rule options. It can be modified to change
         *   the final behavior of "check".
         *   "check" will be a function reporting appropriate problems depending on the other
         *   properties.
         */
        function prepareCheck(node, body, name, opts) ***REMOVED***
            const hasBlock = (body.type === "BlockStatement");
            let expected = null;

            if (node.type === "IfStatement" && node.consequent === body && requiresBraceOfConsequent(node)) ***REMOVED***
                expected = true;
            ***REMOVED*** else if (multiOnly) ***REMOVED***
                if (hasBlock && body.body.length === 1) ***REMOVED***
                    expected = false;
                ***REMOVED***
            ***REMOVED*** else if (multiLine) ***REMOVED***
                if (!isCollapsedOneLiner(body)) ***REMOVED***
                    expected = true;
                ***REMOVED***
            ***REMOVED*** else if (multiOrNest) ***REMOVED***
                if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) ***REMOVED***
                    const leadingComments = sourceCode.getCommentsBefore(body.body[0]);
                    const isLexDef = isLexicalDeclaration(body.body[0]);

                    if (isLexDef) ***REMOVED***
                        expected = true;
                    ***REMOVED*** else ***REMOVED***
                        expected = leadingComments.length > 0;
                    ***REMOVED***
                ***REMOVED*** else if (!isOneLiner(body)) ***REMOVED***
                    expected = true;
                ***REMOVED***
            ***REMOVED*** else ***REMOVED***
                expected = true;
            ***REMOVED***

            return ***REMOVED***
                actual: hasBlock,
                expected,
                check() ***REMOVED***
                    if (this.expected !== null && this.expected !== this.actual) ***REMOVED***
                        if (this.expected) ***REMOVED***
                            context.report(***REMOVED***
                                node,
                                loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
                                messageId: opts && opts.condition ? "missingCurlyAfterCondition" : "missingCurlyAfter",
                                data: ***REMOVED***
                                    name
                                ***REMOVED***,
                                fix: fixer => fixer.replaceText(body, `***REMOVED***$***REMOVED***sourceCode.getText(body)***REMOVED******REMOVED***`)
                            ***REMOVED***);
                        ***REMOVED*** else ***REMOVED***
                            context.report(***REMOVED***
                                node,
                                loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
                                messageId: opts && opts.condition ? "unexpectedCurlyAfterCondition" : "unexpectedCurlyAfter",
                                data: ***REMOVED***
                                    name
                                ***REMOVED***,
                                fix(fixer) ***REMOVED***

                                    /*
                                     * `do while` expressions sometimes need a space to be inserted after `do`.
                                     * e.g. `do***REMOVED***foo()***REMOVED*** while (bar)` should be corrected to `do foo() while (bar)`
                                     */
                                    const needsPrecedingSpace = node.type === "DoWhileStatement" &&
                                        sourceCode.getTokenBefore(body).range[1] === body.range[0] &&
                                        !astUtils.canTokensBeAdjacent("do", sourceCode.getFirstToken(body, ***REMOVED*** skip: 1 ***REMOVED***));

                                    const openingBracket = sourceCode.getFirstToken(body);
                                    const closingBracket = sourceCode.getLastToken(body);
                                    const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);

                                    if (needsSemicolon(closingBracket)) ***REMOVED***

                                        /*
                                         * If removing braces would cause a SyntaxError due to multiple statements on the same line (or
                                         * change the semantics of the code due to ASI), don't perform a fix.
                                         */
                                        return null;
                                    ***REMOVED***

                                    const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) +
                                        sourceCode.getText(lastTokenInBlock) +
                                        sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);

                                    return fixer.replaceText(body, (needsPrecedingSpace ? " " : "") + resultingBodyText);
                                ***REMOVED***
                            ***REMOVED***);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***;
        ***REMOVED***

        /**
         * Prepares to check the bodies of a "if", "else if" and "else" chain.
         * @param ***REMOVED***ASTNode***REMOVED*** node The first IfStatement node of the chain.
         * @returns ***REMOVED***Object[]***REMOVED*** prepared checks for each body of the chain. See `prepareCheck` for more
         *   information.
         */
        function prepareIfChecks(node) ***REMOVED***
            const preparedChecks = [];

            for (let currentNode = node; currentNode; currentNode = currentNode.alternate) ***REMOVED***
                preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, "if", ***REMOVED*** condition: true ***REMOVED***));
                if (currentNode.alternate && currentNode.alternate.type !== "IfStatement") ***REMOVED***
                    preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, "else"));
                    break;
                ***REMOVED***
            ***REMOVED***

            if (consistent) ***REMOVED***

                /*
                 * If any node should have or already have braces, make sure they
                 * all have braces.
                 * If all nodes shouldn't have braces, make sure they don't.
                 */
                const expected = preparedChecks.some(preparedCheck => ***REMOVED***
                    if (preparedCheck.expected !== null) ***REMOVED***
                        return preparedCheck.expected;
                    ***REMOVED***
                    return preparedCheck.actual;
                ***REMOVED***);

                preparedChecks.forEach(preparedCheck => ***REMOVED***
                    preparedCheck.expected = expected;
                ***REMOVED***);
            ***REMOVED***

            return preparedChecks;
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***
            IfStatement(node) ***REMOVED***
                if (node.parent.type !== "IfStatement") ***REMOVED***
                    prepareIfChecks(node).forEach(preparedCheck => ***REMOVED***
                        preparedCheck.check();
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***,

            WhileStatement(node) ***REMOVED***
                prepareCheck(node, node.body, "while", ***REMOVED*** condition: true ***REMOVED***).check();
            ***REMOVED***,

            DoWhileStatement(node) ***REMOVED***
                prepareCheck(node, node.body, "do").check();
            ***REMOVED***,

            ForStatement(node) ***REMOVED***
                prepareCheck(node, node.body, "for", ***REMOVED*** condition: true ***REMOVED***).check();
            ***REMOVED***,

            ForInStatement(node) ***REMOVED***
                prepareCheck(node, node.body, "for-in").check();
            ***REMOVED***,

            ForOfStatement(node) ***REMOVED***
                prepareCheck(node, node.body, "for-of").check();
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
