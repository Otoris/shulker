/**
 * @fileoverview Rule to disallow assignments to native objects or read-only global variables
 * @author Ilya Volodin
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow assignments to native objects or read-only global variables",
            category: "Best Practices",
            recommended: true,
            url: "https://eslint.org/docs/rules/no-global-assign"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    exceptions: ***REMOVED***
                        type: "array",
                        items: ***REMOVED*** type: "string" ***REMOVED***,
                        uniqueItems: true
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***
        const config = context.options[0];
        const exceptions = (config && config.exceptions) || [];

        /**
         * Reports write references.
         * @param ***REMOVED***Reference***REMOVED*** reference - A reference to check.
         * @param ***REMOVED***int***REMOVED*** index - The index of the reference in the references.
         * @param ***REMOVED***Reference[]***REMOVED*** references - The array that the reference belongs to.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkReference(reference, index, references) ***REMOVED***
            const identifier = reference.identifier;

            if (reference.init === false &&
                reference.isWrite() &&

                /*
                 * Destructuring assignments can have multiple default value,
                 * so possibly there are multiple writeable references for the same identifier.
                 */
                (index === 0 || references[index - 1].identifier !== identifier)
            ) ***REMOVED***
                context.report(***REMOVED***
                    node: identifier,
                    message: "Read-only global '***REMOVED******REMOVED***name***REMOVED******REMOVED***' should not be modified.",
                    data: identifier
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Reports write references if a given variable is read-only builtin.
         * @param ***REMOVED***Variable***REMOVED*** variable - A variable to check.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkVariable(variable) ***REMOVED***
            if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) ***REMOVED***
                variable.references.forEach(checkReference);
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            Program() ***REMOVED***
                const globalScope = context.getScope();

                globalScope.variables.forEach(checkVariable);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
