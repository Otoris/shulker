/**
 * @fileoverview Rule to flag when IIFE is not wrapped in parens
 * @author Ilya Volodin
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "require parentheses around immediate `function` invocations",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/wrap-iife"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                enum: ["outside", "inside", "any"]
            ***REMOVED***,
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    functionPrototypeMethods: ***REMOVED***
                        type: "boolean",
                        default: false
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],

        fixable: "code",
        messages: ***REMOVED***
            wrapInvocation: "Wrap an immediate function invocation in parentheses.",
            wrapExpression: "Wrap only the function expression in parens.",
            moveInvocation: "Move the invocation into the parens that contain the function."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        const style = context.options[0] || "outside";
        const includeFunctionPrototypeMethods = context.options[1] && context.options[1].functionPrototypeMethods;

        const sourceCode = context.getSourceCode();

        /**
         * Check if the node is wrapped in ()
         * @param ***REMOVED***ASTNode***REMOVED*** node node to evaluate
         * @returns ***REMOVED***boolean***REMOVED*** True if it is wrapped
         * @private
         */
        function wrapped(node) ***REMOVED***
            return astUtils.isParenthesised(sourceCode, node);
        ***REMOVED***

        /**
         * Get the function node from an IIFE
         * @param ***REMOVED***ASTNode***REMOVED*** node node to evaluate
         * @returns ***REMOVED***ASTNode***REMOVED*** node that is the function expression of the given IIFE, or null if none exist
         */
        function getFunctionNodeFromIIFE(node) ***REMOVED***
            const callee = node.callee;

            if (callee.type === "FunctionExpression") ***REMOVED***
                return callee;
            ***REMOVED***

            if (includeFunctionPrototypeMethods &&
                callee.type === "MemberExpression" &&
                callee.object.type === "FunctionExpression" &&
                (astUtils.getStaticPropertyName(callee) === "call" || astUtils.getStaticPropertyName(callee) === "apply")
            ) ***REMOVED***
                return callee.object;
            ***REMOVED***

            return null;
        ***REMOVED***


        return ***REMOVED***
            CallExpression(node) ***REMOVED***
                const innerNode = getFunctionNodeFromIIFE(node);

                if (!innerNode) ***REMOVED***
                    return;
                ***REMOVED***

                const callExpressionWrapped = wrapped(node),
                    functionExpressionWrapped = wrapped(innerNode);

                if (!callExpressionWrapped && !functionExpressionWrapped) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        messageId: "wrapInvocation",
                        fix(fixer) ***REMOVED***
                            const nodeToSurround = style === "inside" ? innerNode : node;

                            return fixer.replaceText(nodeToSurround, `($***REMOVED***sourceCode.getText(nodeToSurround)***REMOVED***)`);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED*** else if (style === "inside" && !functionExpressionWrapped) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        messageId: "wrapExpression",
                        fix(fixer) ***REMOVED***

                            /*
                             * The outer call expression will always be wrapped at this point.
                             * Replace the range between the end of the function expression and the end of the call expression.
                             * for example, in `(function(foo) ***REMOVED******REMOVED***(bar))`, the range `(bar))` should get replaced with `)(bar)`.
                             * Replace the parens from the outer expression, and parenthesize the function expression.
                             */
                            const parenAfter = sourceCode.getTokenAfter(node);

                            return fixer.replaceTextRange(
                                [innerNode.range[1], parenAfter.range[1]],
                                `)$***REMOVED***sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])***REMOVED***`
                            );
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED*** else if (style === "outside" && !callExpressionWrapped) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        messageId: "moveInvocation",
                        fix(fixer) ***REMOVED***

                            /*
                             * The inner function expression will always be wrapped at this point.
                             * It's only necessary to replace the range between the end of the function expression
                             * and the call expression. For example, in `(function(foo) ***REMOVED******REMOVED***)(bar)`, the range `)(bar)`
                             * should get replaced with `(bar))`.
                             */
                            const parenAfter = sourceCode.getTokenAfter(innerNode);

                            return fixer.replaceTextRange(
                                [parenAfter.range[0], node.range[1]],
                                `$***REMOVED***sourceCode.getText().slice(parenAfter.range[1], node.range[1])***REMOVED***)`
                            );
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
