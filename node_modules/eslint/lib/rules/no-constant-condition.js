/**
 * @fileoverview Rule to flag use constant conditions
 * @author Christian Schulz <http://rndm.de>
 */

"use strict";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const EQUALITY_OPERATORS = ["===", "!==", "==", "!="];
const RELATIONAL_OPERATORS = [">", "<", ">=", "<=", "in", "instanceof"];

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "problem",

        docs: ***REMOVED***
            description: "disallow constant expressions in conditions",
            category: "Possible Errors",
            recommended: true,
            url: "https://eslint.org/docs/rules/no-constant-condition"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    checkLoops: ***REMOVED***
                        type: "boolean",
                        default: true
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],

        messages: ***REMOVED***
            unexpected: "Unexpected constant condition."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const options = context.options[0] || ***REMOVED******REMOVED***,
            checkLoops = options.checkLoops !== false,
            loopSetStack = [];

        let loopsInCurrentScope = new Set();

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------


        /**
         * Checks if a branch node of LogicalExpression short circuits the whole condition
         * @param ***REMOVED***ASTNode***REMOVED*** node The branch of main condition which needs to be checked
         * @param ***REMOVED***string***REMOVED*** operator The operator of the main LogicalExpression.
         * @returns ***REMOVED***boolean***REMOVED*** true when condition short circuits whole condition
         */
        function isLogicalIdentity(node, operator) ***REMOVED***
            switch (node.type) ***REMOVED***
                case "Literal":
                    return (operator === "||" && node.value === true) ||
                           (operator === "&&" && node.value === false);

                case "UnaryExpression":
                    return (operator === "&&" && node.operator === "void");

                case "LogicalExpression":
                    return isLogicalIdentity(node.left, node.operator) ||
                             isLogicalIdentity(node.right, node.operator);

                // no default
            ***REMOVED***
            return false;
        ***REMOVED***

        /**
         * Checks if a node has a constant truthiness value.
         * @param ***REMOVED***ASTNode***REMOVED*** node The AST node to check.
         * @param ***REMOVED***boolean***REMOVED*** inBooleanPosition `false` if checking branch of a condition.
         *  `true` in all other cases
         * @returns ***REMOVED***Bool***REMOVED*** true when node's truthiness is constant
         * @private
         */
        function isConstant(node, inBooleanPosition) ***REMOVED***
            switch (node.type) ***REMOVED***
                case "Literal":
                case "ArrowFunctionExpression":
                case "FunctionExpression":
                case "ObjectExpression":
                case "ArrayExpression":
                    return true;

                case "UnaryExpression":
                    if (node.operator === "void") ***REMOVED***
                        return true;
                    ***REMOVED***

                    return (node.operator === "typeof" && inBooleanPosition) ||
                        isConstant(node.argument, true);

                case "BinaryExpression":
                    return isConstant(node.left, false) &&
                            isConstant(node.right, false) &&
                            node.operator !== "in";

                case "LogicalExpression": ***REMOVED***
                    const isLeftConstant = isConstant(node.left, inBooleanPosition);
                    const isRightConstant = isConstant(node.right, inBooleanPosition);
                    const isLeftShortCircuit = (isLeftConstant && isLogicalIdentity(node.left, node.operator));
                    const isRightShortCircuit = (isRightConstant && isLogicalIdentity(node.right, node.operator));

                    return (isLeftConstant && isRightConstant) ||
                        (

                            // in the case of an "OR", we need to know if the right constant value is truthy
                            node.operator === "||" &&
                            isRightConstant &&
                            node.right.value &&
                            (
                                !node.parent ||
                                node.parent.type !== "BinaryExpression" ||
                                !(EQUALITY_OPERATORS.includes(node.parent.operator) || RELATIONAL_OPERATORS.includes(node.parent.operator))
                            )
                        ) ||
                        isLeftShortCircuit ||
                        isRightShortCircuit;
                ***REMOVED***

                case "AssignmentExpression":
                    return (node.operator === "=") && isConstant(node.right, inBooleanPosition);

                case "SequenceExpression":
                    return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);

                // no default
            ***REMOVED***
            return false;
        ***REMOVED***

        /**
         * Tracks when the given node contains a constant condition.
         * @param ***REMOVED***ASTNode***REMOVED*** node The AST node to check.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function trackConstantConditionLoop(node) ***REMOVED***
            if (node.test && isConstant(node.test, true)) ***REMOVED***
                loopsInCurrentScope.add(node);
            ***REMOVED***
        ***REMOVED***

        /**
         * Reports when the set contains the given constant condition node
         * @param ***REMOVED***ASTNode***REMOVED*** node The AST node to check.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkConstantConditionLoopInSet(node) ***REMOVED***
            if (loopsInCurrentScope.has(node)) ***REMOVED***
                loopsInCurrentScope.delete(node);
                context.report(***REMOVED*** node: node.test, messageId: "unexpected" ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Reports when the given node contains a constant condition.
         * @param ***REMOVED***ASTNode***REMOVED*** node The AST node to check.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function reportIfConstant(node) ***REMOVED***
            if (node.test && isConstant(node.test, true)) ***REMOVED***
                context.report(***REMOVED*** node: node.test, messageId: "unexpected" ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Stores current set of constant loops in loopSetStack temporarily
         * and uses a new set to track constant loops
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function enterFunction() ***REMOVED***
            loopSetStack.push(loopsInCurrentScope);
            loopsInCurrentScope = new Set();
        ***REMOVED***

        /**
         * Reports when the set still contains stored constant conditions
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function exitFunction() ***REMOVED***
            loopsInCurrentScope = loopSetStack.pop();
        ***REMOVED***

        /**
         * Checks node when checkLoops option is enabled
         * @param ***REMOVED***ASTNode***REMOVED*** node The AST node to check.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkLoop(node) ***REMOVED***
            if (checkLoops) ***REMOVED***
                trackConstantConditionLoop(node);
            ***REMOVED***
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***
            ConditionalExpression: reportIfConstant,
            IfStatement: reportIfConstant,
            WhileStatement: checkLoop,
            "WhileStatement:exit": checkConstantConditionLoopInSet,
            DoWhileStatement: checkLoop,
            "DoWhileStatement:exit": checkConstantConditionLoopInSet,
            ForStatement: checkLoop,
            "ForStatement > .test": node => checkLoop(node.parent),
            "ForStatement:exit": checkConstantConditionLoopInSet,
            FunctionDeclaration: enterFunction,
            "FunctionDeclaration:exit": exitFunction,
            FunctionExpression: enterFunction,
            "FunctionExpression:exit": exitFunction,
            YieldExpression: () => loopsInCurrentScope.clear()
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
