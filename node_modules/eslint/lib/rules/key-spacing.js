/**
 * @fileoverview Rule to specify spacing of object literal keys and values
 * @author Brandon Mills
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether a string contains a line terminator as defined in
 * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3
 * @param ***REMOVED***string***REMOVED*** str String to test.
 * @returns ***REMOVED***boolean***REMOVED*** True if str contains a line terminator.
 */
function containsLineTerminator(str) ***REMOVED***
    return astUtils.LINEBREAK_MATCHER.test(str);
***REMOVED***

/**
 * Gets the last element of an array.
 * @param ***REMOVED***Array***REMOVED*** arr An array.
 * @returns ***REMOVED***any***REMOVED*** Last element of arr.
 */
function last(arr) ***REMOVED***
    return arr[arr.length - 1];
***REMOVED***

/**
 * Checks whether a node is contained on a single line.
 * @param ***REMOVED***ASTNode***REMOVED*** node AST Node being evaluated.
 * @returns ***REMOVED***boolean***REMOVED*** True if the node is a single line.
 */
function isSingleLine(node) ***REMOVED***
    return (node.loc.end.line === node.loc.start.line);
***REMOVED***

/**
 * Initializes a single option property from the configuration with defaults for undefined values
 * @param ***REMOVED***Object***REMOVED*** toOptions Object to be initialized
 * @param ***REMOVED***Object***REMOVED*** fromOptions Object to be initialized from
 * @returns ***REMOVED***Object***REMOVED*** The object with correctly initialized options and values
 */
function initOptionProperty(toOptions, fromOptions) ***REMOVED***
    toOptions.mode = fromOptions.mode || "strict";

    // Set value of beforeColon
    if (typeof fromOptions.beforeColon !== "undefined") ***REMOVED***
        toOptions.beforeColon = +fromOptions.beforeColon;
    ***REMOVED*** else ***REMOVED***
        toOptions.beforeColon = 0;
    ***REMOVED***

    // Set value of afterColon
    if (typeof fromOptions.afterColon !== "undefined") ***REMOVED***
        toOptions.afterColon = +fromOptions.afterColon;
    ***REMOVED*** else ***REMOVED***
        toOptions.afterColon = 1;
    ***REMOVED***

    // Set align if exists
    if (typeof fromOptions.align !== "undefined") ***REMOVED***
        if (typeof fromOptions.align === "object") ***REMOVED***
            toOptions.align = fromOptions.align;
        ***REMOVED*** else ***REMOVED*** // "string"
            toOptions.align = ***REMOVED***
                on: fromOptions.align,
                mode: toOptions.mode,
                beforeColon: toOptions.beforeColon,
                afterColon: toOptions.afterColon
            ***REMOVED***;
        ***REMOVED***
    ***REMOVED***

    return toOptions;
***REMOVED***

/**
 * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values
 * @param ***REMOVED***Object***REMOVED*** toOptions Object to be initialized
 * @param ***REMOVED***Object***REMOVED*** fromOptions Object to be initialized from
 * @returns ***REMOVED***Object***REMOVED*** The object with correctly initialized options and values
 */
function initOptions(toOptions, fromOptions) ***REMOVED***
    if (typeof fromOptions.align === "object") ***REMOVED***

        // Initialize the alignment configuration
        toOptions.align = initOptionProperty(***REMOVED******REMOVED***, fromOptions.align);
        toOptions.align.on = fromOptions.align.on || "colon";
        toOptions.align.mode = fromOptions.align.mode || "strict";

        toOptions.multiLine = initOptionProperty(***REMOVED******REMOVED***, (fromOptions.multiLine || fromOptions));
        toOptions.singleLine = initOptionProperty(***REMOVED******REMOVED***, (fromOptions.singleLine || fromOptions));

    ***REMOVED*** else ***REMOVED*** // string or undefined
        toOptions.multiLine = initOptionProperty(***REMOVED******REMOVED***, (fromOptions.multiLine || fromOptions));
        toOptions.singleLine = initOptionProperty(***REMOVED******REMOVED***, (fromOptions.singleLine || fromOptions));

        // If alignment options are defined in multiLine, pull them out into the general align configuration
        if (toOptions.multiLine.align) ***REMOVED***
            toOptions.align = ***REMOVED***
                on: toOptions.multiLine.align.on,
                mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,
                beforeColon: toOptions.multiLine.align.beforeColon,
                afterColon: toOptions.multiLine.align.afterColon
            ***REMOVED***;
        ***REMOVED***
    ***REMOVED***

    return toOptions;
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "enforce consistent spacing between keys and values in object literal properties",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/key-spacing"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [***REMOVED***
            anyOf: [
                ***REMOVED***
                    type: "object",
                    properties: ***REMOVED***
                        align: ***REMOVED***
                            anyOf: [
                                ***REMOVED***
                                    enum: ["colon", "value"]
                                ***REMOVED***,
                                ***REMOVED***
                                    type: "object",
                                    properties: ***REMOVED***
                                        mode: ***REMOVED***
                                            enum: ["strict", "minimum"]
                                        ***REMOVED***,
                                        on: ***REMOVED***
                                            enum: ["colon", "value"]
                                        ***REMOVED***,
                                        beforeColon: ***REMOVED***
                                            type: "boolean"
                                        ***REMOVED***,
                                        afterColon: ***REMOVED***
                                            type: "boolean"
                                        ***REMOVED***
                                    ***REMOVED***,
                                    additionalProperties: false
                                ***REMOVED***
                            ]
                        ***REMOVED***,
                        mode: ***REMOVED***
                            enum: ["strict", "minimum"]
                        ***REMOVED***,
                        beforeColon: ***REMOVED***
                            type: "boolean"
                        ***REMOVED***,
                        afterColon: ***REMOVED***
                            type: "boolean"
                        ***REMOVED***
                    ***REMOVED***,
                    additionalProperties: false
                ***REMOVED***,
                ***REMOVED***
                    type: "object",
                    properties: ***REMOVED***
                        singleLine: ***REMOVED***
                            type: "object",
                            properties: ***REMOVED***
                                mode: ***REMOVED***
                                    enum: ["strict", "minimum"]
                                ***REMOVED***,
                                beforeColon: ***REMOVED***
                                    type: "boolean"
                                ***REMOVED***,
                                afterColon: ***REMOVED***
                                    type: "boolean"
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***,
                        multiLine: ***REMOVED***
                            type: "object",
                            properties: ***REMOVED***
                                align: ***REMOVED***
                                    anyOf: [
                                        ***REMOVED***
                                            enum: ["colon", "value"]
                                        ***REMOVED***,
                                        ***REMOVED***
                                            type: "object",
                                            properties: ***REMOVED***
                                                mode: ***REMOVED***
                                                    enum: ["strict", "minimum"]
                                                ***REMOVED***,
                                                on: ***REMOVED***
                                                    enum: ["colon", "value"]
                                                ***REMOVED***,
                                                beforeColon: ***REMOVED***
                                                    type: "boolean"
                                                ***REMOVED***,
                                                afterColon: ***REMOVED***
                                                    type: "boolean"
                                                ***REMOVED***
                                            ***REMOVED***,
                                            additionalProperties: false
                                        ***REMOVED***
                                    ]
                                ***REMOVED***,
                                mode: ***REMOVED***
                                    enum: ["strict", "minimum"]
                                ***REMOVED***,
                                beforeColon: ***REMOVED***
                                    type: "boolean"
                                ***REMOVED***,
                                afterColon: ***REMOVED***
                                    type: "boolean"
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***
                    ***REMOVED***,
                    additionalProperties: false
                ***REMOVED***,
                ***REMOVED***
                    type: "object",
                    properties: ***REMOVED***
                        singleLine: ***REMOVED***
                            type: "object",
                            properties: ***REMOVED***
                                mode: ***REMOVED***
                                    enum: ["strict", "minimum"]
                                ***REMOVED***,
                                beforeColon: ***REMOVED***
                                    type: "boolean"
                                ***REMOVED***,
                                afterColon: ***REMOVED***
                                    type: "boolean"
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***,
                        multiLine: ***REMOVED***
                            type: "object",
                            properties: ***REMOVED***
                                mode: ***REMOVED***
                                    enum: ["strict", "minimum"]
                                ***REMOVED***,
                                beforeColon: ***REMOVED***
                                    type: "boolean"
                                ***REMOVED***,
                                afterColon: ***REMOVED***
                                    type: "boolean"
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***,
                        align: ***REMOVED***
                            type: "object",
                            properties: ***REMOVED***
                                mode: ***REMOVED***
                                    enum: ["strict", "minimum"]
                                ***REMOVED***,
                                on: ***REMOVED***
                                    enum: ["colon", "value"]
                                ***REMOVED***,
                                beforeColon: ***REMOVED***
                                    type: "boolean"
                                ***REMOVED***,
                                afterColon: ***REMOVED***
                                    type: "boolean"
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***
                    ***REMOVED***,
                    additionalProperties: false
                ***REMOVED***
            ]
        ***REMOVED***],
        messages: ***REMOVED***
            extraKey: "Extra space after ***REMOVED******REMOVED***computed***REMOVED******REMOVED***key '***REMOVED******REMOVED***key***REMOVED******REMOVED***'.",
            extraValue: "Extra space before value for ***REMOVED******REMOVED***computed***REMOVED******REMOVED***key '***REMOVED******REMOVED***key***REMOVED******REMOVED***'.",
            missingKey: "Missing space after ***REMOVED******REMOVED***computed***REMOVED******REMOVED***key '***REMOVED******REMOVED***key***REMOVED******REMOVED***'.",
            missingValue: "Missing space before value for ***REMOVED******REMOVED***computed***REMOVED******REMOVED***key '***REMOVED******REMOVED***key***REMOVED******REMOVED***'."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        /**
         * OPTIONS
         * "key-spacing": [2, ***REMOVED***
         *     beforeColon: false,
         *     afterColon: true,
         *     align: "colon" // Optional, or "value"
         * ***REMOVED***
         */
        const options = context.options[0] || ***REMOVED******REMOVED***,
            ruleOptions = initOptions(***REMOVED******REMOVED***, options),
            multiLineOptions = ruleOptions.multiLine,
            singleLineOptions = ruleOptions.singleLine,
            alignmentOptions = ruleOptions.align || null;

        const sourceCode = context.getSourceCode();

        /**
         * Checks whether a property is a member of the property group it follows.
         * @param ***REMOVED***ASTNode***REMOVED*** lastMember The last Property known to be in the group.
         * @param ***REMOVED***ASTNode***REMOVED*** candidate The next Property that might be in the group.
         * @returns ***REMOVED***boolean***REMOVED*** True if the candidate property is part of the group.
         */
        function continuesPropertyGroup(lastMember, candidate) ***REMOVED***
            const groupEndLine = lastMember.loc.start.line,
                candidateStartLine = candidate.loc.start.line;

            if (candidateStartLine - groupEndLine <= 1) ***REMOVED***
                return true;
            ***REMOVED***

            /*
             * Check that the first comment is adjacent to the end of the group, the
             * last comment is adjacent to the candidate property, and that successive
             * comments are adjacent to each other.
             */
            const leadingComments = sourceCode.getCommentsBefore(candidate);

            if (
                leadingComments.length &&
                leadingComments[0].loc.start.line - groupEndLine <= 1 &&
                candidateStartLine - last(leadingComments).loc.end.line <= 1
            ) ***REMOVED***
                for (let i = 1; i < leadingComments.length; i++) ***REMOVED***
                    if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) ***REMOVED***
                        return false;
                    ***REMOVED***
                ***REMOVED***
                return true;
            ***REMOVED***

            return false;
        ***REMOVED***

        /**
         * Determines if the given property is key-value property.
         * @param ***REMOVED***ASTNode***REMOVED*** property Property node to check.
         * @returns ***REMOVED***boolean***REMOVED*** Whether the property is a key-value property.
         */
        function isKeyValueProperty(property) ***REMOVED***
            return !(
                (property.method ||
                property.shorthand ||
                property.kind !== "init" || property.type !== "Property") // Could be "ExperimentalSpreadProperty" or "SpreadElement"
            );
        ***REMOVED***

        /**
         * Starting from the given a node (a property.key node here) looks forward
         * until it finds the last token before a colon punctuator and returns it.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to start looking from.
         * @returns ***REMOVED***ASTNode***REMOVED*** The last token before a colon punctuator.
         */
        function getLastTokenBeforeColon(node) ***REMOVED***
            const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);

            return sourceCode.getTokenBefore(colonToken);
        ***REMOVED***

        /**
         * Starting from the given a node (a property.key node here) looks forward
         * until it finds the colon punctuator and returns it.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to start looking from.
         * @returns ***REMOVED***ASTNode***REMOVED*** The colon punctuator.
         */
        function getNextColon(node) ***REMOVED***
            return sourceCode.getTokenAfter(node, astUtils.isColonToken);
        ***REMOVED***

        /**
         * Gets an object literal property's key as the identifier name or string value.
         * @param ***REMOVED***ASTNode***REMOVED*** property Property node whose key to retrieve.
         * @returns ***REMOVED***string***REMOVED*** The property's key.
         */
        function getKey(property) ***REMOVED***
            const key = property.key;

            if (property.computed) ***REMOVED***
                return sourceCode.getText().slice(key.range[0], key.range[1]);
            ***REMOVED***

            return property.key.name || property.key.value;
        ***REMOVED***

        /**
         * Reports an appropriately-formatted error if spacing is incorrect on one
         * side of the colon.
         * @param ***REMOVED***ASTNode***REMOVED*** property Key-value pair in an object literal.
         * @param ***REMOVED***string***REMOVED*** side Side being verified - either "key" or "value".
         * @param ***REMOVED***string***REMOVED*** whitespace Actual whitespace string.
         * @param ***REMOVED***int***REMOVED*** expected Expected whitespace length.
         * @param ***REMOVED***string***REMOVED*** mode Value of the mode as "strict" or "minimum"
         * @returns ***REMOVED***void***REMOVED***
         */
        function report(property, side, whitespace, expected, mode) ***REMOVED***
            const diff = whitespace.length - expected,
                nextColon = getNextColon(property.key),
                tokenBeforeColon = sourceCode.getTokenBefore(nextColon, ***REMOVED*** includeComments: true ***REMOVED***),
                tokenAfterColon = sourceCode.getTokenAfter(nextColon, ***REMOVED*** includeComments: true ***REMOVED***),
                isKeySide = side === "key",
                locStart = isKeySide ? tokenBeforeColon.loc.start : tokenAfterColon.loc.start,
                isExtra = diff > 0,
                diffAbs = Math.abs(diff),
                spaces = Array(diffAbs + 1).join(" ");

            if ((
                diff && mode === "strict" ||
                diff < 0 && mode === "minimum" ||
                diff > 0 && !expected && mode === "minimum") &&
                !(expected && containsLineTerminator(whitespace))
            ) ***REMOVED***
                let fix;

                if (isExtra) ***REMOVED***
                    let range;

                    // Remove whitespace
                    if (isKeySide) ***REMOVED***
                        range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];
                    ***REMOVED*** else ***REMOVED***
                        range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];
                    ***REMOVED***
                    fix = function(fixer) ***REMOVED***
                        return fixer.removeRange(range);
                    ***REMOVED***;
                ***REMOVED*** else ***REMOVED***

                    // Add whitespace
                    if (isKeySide) ***REMOVED***
                        fix = function(fixer) ***REMOVED***
                            return fixer.insertTextAfter(tokenBeforeColon, spaces);
                        ***REMOVED***;
                    ***REMOVED*** else ***REMOVED***
                        fix = function(fixer) ***REMOVED***
                            return fixer.insertTextBefore(tokenAfterColon, spaces);
                        ***REMOVED***;
                    ***REMOVED***
                ***REMOVED***

                let messageId = "";

                if (isExtra) ***REMOVED***
                    messageId = side === "key" ? "extraKey" : "extraValue";
                ***REMOVED*** else ***REMOVED***
                    messageId = side === "key" ? "missingKey" : "missingValue";
                ***REMOVED***

                context.report(***REMOVED***
                    node: property[side],
                    loc: locStart,
                    messageId,
                    data: ***REMOVED***
                        computed: property.computed ? "computed " : "",
                        key: getKey(property)
                    ***REMOVED***,
                    fix
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Gets the number of characters in a key, including quotes around string
         * keys and braces around computed property keys.
         * @param ***REMOVED***ASTNode***REMOVED*** property Property of on object literal.
         * @returns ***REMOVED***int***REMOVED*** Width of the key.
         */
        function getKeyWidth(property) ***REMOVED***
            const startToken = sourceCode.getFirstToken(property);
            const endToken = getLastTokenBeforeColon(property.key);

            return endToken.range[1] - startToken.range[0];
        ***REMOVED***

        /**
         * Gets the whitespace around the colon in an object literal property.
         * @param ***REMOVED***ASTNode***REMOVED*** property Property node from an object literal.
         * @returns ***REMOVED***Object***REMOVED*** Whitespace before and after the property's colon.
         */
        function getPropertyWhitespace(property) ***REMOVED***
            const whitespace = /(\s*):(\s*)/u.exec(sourceCode.getText().slice(
                property.key.range[1], property.value.range[0]
            ));

            if (whitespace) ***REMOVED***
                return ***REMOVED***
                    beforeColon: whitespace[1],
                    afterColon: whitespace[2]
                ***REMOVED***;
            ***REMOVED***
            return null;
        ***REMOVED***

        /**
         * Creates groups of properties.
         * @param  ***REMOVED***ASTNode***REMOVED*** node ObjectExpression node being evaluated.
         * @returns ***REMOVED***Array.<ASTNode[]>***REMOVED*** Groups of property AST node lists.
         */
        function createGroups(node) ***REMOVED***
            if (node.properties.length === 1) ***REMOVED***
                return [node.properties];
            ***REMOVED***

            return node.properties.reduce((groups, property) => ***REMOVED***
                const currentGroup = last(groups),
                    prev = last(currentGroup);

                if (!prev || continuesPropertyGroup(prev, property)) ***REMOVED***
                    currentGroup.push(property);
                ***REMOVED*** else ***REMOVED***
                    groups.push([property]);
                ***REMOVED***

                return groups;
            ***REMOVED***, [
                []
            ]);
        ***REMOVED***

        /**
         * Verifies correct vertical alignment of a group of properties.
         * @param ***REMOVED***ASTNode[]***REMOVED*** properties List of Property AST nodes.
         * @returns ***REMOVED***void***REMOVED***
         */
        function verifyGroupAlignment(properties) ***REMOVED***
            const length = properties.length,
                widths = properties.map(getKeyWidth), // Width of keys, including quotes
                align = alignmentOptions.on; // "value" or "colon"
            let targetWidth = Math.max(...widths),
                beforeColon, afterColon, mode;

            if (alignmentOptions && length > 1) ***REMOVED*** // When aligning values within a group, use the alignment configuration.
                beforeColon = alignmentOptions.beforeColon;
                afterColon = alignmentOptions.afterColon;
                mode = alignmentOptions.mode;
            ***REMOVED*** else ***REMOVED***
                beforeColon = multiLineOptions.beforeColon;
                afterColon = multiLineOptions.afterColon;
                mode = alignmentOptions.mode;
            ***REMOVED***

            // Conditionally include one space before or after colon
            targetWidth += (align === "colon" ? beforeColon : afterColon);

            for (let i = 0; i < length; i++) ***REMOVED***
                const property = properties[i];
                const whitespace = getPropertyWhitespace(property);

                if (whitespace) ***REMOVED*** // Object literal getters/setters lack a colon
                    const width = widths[i];

                    if (align === "value") ***REMOVED***
                        report(property, "key", whitespace.beforeColon, beforeColon, mode);
                        report(property, "value", whitespace.afterColon, targetWidth - width, mode);
                    ***REMOVED*** else ***REMOVED*** // align = "colon"
                        report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
                        report(property, "value", whitespace.afterColon, afterColon, mode);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Verifies vertical alignment, taking into account groups of properties.
         * @param  ***REMOVED***ASTNode***REMOVED*** node ObjectExpression node being evaluated.
         * @returns ***REMOVED***void***REMOVED***
         */
        function verifyAlignment(node) ***REMOVED***
            createGroups(node).forEach(group => ***REMOVED***
                verifyGroupAlignment(group.filter(isKeyValueProperty));
            ***REMOVED***);
        ***REMOVED***

        /**
         * Verifies spacing of property conforms to specified options.
         * @param  ***REMOVED***ASTNode***REMOVED*** node Property node being evaluated.
         * @param ***REMOVED***Object***REMOVED*** lineOptions Configured singleLine or multiLine options
         * @returns ***REMOVED***void***REMOVED***
         */
        function verifySpacing(node, lineOptions) ***REMOVED***
            const actual = getPropertyWhitespace(node);

            if (actual) ***REMOVED*** // Object literal getters/setters lack colons
                report(node, "key", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
                report(node, "value", actual.afterColon, lineOptions.afterColon, lineOptions.mode);
            ***REMOVED***
        ***REMOVED***

        /**
         * Verifies spacing of each property in a list.
         * @param  ***REMOVED***ASTNode[]***REMOVED*** properties List of Property AST nodes.
         * @returns ***REMOVED***void***REMOVED***
         */
        function verifyListSpacing(properties) ***REMOVED***
            const length = properties.length;

            for (let i = 0; i < length; i++) ***REMOVED***
                verifySpacing(properties[i], singleLineOptions);
            ***REMOVED***
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public API
        //--------------------------------------------------------------------------

        if (alignmentOptions) ***REMOVED*** // Verify vertical alignment

            return ***REMOVED***
                ObjectExpression(node) ***REMOVED***
                    if (isSingleLine(node)) ***REMOVED***
                        verifyListSpacing(node.properties.filter(isKeyValueProperty));
                    ***REMOVED*** else ***REMOVED***
                        verifyAlignment(node);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***;

        ***REMOVED***

        // Obey beforeColon and afterColon in each property as configured
        return ***REMOVED***
            Property(node) ***REMOVED***
                verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);
            ***REMOVED***
        ***REMOVED***;


    ***REMOVED***
***REMOVED***;
