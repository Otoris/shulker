/**
 * @fileoverview Disallow parenthesising higher precedence subexpressions.
 * @author Michael Ficarra
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const ***REMOVED*** isParenthesized: isParenthesizedRaw ***REMOVED*** = require("eslint-utils");
const astUtils = require("./utils/ast-utils.js");

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "disallow unnecessary parentheses",
            category: "Possible Errors",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-extra-parens"
        ***REMOVED***,

        fixable: "code",

        schema: ***REMOVED***
            anyOf: [
                ***REMOVED***
                    type: "array",
                    items: [
                        ***REMOVED***
                            enum: ["functions"]
                        ***REMOVED***
                    ],
                    minItems: 0,
                    maxItems: 1
                ***REMOVED***,
                ***REMOVED***
                    type: "array",
                    items: [
                        ***REMOVED***
                            enum: ["all"]
                        ***REMOVED***,
                        ***REMOVED***
                            type: "object",
                            properties: ***REMOVED***
                                conditionalAssign: ***REMOVED*** type: "boolean" ***REMOVED***,
                                nestedBinaryExpressions: ***REMOVED*** type: "boolean" ***REMOVED***,
                                returnAssign: ***REMOVED*** type: "boolean" ***REMOVED***,
                                ignoreJSX: ***REMOVED*** enum: ["none", "all", "single-line", "multi-line"] ***REMOVED***,
                                enforceForArrowConditionals: ***REMOVED*** type: "boolean" ***REMOVED***,
                                enforceForSequenceExpressions: ***REMOVED*** type: "boolean" ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***
                    ],
                    minItems: 0,
                    maxItems: 2
                ***REMOVED***
            ]
        ***REMOVED***,

        messages: ***REMOVED***
            unexpected: "Unnecessary parentheses around expression."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();

        const tokensToIgnore = new WeakSet();
        const precedence = astUtils.getPrecedence;
        const ALL_NODES = context.options[0] !== "functions";
        const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;
        const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;
        const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;
        const IGNORE_JSX = ALL_NODES && context.options[1] && context.options[1].ignoreJSX;
        const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context.options[1] &&
            context.options[1].enforceForArrowConditionals === false;
        const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && context.options[1] &&
            context.options[1].enforceForSequenceExpressions === false;

        const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence(***REMOVED*** type: "AssignmentExpression" ***REMOVED***);
        const PRECEDENCE_OF_UPDATE_EXPR = precedence(***REMOVED*** type: "UpdateExpression" ***REMOVED***);

        let reportsBuffer;

        /**
         * Determines if this rule should be enforced for a node given the current configuration.
         * @param ***REMOVED***ASTNode***REMOVED*** node - The node to be checked.
         * @returns ***REMOVED***boolean***REMOVED*** True if the rule should be enforced for this node.
         * @private
         */
        function ruleApplies(node) ***REMOVED***
            if (node.type === "JSXElement" || node.type === "JSXFragment") ***REMOVED***
                const isSingleLine = node.loc.start.line === node.loc.end.line;

                switch (IGNORE_JSX) ***REMOVED***

                    // Exclude this JSX element from linting
                    case "all":
                        return false;

                    // Exclude this JSX element if it is multi-line element
                    case "multi-line":
                        return isSingleLine;

                    // Exclude this JSX element if it is single-line element
                    case "single-line":
                        return !isSingleLine;

                    // Nothing special to be done for JSX elements
                    case "none":
                        break;

                    // no default
                ***REMOVED***
            ***REMOVED***

            if (node.type === "SequenceExpression" && IGNORE_SEQUENCE_EXPRESSIONS) ***REMOVED***
                return false;
            ***REMOVED***

            return ALL_NODES || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
        ***REMOVED***

        /**
         * Determines if a node is surrounded by parentheses.
         * @param ***REMOVED***ASTNode***REMOVED*** node - The node to be checked.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is parenthesised.
         * @private
         */
        function isParenthesised(node) ***REMOVED***
            return isParenthesizedRaw(1, node, sourceCode);
        ***REMOVED***

        /**
         * Determines if a node is surrounded by parentheses twice.
         * @param ***REMOVED***ASTNode***REMOVED*** node - The node to be checked.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is doubly parenthesised.
         * @private
         */
        function isParenthesisedTwice(node) ***REMOVED***
            return isParenthesizedRaw(2, node, sourceCode);
        ***REMOVED***

        /**
         * Determines if a node is surrounded by (potentially) invalid parentheses.
         * @param ***REMOVED***ASTNode***REMOVED*** node - The node to be checked.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is incorrectly parenthesised.
         * @private
         */
        function hasExcessParens(node) ***REMOVED***
            return ruleApplies(node) && isParenthesised(node);
        ***REMOVED***

        /**
         * Determines if a node that is expected to be parenthesised is surrounded by
         * (potentially) invalid extra parentheses.
         * @param ***REMOVED***ASTNode***REMOVED*** node - The node to be checked.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is has an unexpected extra pair of parentheses.
         * @private
         */
        function hasDoubleExcessParens(node) ***REMOVED***
            return ruleApplies(node) && isParenthesisedTwice(node);
        ***REMOVED***

        /**
         * Determines if a node test expression is allowed to have a parenthesised assignment
         * @param ***REMOVED***ASTNode***REMOVED*** node - The node to be checked.
         * @returns ***REMOVED***boolean***REMOVED*** True if the assignment can be parenthesised.
         * @private
         */
        function isCondAssignException(node) ***REMOVED***
            return EXCEPT_COND_ASSIGN && node.test.type === "AssignmentExpression";
        ***REMOVED***

        /**
         * Determines if a node is in a return statement
         * @param ***REMOVED***ASTNode***REMOVED*** node - The node to be checked.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is in a return statement.
         * @private
         */
        function isInReturnStatement(node) ***REMOVED***
            for (let currentNode = node; currentNode; currentNode = currentNode.parent) ***REMOVED***
                if (
                    currentNode.type === "ReturnStatement" ||
                    (currentNode.type === "ArrowFunctionExpression" && currentNode.body.type !== "BlockStatement")
                ) ***REMOVED***
                    return true;
                ***REMOVED***
            ***REMOVED***

            return false;
        ***REMOVED***

        /**
         * Determines if a constructor function is newed-up with parens
         * @param ***REMOVED***ASTNode***REMOVED*** newExpression - The NewExpression node to be checked.
         * @returns ***REMOVED***boolean***REMOVED*** True if the constructor is called with parens.
         * @private
         */
        function isNewExpressionWithParens(newExpression) ***REMOVED***
            const lastToken = sourceCode.getLastToken(newExpression);
            const penultimateToken = sourceCode.getTokenBefore(lastToken);

            return newExpression.arguments.length > 0 || astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken);
        ***REMOVED***

        /**
         * Determines if a node is or contains an assignment expression
         * @param ***REMOVED***ASTNode***REMOVED*** node - The node to be checked.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is or contains an assignment expression.
         * @private
         */
        function containsAssignment(node) ***REMOVED***
            if (node.type === "AssignmentExpression") ***REMOVED***
                return true;
            ***REMOVED***
            if (node.type === "ConditionalExpression" &&
                    (node.consequent.type === "AssignmentExpression" || node.alternate.type === "AssignmentExpression")) ***REMOVED***
                return true;
            ***REMOVED***
            if ((node.left && node.left.type === "AssignmentExpression") ||
                    (node.right && node.right.type === "AssignmentExpression")) ***REMOVED***
                return true;
            ***REMOVED***

            return false;
        ***REMOVED***

        /**
         * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment
         * @param ***REMOVED***ASTNode***REMOVED*** node - The node to be checked.
         * @returns ***REMOVED***boolean***REMOVED*** True if the assignment can be parenthesised.
         * @private
         */
        function isReturnAssignException(node) ***REMOVED***
            if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) ***REMOVED***
                return false;
            ***REMOVED***

            if (node.type === "ReturnStatement") ***REMOVED***
                return node.argument && containsAssignment(node.argument);
            ***REMOVED***
            if (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") ***REMOVED***
                return containsAssignment(node.body);
            ***REMOVED***
            return containsAssignment(node);

        ***REMOVED***

        /**
         * Determines if a node following a [no LineTerminator here] restriction is
         * surrounded by (potentially) invalid extra parentheses.
         * @param ***REMOVED***Token***REMOVED*** token - The token preceding the [no LineTerminator here] restriction.
         * @param ***REMOVED***ASTNode***REMOVED*** node - The node to be checked.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is incorrectly parenthesised.
         * @private
         */
        function hasExcessParensNoLineTerminator(token, node) ***REMOVED***
            if (token.loc.end.line === node.loc.start.line) ***REMOVED***
                return hasExcessParens(node);
            ***REMOVED***

            return hasDoubleExcessParens(node);
        ***REMOVED***

        /**
         * Determines whether a node should be preceded by an additional space when removing parens
         * @param ***REMOVED***ASTNode***REMOVED*** node node to evaluate; must be surrounded by parentheses
         * @returns ***REMOVED***boolean***REMOVED*** `true` if a space should be inserted before the node
         * @private
         */
        function requiresLeadingSpace(node) ***REMOVED***
            const leftParenToken = sourceCode.getTokenBefore(node);
            const tokenBeforeLeftParen = sourceCode.getTokenBefore(node, 1);
            const firstToken = sourceCode.getFirstToken(node);

            return tokenBeforeLeftParen &&
                tokenBeforeLeftParen.range[1] === leftParenToken.range[0] &&
                leftParenToken.range[1] === firstToken.range[0] &&
                !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, firstToken);
        ***REMOVED***

        /**
         * Determines whether a node should be followed by an additional space when removing parens
         * @param ***REMOVED***ASTNode***REMOVED*** node node to evaluate; must be surrounded by parentheses
         * @returns ***REMOVED***boolean***REMOVED*** `true` if a space should be inserted after the node
         * @private
         */
        function requiresTrailingSpace(node) ***REMOVED***
            const nextTwoTokens = sourceCode.getTokensAfter(node, ***REMOVED*** count: 2 ***REMOVED***);
            const rightParenToken = nextTwoTokens[0];
            const tokenAfterRightParen = nextTwoTokens[1];
            const tokenBeforeRightParen = sourceCode.getLastToken(node);

            return rightParenToken && tokenAfterRightParen &&
                !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) &&
                !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);
        ***REMOVED***

        /**
         * Determines if a given expression node is an IIFE
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the given node is an IIFE
         */
        function isIIFE(node) ***REMOVED***
            return node.type === "CallExpression" && node.callee.type === "FunctionExpression";
        ***REMOVED***

        /**
         * Report the node
         * @param ***REMOVED***ASTNode***REMOVED*** node node to evaluate
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function report(node) ***REMOVED***
            const leftParenToken = sourceCode.getTokenBefore(node);
            const rightParenToken = sourceCode.getTokenAfter(node);

            if (!isParenthesisedTwice(node)) ***REMOVED***
                if (tokensToIgnore.has(sourceCode.getFirstToken(node))) ***REMOVED***
                    return;
                ***REMOVED***

                if (isIIFE(node) && !isParenthesised(node.callee)) ***REMOVED***
                    return;
                ***REMOVED***
            ***REMOVED***

            /**
             * Finishes reporting
             * @returns ***REMOVED***void***REMOVED***
             * @private
             */
            function finishReport() ***REMOVED***
                context.report(***REMOVED***
                    node,
                    loc: leftParenToken.loc.start,
                    messageId: "unexpected",
                    fix(fixer) ***REMOVED***
                        const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);

                        return fixer.replaceTextRange([
                            leftParenToken.range[0],
                            rightParenToken.range[1]
                        ], (requiresLeadingSpace(node) ? " " : "") + parenthesizedSource + (requiresTrailingSpace(node) ? " " : ""));
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***

            if (reportsBuffer) ***REMOVED***
                reportsBuffer.reports.push(***REMOVED*** node, finishReport ***REMOVED***);
                return;
            ***REMOVED***

            finishReport();
        ***REMOVED***

        /**
         * Evaluate Unary update
         * @param ***REMOVED***ASTNode***REMOVED*** node node to evaluate
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkUnaryUpdate(node) ***REMOVED***
            if (node.type === "UnaryExpression" && node.argument.type === "BinaryExpression" && node.argument.operator === "**") ***REMOVED***
                return;
            ***REMOVED***

            if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) ***REMOVED***
                report(node.argument);
            ***REMOVED***
        ***REMOVED***

        /**
         * Check if a member expression contains a call expression
         * @param ***REMOVED***ASTNode***REMOVED*** node MemberExpression node to evaluate
         * @returns ***REMOVED***boolean***REMOVED*** true if found, false if not
         */
        function doesMemberExpressionContainCallExpression(node) ***REMOVED***
            let currentNode = node.object;
            let currentNodeType = node.object.type;

            while (currentNodeType === "MemberExpression") ***REMOVED***
                currentNode = currentNode.object;
                currentNodeType = currentNode.type;
            ***REMOVED***

            return currentNodeType === "CallExpression";
        ***REMOVED***

        /**
         * Evaluate a new call
         * @param ***REMOVED***ASTNode***REMOVED*** node node to evaluate
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkCallNew(node) ***REMOVED***
            const callee = node.callee;

            if (hasExcessParens(callee) && precedence(callee) >= precedence(node)) ***REMOVED***
                const hasNewParensException = callee.type === "NewExpression" && !isNewExpressionWithParens(callee);

                if (
                    hasDoubleExcessParens(callee) ||
                    !isIIFE(node) && !hasNewParensException && !(

                        /*
                         * Allow extra parens around a new expression if
                         * there are intervening parentheses.
                         */
                        (callee.type === "MemberExpression" && doesMemberExpressionContainCallExpression(callee))
                    )
                ) ***REMOVED***
                    report(node.callee);
                ***REMOVED***
            ***REMOVED***
            node.arguments
                .filter(arg => hasExcessParens(arg) && precedence(arg) >= PRECEDENCE_OF_ASSIGNMENT_EXPR)
                .forEach(report);
        ***REMOVED***

        /**
         * Evaluate binary logicals
         * @param ***REMOVED***ASTNode***REMOVED*** node node to evaluate
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkBinaryLogical(node) ***REMOVED***
            const prec = precedence(node);
            const leftPrecedence = precedence(node.left);
            const rightPrecedence = precedence(node.right);
            const isExponentiation = node.operator === "**";
            const shouldSkipLeft = (NESTED_BINARY && (node.left.type === "BinaryExpression" || node.left.type === "LogicalExpression")) ||
              node.left.type === "UnaryExpression" && isExponentiation;
            const shouldSkipRight = NESTED_BINARY && (node.right.type === "BinaryExpression" || node.right.type === "LogicalExpression");

            if (!shouldSkipLeft && hasExcessParens(node.left) && (leftPrecedence > prec || (leftPrecedence === prec && !isExponentiation))) ***REMOVED***
                report(node.left);
            ***REMOVED***
            if (!shouldSkipRight && hasExcessParens(node.right) && (rightPrecedence > prec || (rightPrecedence === prec && isExponentiation))) ***REMOVED***
                report(node.right);
            ***REMOVED***
        ***REMOVED***

        /**
         * Check the parentheses around the super class of the given class definition.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node of class declarations to check.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkClass(node) ***REMOVED***
            if (!node.superClass) ***REMOVED***
                return;
            ***REMOVED***

            /*
             * If `node.superClass` is a LeftHandSideExpression, parentheses are extra.
             * Otherwise, parentheses are needed.
             */
            const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR
                ? hasExcessParens(node.superClass)
                : hasDoubleExcessParens(node.superClass);

            if (hasExtraParens) ***REMOVED***
                report(node.superClass);
            ***REMOVED***
        ***REMOVED***

        /**
         * Check the parentheses around the argument of the given spread operator.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node of spread elements/properties to check.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkSpreadOperator(node) ***REMOVED***
            const hasExtraParens = precedence(node.argument) >= PRECEDENCE_OF_ASSIGNMENT_EXPR
                ? hasExcessParens(node.argument)
                : hasDoubleExcessParens(node.argument);

            if (hasExtraParens) ***REMOVED***
                report(node.argument);
            ***REMOVED***
        ***REMOVED***

        /**
         * Checks the parentheses for an ExpressionStatement or ExportDefaultDeclaration
         * @param ***REMOVED***ASTNode***REMOVED*** node The ExpressionStatement.expression or ExportDefaultDeclaration.declaration node
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkExpressionOrExportStatement(node) ***REMOVED***
            const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);
            const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);
            const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;
            const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;

            if (
                astUtils.isOpeningParenToken(firstToken) &&
                (
                    astUtils.isOpeningBraceToken(secondToken) ||
                    secondToken.type === "Keyword" && (
                        secondToken.value === "function" ||
                        secondToken.value === "class" ||
                        secondToken.value === "let" &&
                            tokenAfterClosingParens &&
                            (
                                astUtils.isOpeningBracketToken(tokenAfterClosingParens) ||
                                tokenAfterClosingParens.type === "Identifier"
                            )
                    ) ||
                    secondToken && secondToken.type === "Identifier" && secondToken.value === "async" && thirdToken && thirdToken.type === "Keyword" && thirdToken.value === "function"
                )
            ) ***REMOVED***
                tokensToIgnore.add(secondToken);
            ***REMOVED***

            if (hasExcessParens(node)) ***REMOVED***
                report(node);
            ***REMOVED***
        ***REMOVED***

        /**
         * Finds the path from the given node to the specified ancestor.
         * @param ***REMOVED***ASTNode***REMOVED*** node First node in the path.
         * @param ***REMOVED***ASTNode***REMOVED*** ancestor Last node in the path.
         * @returns ***REMOVED***ASTNode[]***REMOVED*** Path, including both nodes.
         * @throws ***REMOVED***Error***REMOVED*** If the given node does not have the specified ancestor.
         */
        function pathToAncestor(node, ancestor) ***REMOVED***
            const path = [node];
            let currentNode = node;

            while (currentNode !== ancestor) ***REMOVED***

                currentNode = currentNode.parent;

                /* istanbul ignore if */
                if (currentNode === null) ***REMOVED***
                    throw new Error("Nodes are not in the ancestor-descendant relationship.");
                ***REMOVED***

                path.push(currentNode);
            ***REMOVED***

            return path;
        ***REMOVED***

        /**
         * Finds the path from the given node to the specified descendant.
         * @param ***REMOVED***ASTNode***REMOVED*** node First node in the path.
         * @param ***REMOVED***ASTNode***REMOVED*** descendant Last node in the path.
         * @returns ***REMOVED***ASTNode[]***REMOVED*** Path, including both nodes.
         * @throws ***REMOVED***Error***REMOVED*** If the given node does not have the specified descendant.
         */
        function pathToDescendant(node, descendant) ***REMOVED***
            return pathToAncestor(descendant, node).reverse();
        ***REMOVED***

        /**
         * Checks whether the syntax of the given ancestor of an 'in' expression inside a for-loop initializer
         * is preventing the 'in' keyword from being interpreted as a part of an ill-formed for-in loop.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node Ancestor of an 'in' expression.
         * @param ***REMOVED***ASTNode***REMOVED*** child Child of the node, ancestor of the same 'in' expression or the 'in' expression itself.
         * @returns ***REMOVED***boolean***REMOVED*** True if the keyword 'in' would be interpreted as the 'in' operator, without any parenthesis.
         */
        function isSafelyEnclosingInExpression(node, child) ***REMOVED***
            switch (node.type) ***REMOVED***
                case "ArrayExpression":
                case "ArrayPattern":
                case "BlockStatement":
                case "ObjectExpression":
                case "ObjectPattern":
                case "TemplateLiteral":
                    return true;
                case "ArrowFunctionExpression":
                case "FunctionExpression":
                    return node.params.includes(child);
                case "CallExpression":
                case "NewExpression":
                    return node.arguments.includes(child);
                case "MemberExpression":
                    return node.computed && node.property === child;
                case "ConditionalExpression":
                    return node.consequent === child;
                default:
                    return false;
            ***REMOVED***
        ***REMOVED***

        /**
         * Starts a new reports buffering. Warnings will be stored in a buffer instead of being reported immediately.
         * An additional logic that requires multiple nodes (e.g. a whole subtree) may dismiss some of the stored warnings.
         *
         * @returns ***REMOVED***void***REMOVED***
         */
        function startNewReportsBuffering() ***REMOVED***
            reportsBuffer = ***REMOVED***
                upper: reportsBuffer,
                inExpressionNodes: [],
                reports: []
            ***REMOVED***;
        ***REMOVED***

        /**
         * Ends the current reports buffering.
         * @returns ***REMOVED***void***REMOVED***
         */
        function endCurrentReportsBuffering() ***REMOVED***
            const ***REMOVED*** upper, inExpressionNodes, reports ***REMOVED*** = reportsBuffer;

            if (upper) ***REMOVED***
                upper.inExpressionNodes.push(...inExpressionNodes);
                upper.reports.push(...reports);
            ***REMOVED*** else ***REMOVED***

                // flush remaining reports
                reports.forEach((***REMOVED*** finishReport ***REMOVED***) => finishReport());
            ***REMOVED***

            reportsBuffer = upper;
        ***REMOVED***

        /**
         * Checks whether the given node is in the current reports buffer.
         * @param ***REMOVED***ASTNode***REMOVED*** node Node to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is in the current buffer, false otherwise.
         */
        function isInCurrentReportsBuffer(node) ***REMOVED***
            return reportsBuffer.reports.some(r => r.node === node);
        ***REMOVED***

        /**
         * Removes the given node from the current reports buffer.
         * @param ***REMOVED***ASTNode***REMOVED*** node Node to remove.
         * @returns ***REMOVED***void***REMOVED***
         */
        function removeFromCurrentReportsBuffer(node) ***REMOVED***
            reportsBuffer.reports = reportsBuffer.reports.filter(r => r.node !== node);
        ***REMOVED***

        return ***REMOVED***
            ArrayExpression(node) ***REMOVED***
                node.elements
                    .filter(e => e && hasExcessParens(e) && precedence(e) >= PRECEDENCE_OF_ASSIGNMENT_EXPR)
                    .forEach(report);
            ***REMOVED***,

            ArrowFunctionExpression(node) ***REMOVED***
                if (isReturnAssignException(node)) ***REMOVED***
                    return;
                ***REMOVED***

                if (node.body.type === "ConditionalExpression" &&
                    IGNORE_ARROW_CONDITIONALS &&
                    !isParenthesisedTwice(node.body)
                ) ***REMOVED***
                    return;
                ***REMOVED***

                if (node.body.type !== "BlockStatement") ***REMOVED***
                    const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);
                    const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);

                    if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) ***REMOVED***
                        tokensToIgnore.add(firstBodyToken);
                    ***REMOVED***
                    if (hasExcessParens(node.body) && precedence(node.body) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) ***REMOVED***
                        report(node.body);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***,

            AssignmentExpression(node) ***REMOVED***
                if (isReturnAssignException(node)) ***REMOVED***
                    return;
                ***REMOVED***

                if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) ***REMOVED***
                    report(node.right);
                ***REMOVED***
            ***REMOVED***,

            BinaryExpression(node) ***REMOVED***
                if (reportsBuffer && node.operator === "in") ***REMOVED***
                    reportsBuffer.inExpressionNodes.push(node);
                ***REMOVED***

                checkBinaryLogical(node);
            ***REMOVED***,

            CallExpression: checkCallNew,

            ClassBody(node) ***REMOVED***
                node.body
                    .filter(member => member.type === "MethodDefinition" && member.computed &&
                        member.key && hasExcessParens(member.key) && precedence(member.key) >= PRECEDENCE_OF_ASSIGNMENT_EXPR)
                    .forEach(member => report(member.key));
            ***REMOVED***,

            ConditionalExpression(node) ***REMOVED***
                if (isReturnAssignException(node)) ***REMOVED***
                    return;
                ***REMOVED***

                if (hasExcessParens(node.test) && precedence(node.test) >= precedence(***REMOVED*** type: "LogicalExpression", operator: "||" ***REMOVED***)) ***REMOVED***
                    report(node.test);
                ***REMOVED***

                if (hasExcessParens(node.consequent) && precedence(node.consequent) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) ***REMOVED***
                    report(node.consequent);
                ***REMOVED***

                if (hasExcessParens(node.alternate) && precedence(node.alternate) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) ***REMOVED***
                    report(node.alternate);
                ***REMOVED***
            ***REMOVED***,

            DoWhileStatement(node) ***REMOVED***
                if (hasExcessParens(node.test) && !isCondAssignException(node)) ***REMOVED***
                    report(node.test);
                ***REMOVED***
            ***REMOVED***,

            ExportDefaultDeclaration: node => checkExpressionOrExportStatement(node.declaration),
            ExpressionStatement: node => checkExpressionOrExportStatement(node.expression),

            "ForInStatement, ForOfStatement"(node) ***REMOVED***
                if (node.left.type !== "VariableDeclarator") ***REMOVED***
                    const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);

                    if (
                        firstLeftToken.value === "let" && (

                            /*
                             * If `let` is the only thing on the left side of the loop, it's the loop variable: `for ((let) of foo);`
                             * Removing it will cause a syntax error, because it will be parsed as the start of a VariableDeclarator.
                             */
                            (firstLeftToken.range[1] === node.left.range[1] || /*
                             * If `let` is followed by a `[` token, it's a property access on the `let` value: `for ((let[foo]) of bar);`
                             * Removing it will cause the property access to be parsed as a destructuring declaration of `foo` instead.
                             */
                            astUtils.isOpeningBracketToken(
                                sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken)
                            ))
                        )
                    ) ***REMOVED***
                        tokensToIgnore.add(firstLeftToken);
                    ***REMOVED***
                ***REMOVED***
                if (!(node.type === "ForOfStatement" && node.right.type === "SequenceExpression") && hasExcessParens(node.right)) ***REMOVED***
                    report(node.right);
                ***REMOVED***
                if (hasExcessParens(node.left)) ***REMOVED***
                    report(node.left);
                ***REMOVED***
            ***REMOVED***,

            ForStatement(node) ***REMOVED***
                if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) ***REMOVED***
                    report(node.test);
                ***REMOVED***

                if (node.update && hasExcessParens(node.update)) ***REMOVED***
                    report(node.update);
                ***REMOVED***

                if (node.init) ***REMOVED***
                    startNewReportsBuffering();

                    if (hasExcessParens(node.init)) ***REMOVED***
                        report(node.init);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***,

            "ForStatement > *.init:exit"(node) ***REMOVED***

                /*
                 * Removing parentheses around `in` expressions might change semantics and cause errors.
                 *
                 * For example, this valid for loop:
                 *      for (let a = (b in c); ;);
                 * after removing parentheses would be treated as an invalid for-in loop:
                 *      for (let a = b in c; ;);
                 */

                if (reportsBuffer.reports.length) ***REMOVED***
                    reportsBuffer.inExpressionNodes.forEach(inExpressionNode => ***REMOVED***
                        const path = pathToDescendant(node, inExpressionNode);
                        let nodeToExclude;

                        for (let i = 0; i < path.length; i++) ***REMOVED***
                            const pathNode = path[i];

                            if (i < path.length - 1) ***REMOVED***
                                const nextPathNode = path[i + 1];

                                if (isSafelyEnclosingInExpression(pathNode, nextPathNode)) ***REMOVED***

                                    // The 'in' expression in safely enclosed by the syntax of its ancestor nodes (e.g. by '***REMOVED******REMOVED***' or '[]').
                                    return;
                                ***REMOVED***
                            ***REMOVED***

                            if (isParenthesised(pathNode)) ***REMOVED***
                                if (isInCurrentReportsBuffer(pathNode)) ***REMOVED***

                                    // This node was supposed to be reported, but parentheses might be necessary.

                                    if (isParenthesisedTwice(pathNode)) ***REMOVED***

                                        /*
                                         * This node is parenthesised twice, it certainly has at least one pair of `extra` parentheses.
                                         * If the --fix option is on, the current fixing iteration will remove only one pair of parentheses.
                                         * The remaining pair is safely enclosing the 'in' expression.
                                         */
                                        return;
                                    ***REMOVED***

                                    // Exclude the outermost node only.
                                    if (!nodeToExclude) ***REMOVED***
                                        nodeToExclude = pathNode;
                                    ***REMOVED***

                                    // Don't break the loop here, there might be some safe nodes or parentheses that will stay inside.

                                ***REMOVED*** else ***REMOVED***

                                    // This node will stay parenthesised, the 'in' expression in safely enclosed by '()'.
                                    return;
                                ***REMOVED***
                            ***REMOVED***
                        ***REMOVED***

                        // Exclude the node from the list (i.e. treat parentheses as necessary)
                        removeFromCurrentReportsBuffer(nodeToExclude);
                    ***REMOVED***);
                ***REMOVED***

                endCurrentReportsBuffering();
            ***REMOVED***,

            IfStatement(node) ***REMOVED***
                if (hasExcessParens(node.test) && !isCondAssignException(node)) ***REMOVED***
                    report(node.test);
                ***REMOVED***
            ***REMOVED***,

            ImportExpression(node) ***REMOVED***
                const ***REMOVED*** source ***REMOVED*** = node;

                if (source.type === "SequenceExpression") ***REMOVED***
                    if (hasDoubleExcessParens(source)) ***REMOVED***
                        report(source);
                    ***REMOVED***
                ***REMOVED*** else if (hasExcessParens(source)) ***REMOVED***
                    report(source);
                ***REMOVED***
            ***REMOVED***,

            LogicalExpression: checkBinaryLogical,

            MemberExpression(node) ***REMOVED***
                const nodeObjHasExcessParens = hasExcessParens(node.object);

                if (
                    nodeObjHasExcessParens &&
                    precedence(node.object) >= precedence(node) &&
                    (
                        node.computed ||
                        !(
                            astUtils.isDecimalInteger(node.object) ||

                            // RegExp literal is allowed to have parens (#1589)
                            (node.object.type === "Literal" && node.object.regex)
                        )
                    )
                ) ***REMOVED***
                    report(node.object);
                ***REMOVED***

                if (nodeObjHasExcessParens &&
                  node.object.type === "CallExpression" &&
                  node.parent.type !== "NewExpression") ***REMOVED***
                    report(node.object);
                ***REMOVED***

                if (node.computed && hasExcessParens(node.property)) ***REMOVED***
                    report(node.property);
                ***REMOVED***
            ***REMOVED***,

            NewExpression: checkCallNew,

            ObjectExpression(node) ***REMOVED***
                node.properties
                    .filter(property => ***REMOVED***
                        const value = property.value;

                        return value && hasExcessParens(value) && precedence(value) >= PRECEDENCE_OF_ASSIGNMENT_EXPR;
                    ***REMOVED***).forEach(property => report(property.value));
            ***REMOVED***,

            Property(node) ***REMOVED***
                if (node.computed) ***REMOVED***
                    const ***REMOVED*** key ***REMOVED*** = node;

                    if (key && hasExcessParens(key) && precedence(key) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) ***REMOVED***
                        report(key);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***,

            ReturnStatement(node) ***REMOVED***
                const returnToken = sourceCode.getFirstToken(node);

                if (isReturnAssignException(node)) ***REMOVED***
                    return;
                ***REMOVED***

                if (node.argument &&
                        hasExcessParensNoLineTerminator(returnToken, node.argument) &&

                        // RegExp literal is allowed to have parens (#1589)
                        !(node.argument.type === "Literal" && node.argument.regex)) ***REMOVED***
                    report(node.argument);
                ***REMOVED***
            ***REMOVED***,

            SequenceExpression(node) ***REMOVED***
                node.expressions
                    .filter(e => hasExcessParens(e) && precedence(e) >= precedence(node))
                    .forEach(report);
            ***REMOVED***,

            SwitchCase(node) ***REMOVED***
                if (node.test && hasExcessParens(node.test)) ***REMOVED***
                    report(node.test);
                ***REMOVED***
            ***REMOVED***,

            SwitchStatement(node) ***REMOVED***
                if (hasExcessParens(node.discriminant)) ***REMOVED***
                    report(node.discriminant);
                ***REMOVED***
            ***REMOVED***,

            ThrowStatement(node) ***REMOVED***
                const throwToken = sourceCode.getFirstToken(node);

                if (hasExcessParensNoLineTerminator(throwToken, node.argument)) ***REMOVED***
                    report(node.argument);
                ***REMOVED***
            ***REMOVED***,

            UnaryExpression: checkUnaryUpdate,
            UpdateExpression: checkUnaryUpdate,
            AwaitExpression: checkUnaryUpdate,

            VariableDeclarator(node) ***REMOVED***
                if (node.init && hasExcessParens(node.init) &&
                        precedence(node.init) >= PRECEDENCE_OF_ASSIGNMENT_EXPR &&

                        // RegExp literal is allowed to have parens (#1589)
                        !(node.init.type === "Literal" && node.init.regex)) ***REMOVED***
                    report(node.init);
                ***REMOVED***
            ***REMOVED***,

            WhileStatement(node) ***REMOVED***
                if (hasExcessParens(node.test) && !isCondAssignException(node)) ***REMOVED***
                    report(node.test);
                ***REMOVED***
            ***REMOVED***,

            WithStatement(node) ***REMOVED***
                if (hasExcessParens(node.object)) ***REMOVED***
                    report(node.object);
                ***REMOVED***
            ***REMOVED***,

            YieldExpression(node) ***REMOVED***
                if (node.argument) ***REMOVED***
                    const yieldToken = sourceCode.getFirstToken(node);

                    if ((precedence(node.argument) >= precedence(node) &&
                            hasExcessParensNoLineTerminator(yieldToken, node.argument)) ||
                            hasDoubleExcessParens(node.argument)) ***REMOVED***
                        report(node.argument);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***,

            ClassDeclaration: checkClass,
            ClassExpression: checkClass,

            SpreadElement: checkSpreadOperator,
            SpreadProperty: checkSpreadOperator,
            ExperimentalSpreadProperty: checkSpreadOperator,

            TemplateLiteral(node) ***REMOVED***
                node.expressions
                    .filter(e => e && hasExcessParens(e))
                    .forEach(report);
            ***REMOVED***,

            AssignmentPattern(node) ***REMOVED***
                const ***REMOVED*** right ***REMOVED*** = node;

                if (right && hasExcessParens(right) && precedence(right) >= PRECEDENCE_OF_ASSIGNMENT_EXPR) ***REMOVED***
                    report(right);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
