/**
 * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.
 * @author Toru Nagashima
 */

"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;
const DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/u;
const DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;

/**
 * Checks whether a given node is located at `ForStatement.init` or not.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is located at `ForStatement.init`.
 */
function isInitOfForStatement(node) ***REMOVED***
    return node.parent.type === "ForStatement" && node.parent.init === node;
***REMOVED***

/**
 * Checks whether a given Identifier node becomes a VariableDeclaration or not.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** identifier - An Identifier node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node can become a VariableDeclaration.
 */
function canBecomeVariableDeclaration(identifier) ***REMOVED***
    let node = identifier.parent;

    while (PATTERN_TYPE.test(node.type)) ***REMOVED***
        node = node.parent;
    ***REMOVED***

    return (
        node.type === "VariableDeclarator" ||
        (
            node.type === "AssignmentExpression" &&
            node.parent.type === "ExpressionStatement" &&
            DECLARATION_HOST_TYPE.test(node.parent.parent.type)
        )
    );
***REMOVED***

/**
 * Checks if an property or element is from outer scope or function parameters
 * in destructing pattern.
 *
 * @param ***REMOVED***string***REMOVED*** name - A variable name to be checked.
 * @param ***REMOVED***eslint-scope.Scope***REMOVED*** initScope - A scope to start find.
 * @returns ***REMOVED***boolean***REMOVED*** Indicates if the variable is from outer scope or function parameters.
 */
function isOuterVariableInDestructing(name, initScope) ***REMOVED***

    if (initScope.through.find(ref => ref.resolved && ref.resolved.name === name)) ***REMOVED***
        return true;
    ***REMOVED***

    const variable = astUtils.getVariableByName(initScope, name);

    if (variable !== null) ***REMOVED***
        return variable.defs.some(def => def.type === "Parameter");
    ***REMOVED***

    return false;
***REMOVED***

/**
 * Gets the VariableDeclarator/AssignmentExpression node that a given reference
 * belongs to.
 * This is used to detect a mix of reassigned and never reassigned in a
 * destructuring.
 *
 * @param ***REMOVED***eslint-scope.Reference***REMOVED*** reference - A reference to get.
 * @returns ***REMOVED***ASTNode|null***REMOVED*** A VariableDeclarator/AssignmentExpression node or
 *      null.
 */
function getDestructuringHost(reference) ***REMOVED***
    if (!reference.isWrite()) ***REMOVED***
        return null;
    ***REMOVED***
    let node = reference.identifier.parent;

    while (PATTERN_TYPE.test(node.type)) ***REMOVED***
        node = node.parent;
    ***REMOVED***

    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) ***REMOVED***
        return null;
    ***REMOVED***
    return node;
***REMOVED***

/**
 * Determines if a destructuring assignment node contains
 * any MemberExpression nodes. This is used to determine if a
 * variable that is only written once using destructuring can be
 * safely converted into a const declaration.
 * @param ***REMOVED***ASTNode***REMOVED*** node The ObjectPattern or ArrayPattern node to check.
 * @returns ***REMOVED***boolean***REMOVED*** True if the destructuring pattern contains
 *      a MemberExpression, false if not.
 */
function hasMemberExpressionAssignment(node) ***REMOVED***
    switch (node.type) ***REMOVED***
        case "ObjectPattern":
            return node.properties.some(prop => ***REMOVED***
                if (prop) ***REMOVED***

                    /*
                     * Spread elements have an argument property while
                     * others have a value property. Because different
                     * parsers use different node types for spread elements,
                     * we just check if there is an argument property.
                     */
                    return hasMemberExpressionAssignment(prop.argument || prop.value);
                ***REMOVED***

                return false;
            ***REMOVED***);

        case "ArrayPattern":
            return node.elements.some(element => ***REMOVED***
                if (element) ***REMOVED***
                    return hasMemberExpressionAssignment(element);
                ***REMOVED***

                return false;
            ***REMOVED***);

        case "AssignmentPattern":
            return hasMemberExpressionAssignment(node.left);

        case "MemberExpression":
            return true;

        // no default
    ***REMOVED***

    return false;
***REMOVED***

/**
 * Gets an identifier node of a given variable.
 *
 * If the initialization exists or one or more reading references exist before
 * the first assignment, the identifier node is the node of the declaration.
 * Otherwise, the identifier node is the node of the first assignment.
 *
 * If the variable should not change to const, this function returns null.
 * - If the variable is reassigned.
 * - If the variable is never initialized nor assigned.
 * - If the variable is initialized in a different scope from the declaration.
 * - If the unique assignment of the variable cannot change to a declaration.
 *   e.g. `if (a) b = 1` / `return (b = 1)`
 * - If the variable is declared in the global scope and `eslintUsed` is `true`.
 *   `/*exported foo` directive comment makes such variables. This rule does not
 *   warn such variables because this rule cannot distinguish whether the
 *   exported variables are reassigned or not.
 *
 * @param ***REMOVED***eslint-scope.Variable***REMOVED*** variable - A variable to get.
 * @param ***REMOVED***boolean***REMOVED*** ignoreReadBeforeAssign -
 *      The value of `ignoreReadBeforeAssign` option.
 * @returns ***REMOVED***ASTNode|null***REMOVED***
 *      An Identifier node if the variable should change to const.
 *      Otherwise, null.
 */
function getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) ***REMOVED***
    if (variable.eslintUsed && variable.scope.type === "global") ***REMOVED***
        return null;
    ***REMOVED***

    // Finds the unique WriteReference.
    let writer = null;
    let isReadBeforeInit = false;
    const references = variable.references;

    for (let i = 0; i < references.length; ++i) ***REMOVED***
        const reference = references[i];

        if (reference.isWrite()) ***REMOVED***
            const isReassigned = (
                writer !== null &&
                writer.identifier !== reference.identifier
            );

            if (isReassigned) ***REMOVED***
                return null;
            ***REMOVED***

            const destructuringHost = getDestructuringHost(reference);

            if (destructuringHost !== null && destructuringHost.left !== void 0) ***REMOVED***
                const leftNode = destructuringHost.left;
                let hasOuterVariables = false,
                    hasNonIdentifiers = false;

                if (leftNode.type === "ObjectPattern") ***REMOVED***
                    const properties = leftNode.properties;

                    hasOuterVariables = properties
                        .filter(prop => prop.value)
                        .map(prop => prop.value.name)
                        .some(name => isOuterVariableInDestructing(name, variable.scope));

                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);

                ***REMOVED*** else if (leftNode.type === "ArrayPattern") ***REMOVED***
                    const elements = leftNode.elements;

                    hasOuterVariables = elements
                        .map(element => element && element.name)
                        .some(name => isOuterVariableInDestructing(name, variable.scope));

                    hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);
                ***REMOVED***

                if (hasOuterVariables || hasNonIdentifiers) ***REMOVED***
                    return null;
                ***REMOVED***

            ***REMOVED***

            writer = reference;

        ***REMOVED*** else if (reference.isRead() && writer === null) ***REMOVED***
            if (ignoreReadBeforeAssign) ***REMOVED***
                return null;
            ***REMOVED***
            isReadBeforeInit = true;
        ***REMOVED***
    ***REMOVED***

    /*
     * If the assignment is from a different scope, ignore it.
     * If the assignment cannot change to a declaration, ignore it.
     */
    const shouldBeConst = (
        writer !== null &&
        writer.from === variable.scope &&
        canBecomeVariableDeclaration(writer.identifier)
    );

    if (!shouldBeConst) ***REMOVED***
        return null;
    ***REMOVED***

    if (isReadBeforeInit) ***REMOVED***
        return variable.defs[0].name;
    ***REMOVED***

    return writer.identifier;
***REMOVED***

/**
 * Groups by the VariableDeclarator/AssignmentExpression node that each
 * reference of given variables belongs to.
 * This is used to detect a mix of reassigned and never reassigned in a
 * destructuring.
 *
 * @param ***REMOVED***eslint-scope.Variable[]***REMOVED*** variables - Variables to group by destructuring.
 * @param ***REMOVED***boolean***REMOVED*** ignoreReadBeforeAssign -
 *      The value of `ignoreReadBeforeAssign` option.
 * @returns ***REMOVED***Map<ASTNode, ASTNode[]>***REMOVED*** Grouped identifier nodes.
 */
function groupByDestructuring(variables, ignoreReadBeforeAssign) ***REMOVED***
    const identifierMap = new Map();

    for (let i = 0; i < variables.length; ++i) ***REMOVED***
        const variable = variables[i];
        const references = variable.references;
        const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);
        let prevId = null;

        for (let j = 0; j < references.length; ++j) ***REMOVED***
            const reference = references[j];
            const id = reference.identifier;

            /*
             * Avoid counting a reference twice or more for default values of
             * destructuring.
             */
            if (id === prevId) ***REMOVED***
                continue;
            ***REMOVED***
            prevId = id;

            // Add the identifier node into the destructuring group.
            const group = getDestructuringHost(reference);

            if (group) ***REMOVED***
                if (identifierMap.has(group)) ***REMOVED***
                    identifierMap.get(group).push(identifier);
                ***REMOVED*** else ***REMOVED***
                    identifierMap.set(group, [identifier]);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return identifierMap;
***REMOVED***

/**
 * Finds the nearest parent of node with a given type.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node – The node to search from.
 * @param ***REMOVED***string***REMOVED*** type – The type field of the parent node.
 * @param ***REMOVED***Function***REMOVED*** shouldStop – a predicate that returns true if the traversal should stop, and false otherwise.
 * @returns ***REMOVED***ASTNode***REMOVED*** The closest ancestor with the specified type; null if no such ancestor exists.
 */
function findUp(node, type, shouldStop) ***REMOVED***
    if (!node || shouldStop(node)) ***REMOVED***
        return null;
    ***REMOVED***
    if (node.type === type) ***REMOVED***
        return node;
    ***REMOVED***
    return findUp(node.parent, type, shouldStop);
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "require `const` declarations for variables that are never reassigned after declared",
            category: "ECMAScript 6",
            recommended: false,
            url: "https://eslint.org/docs/rules/prefer-const"
        ***REMOVED***,

        fixable: "code",

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    destructuring: ***REMOVED*** enum: ["any", "all"], default: "any" ***REMOVED***,
                    ignoreReadBeforeAssign: ***REMOVED*** type: "boolean", default: false ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],
        messages: ***REMOVED***
            useConst: "'***REMOVED******REMOVED***name***REMOVED******REMOVED***' is never reassigned. Use 'const' instead."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const options = context.options[0] || ***REMOVED******REMOVED***;
        const sourceCode = context.getSourceCode();
        const shouldMatchAnyDestructuredVariable = options.destructuring !== "all";
        const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;
        const variables = [];
        let reportCount = 0;
        let name = "";

        /**
         * Reports given identifier nodes if all of the nodes should be declared
         * as const.
         *
         * The argument 'nodes' is an array of Identifier nodes.
         * This node is the result of 'getIdentifierIfShouldBeConst()', so it's
         * nullable. In simple declaration or assignment cases, the length of
         * the array is 1. In destructuring cases, the length of the array can
         * be 2 or more.
         *
         * @param ***REMOVED***(eslint-scope.Reference|null)[]***REMOVED*** nodes -
         *      References which are grouped by destructuring to report.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkGroup(nodes) ***REMOVED***
            const nodesToReport = nodes.filter(Boolean);

            if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) ***REMOVED***
                const varDeclParent = findUp(nodes[0], "VariableDeclaration", parentNode => parentNode.type.endsWith("Statement"));
                const isVarDecParentNull = varDeclParent === null;

                if (!isVarDecParentNull && varDeclParent.declarations.length > 0) ***REMOVED***
                    const firstDeclaration = varDeclParent.declarations[0];

                    if (firstDeclaration.init) ***REMOVED***
                        const firstDecParent = firstDeclaration.init.parent;

                        /*
                         * First we check the declaration type and then depending on
                         * if the type is a "VariableDeclarator" or its an "ObjectPattern"
                         * we compare the name from the first identifier, if the names are different
                         * we assign the new name and reset the count of reportCount and nodeCount in
                         * order to check each block for the number of reported errors and base our fix
                         * based on comparing nodes.length and nodesToReport.length.
                         */

                        if (firstDecParent.type === "VariableDeclarator") ***REMOVED***

                            if (firstDecParent.id.name !== name) ***REMOVED***
                                name = firstDecParent.id.name;
                                reportCount = 0;
                            ***REMOVED***

                            if (firstDecParent.id.type === "ObjectPattern") ***REMOVED***
                                if (firstDecParent.init.name !== name) ***REMOVED***
                                    name = firstDecParent.init.name;
                                    reportCount = 0;
                                ***REMOVED***
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***

                let shouldFix = varDeclParent &&

                    // Don't do a fix unless all variables in the declarations are initialized (or it's in a for-in or for-of loop)
                    (varDeclParent.parent.type === "ForInStatement" || varDeclParent.parent.type === "ForOfStatement" ||
                        varDeclParent.declarations.every(declaration => declaration.init)) &&

                    /*
                     * If options.destructuring is "all", then this warning will not occur unless
                     * every assignment in the destructuring should be const. In that case, it's safe
                     * to apply the fix.
                     */
                    nodesToReport.length === nodes.length;

                if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) ***REMOVED***

                    if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) ***REMOVED***

                        /*
                         * Add nodesToReport.length to a count, then comparing the count to the length
                         * of the declarations in the current block.
                         */

                        reportCount += nodesToReport.length;

                        shouldFix = shouldFix && (reportCount === varDeclParent.declarations.length);
                    ***REMOVED***
                ***REMOVED***

                nodesToReport.forEach(node => ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        messageId: "useConst",
                        data: node,
                        fix: shouldFix
                            ? fixer => fixer.replaceText(
                                sourceCode.getFirstToken(varDeclParent, t => t.value === varDeclParent.kind),
                                "const"
                            )
                            : null
                    ***REMOVED***);
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            "Program:exit"() ***REMOVED***
                groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);
            ***REMOVED***,

            VariableDeclaration(node) ***REMOVED***
                if (node.kind === "let" && !isInitOfForStatement(node)) ***REMOVED***
                    variables.push(...context.getDeclaredVariables(node));
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
