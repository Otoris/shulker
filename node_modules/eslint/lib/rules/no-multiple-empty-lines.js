/**
 * @fileoverview Disallows multiple blank lines.
 * implementation adapted from the no-trailing-spaces rule.
 * @author Greg Cochard
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "disallow multiple empty lines",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-multiple-empty-lines"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    max: ***REMOVED***
                        type: "integer",
                        minimum: 0
                    ***REMOVED***,
                    maxEOF: ***REMOVED***
                        type: "integer",
                        minimum: 0
                    ***REMOVED***,
                    maxBOF: ***REMOVED***
                        type: "integer",
                        minimum: 0
                    ***REMOVED***
                ***REMOVED***,
                required: ["max"],
                additionalProperties: false
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***

        // Use options.max or 2 as default
        let max = 2,
            maxEOF = max,
            maxBOF = max;

        if (context.options.length) ***REMOVED***
            max = context.options[0].max;
            maxEOF = typeof context.options[0].maxEOF !== "undefined" ? context.options[0].maxEOF : max;
            maxBOF = typeof context.options[0].maxBOF !== "undefined" ? context.options[0].maxBOF : max;
        ***REMOVED***

        const sourceCode = context.getSourceCode();

        // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue
        const allLines = sourceCode.lines[sourceCode.lines.length - 1] === "" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;
        const templateLiteralLines = new Set();

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***
            TemplateLiteral(node) ***REMOVED***
                node.quasis.forEach(literalPart => ***REMOVED***

                    // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.
                    for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) ***REMOVED***
                        templateLiteralLines.add(ignoredLine);
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***,
            "Program:exit"(node) ***REMOVED***
                return allLines

                    // Given a list of lines, first get a list of line numbers that are non-empty.
                    .reduce((nonEmptyLineNumbers, line, index) => ***REMOVED***
                        if (line.trim() || templateLiteralLines.has(index + 1)) ***REMOVED***
                            nonEmptyLineNumbers.push(index + 1);
                        ***REMOVED***
                        return nonEmptyLineNumbers;
                    ***REMOVED***, [])

                    // Add a value at the end to allow trailing empty lines to be checked.
                    .concat(allLines.length + 1)

                    // Given two line numbers of non-empty lines, report the lines between if the difference is too large.
                    .reduce((lastLineNumber, lineNumber) => ***REMOVED***
                        let message, maxAllowed;

                        if (lastLineNumber === 0) ***REMOVED***
                            message = "Too many blank lines at the beginning of file. Max of ***REMOVED******REMOVED***max***REMOVED******REMOVED*** allowed.";
                            maxAllowed = maxBOF;
                        ***REMOVED*** else if (lineNumber === allLines.length + 1) ***REMOVED***
                            message = "Too many blank lines at the end of file. Max of ***REMOVED******REMOVED***max***REMOVED******REMOVED*** allowed.";
                            maxAllowed = maxEOF;
                        ***REMOVED*** else ***REMOVED***
                            message = "More than ***REMOVED******REMOVED***max***REMOVED******REMOVED*** blank ***REMOVED******REMOVED***pluralizedLines***REMOVED******REMOVED*** not allowed.";
                            maxAllowed = max;
                        ***REMOVED***

                        if (lineNumber - lastLineNumber - 1 > maxAllowed) ***REMOVED***
                            context.report(***REMOVED***
                                node,
                                loc: ***REMOVED*** start: ***REMOVED*** line: lastLineNumber + 1, column: 0 ***REMOVED***, end: ***REMOVED*** line: lineNumber, column: 0 ***REMOVED*** ***REMOVED***,
                                message,
                                data: ***REMOVED*** max: maxAllowed, pluralizedLines: maxAllowed === 1 ? "line" : "lines" ***REMOVED***,
                                fix(fixer) ***REMOVED***
                                    const rangeStart = sourceCode.getIndexFromLoc(***REMOVED*** line: lastLineNumber + 1, column: 0 ***REMOVED***);

                                    /*
                                     * The end of the removal range is usually the start index of the next line.
                                     * However, at the end of the file there is no next line, so the end of the
                                     * range is just the length of the text.
                                     */
                                    const lineNumberAfterRemovedLines = lineNumber - maxAllowed;
                                    const rangeEnd = lineNumberAfterRemovedLines <= allLines.length
                                        ? sourceCode.getIndexFromLoc(***REMOVED*** line: lineNumberAfterRemovedLines, column: 0 ***REMOVED***)
                                        : sourceCode.text.length;

                                    return fixer.removeRange([rangeStart, rangeEnd]);
                                ***REMOVED***
                            ***REMOVED***);
                        ***REMOVED***

                        return lineNumber;
                    ***REMOVED***, 0);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
