/**
 * @fileoverview Checks for unreachable code due to return, throws, break, and continue.
 * @author Joel Feenstra
 */
"use strict";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given variable declarator has the initializer.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A VariableDeclarator node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node has the initializer.
 */
function isInitialized(node) ***REMOVED***
    return Boolean(node.init);
***REMOVED***

/**
 * Checks whether or not a given code path segment is unreachable.
 * @param ***REMOVED***CodePathSegment***REMOVED*** segment - A CodePathSegment to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the segment is unreachable.
 */
function isUnreachable(segment) ***REMOVED***
    return !segment.reachable;
***REMOVED***

/**
 * The class to distinguish consecutive unreachable statements.
 */
class ConsecutiveRange ***REMOVED***
    constructor(sourceCode) ***REMOVED***
        this.sourceCode = sourceCode;
        this.startNode = null;
        this.endNode = null;
    ***REMOVED***

    /**
     * The location object of this range.
     * @type ***REMOVED***Object***REMOVED***
     */
    get location() ***REMOVED***
        return ***REMOVED***
            start: this.startNode.loc.start,
            end: this.endNode.loc.end
        ***REMOVED***;
    ***REMOVED***

    /**
     * `true` if this range is empty.
     * @type ***REMOVED***boolean***REMOVED***
     */
    get isEmpty() ***REMOVED***
        return !(this.startNode && this.endNode);
    ***REMOVED***

    /**
     * Checks whether the given node is inside of this range.
     * @param ***REMOVED***ASTNode|Token***REMOVED*** node - The node to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is inside of this range.
     */
    contains(node) ***REMOVED***
        return (
            node.range[0] >= this.startNode.range[0] &&
            node.range[1] <= this.endNode.range[1]
        );
    ***REMOVED***

    /**
     * Checks whether the given node is consecutive to this range.
     * @param ***REMOVED***ASTNode***REMOVED*** node - The node to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is consecutive to this range.
     */
    isConsecutive(node) ***REMOVED***
        return this.contains(this.sourceCode.getTokenBefore(node));
    ***REMOVED***

    /**
     * Merges the given node to this range.
     * @param ***REMOVED***ASTNode***REMOVED*** node - The node to merge.
     * @returns ***REMOVED***void***REMOVED***
     */
    merge(node) ***REMOVED***
        this.endNode = node;
    ***REMOVED***

    /**
     * Resets this range by the given node or null.
     * @param ***REMOVED***ASTNode|null***REMOVED*** node - The node to reset, or null.
     * @returns ***REMOVED***void***REMOVED***
     */
    reset(node) ***REMOVED***
        this.startNode = this.endNode = node;
    ***REMOVED***
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "problem",

        docs: ***REMOVED***
            description: "disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",
            category: "Possible Errors",
            recommended: true,
            url: "https://eslint.org/docs/rules/no-unreachable"
        ***REMOVED***,

        schema: []
    ***REMOVED***,

    create(context) ***REMOVED***
        let currentCodePath = null;

        const range = new ConsecutiveRange(context.getSourceCode());

        /**
         * Reports a given node if it's unreachable.
         * @param ***REMOVED***ASTNode***REMOVED*** node - A statement node to report.
         * @returns ***REMOVED***void***REMOVED***
         */
        function reportIfUnreachable(node) ***REMOVED***
            let nextNode = null;

            if (node && currentCodePath.currentSegments.every(isUnreachable)) ***REMOVED***

                // Store this statement to distinguish consecutive statements.
                if (range.isEmpty) ***REMOVED***
                    range.reset(node);
                    return;
                ***REMOVED***

                // Skip if this statement is inside of the current range.
                if (range.contains(node)) ***REMOVED***
                    return;
                ***REMOVED***

                // Merge if this statement is consecutive to the current range.
                if (range.isConsecutive(node)) ***REMOVED***
                    range.merge(node);
                    return;
                ***REMOVED***

                nextNode = node;
            ***REMOVED***

            /*
             * Report the current range since this statement is reachable or is
             * not consecutive to the current range.
             */
            if (!range.isEmpty) ***REMOVED***
                context.report(***REMOVED***
                    message: "Unreachable code.",
                    loc: range.location,
                    node: range.startNode
                ***REMOVED***);
            ***REMOVED***

            // Update the current range.
            range.reset(nextNode);
        ***REMOVED***

        return ***REMOVED***

            // Manages the current code path.
            onCodePathStart(codePath) ***REMOVED***
                currentCodePath = codePath;
            ***REMOVED***,

            onCodePathEnd() ***REMOVED***
                currentCodePath = currentCodePath.upper;
            ***REMOVED***,

            // Registers for all statement nodes (excludes FunctionDeclaration).
            BlockStatement: reportIfUnreachable,
            BreakStatement: reportIfUnreachable,
            ClassDeclaration: reportIfUnreachable,
            ContinueStatement: reportIfUnreachable,
            DebuggerStatement: reportIfUnreachable,
            DoWhileStatement: reportIfUnreachable,
            ExpressionStatement: reportIfUnreachable,
            ForInStatement: reportIfUnreachable,
            ForOfStatement: reportIfUnreachable,
            ForStatement: reportIfUnreachable,
            IfStatement: reportIfUnreachable,
            ImportDeclaration: reportIfUnreachable,
            LabeledStatement: reportIfUnreachable,
            ReturnStatement: reportIfUnreachable,
            SwitchStatement: reportIfUnreachable,
            ThrowStatement: reportIfUnreachable,
            TryStatement: reportIfUnreachable,

            VariableDeclaration(node) ***REMOVED***
                if (node.kind !== "var" || node.declarations.some(isInitialized)) ***REMOVED***
                    reportIfUnreachable(node);
                ***REMOVED***
            ***REMOVED***,

            WhileStatement: reportIfUnreachable,
            WithStatement: reportIfUnreachable,
            ExportNamedDeclaration: reportIfUnreachable,
            ExportDefaultDeclaration: reportIfUnreachable,
            ExportAllDeclaration: reportIfUnreachable,

            "Program:exit"() ***REMOVED***
                reportIfUnreachable();
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
