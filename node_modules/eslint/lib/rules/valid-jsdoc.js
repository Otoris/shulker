/**
 * @fileoverview Validates JSDoc comments are syntactically correct
 * @author Nicholas C. Zakas
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const doctrine = require("doctrine");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "enforce valid JSDoc comments",
            category: "Possible Errors",
            recommended: false,
            url: "https://eslint.org/docs/rules/valid-jsdoc"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    prefer: ***REMOVED***
                        type: "object",
                        additionalProperties: ***REMOVED***
                            type: "string"
                        ***REMOVED***
                    ***REMOVED***,
                    preferType: ***REMOVED***
                        type: "object",
                        additionalProperties: ***REMOVED***
                            type: "string"
                        ***REMOVED***
                    ***REMOVED***,
                    requireReturn: ***REMOVED***
                        type: "boolean",
                        default: true
                    ***REMOVED***,
                    requireParamDescription: ***REMOVED***
                        type: "boolean",
                        default: true
                    ***REMOVED***,
                    requireReturnDescription: ***REMOVED***
                        type: "boolean",
                        default: true
                    ***REMOVED***,
                    matchDescription: ***REMOVED***
                        type: "string"
                    ***REMOVED***,
                    requireReturnType: ***REMOVED***
                        type: "boolean",
                        default: true
                    ***REMOVED***,
                    requireParamType: ***REMOVED***
                        type: "boolean",
                        default: true
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],

        fixable: "code",
        messages: ***REMOVED***
            unexpectedTag: "Unexpected @***REMOVED******REMOVED***title***REMOVED******REMOVED*** tag; function has no return statement.",
            expected: "Expected JSDoc for '***REMOVED******REMOVED***name***REMOVED******REMOVED***' but found '***REMOVED******REMOVED***jsdocName***REMOVED******REMOVED***'.",
            use: "Use @***REMOVED******REMOVED***name***REMOVED******REMOVED*** instead.",
            useType: "Use '***REMOVED******REMOVED***expectedTypeName***REMOVED******REMOVED***' instead of '***REMOVED******REMOVED***currentTypeName***REMOVED******REMOVED***'.",
            syntaxError: "JSDoc syntax error.",
            missingBrace: "JSDoc type missing brace.",
            missingParamDesc: "Missing JSDoc parameter description for '***REMOVED******REMOVED***name***REMOVED******REMOVED***'.",
            missingParamType: "Missing JSDoc parameter type for '***REMOVED******REMOVED***name***REMOVED******REMOVED***'.",
            missingReturnType: "Missing JSDoc return type.",
            missingReturnDesc: "Missing JSDoc return description.",
            missingReturn: "Missing JSDoc @***REMOVED******REMOVED***returns***REMOVED******REMOVED*** for function.",
            missingParam: "Missing JSDoc for parameter '***REMOVED******REMOVED***name***REMOVED******REMOVED***'.",
            duplicateParam: "Duplicate JSDoc parameter '***REMOVED******REMOVED***name***REMOVED******REMOVED***'.",
            unsatisfiedDesc: "JSDoc description does not satisfy the regex pattern."
        ***REMOVED***,

        deprecated: true,
        replacedBy: []
    ***REMOVED***,

    create(context) ***REMOVED***

        const options = context.options[0] || ***REMOVED******REMOVED***,
            prefer = options.prefer || ***REMOVED******REMOVED***,
            sourceCode = context.getSourceCode(),

            // these both default to true, so you have to explicitly make them false
            requireReturn = options.requireReturn !== false,
            requireParamDescription = options.requireParamDescription !== false,
            requireReturnDescription = options.requireReturnDescription !== false,
            requireReturnType = options.requireReturnType !== false,
            requireParamType = options.requireParamType !== false,
            preferType = options.preferType || ***REMOVED******REMOVED***,
            checkPreferType = Object.keys(preferType).length !== 0;

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        // Using a stack to store if a function returns or not (handling nested functions)
        const fns = [];

        /**
         * Check if node type is a Class
         * @param ***REMOVED***ASTNode***REMOVED*** node node to check.
         * @returns ***REMOVED***boolean***REMOVED*** True is its a class
         * @private
         */
        function isTypeClass(node) ***REMOVED***
            return node.type === "ClassExpression" || node.type === "ClassDeclaration";
        ***REMOVED***

        /**
         * When parsing a new function, store it in our function stack.
         * @param ***REMOVED***ASTNode***REMOVED*** node A function node to check.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function startFunction(node) ***REMOVED***
            fns.push(***REMOVED***
                returnPresent: (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") ||
                    isTypeClass(node) || node.async
            ***REMOVED***);
        ***REMOVED***

        /**
         * Indicate that return has been found in the current function.
         * @param ***REMOVED***ASTNode***REMOVED*** node The return node.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function addReturn(node) ***REMOVED***
            const functionState = fns[fns.length - 1];

            if (functionState && node.argument !== null) ***REMOVED***
                functionState.returnPresent = true;
            ***REMOVED***
        ***REMOVED***

        /**
         * Check if return tag type is void or undefined
         * @param ***REMOVED***Object***REMOVED*** tag JSDoc tag
         * @returns ***REMOVED***boolean***REMOVED*** True if its of type void or undefined
         * @private
         */
        function isValidReturnType(tag) ***REMOVED***
            return tag.type === null || tag.type.name === "void" || tag.type.type === "UndefinedLiteral";
        ***REMOVED***

        /**
         * Check if type should be validated based on some exceptions
         * @param ***REMOVED***Object***REMOVED*** type JSDoc tag
         * @returns ***REMOVED***boolean***REMOVED*** True if it can be validated
         * @private
         */
        function canTypeBeValidated(type) ***REMOVED***
            return type !== "UndefinedLiteral" && // ***REMOVED***undefined***REMOVED*** as there is no name property available.
                   type !== "NullLiteral" && // ***REMOVED***null***REMOVED***
                   type !== "NullableLiteral" && // ***REMOVED***?***REMOVED***
                   type !== "FunctionType" && // ***REMOVED***function(a)***REMOVED***
                   type !== "AllLiteral"; // ***REMOVED*******REMOVED***
        ***REMOVED***

        /**
         * Extract the current and expected type based on the input type object
         * @param ***REMOVED***Object***REMOVED*** type JSDoc tag
         * @returns ***REMOVED******REMOVED***currentType: Doctrine.Type, expectedTypeName: string***REMOVED******REMOVED*** The current type annotation and
         * the expected name of the annotation
         * @private
         */
        function getCurrentExpectedTypes(type) ***REMOVED***
            let currentType;

            if (type.name) ***REMOVED***
                currentType = type;
            ***REMOVED*** else if (type.expression) ***REMOVED***
                currentType = type.expression;
            ***REMOVED***

            return ***REMOVED***
                currentType,
                expectedTypeName: currentType && preferType[currentType.name]
            ***REMOVED***;
        ***REMOVED***

        /**
         * Gets the location of a JSDoc node in a file
         * @param ***REMOVED***Token***REMOVED*** jsdocComment The comment that this node is parsed from
         * @param ***REMOVED******REMOVED***range: number[]***REMOVED******REMOVED*** parsedJsdocNode A tag or other node which was parsed from this comment
         * @returns ***REMOVED******REMOVED***start: SourceLocation, end: SourceLocation***REMOVED******REMOVED*** The 0-based source location for the tag
         */
        function getAbsoluteRange(jsdocComment, parsedJsdocNode) ***REMOVED***
            return ***REMOVED***
                start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),
                end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])
            ***REMOVED***;
        ***REMOVED***

        /**
         * Validate type for a given JSDoc node
         * @param ***REMOVED***Object***REMOVED*** jsdocNode JSDoc node
         * @param ***REMOVED***Object***REMOVED*** type JSDoc tag
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function validateType(jsdocNode, type) ***REMOVED***
            if (!type || !canTypeBeValidated(type.type)) ***REMOVED***
                return;
            ***REMOVED***

            const typesToCheck = [];
            let elements = [];

            switch (type.type) ***REMOVED***
                case "TypeApplication": // ***REMOVED***Array.<String>***REMOVED***
                    elements = type.applications[0].type === "UnionType" ? type.applications[0].elements : type.applications;
                    typesToCheck.push(getCurrentExpectedTypes(type));
                    break;
                case "RecordType": // ***REMOVED******REMOVED***20:String***REMOVED******REMOVED***
                    elements = type.fields;
                    break;
                case "UnionType": // ***REMOVED***String|number|Test***REMOVED***
                case "ArrayType": // ***REMOVED***[String, number, Test]***REMOVED***
                    elements = type.elements;
                    break;
                case "FieldType": // Array.<***REMOVED***count: number, votes: number***REMOVED***>
                    if (type.value) ***REMOVED***
                        typesToCheck.push(getCurrentExpectedTypes(type.value));
                    ***REMOVED***
                    break;
                default:
                    typesToCheck.push(getCurrentExpectedTypes(type));
            ***REMOVED***

            elements.forEach(validateType.bind(null, jsdocNode));

            typesToCheck.forEach(typeToCheck => ***REMOVED***
                if (typeToCheck.expectedTypeName &&
                    typeToCheck.expectedTypeName !== typeToCheck.currentType.name) ***REMOVED***
                    context.report(***REMOVED***
                        node: jsdocNode,
                        messageId: "useType",
                        loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),
                        data: ***REMOVED***
                            currentTypeName: typeToCheck.currentType.name,
                            expectedTypeName: typeToCheck.expectedTypeName
                        ***REMOVED***,
                        fix(fixer) ***REMOVED***
                            return fixer.replaceTextRange(
                                typeToCheck.currentType.range.map(indexInComment => jsdocNode.range[0] + 2 + indexInComment),
                                typeToCheck.expectedTypeName
                            );
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        /**
         * Validate the JSDoc node and output warnings if anything is wrong.
         * @param ***REMOVED***ASTNode***REMOVED*** node The AST node to check.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkJSDoc(node) ***REMOVED***
            const jsdocNode = sourceCode.getJSDocComment(node),
                functionData = fns.pop(),
                paramTagsByName = Object.create(null),
                paramTags = [];
            let hasReturns = false,
                returnsTag,
                hasConstructor = false,
                isInterface = false,
                isOverride = false,
                isAbstract = false;

            // make sure only to validate JSDoc comments
            if (jsdocNode) ***REMOVED***
                let jsdoc;

                try ***REMOVED***
                    jsdoc = doctrine.parse(jsdocNode.value, ***REMOVED***
                        strict: true,
                        unwrap: true,
                        sloppy: true,
                        range: true
                    ***REMOVED***);
                ***REMOVED*** catch (ex) ***REMOVED***

                    if (/braces/iu.test(ex.message)) ***REMOVED***
                        context.report(***REMOVED*** node: jsdocNode, messageId: "missingBrace" ***REMOVED***);
                    ***REMOVED*** else ***REMOVED***
                        context.report(***REMOVED*** node: jsdocNode, messageId: "syntaxError" ***REMOVED***);
                    ***REMOVED***

                    return;
                ***REMOVED***

                jsdoc.tags.forEach(tag => ***REMOVED***

                    switch (tag.title.toLowerCase()) ***REMOVED***

                        case "param":
                        case "arg":
                        case "argument":
                            paramTags.push(tag);
                            break;

                        case "return":
                        case "returns":
                            hasReturns = true;
                            returnsTag = tag;
                            break;

                        case "constructor":
                        case "class":
                            hasConstructor = true;
                            break;

                        case "override":
                        case "inheritdoc":
                            isOverride = true;
                            break;

                        case "abstract":
                        case "virtual":
                            isAbstract = true;
                            break;

                        case "interface":
                            isInterface = true;
                            break;

                        // no default
                    ***REMOVED***

                    // check tag preferences
                    if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) ***REMOVED***
                        const entireTagRange = getAbsoluteRange(jsdocNode, tag);

                        context.report(***REMOVED***
                            node: jsdocNode,
                            messageId: "use",
                            loc: ***REMOVED***
                                start: entireTagRange.start,
                                end: ***REMOVED***
                                    line: entireTagRange.start.line,
                                    column: entireTagRange.start.column + `@$***REMOVED***tag.title***REMOVED***`.length
                                ***REMOVED***
                            ***REMOVED***,
                            data: ***REMOVED*** name: prefer[tag.title] ***REMOVED***,
                            fix(fixer) ***REMOVED***
                                return fixer.replaceTextRange(
                                    [
                                        jsdocNode.range[0] + tag.range[0] + 3,
                                        jsdocNode.range[0] + tag.range[0] + tag.title.length + 3
                                    ],
                                    prefer[tag.title]
                                );
                            ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED***

                    // validate the types
                    if (checkPreferType && tag.type) ***REMOVED***
                        validateType(jsdocNode, tag.type);
                    ***REMOVED***
                ***REMOVED***);

                paramTags.forEach(param => ***REMOVED***
                    if (requireParamType && !param.type) ***REMOVED***
                        context.report(***REMOVED***
                            node: jsdocNode,
                            messageId: "missingParamType",
                            loc: getAbsoluteRange(jsdocNode, param),
                            data: ***REMOVED*** name: param.name ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED***
                    if (!param.description && requireParamDescription) ***REMOVED***
                        context.report(***REMOVED***
                            node: jsdocNode,
                            messageId: "missingParamDesc",
                            loc: getAbsoluteRange(jsdocNode, param),
                            data: ***REMOVED*** name: param.name ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED***
                    if (paramTagsByName[param.name]) ***REMOVED***
                        context.report(***REMOVED***
                            node: jsdocNode,
                            messageId: "duplicateParam",
                            loc: getAbsoluteRange(jsdocNode, param),
                            data: ***REMOVED*** name: param.name ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED*** else if (param.name.indexOf(".") === -1) ***REMOVED***
                        paramTagsByName[param.name] = param;
                    ***REMOVED***
                ***REMOVED***);

                if (hasReturns) ***REMOVED***
                    if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) ***REMOVED***
                        context.report(***REMOVED***
                            node: jsdocNode,
                            messageId: "unexpectedTag",
                            loc: getAbsoluteRange(jsdocNode, returnsTag),
                            data: ***REMOVED***
                                title: returnsTag.title
                            ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED*** else ***REMOVED***
                        if (requireReturnType && !returnsTag.type) ***REMOVED***
                            context.report(***REMOVED*** node: jsdocNode, messageId: "missingReturnType" ***REMOVED***);
                        ***REMOVED***

                        if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) ***REMOVED***
                            context.report(***REMOVED*** node: jsdocNode, messageId: "missingReturnDesc" ***REMOVED***);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***

                // check for functions missing @returns
                if (!isOverride && !hasReturns && !hasConstructor && !isInterface &&
                    node.parent.kind !== "get" && node.parent.kind !== "constructor" &&
                    node.parent.kind !== "set" && !isTypeClass(node)) ***REMOVED***
                    if (requireReturn || (functionData.returnPresent && !node.async)) ***REMOVED***
                        context.report(***REMOVED***
                            node: jsdocNode,
                            messageId: "missingReturn",
                            data: ***REMOVED***
                                returns: prefer.returns || "returns"
                            ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED***
                ***REMOVED***

                // check the parameters
                const jsdocParamNames = Object.keys(paramTagsByName);

                if (node.params) ***REMOVED***
                    node.params.forEach((param, paramsIndex) => ***REMOVED***
                        const bindingParam = param.type === "AssignmentPattern"
                            ? param.left
                            : param;

                        // TODO(nzakas): Figure out logical things to do with destructured, default, rest params
                        if (bindingParam.type === "Identifier") ***REMOVED***
                            const name = bindingParam.name;

                            if (jsdocParamNames[paramsIndex] && (name !== jsdocParamNames[paramsIndex])) ***REMOVED***
                                context.report(***REMOVED***
                                    node: jsdocNode,
                                    messageId: "expected",
                                    loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),
                                    data: ***REMOVED***
                                        name,
                                        jsdocName: jsdocParamNames[paramsIndex]
                                    ***REMOVED***
                                ***REMOVED***);
                            ***REMOVED*** else if (!paramTagsByName[name] && !isOverride) ***REMOVED***
                                context.report(***REMOVED***
                                    node: jsdocNode,
                                    messageId: "missingParam",
                                    data: ***REMOVED***
                                        name
                                    ***REMOVED***
                                ***REMOVED***);
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***

                if (options.matchDescription) ***REMOVED***
                    const regex = new RegExp(options.matchDescription, "u");

                    if (!regex.test(jsdoc.description)) ***REMOVED***
                        context.report(***REMOVED*** node: jsdocNode, messageId: "unsatisfiedDesc" ***REMOVED***);
                    ***REMOVED***
                ***REMOVED***

            ***REMOVED***

        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***
            ArrowFunctionExpression: startFunction,
            FunctionExpression: startFunction,
            FunctionDeclaration: startFunction,
            ClassExpression: startFunction,
            ClassDeclaration: startFunction,
            "ArrowFunctionExpression:exit": checkJSDoc,
            "FunctionExpression:exit": checkJSDoc,
            "FunctionDeclaration:exit": checkJSDoc,
            "ClassExpression:exit": checkJSDoc,
            "ClassDeclaration:exit": checkJSDoc,
            ReturnStatement: addReturn
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
