/**
 * @fileoverview disallow assignments that can lead to race conditions due to usage of `await` or `yield`
 * @author Teddy Katz
 * @author Toru Nagashima
 */
"use strict";

/**
 * Make the map from identifiers to each reference.
 * @param ***REMOVED***escope.Scope***REMOVED*** scope The scope to get references.
 * @param ***REMOVED***Map<Identifier, escope.Reference>***REMOVED*** [outReferenceMap] The map from identifier nodes to each reference object.
 * @returns ***REMOVED***Map<Identifier, escope.Reference>***REMOVED*** `referenceMap`.
 */
function createReferenceMap(scope, outReferenceMap = new Map()) ***REMOVED***
    for (const reference of scope.references) ***REMOVED***
        outReferenceMap.set(reference.identifier, reference);
    ***REMOVED***
    for (const childScope of scope.childScopes) ***REMOVED***
        if (childScope.type !== "function") ***REMOVED***
            createReferenceMap(childScope, outReferenceMap);
        ***REMOVED***
    ***REMOVED***

    return outReferenceMap;
***REMOVED***

/**
 * Get `reference.writeExpr` of a given reference.
 * If it's the read reference of MemberExpression in LHS, returns RHS in order to address `a.b = await a`
 * @param ***REMOVED***escope.Reference***REMOVED*** reference The reference to get.
 * @returns ***REMOVED***Expression|null***REMOVED*** The `reference.writeExpr`.
 */
function getWriteExpr(reference) ***REMOVED***
    if (reference.writeExpr) ***REMOVED***
        return reference.writeExpr;
    ***REMOVED***
    let node = reference.identifier;

    while (node) ***REMOVED***
        const t = node.parent.type;

        if (t === "AssignmentExpression" && node.parent.left === node) ***REMOVED***
            return node.parent.right;
        ***REMOVED***
        if (t === "MemberExpression" && node.parent.object === node) ***REMOVED***
            node = node.parent;
            continue;
        ***REMOVED***

        break;
    ***REMOVED***

    return null;
***REMOVED***

/**
 * Checks if an expression is a variable that can only be observed within the given function.
 * @param ***REMOVED***Variable|null***REMOVED*** variable The variable to check
 * @param ***REMOVED***boolean***REMOVED*** isMemberAccess If `true` then this is a member access.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the variable is local to the given function, and is never referenced in a closure.
 */
function isLocalVariableWithoutEscape(variable, isMemberAccess) ***REMOVED***
    if (!variable) ***REMOVED***
        return false; // A global variable which was not defined.
    ***REMOVED***

    // If the reference is a property access and the variable is a parameter, it handles the variable is not local.
    if (isMemberAccess && variable.defs.some(d => d.type === "Parameter")) ***REMOVED***
        return false;
    ***REMOVED***

    const functionScope = variable.scope.variableScope;

    return variable.references.every(reference =>
        reference.from.variableScope === functionScope);
***REMOVED***

class SegmentInfo ***REMOVED***
    constructor() ***REMOVED***
        this.info = new WeakMap();
    ***REMOVED***

    /**
     * Initialize the segment information.
     * @param ***REMOVED***PathSegment***REMOVED*** segment The segment to initialize.
     * @returns ***REMOVED***void***REMOVED***
     */
    initialize(segment) ***REMOVED***
        const outdatedReadVariableNames = new Set();
        const freshReadVariableNames = new Set();

        for (const prevSegment of segment.prevSegments) ***REMOVED***
            const info = this.info.get(prevSegment);

            if (info) ***REMOVED***
                info.outdatedReadVariableNames.forEach(Set.prototype.add, outdatedReadVariableNames);
                info.freshReadVariableNames.forEach(Set.prototype.add, freshReadVariableNames);
            ***REMOVED***
        ***REMOVED***

        this.info.set(segment, ***REMOVED*** outdatedReadVariableNames, freshReadVariableNames ***REMOVED***);
    ***REMOVED***

    /**
     * Mark a given variable as read on given segments.
     * @param ***REMOVED***PathSegment[]***REMOVED*** segments The segments that it read the variable on.
     * @param ***REMOVED***string***REMOVED*** variableName The variable name to be read.
     * @returns ***REMOVED***void***REMOVED***
     */
    markAsRead(segments, variableName) ***REMOVED***
        for (const segment of segments) ***REMOVED***
            const info = this.info.get(segment);

            if (info) ***REMOVED***
                info.freshReadVariableNames.add(variableName);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    /**
     * Move `freshReadVariableNames` to `outdatedReadVariableNames`.
     * @param ***REMOVED***PathSegment[]***REMOVED*** segments The segments to process.
     * @returns ***REMOVED***void***REMOVED***
     */
    makeOutdated(segments) ***REMOVED***
        for (const segment of segments) ***REMOVED***
            const info = this.info.get(segment);

            if (info) ***REMOVED***
                info.freshReadVariableNames.forEach(Set.prototype.add, info.outdatedReadVariableNames);
                info.freshReadVariableNames.clear();
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    /**
     * Check if a given variable is outdated on the current segments.
     * @param ***REMOVED***PathSegment[]***REMOVED*** segments The current segments.
     * @param ***REMOVED***string***REMOVED*** variableName The variable name to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the variable is outdated on the segments.
     */
    isOutdated(segments, variableName) ***REMOVED***
        for (const segment of segments) ***REMOVED***
            const info = this.info.get(segment);

            if (info && info.outdatedReadVariableNames.has(variableName)) ***REMOVED***
                return true;
            ***REMOVED***
        ***REMOVED***
        return false;
    ***REMOVED***
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "problem",

        docs: ***REMOVED***
            description: "disallow assignments that can lead to race conditions due to usage of `await` or `yield`",
            category: "Possible Errors",
            recommended: true,
            url: "https://eslint.org/docs/rules/require-atomic-updates"
        ***REMOVED***,

        fixable: null,
        schema: [],

        messages: ***REMOVED***
            nonAtomicUpdate: "Possible race condition: `***REMOVED******REMOVED***value***REMOVED******REMOVED***` might be reassigned based on an outdated value of `***REMOVED******REMOVED***value***REMOVED******REMOVED***`."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();
        const assignmentReferences = new Map();
        const segmentInfo = new SegmentInfo();
        let stack = null;

        return ***REMOVED***
            onCodePathStart(codePath) ***REMOVED***
                const scope = context.getScope();
                const shouldVerify =
                    scope.type === "function" &&
                    (scope.block.async || scope.block.generator);

                stack = ***REMOVED***
                    upper: stack,
                    codePath,
                    referenceMap: shouldVerify ? createReferenceMap(scope) : null
                ***REMOVED***;
            ***REMOVED***,
            onCodePathEnd() ***REMOVED***
                stack = stack.upper;
            ***REMOVED***,

            // Initialize the segment information.
            onCodePathSegmentStart(segment) ***REMOVED***
                segmentInfo.initialize(segment);
            ***REMOVED***,

            // Handle references to prepare verification.
            Identifier(node) ***REMOVED***
                const ***REMOVED*** codePath, referenceMap ***REMOVED*** = stack;
                const reference = referenceMap && referenceMap.get(node);

                // Ignore if this is not a valid variable reference.
                if (!reference) ***REMOVED***
                    return;
                ***REMOVED***
                const name = reference.identifier.name;
                const variable = reference.resolved;
                const writeExpr = getWriteExpr(reference);
                const isMemberAccess = reference.identifier.parent.type === "MemberExpression";

                // Add a fresh read variable.
                if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === "=")) ***REMOVED***
                    segmentInfo.markAsRead(codePath.currentSegments, name);
                ***REMOVED***

                /*
                 * Register the variable to verify after ESLint traversed the `writeExpr` node
                 * if this reference is an assignment to a variable which is referred from other clausure.
                 */
                if (writeExpr &&
                    writeExpr.parent.right === writeExpr && // ‚Üê exclude variable declarations.
                    !isLocalVariableWithoutEscape(variable, isMemberAccess)
                ) ***REMOVED***
                    let refs = assignmentReferences.get(writeExpr);

                    if (!refs) ***REMOVED***
                        refs = [];
                        assignmentReferences.set(writeExpr, refs);
                    ***REMOVED***

                    refs.push(reference);
                ***REMOVED***
            ***REMOVED***,

            /*
             * Verify assignments.
             * If the reference exists in `outdatedReadVariableNames` list, report it.
             */
            ":expression:exit"(node) ***REMOVED***
                const ***REMOVED*** codePath, referenceMap ***REMOVED*** = stack;

                // referenceMap exists if this is in a resumable function scope.
                if (!referenceMap) ***REMOVED***
                    return;
                ***REMOVED***

                // Mark the read variables on this code path as outdated.
                if (node.type === "AwaitExpression" || node.type === "YieldExpression") ***REMOVED***
                    segmentInfo.makeOutdated(codePath.currentSegments);
                ***REMOVED***

                // Verify.
                const references = assignmentReferences.get(node);

                if (references) ***REMOVED***
                    assignmentReferences.delete(node);

                    for (const reference of references) ***REMOVED***
                        const name = reference.identifier.name;

                        if (segmentInfo.isOutdated(codePath.currentSegments, name)) ***REMOVED***
                            context.report(***REMOVED***
                                node: node.parent,
                                messageId: "nonAtomicUpdate",
                                data: ***REMOVED***
                                    value: sourceCode.getText(node.parent.left)
                                ***REMOVED***
                            ***REMOVED***);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
