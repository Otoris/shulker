/**
 * @fileoverview enforce a particular style for multiline comments
 * @author Teddy Katz
 */
"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "enforce a particular style for multiline comments",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/multiline-comment-style"
        ***REMOVED***,

        fixable: "whitespace",
        schema: [***REMOVED*** enum: ["starred-block", "separate-lines", "bare-block"] ***REMOVED***],
        messages: ***REMOVED***
            expectedBlock: "Expected a block comment instead of consecutive line comments.",
            expectedBareBlock: "Expected a block comment without padding stars.",
            startNewline: "Expected a linebreak after '/*'.",
            endNewline: "Expected a linebreak before '*/'.",
            missingStar: "Expected a '*' at the start of this line.",
            alignment: "Expected this line to be aligned with the start of the comment.",
            expectedLines: "Expected multiple line comments instead of a block comment."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();
        const option = context.options[0] || "starred-block";

        //----------------------------------------------------------------------
        // Helpers
        //----------------------------------------------------------------------

        /**
         * Gets a list of comment lines in a group
         * @param ***REMOVED***Token[]***REMOVED*** commentGroup A group of comments, containing either multiple line comments or a single block comment
         * @returns ***REMOVED***string[]***REMOVED*** A list of comment lines
         */
        function getCommentLines(commentGroup) ***REMOVED***
            if (commentGroup[0].type === "Line") ***REMOVED***
                return commentGroup.map(comment => comment.value);
            ***REMOVED***
            return commentGroup[0].value
                .split(astUtils.LINEBREAK_MATCHER)
                .map(line => line.replace(/^\s*\*?/u, ""));
        ***REMOVED***

        /**
         * Converts a comment into starred-block form
         * @param ***REMOVED***Token***REMOVED*** firstComment The first comment of the group being converted
         * @param ***REMOVED***string[]***REMOVED*** commentLinesList A list of lines to appear in the new starred-block comment
         * @returns ***REMOVED***string***REMOVED*** A representation of the comment value in starred-block form, excluding start and end markers
         */
        function convertToStarredBlock(firstComment, commentLinesList) ***REMOVED***
            const initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
            const starredLines = commentLinesList.map(line => `$***REMOVED***initialOffset***REMOVED*** *$***REMOVED***line***REMOVED***`);

            return `\n$***REMOVED***starredLines.join("\n")***REMOVED***\n$***REMOVED***initialOffset***REMOVED*** `;
        ***REMOVED***

        /**
         * Converts a comment into separate-line form
         * @param ***REMOVED***Token***REMOVED*** firstComment The first comment of the group being converted
         * @param ***REMOVED***string[]***REMOVED*** commentLinesList A list of lines to appear in the new starred-block comment
         * @returns ***REMOVED***string***REMOVED*** A representation of the comment value in separate-line form
         */
        function convertToSeparateLines(firstComment, commentLinesList) ***REMOVED***
            const initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
            const separateLines = commentLinesList.map(line => `// $***REMOVED***line.trim()***REMOVED***`);

            return separateLines.join(`\n$***REMOVED***initialOffset***REMOVED***`);
        ***REMOVED***

        /**
         * Converts a comment into bare-block form
         * @param ***REMOVED***Token***REMOVED*** firstComment The first comment of the group being converted
         * @param ***REMOVED***string[]***REMOVED*** commentLinesList A list of lines to appear in the new starred-block comment
         * @returns ***REMOVED***string***REMOVED*** A representation of the comment value in bare-block form
         */
        function convertToBlock(firstComment, commentLinesList) ***REMOVED***
            const initialOffset = sourceCode.text.slice(firstComment.range[0] - firstComment.loc.start.column, firstComment.range[0]);
            const blockLines = commentLinesList.map(line => line.trim());

            return `/* $***REMOVED***blockLines.join(`\n$***REMOVED***initialOffset***REMOVED***   `)***REMOVED*** */`;
        ***REMOVED***

        /**
         * Check a comment is JSDoc form
         * @param ***REMOVED***Token[]***REMOVED*** commentGroup A group of comments, containing either multiple line comments or a single block comment
         * @returns ***REMOVED***boolean***REMOVED*** if commentGroup is JSDoc form, return true
         */
        function isJSDoc(commentGroup) ***REMOVED***
            const lines = commentGroup[0].value.split(astUtils.LINEBREAK_MATCHER);

            return commentGroup[0].type === "Block" &&
                /^\*\s*$/u.test(lines[0]) &&
                lines.slice(1, -1).every(line => /^\s* /u.test(line)) &&
                /^\s*$/u.test(lines[lines.length - 1]);
        ***REMOVED***

        /**
         * Each method checks a group of comments to see if it's valid according to the given option.
         * @param ***REMOVED***Token[]***REMOVED*** commentGroup A list of comments that appear together. This will either contain a single
         * block comment or multiple line comments.
         * @returns ***REMOVED***void***REMOVED***
         */
        const commentGroupCheckers = ***REMOVED***
            "starred-block"(commentGroup) ***REMOVED***
                const commentLines = getCommentLines(commentGroup);

                if (commentLines.some(value => value.includes("*/"))) ***REMOVED***
                    return;
                ***REMOVED***

                if (commentGroup.length > 1) ***REMOVED***
                    context.report(***REMOVED***
                        loc: ***REMOVED***
                            start: commentGroup[0].loc.start,
                            end: commentGroup[commentGroup.length - 1].loc.end
                        ***REMOVED***,
                        messageId: "expectedBlock",
                        fix(fixer) ***REMOVED***
                            const range = [commentGroup[0].range[0], commentGroup[commentGroup.length - 1].range[1]];
                            const starredBlock = `/*$***REMOVED***convertToStarredBlock(commentGroup[0], commentLines)***REMOVED****/`;

                            return commentLines.some(value => value.startsWith("/"))
                                ? null
                                : fixer.replaceTextRange(range, starredBlock);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED*** else ***REMOVED***
                    const block = commentGroup[0];
                    const lines = block.value.split(astUtils.LINEBREAK_MATCHER);
                    const expectedLinePrefix = `$***REMOVED***sourceCode.text.slice(block.range[0] - block.loc.start.column, block.range[0])***REMOVED*** *`;

                    if (!/^\*?\s*$/u.test(lines[0])) ***REMOVED***
                        const start = block.value.startsWith("*") ? block.range[0] + 1 : block.range[0];

                        context.report(***REMOVED***
                            loc: ***REMOVED***
                                start: block.loc.start,
                                end: ***REMOVED*** line: block.loc.start.line, column: block.loc.start.column + 2 ***REMOVED***
                            ***REMOVED***,
                            messageId: "startNewline",
                            fix: fixer => fixer.insertTextAfterRange([start, start + 2], `\n$***REMOVED***expectedLinePrefix***REMOVED***`)
                        ***REMOVED***);
                    ***REMOVED***

                    if (!/^\s*$/u.test(lines[lines.length - 1])) ***REMOVED***
                        context.report(***REMOVED***
                            loc: ***REMOVED***
                                start: ***REMOVED*** line: block.loc.end.line, column: block.loc.end.column - 2 ***REMOVED***,
                                end: block.loc.end
                            ***REMOVED***,
                            messageId: "endNewline",
                            fix: fixer => fixer.replaceTextRange([block.range[1] - 2, block.range[1]], `\n$***REMOVED***expectedLinePrefix***REMOVED***/`)
                        ***REMOVED***);
                    ***REMOVED***

                    for (let lineNumber = block.loc.start.line + 1; lineNumber <= block.loc.end.line; lineNumber++) ***REMOVED***
                        const lineText = sourceCode.lines[lineNumber - 1];

                        if (!lineText.startsWith(expectedLinePrefix)) ***REMOVED***
                            context.report(***REMOVED***
                                loc: ***REMOVED***
                                    start: ***REMOVED*** line: lineNumber, column: 0 ***REMOVED***,
                                    end: ***REMOVED*** line: lineNumber, column: sourceCode.lines[lineNumber - 1].length ***REMOVED***
                                ***REMOVED***,
                                messageId: /^\s*\*/u.test(lineText)
                                    ? "alignment"
                                    : "missingStar",
                                fix(fixer) ***REMOVED***
                                    const lineStartIndex = sourceCode.getIndexFromLoc(***REMOVED*** line: lineNumber, column: 0 ***REMOVED***);
                                    const linePrefixLength = lineText.match(/^\s*\*? ?/u)[0].length;
                                    const commentStartIndex = lineStartIndex + linePrefixLength;

                                    const replacementText = lineNumber === block.loc.end.line || lineText.length === linePrefixLength
                                        ? expectedLinePrefix
                                        : `$***REMOVED***expectedLinePrefix***REMOVED*** `;

                                    return fixer.replaceTextRange([lineStartIndex, commentStartIndex], replacementText);
                                ***REMOVED***
                            ***REMOVED***);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***,
            "separate-lines"(commentGroup) ***REMOVED***
                if (!isJSDoc(commentGroup) && commentGroup[0].type === "Block") ***REMOVED***
                    const commentLines = getCommentLines(commentGroup);
                    const block = commentGroup[0];
                    const tokenAfter = sourceCode.getTokenAfter(block, ***REMOVED*** includeComments: true ***REMOVED***);

                    if (tokenAfter && block.loc.end.line === tokenAfter.loc.start.line) ***REMOVED***
                        return;
                    ***REMOVED***

                    context.report(***REMOVED***
                        loc: ***REMOVED***
                            start: block.loc.start,
                            end: ***REMOVED*** line: block.loc.start.line, column: block.loc.start.column + 2 ***REMOVED***
                        ***REMOVED***,
                        messageId: "expectedLines",
                        fix(fixer) ***REMOVED***
                            return fixer.replaceText(block, convertToSeparateLines(block, commentLines.filter(line => line)));
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***,
            "bare-block"(commentGroup) ***REMOVED***
                if (!isJSDoc(commentGroup)) ***REMOVED***
                    const commentLines = getCommentLines(commentGroup);

                    // disallows consecutive line comments in favor of using a block comment.
                    if (commentGroup[0].type === "Line" && commentLines.length > 1 &&
                        !commentLines.some(value => value.includes("*/"))) ***REMOVED***
                        context.report(***REMOVED***
                            loc: ***REMOVED***
                                start: commentGroup[0].loc.start,
                                end: commentGroup[commentGroup.length - 1].loc.end
                            ***REMOVED***,
                            messageId: "expectedBlock",
                            fix(fixer) ***REMOVED***
                                const range = [commentGroup[0].range[0], commentGroup[commentGroup.length - 1].range[1]];
                                const block = convertToBlock(commentGroup[0], commentLines.filter(line => line));

                                return fixer.replaceTextRange(range, block);
                            ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED***

                    // prohibits block comments from having a * at the beginning of each line.
                    if (commentGroup[0].type === "Block") ***REMOVED***
                        const block = commentGroup[0];
                        const lines = block.value.split(astUtils.LINEBREAK_MATCHER).filter(line => line.trim());

                        if (lines.length > 0 && lines.every(line => /^\s*\*/u.test(line))) ***REMOVED***
                            context.report(***REMOVED***
                                loc: ***REMOVED***
                                    start: block.loc.start,
                                    end: ***REMOVED*** line: block.loc.start.line, column: block.loc.start.column + 2 ***REMOVED***
                                ***REMOVED***,
                                messageId: "expectedBareBlock",
                                fix(fixer) ***REMOVED***
                                    return fixer.replaceText(block, convertToBlock(block, commentLines.filter(line => line)));
                                ***REMOVED***
                            ***REMOVED***);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------

        return ***REMOVED***
            Program() ***REMOVED***
                return sourceCode.getAllComments()
                    .filter(comment => comment.type !== "Shebang")
                    .filter(comment => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value))
                    .filter(comment => ***REMOVED***
                        const tokenBefore = sourceCode.getTokenBefore(comment, ***REMOVED*** includeComments: true ***REMOVED***);

                        return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;
                    ***REMOVED***)
                    .reduce((commentGroups, comment, index, commentList) => ***REMOVED***
                        const tokenBefore = sourceCode.getTokenBefore(comment, ***REMOVED*** includeComments: true ***REMOVED***);

                        if (
                            comment.type === "Line" &&
                            index && commentList[index - 1].type === "Line" &&
                            tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 &&
                            tokenBefore === commentList[index - 1]
                        ) ***REMOVED***
                            commentGroups[commentGroups.length - 1].push(comment);
                        ***REMOVED*** else ***REMOVED***
                            commentGroups.push([comment]);
                        ***REMOVED***

                        return commentGroups;
                    ***REMOVED***, [])
                    .filter(commentGroup => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line))
                    .forEach(commentGroupCheckers[option]);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
