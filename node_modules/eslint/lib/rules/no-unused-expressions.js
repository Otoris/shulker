/**
 * @fileoverview Flag expressions in statement position that do not side effect
 * @author Michael Ficarra
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow unused expressions",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-unused-expressions"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    allowShortCircuit: ***REMOVED***
                        type: "boolean",
                        default: false
                    ***REMOVED***,
                    allowTernary: ***REMOVED***
                        type: "boolean",
                        default: false
                    ***REMOVED***,
                    allowTaggedTemplates: ***REMOVED***
                        type: "boolean",
                        default: false
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***
        const config = context.options[0] || ***REMOVED******REMOVED***,
            allowShortCircuit = config.allowShortCircuit || false,
            allowTernary = config.allowTernary || false,
            allowTaggedTemplates = config.allowTaggedTemplates || false;

        /**
         * @param ***REMOVED***ASTNode***REMOVED*** node - any node
         * @returns ***REMOVED***boolean***REMOVED*** whether the given node structurally represents a directive
         */
        function looksLikeDirective(node) ***REMOVED***
            return node.type === "ExpressionStatement" &&
                node.expression.type === "Literal" && typeof node.expression.value === "string";
        ***REMOVED***

        /**
         * @param ***REMOVED***Function***REMOVED*** predicate - ([a] -> Boolean) the function used to make the determination
         * @param ***REMOVED***a[]***REMOVED*** list - the input list
         * @returns ***REMOVED***a[]***REMOVED*** the leading sequence of members in the given list that pass the given predicate
         */
        function takeWhile(predicate, list) ***REMOVED***
            for (let i = 0; i < list.length; ++i) ***REMOVED***
                if (!predicate(list[i])) ***REMOVED***
                    return list.slice(0, i);
                ***REMOVED***
            ***REMOVED***
            return list.slice();
        ***REMOVED***

        /**
         * @param ***REMOVED***ASTNode***REMOVED*** node - a Program or BlockStatement node
         * @returns ***REMOVED***ASTNode[]***REMOVED*** the leading sequence of directive nodes in the given node's body
         */
        function directives(node) ***REMOVED***
            return takeWhile(looksLikeDirective, node.body);
        ***REMOVED***

        /**
         * @param ***REMOVED***ASTNode***REMOVED*** node - any node
         * @param ***REMOVED***ASTNode[]***REMOVED*** ancestors - the given node's ancestors
         * @returns ***REMOVED***boolean***REMOVED*** whether the given node is considered a directive in its current position
         */
        function isDirective(node, ancestors) ***REMOVED***
            const parent = ancestors[ancestors.length - 1],
                grandparent = ancestors[ancestors.length - 2];

            return (parent.type === "Program" || parent.type === "BlockStatement" &&
                    (/Function/u.test(grandparent.type))) &&
                    directives(parent).indexOf(node) >= 0;
        ***REMOVED***

        /**
         * Determines whether or not a given node is a valid expression. Recurses on short circuit eval and ternary nodes if enabled by flags.
         * @param ***REMOVED***ASTNode***REMOVED*** node - any node
         * @returns ***REMOVED***boolean***REMOVED*** whether the given node is a valid expression
         */
        function isValidExpression(node) ***REMOVED***
            if (allowTernary) ***REMOVED***

                // Recursive check for ternary and logical expressions
                if (node.type === "ConditionalExpression") ***REMOVED***
                    return isValidExpression(node.consequent) && isValidExpression(node.alternate);
                ***REMOVED***
            ***REMOVED***

            if (allowShortCircuit) ***REMOVED***
                if (node.type === "LogicalExpression") ***REMOVED***
                    return isValidExpression(node.right);
                ***REMOVED***
            ***REMOVED***

            if (allowTaggedTemplates && node.type === "TaggedTemplateExpression") ***REMOVED***
                return true;
            ***REMOVED***

            return /^(?:Assignment|Call|New|Update|Yield|Await)Expression$/u.test(node.type) ||
                (node.type === "UnaryExpression" && ["delete", "void"].indexOf(node.operator) >= 0);
        ***REMOVED***

        return ***REMOVED***
            ExpressionStatement(node) ***REMOVED***
                if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) ***REMOVED***
                    context.report(***REMOVED*** node, message: "Expected an assignment or function call and instead saw an expression." ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
