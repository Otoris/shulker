/**
 * @fileoverview Rule to enforce concise object methods and properties.
 * @author Jamund Ferguson
 */

"use strict";

const OPTIONS = ***REMOVED***
    always: "always",
    never: "never",
    methods: "methods",
    properties: "properties",
    consistent: "consistent",
    consistentAsNeeded: "consistent-as-needed"
***REMOVED***;

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------
const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "require or disallow method and property shorthand syntax for object literals",
            category: "ECMAScript 6",
            recommended: false,
            url: "https://eslint.org/docs/rules/object-shorthand"
        ***REMOVED***,

        fixable: "code",

        schema: ***REMOVED***
            anyOf: [
                ***REMOVED***
                    type: "array",
                    items: [
                        ***REMOVED***
                            enum: ["always", "methods", "properties", "never", "consistent", "consistent-as-needed"]
                        ***REMOVED***
                    ],
                    minItems: 0,
                    maxItems: 1
                ***REMOVED***,
                ***REMOVED***
                    type: "array",
                    items: [
                        ***REMOVED***
                            enum: ["always", "methods", "properties"]
                        ***REMOVED***,
                        ***REMOVED***
                            type: "object",
                            properties: ***REMOVED***
                                avoidQuotes: ***REMOVED***
                                    type: "boolean"
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***
                    ],
                    minItems: 0,
                    maxItems: 2
                ***REMOVED***,
                ***REMOVED***
                    type: "array",
                    items: [
                        ***REMOVED***
                            enum: ["always", "methods"]
                        ***REMOVED***,
                        ***REMOVED***
                            type: "object",
                            properties: ***REMOVED***
                                ignoreConstructors: ***REMOVED***
                                    type: "boolean"
                                ***REMOVED***,
                                avoidQuotes: ***REMOVED***
                                    type: "boolean"
                                ***REMOVED***,
                                avoidExplicitReturnArrows: ***REMOVED***
                                    type: "boolean"
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***
                    ],
                    minItems: 0,
                    maxItems: 2
                ***REMOVED***
            ]
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const APPLY = context.options[0] || OPTIONS.always;
        const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;
        const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;
        const APPLY_NEVER = APPLY === OPTIONS.never;
        const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;
        const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;

        const PARAMS = context.options[1] || ***REMOVED******REMOVED***;
        const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;
        const AVOID_QUOTES = PARAMS.avoidQuotes;
        const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;
        const sourceCode = context.getSourceCode();

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        const CTOR_PREFIX_REGEX = /[^_$0-9]/u;

        /**
         * Determines if the first character of the name is a capital letter.
         * @param ***REMOVED***string***REMOVED*** name The name of the node to evaluate.
         * @returns ***REMOVED***boolean***REMOVED*** True if the first character of the property name is a capital letter, false if not.
         * @private
         */
        function isConstructor(name) ***REMOVED***
            const match = CTOR_PREFIX_REGEX.exec(name);

            // Not a constructor if name has no characters apart from '_', '$' and digits e.g. '_', '$$', '_8'
            if (!match) ***REMOVED***
                return false;
            ***REMOVED***

            const firstChar = name.charAt(match.index);

            return firstChar === firstChar.toUpperCase();
        ***REMOVED***

        /**
         * Determines if the property can have a shorthand form.
         * @param ***REMOVED***ASTNode***REMOVED*** property Property AST node
         * @returns ***REMOVED***boolean***REMOVED*** True if the property can have a shorthand form
         * @private
         *
         */
        function canHaveShorthand(property) ***REMOVED***
            return (property.kind !== "set" && property.kind !== "get" && property.type !== "SpreadElement" && property.type !== "SpreadProperty" && property.type !== "ExperimentalSpreadProperty");
        ***REMOVED***

        /**
         * Checks whether a node is a string literal.
         * @param   ***REMOVED***ASTNode***REMOVED*** node - Any AST node.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if it is a string literal.
         */
        function isStringLiteral(node) ***REMOVED***
            return node.type === "Literal" && typeof node.value === "string";
        ***REMOVED***

        /**
         * Determines if the property is a shorthand or not.
         * @param ***REMOVED***ASTNode***REMOVED*** property Property AST node
         * @returns ***REMOVED***boolean***REMOVED*** True if the property is considered shorthand, false if not.
         * @private
         *
         */
        function isShorthand(property) ***REMOVED***

            // property.method is true when `***REMOVED***a()***REMOVED******REMOVED******REMOVED***`.
            return (property.shorthand || property.method);
        ***REMOVED***

        /**
         * Determines if the property's key and method or value are named equally.
         * @param ***REMOVED***ASTNode***REMOVED*** property Property AST node
         * @returns ***REMOVED***boolean***REMOVED*** True if the key and value are named equally, false if not.
         * @private
         *
         */
        function isRedundant(property) ***REMOVED***
            const value = property.value;

            if (value.type === "FunctionExpression") ***REMOVED***
                return !value.id; // Only anonymous should be shorthand method.
            ***REMOVED***
            if (value.type === "Identifier") ***REMOVED***
                return astUtils.getStaticPropertyName(property) === value.name;
            ***REMOVED***

            return false;
        ***REMOVED***

        /**
         * Ensures that an object's properties are consistently shorthand, or not shorthand at all.
         * @param   ***REMOVED***ASTNode***REMOVED*** node Property AST node
         * @param   ***REMOVED***boolean***REMOVED*** checkRedundancy Whether to check longform redundancy
         * @returns ***REMOVED***void***REMOVED***
         *
         */
        function checkConsistency(node, checkRedundancy) ***REMOVED***

            // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.
            const properties = node.properties.filter(canHaveShorthand);

            // Do we still have properties left after filtering the getters and setters?
            if (properties.length > 0) ***REMOVED***
                const shorthandProperties = properties.filter(isShorthand);

                /*
                 * If we do not have an equal number of longform properties as
                 * shorthand properties, we are using the annotations inconsistently
                 */
                if (shorthandProperties.length !== properties.length) ***REMOVED***

                    // We have at least 1 shorthand property
                    if (shorthandProperties.length > 0) ***REMOVED***
                        context.report(***REMOVED*** node, message: "Unexpected mix of shorthand and non-shorthand properties." ***REMOVED***);
                    ***REMOVED*** else if (checkRedundancy) ***REMOVED***

                        /*
                         * If all properties of the object contain a method or value with a name matching it's key,
                         * all the keys are redundant.
                         */
                        const canAlwaysUseShorthand = properties.every(isRedundant);

                        if (canAlwaysUseShorthand) ***REMOVED***
                            context.report(***REMOVED*** node, message: "Expected shorthand for all properties." ***REMOVED***);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Fixes a FunctionExpression node by making it into a shorthand property.
         * @param ***REMOVED***SourceCodeFixer***REMOVED*** fixer The fixer object
         * @param ***REMOVED***ASTNode***REMOVED*** node A `Property` node that has a `FunctionExpression` or `ArrowFunctionExpression` as its value
         * @returns ***REMOVED***Object***REMOVED*** A fix for this node
         */
        function makeFunctionShorthand(fixer, node) ***REMOVED***
            const firstKeyToken = node.computed
                ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken)
                : sourceCode.getFirstToken(node.key);
            const lastKeyToken = node.computed
                ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken)
                : sourceCode.getLastToken(node.key);
            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
            let keyPrefix = "";

            // key: /* */ () => ***REMOVED******REMOVED***
            if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) ***REMOVED***
                return null;
            ***REMOVED***

            if (node.value.async) ***REMOVED***
                keyPrefix += "async ";
            ***REMOVED***
            if (node.value.generator) ***REMOVED***
                keyPrefix += "*";
            ***REMOVED***

            const fixRange = [firstKeyToken.range[0], node.range[1]];
            const methodPrefix = keyPrefix + keyText;

            if (node.value.type === "FunctionExpression") ***REMOVED***
                const functionToken = sourceCode.getTokens(node.value).find(token => token.type === "Keyword" && token.value === "function");
                const tokenBeforeParams = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;

                return fixer.replaceTextRange(
                    fixRange,
                    methodPrefix + sourceCode.text.slice(tokenBeforeParams.range[1], node.value.range[1])
                );
            ***REMOVED***

            const arrowToken = sourceCode.getTokenBefore(node.value.body, astUtils.isArrowToken);
            const fnBody = sourceCode.text.slice(arrowToken.range[1], node.value.range[1]);

            let shouldAddParensAroundParameters = false;
            let tokenBeforeParams;

            if (node.value.params.length === 0) ***REMOVED***
                tokenBeforeParams = sourceCode.getFirstToken(node.value, astUtils.isOpeningParenToken);
            ***REMOVED*** else ***REMOVED***
                tokenBeforeParams = sourceCode.getTokenBefore(node.value.params[0]);
            ***REMOVED***

            if (node.value.params.length === 1) ***REMOVED***
                const hasParen = astUtils.isOpeningParenToken(tokenBeforeParams);
                const isTokenOutsideNode = tokenBeforeParams.range[0] < node.range[0];

                shouldAddParensAroundParameters = !hasParen || isTokenOutsideNode;
            ***REMOVED***

            const sliceStart = shouldAddParensAroundParameters
                ? node.value.params[0].range[0]
                : tokenBeforeParams.range[0];
            const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];

            const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);
            const newParamText = shouldAddParensAroundParameters ? `($***REMOVED***oldParamText***REMOVED***)` : oldParamText;

            return fixer.replaceTextRange(
                fixRange,
                methodPrefix + newParamText + fnBody
            );

        ***REMOVED***

        /**
         * Fixes a FunctionExpression node by making it into a longform property.
         * @param ***REMOVED***SourceCodeFixer***REMOVED*** fixer The fixer object
         * @param ***REMOVED***ASTNode***REMOVED*** node A `Property` node that has a `FunctionExpression` as its value
         * @returns ***REMOVED***Object***REMOVED*** A fix for this node
         */
        function makeFunctionLongform(fixer, node) ***REMOVED***
            const firstKeyToken = node.computed ? sourceCode.getTokens(node).find(token => token.value === "[") : sourceCode.getFirstToken(node.key);
            const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === "]") : sourceCode.getLastToken(node.key);
            const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
            let functionHeader = "function";

            if (node.value.async) ***REMOVED***
                functionHeader = `async $***REMOVED***functionHeader***REMOVED***`;
            ***REMOVED***
            if (node.value.generator) ***REMOVED***
                functionHeader = `$***REMOVED***functionHeader***REMOVED****`;
            ***REMOVED***

            return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `$***REMOVED***keyText***REMOVED***: $***REMOVED***functionHeader***REMOVED***`);
        ***REMOVED***

        /*
         * To determine whether a given arrow function has a lexical identifier (`this`, `arguments`, `super`, or `new.target`),
         * create a stack of functions that define these identifiers (i.e. all functions except arrow functions) as the AST is
         * traversed. Whenever a new function is encountered, create a new entry on the stack (corresponding to a different lexical
         * scope of `this`), and whenever a function is exited, pop that entry off the stack. When an arrow function is entered,
         * keep a reference to it on the current stack entry, and remove that reference when the arrow function is exited.
         * When a lexical identifier is encountered, mark all the arrow functions on the current stack entry by adding them
         * to an `arrowsWithLexicalIdentifiers` set. Any arrow function in that set will not be reported by this rule,
         * because converting it into a method would change the value of one of the lexical identifiers.
         */
        const lexicalScopeStack = [];
        const arrowsWithLexicalIdentifiers = new WeakSet();
        const argumentsIdentifiers = new WeakSet();

        /**
         * Enters a function. This creates a new lexical identifier scope, so a new Set of arrow functions is pushed onto the stack.
         * Also, this marks all `arguments` identifiers so that they can be detected later.
         * @returns ***REMOVED***void***REMOVED***
         */
        function enterFunction() ***REMOVED***
            lexicalScopeStack.unshift(new Set());
            context.getScope().variables.filter(variable => variable.name === "arguments").forEach(variable => ***REMOVED***
                variable.references.map(ref => ref.identifier).forEach(identifier => argumentsIdentifiers.add(identifier));
            ***REMOVED***);
        ***REMOVED***

        /**
         * Exits a function. This pops the current set of arrow functions off the lexical scope stack.
         * @returns ***REMOVED***void***REMOVED***
         */
        function exitFunction() ***REMOVED***
            lexicalScopeStack.shift();
        ***REMOVED***

        /**
         * Marks the current function as having a lexical keyword. This implies that all arrow functions
         * in the current lexical scope contain a reference to this lexical keyword.
         * @returns ***REMOVED***void***REMOVED***
         */
        function reportLexicalIdentifier() ***REMOVED***
            lexicalScopeStack[0].forEach(arrowFunction => arrowsWithLexicalIdentifiers.add(arrowFunction));
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***
            Program: enterFunction,
            FunctionDeclaration: enterFunction,
            FunctionExpression: enterFunction,
            "Program:exit": exitFunction,
            "FunctionDeclaration:exit": exitFunction,
            "FunctionExpression:exit": exitFunction,

            ArrowFunctionExpression(node) ***REMOVED***
                lexicalScopeStack[0].add(node);
            ***REMOVED***,
            "ArrowFunctionExpression:exit"(node) ***REMOVED***
                lexicalScopeStack[0].delete(node);
            ***REMOVED***,

            ThisExpression: reportLexicalIdentifier,
            Super: reportLexicalIdentifier,
            MetaProperty(node) ***REMOVED***
                if (node.meta.name === "new" && node.property.name === "target") ***REMOVED***
                    reportLexicalIdentifier();
                ***REMOVED***
            ***REMOVED***,
            Identifier(node) ***REMOVED***
                if (argumentsIdentifiers.has(node)) ***REMOVED***
                    reportLexicalIdentifier();
                ***REMOVED***
            ***REMOVED***,

            ObjectExpression(node) ***REMOVED***
                if (APPLY_CONSISTENT) ***REMOVED***
                    checkConsistency(node, false);
                ***REMOVED*** else if (APPLY_CONSISTENT_AS_NEEDED) ***REMOVED***
                    checkConsistency(node, true);
                ***REMOVED***
            ***REMOVED***,

            "Property:exit"(node) ***REMOVED***
                const isConciseProperty = node.method || node.shorthand;

                // Ignore destructuring assignment
                if (node.parent.type === "ObjectPattern") ***REMOVED***
                    return;
                ***REMOVED***

                // getters and setters are ignored
                if (node.kind === "get" || node.kind === "set") ***REMOVED***
                    return;
                ***REMOVED***

                // only computed methods can fail the following checks
                if (node.computed && node.value.type !== "FunctionExpression" && node.value.type !== "ArrowFunctionExpression") ***REMOVED***
                    return;
                ***REMOVED***

                //--------------------------------------------------------------
                // Checks for property/method shorthand.
                if (isConciseProperty) ***REMOVED***
                    if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) ***REMOVED***
                        const message = APPLY_NEVER ? "Expected longform method syntax." : "Expected longform method syntax for string literal keys.";

                        // ***REMOVED*** x() ***REMOVED******REMOVED*** ***REMOVED*** should be written as ***REMOVED*** x: function() ***REMOVED******REMOVED*** ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            message,
                            fix: fixer => makeFunctionLongform(fixer, node)
                        ***REMOVED***);
                    ***REMOVED*** else if (APPLY_NEVER) ***REMOVED***

                        // ***REMOVED*** x ***REMOVED*** should be written as ***REMOVED*** x: x ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            message: "Expected longform property syntax.",
                            fix: fixer => fixer.insertTextAfter(node.key, `: $***REMOVED***node.key.name***REMOVED***`)
                        ***REMOVED***);
                    ***REMOVED***
                ***REMOVED*** else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === "FunctionExpression" || node.value.type === "ArrowFunctionExpression")) ***REMOVED***
                    if (IGNORE_CONSTRUCTORS && node.key.type === "Identifier" && isConstructor(node.key.name)) ***REMOVED***
                        return;
                    ***REMOVED***
                    if (AVOID_QUOTES && isStringLiteral(node.key)) ***REMOVED***
                        return;
                    ***REMOVED***

                    // ***REMOVED***[x]: function()***REMOVED******REMOVED******REMOVED*** should be written as ***REMOVED***[x]() ***REMOVED******REMOVED******REMOVED***
                    if (node.value.type === "FunctionExpression" ||
                        node.value.type === "ArrowFunctionExpression" &&
                        node.value.body.type === "BlockStatement" &&
                        AVOID_EXPLICIT_RETURN_ARROWS &&
                        !arrowsWithLexicalIdentifiers.has(node.value)
                    ) ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            message: "Expected method shorthand.",
                            fix: fixer => makeFunctionShorthand(fixer, node)
                        ***REMOVED***);
                    ***REMOVED***
                ***REMOVED*** else if (node.value.type === "Identifier" && node.key.name === node.value.name && APPLY_TO_PROPS) ***REMOVED***

                    // ***REMOVED***x: x***REMOVED*** should be written as ***REMOVED***x***REMOVED***
                    context.report(***REMOVED***
                        node,
                        message: "Expected property shorthand.",
                        fix(fixer) ***REMOVED***
                            return fixer.replaceText(node, node.value.name);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED*** else if (node.value.type === "Identifier" && node.key.type === "Literal" && node.key.value === node.value.name && APPLY_TO_PROPS) ***REMOVED***
                    if (AVOID_QUOTES) ***REMOVED***
                        return;
                    ***REMOVED***

                    // ***REMOVED***"x": x***REMOVED*** should be written as ***REMOVED***x***REMOVED***
                    context.report(***REMOVED***
                        node,
                        message: "Expected property shorthand.",
                        fix(fixer) ***REMOVED***
                            return fixer.replaceText(node, node.value.name);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
