/**
 * @fileoverview A rule to disallow the type conversions with shorter notations.
 * @author Toru Nagashima
 */

"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;
const ALLOWABLE_OPERATORS = ["~", "!!", "+", "*"];

/**
 * Parses and normalizes an option object.
 * @param ***REMOVED***Object***REMOVED*** options - An option object to parse.
 * @returns ***REMOVED***Object***REMOVED*** The parsed and normalized option object.
 */
function parseOptions(options) ***REMOVED***
    return ***REMOVED***
        boolean: "boolean" in options ? options.boolean : true,
        number: "number" in options ? options.number : true,
        string: "string" in options ? options.string : true,
        allow: options.allow || []
    ***REMOVED***;
***REMOVED***

/**
 * Checks whether or not a node is a double logical nigating.
 * @param ***REMOVED***ASTNode***REMOVED*** node - An UnaryExpression node to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not the node is a double logical nigating.
 */
function isDoubleLogicalNegating(node) ***REMOVED***
    return (
        node.operator === "!" &&
        node.argument.type === "UnaryExpression" &&
        node.argument.operator === "!"
    );
***REMOVED***

/**
 * Checks whether or not a node is a binary negating of `.indexOf()` method calling.
 * @param ***REMOVED***ASTNode***REMOVED*** node - An UnaryExpression node to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not the node is a binary negating of `.indexOf()` method calling.
 */
function isBinaryNegatingOfIndexOf(node) ***REMOVED***
    return (
        node.operator === "~" &&
        node.argument.type === "CallExpression" &&
        node.argument.callee.type === "MemberExpression" &&
        node.argument.callee.property.type === "Identifier" &&
        INDEX_OF_PATTERN.test(node.argument.callee.property.name)
    );
***REMOVED***

/**
 * Checks whether or not a node is a multiplying by one.
 * @param ***REMOVED***BinaryExpression***REMOVED*** node - A BinaryExpression node to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not the node is a multiplying by one.
 */
function isMultiplyByOne(node) ***REMOVED***
    return node.operator === "*" && (
        node.left.type === "Literal" && node.left.value === 1 ||
        node.right.type === "Literal" && node.right.value === 1
    );
***REMOVED***

/**
 * Checks whether the result of a node is numeric or not
 * @param ***REMOVED***ASTNode***REMOVED*** node The node to test
 * @returns ***REMOVED***boolean***REMOVED*** true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call
 */
function isNumeric(node) ***REMOVED***
    return (
        node.type === "Literal" && typeof node.value === "number" ||
        node.type === "CallExpression" && (
            node.callee.name === "Number" ||
            node.callee.name === "parseInt" ||
            node.callee.name === "parseFloat"
        )
    );
***REMOVED***

/**
 * Returns the first non-numeric operand in a BinaryExpression. Designed to be
 * used from bottom to up since it walks up the BinaryExpression trees using
 * node.parent to find the result.
 * @param ***REMOVED***BinaryExpression***REMOVED*** node The BinaryExpression node to be walked up on
 * @returns ***REMOVED***ASTNode|null***REMOVED*** The first non-numeric item in the BinaryExpression tree or null
 */
function getNonNumericOperand(node) ***REMOVED***
    const left = node.left,
        right = node.right;

    if (right.type !== "BinaryExpression" && !isNumeric(right)) ***REMOVED***
        return right;
    ***REMOVED***

    if (left.type !== "BinaryExpression" && !isNumeric(left)) ***REMOVED***
        return left;
    ***REMOVED***

    return null;
***REMOVED***

/**
 * Checks whether a node is an empty string literal or not.
 * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not the passed in node is an
 * empty string literal or not.
 */
function isEmptyString(node) ***REMOVED***
    return astUtils.isStringLiteral(node) && (node.value === "" || (node.type === "TemplateLiteral" && node.quasis.length === 1 && node.quasis[0].value.cooked === ""));
***REMOVED***

/**
 * Checks whether or not a node is a concatenating with an empty string.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A BinaryExpression node to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not the node is a concatenating with an empty string.
 */
function isConcatWithEmptyString(node) ***REMOVED***
    return node.operator === "+" && (
        (isEmptyString(node.left) && !astUtils.isStringLiteral(node.right)) ||
        (isEmptyString(node.right) && !astUtils.isStringLiteral(node.left))
    );
***REMOVED***

/**
 * Checks whether or not a node is appended with an empty string.
 * @param ***REMOVED***ASTNode***REMOVED*** node - An AssignmentExpression node to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not the node is appended with an empty string.
 */
function isAppendEmptyString(node) ***REMOVED***
    return node.operator === "+=" && isEmptyString(node.right);
***REMOVED***

/**
 * Returns the operand that is not an empty string from a flagged BinaryExpression.
 * @param ***REMOVED***ASTNode***REMOVED*** node - The flagged BinaryExpression node to check.
 * @returns ***REMOVED***ASTNode***REMOVED*** The operand that is not an empty string from a flagged BinaryExpression.
 */
function getNonEmptyOperand(node) ***REMOVED***
    return isEmptyString(node.left) ? node.right : node.left;
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow shorthand type conversions",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-implicit-coercion"
        ***REMOVED***,

        fixable: "code",

        schema: [***REMOVED***
            type: "object",
            properties: ***REMOVED***
                boolean: ***REMOVED***
                    type: "boolean",
                    default: true
                ***REMOVED***,
                number: ***REMOVED***
                    type: "boolean",
                    default: true
                ***REMOVED***,
                string: ***REMOVED***
                    type: "boolean",
                    default: true
                ***REMOVED***,
                allow: ***REMOVED***
                    type: "array",
                    items: ***REMOVED***
                        enum: ALLOWABLE_OPERATORS
                    ***REMOVED***,
                    uniqueItems: true
                ***REMOVED***
            ***REMOVED***,
            additionalProperties: false
        ***REMOVED***]
    ***REMOVED***,

    create(context) ***REMOVED***
        const options = parseOptions(context.options[0] || ***REMOVED******REMOVED***);
        const sourceCode = context.getSourceCode();

        /**
         * Reports an error and autofixes the node
         * @param ***REMOVED***ASTNode***REMOVED*** node - An ast node to report the error on.
         * @param ***REMOVED***string***REMOVED*** recommendation - The recommended code for the issue
         * @param ***REMOVED***bool***REMOVED*** shouldFix - Whether this report should fix the node
         * @returns ***REMOVED***void***REMOVED***
         */
        function report(node, recommendation, shouldFix) ***REMOVED***
            context.report(***REMOVED***
                node,
                message: "use `***REMOVED******REMOVED***recommendation***REMOVED******REMOVED***` instead.",
                data: ***REMOVED***
                    recommendation
                ***REMOVED***,
                fix(fixer) ***REMOVED***
                    if (!shouldFix) ***REMOVED***
                        return null;
                    ***REMOVED***

                    const tokenBefore = sourceCode.getTokenBefore(node);

                    if (
                        tokenBefore &&
                        tokenBefore.range[1] === node.range[0] &&
                        !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)
                    ) ***REMOVED***
                        return fixer.replaceText(node, ` $***REMOVED***recommendation***REMOVED***`);
                    ***REMOVED***
                    return fixer.replaceText(node, recommendation);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        return ***REMOVED***
            UnaryExpression(node) ***REMOVED***
                let operatorAllowed;

                // !!foo
                operatorAllowed = options.allow.indexOf("!!") >= 0;
                if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) ***REMOVED***
                    const recommendation = `Boolean($***REMOVED***sourceCode.getText(node.argument.argument)***REMOVED***)`;

                    report(node, recommendation, true);
                ***REMOVED***

                // ~foo.indexOf(bar)
                operatorAllowed = options.allow.indexOf("~") >= 0;
                if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) ***REMOVED***
                    const recommendation = `$***REMOVED***sourceCode.getText(node.argument)***REMOVED*** !== -1`;

                    report(node, recommendation, false);
                ***REMOVED***

                // +foo
                operatorAllowed = options.allow.indexOf("+") >= 0;
                if (!operatorAllowed && options.number && node.operator === "+" && !isNumeric(node.argument)) ***REMOVED***
                    const recommendation = `Number($***REMOVED***sourceCode.getText(node.argument)***REMOVED***)`;

                    report(node, recommendation, true);
                ***REMOVED***
            ***REMOVED***,

            // Use `:exit` to prevent double reporting
            "BinaryExpression:exit"(node) ***REMOVED***
                let operatorAllowed;

                // 1 * foo
                operatorAllowed = options.allow.indexOf("*") >= 0;
                const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);

                if (nonNumericOperand) ***REMOVED***
                    const recommendation = `Number($***REMOVED***sourceCode.getText(nonNumericOperand)***REMOVED***)`;

                    report(node, recommendation, true);
                ***REMOVED***

                // "" + foo
                operatorAllowed = options.allow.indexOf("+") >= 0;
                if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) ***REMOVED***
                    const recommendation = `String($***REMOVED***sourceCode.getText(getNonEmptyOperand(node))***REMOVED***)`;

                    report(node, recommendation, true);
                ***REMOVED***
            ***REMOVED***,

            AssignmentExpression(node) ***REMOVED***

                // foo += ""
                const operatorAllowed = options.allow.indexOf("+") >= 0;

                if (!operatorAllowed && options.string && isAppendEmptyString(node)) ***REMOVED***
                    const code = sourceCode.getText(getNonEmptyOperand(node));
                    const recommendation = `$***REMOVED***code***REMOVED*** = String($***REMOVED***code***REMOVED***)`;

                    report(node, recommendation, true);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
