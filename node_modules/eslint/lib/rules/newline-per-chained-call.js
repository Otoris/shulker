/**
 * @fileoverview Rule to ensure newline per method call when chaining calls
 * @author Rajendra Patil
 * @author Burak Yigit Kaya
 */

"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "require a newline after each call in a method chain",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/newline-per-chained-call"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [***REMOVED***
            type: "object",
            properties: ***REMOVED***
                ignoreChainWithDepth: ***REMOVED***
                    type: "integer",
                    minimum: 1,
                    maximum: 10,
                    default: 2
                ***REMOVED***
            ***REMOVED***,
            additionalProperties: false
        ***REMOVED***],
        messages: ***REMOVED***
            expected: "Expected line break before `***REMOVED******REMOVED***callee***REMOVED******REMOVED***`."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        const options = context.options[0] || ***REMOVED******REMOVED***,
            ignoreChainWithDepth = options.ignoreChainWithDepth || 2;

        const sourceCode = context.getSourceCode();

        /**
         * Get the prefix of a given MemberExpression node.
         * If the MemberExpression node is a computed value it returns a
         * left bracket. If not it returns a period.
         *
         * @param  ***REMOVED***ASTNode***REMOVED*** node - A MemberExpression node to get
         * @returns ***REMOVED***string***REMOVED*** The prefix of the node.
         */
        function getPrefix(node) ***REMOVED***
            return node.computed ? "[" : ".";
        ***REMOVED***

        /**
         * Gets the property text of a given MemberExpression node.
         * If the text is multiline, this returns only the first line.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node - A MemberExpression node to get.
         * @returns ***REMOVED***string***REMOVED*** The property text of the node.
         */
        function getPropertyText(node) ***REMOVED***
            const prefix = getPrefix(node);
            const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);
            const suffix = node.computed && lines.length === 1 ? "]" : "";

            return prefix + lines[0] + suffix;
        ***REMOVED***

        return ***REMOVED***
            "CallExpression:exit"(node) ***REMOVED***
                if (!node.callee || node.callee.type !== "MemberExpression") ***REMOVED***
                    return;
                ***REMOVED***

                const callee = node.callee;
                let parent = callee.object;
                let depth = 1;

                while (parent && parent.callee) ***REMOVED***
                    depth += 1;
                    parent = parent.callee.object;
                ***REMOVED***

                if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) ***REMOVED***
                    context.report(***REMOVED***
                        node: callee.property,
                        loc: callee.property.loc.start,
                        messageId: "expected",
                        data: ***REMOVED***
                            callee: getPropertyText(callee)
                        ***REMOVED***,
                        fix(fixer) ***REMOVED***
                            const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);

                            return fixer.insertTextBefore(firstTokenAfterObject, "\n");
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
