/**
 * @fileoverview Rule to flag wrapping non-iife in parens
 * @author Gyandeep Singh
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/**
 * Property name if it can be computed statically, otherwise the list of the tokens of the key node.
 * @typedef ***REMOVED***string|Token[]***REMOVED*** Key
 */

/**
 * Accessor nodes with the same key.
 * @typedef ***REMOVED***Object***REMOVED*** AccessorData
 * @property ***REMOVED***Key***REMOVED*** key Accessor's key
 * @property ***REMOVED***ASTNode[]***REMOVED*** getters List of getter nodes.
 * @property ***REMOVED***ASTNode[]***REMOVED*** setters List of setter nodes.
 */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not the given lists represent the equal tokens in the same order.
 * Tokens are compared by their properties, not by instance.
 * @param ***REMOVED***Token[]***REMOVED*** left First list of tokens.
 * @param ***REMOVED***Token[]***REMOVED*** right Second list of tokens.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the lists have same tokens.
 */
function areEqualTokenLists(left, right) ***REMOVED***
    if (left.length !== right.length) ***REMOVED***
        return false;
    ***REMOVED***

    for (let i = 0; i < left.length; i++) ***REMOVED***
        const leftToken = left[i],
            rightToken = right[i];

        if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***

    return true;
***REMOVED***

/**
 * Checks whether or not the given keys are equal.
 * @param ***REMOVED***Key***REMOVED*** left First key.
 * @param ***REMOVED***Key***REMOVED*** right Second key.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the keys are equal.
 */
function areEqualKeys(left, right) ***REMOVED***
    if (typeof left === "string" && typeof right === "string") ***REMOVED***

        // Statically computed names.
        return left === right;
    ***REMOVED***
    if (Array.isArray(left) && Array.isArray(right)) ***REMOVED***

        // Token lists.
        return areEqualTokenLists(left, right);
    ***REMOVED***

    return false;
***REMOVED***

/**
 * Checks whether or not a given node is of an accessor kind ('get' or 'set').
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is of an accessor kind.
 */
function isAccessorKind(node) ***REMOVED***
    return node.kind === "get" || node.kind === "set";
***REMOVED***

/**
 * Checks whether or not a given node is an `Identifier` node which was named a given name.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @param ***REMOVED***string***REMOVED*** name - An expected name of the node.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is an `Identifier` node which was named as expected.
 */
function isIdentifier(node, name) ***REMOVED***
    return node.type === "Identifier" && node.name === name;
***REMOVED***

/**
 * Checks whether or not a given node is an argument of a specified method call.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @param ***REMOVED***number***REMOVED*** index - An expected index of the node in arguments.
 * @param ***REMOVED***string***REMOVED*** object - An expected name of the object of the method.
 * @param ***REMOVED***string***REMOVED*** property - An expected name of the method.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is an argument of the specified method call.
 */
function isArgumentOfMethodCall(node, index, object, property) ***REMOVED***
    const parent = node.parent;

    return (
        parent.type === "CallExpression" &&
        parent.callee.type === "MemberExpression" &&
        parent.callee.computed === false &&
        isIdentifier(parent.callee.object, object) &&
        isIdentifier(parent.callee.property, property) &&
        parent.arguments[index] === node
    );
***REMOVED***

/**
 * Checks whether or not a given node is a property descriptor.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a property descriptor.
 */
function isPropertyDescriptor(node) ***REMOVED***

    // Object.defineProperty(obj, "foo", ***REMOVED***set: ...***REMOVED***)
    if (isArgumentOfMethodCall(node, 2, "Object", "defineProperty") ||
        isArgumentOfMethodCall(node, 2, "Reflect", "defineProperty")
    ) ***REMOVED***
        return true;
    ***REMOVED***

    /*
     * Object.defineProperties(obj, ***REMOVED***foo: ***REMOVED***set: ...***REMOVED******REMOVED***)
     * Object.create(proto, ***REMOVED***foo: ***REMOVED***set: ...***REMOVED******REMOVED***)
     */
    const grandparent = node.parent.parent;

    return grandparent.type === "ObjectExpression" && (
        isArgumentOfMethodCall(grandparent, 1, "Object", "create") ||
        isArgumentOfMethodCall(grandparent, 1, "Object", "defineProperties")
    );
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "enforce getter and setter pairs in objects and classes",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/accessor-pairs"
        ***REMOVED***,

        schema: [***REMOVED***
            type: "object",
            properties: ***REMOVED***
                getWithoutSet: ***REMOVED***
                    type: "boolean",
                    default: false
                ***REMOVED***,
                setWithoutGet: ***REMOVED***
                    type: "boolean",
                    default: true
                ***REMOVED***,
                enforceForClassMembers: ***REMOVED***
                    type: "boolean",
                    default: false
                ***REMOVED***
            ***REMOVED***,
            additionalProperties: false
        ***REMOVED***],

        messages: ***REMOVED***
            missingGetterInPropertyDescriptor: "Getter is not present in property descriptor.",
            missingSetterInPropertyDescriptor: "Setter is not present in property descriptor.",
            missingGetterInObjectLiteral: "Getter is not present for ***REMOVED******REMOVED*** name ***REMOVED******REMOVED***.",
            missingSetterInObjectLiteral: "Setter is not present for ***REMOVED******REMOVED*** name ***REMOVED******REMOVED***.",
            missingGetterInClass: "Getter is not present for class ***REMOVED******REMOVED*** name ***REMOVED******REMOVED***.",
            missingSetterInClass: "Setter is not present for class ***REMOVED******REMOVED*** name ***REMOVED******REMOVED***."
        ***REMOVED***
    ***REMOVED***,
    create(context) ***REMOVED***
        const config = context.options[0] || ***REMOVED******REMOVED***;
        const checkGetWithoutSet = config.getWithoutSet === true;
        const checkSetWithoutGet = config.setWithoutGet !== false;
        const enforceForClassMembers = config.enforceForClassMembers === true;
        const sourceCode = context.getSourceCode();

        /**
         * Reports the given node.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to report.
         * @param ***REMOVED***string***REMOVED*** messageKind "missingGetter" or "missingSetter".
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function report(node, messageKind) ***REMOVED***
            if (node.type === "Property") ***REMOVED***
                context.report(***REMOVED***
                    node,
                    messageId: `$***REMOVED***messageKind***REMOVED***InObjectLiteral`,
                    loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),
                    data: ***REMOVED*** name: astUtils.getFunctionNameWithKind(node.value) ***REMOVED***
                ***REMOVED***);
            ***REMOVED*** else if (node.type === "MethodDefinition") ***REMOVED***
                context.report(***REMOVED***
                    node,
                    messageId: `$***REMOVED***messageKind***REMOVED***InClass`,
                    loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),
                    data: ***REMOVED*** name: astUtils.getFunctionNameWithKind(node.value) ***REMOVED***
                ***REMOVED***);
            ***REMOVED*** else ***REMOVED***
                context.report(***REMOVED***
                    node,
                    messageId: `$***REMOVED***messageKind***REMOVED***InPropertyDescriptor`
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Reports each of the nodes in the given list using the same messageId.
         * @param ***REMOVED***ASTNode[]***REMOVED*** nodes Nodes to report.
         * @param ***REMOVED***string***REMOVED*** messageKind "missingGetter" or "missingSetter".
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function reportList(nodes, messageKind) ***REMOVED***
            for (const node of nodes) ***REMOVED***
                report(node, messageKind);
            ***REMOVED***
        ***REMOVED***

        /**
         * Creates a new `AccessorData` object for the given getter or setter node.
         * @param ***REMOVED***ASTNode***REMOVED*** node A getter or setter node.
         * @returns ***REMOVED***AccessorData***REMOVED*** New `AccessorData` object that contains the given node.
         * @private
         */
        function createAccessorData(node) ***REMOVED***
            const name = astUtils.getStaticPropertyName(node);
            const key = (name !== null) ? name : sourceCode.getTokens(node.key);

            return ***REMOVED***
                key,
                getters: node.kind === "get" ? [node] : [],
                setters: node.kind === "set" ? [node] : []
            ***REMOVED***;
        ***REMOVED***

        /**
         * Merges the given `AccessorData` object into the given accessors list.
         * @param ***REMOVED***AccessorData[]***REMOVED*** accessors The list to merge into.
         * @param ***REMOVED***AccessorData***REMOVED*** accessorData The object to merge.
         * @returns ***REMOVED***AccessorData[]***REMOVED*** The same instance with the merged object.
         * @private
         */
        function mergeAccessorData(accessors, accessorData) ***REMOVED***
            const equalKeyElement = accessors.find(a => areEqualKeys(a.key, accessorData.key));

            if (equalKeyElement) ***REMOVED***
                equalKeyElement.getters.push(...accessorData.getters);
                equalKeyElement.setters.push(...accessorData.setters);
            ***REMOVED*** else ***REMOVED***
                accessors.push(accessorData);
            ***REMOVED***

            return accessors;
        ***REMOVED***

        /**
         * Checks accessor pairs in the given list of nodes.
         * @param ***REMOVED***ASTNode[]***REMOVED*** nodes The list to check.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkList(nodes) ***REMOVED***
            const accessors = nodes
                .filter(isAccessorKind)
                .map(createAccessorData)
                .reduce(mergeAccessorData, []);

            for (const ***REMOVED*** getters, setters ***REMOVED*** of accessors) ***REMOVED***
                if (checkSetWithoutGet && setters.length && !getters.length) ***REMOVED***
                    reportList(setters, "missingGetter");
                ***REMOVED***
                if (checkGetWithoutSet && getters.length && !setters.length) ***REMOVED***
                    reportList(getters, "missingSetter");
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Checks accessor pairs in an object literal.
         * @param ***REMOVED***ASTNode***REMOVED*** node `ObjectExpression` node to check.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkObjectLiteral(node) ***REMOVED***
            checkList(node.properties.filter(p => p.type === "Property"));
        ***REMOVED***

        /**
         * Checks accessor pairs in a property descriptor.
         * @param ***REMOVED***ASTNode***REMOVED*** node Property descriptor `ObjectExpression` node to check.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkPropertyDescriptor(node) ***REMOVED***
            const namesToCheck = node.properties
                .filter(p => p.type === "Property" && p.kind === "init" && !p.computed)
                .map((***REMOVED*** key ***REMOVED***) => key.name);

            const hasGetter = namesToCheck.includes("get");
            const hasSetter = namesToCheck.includes("set");

            if (checkSetWithoutGet && hasSetter && !hasGetter) ***REMOVED***
                report(node, "missingGetter");
            ***REMOVED***
            if (checkGetWithoutSet && hasGetter && !hasSetter) ***REMOVED***
                report(node, "missingSetter");
            ***REMOVED***
        ***REMOVED***

        /**
         * Checks the given object expression as an object literal and as a possible property descriptor.
         * @param ***REMOVED***ASTNode***REMOVED*** node `ObjectExpression` node to check.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkObjectExpression(node) ***REMOVED***
            checkObjectLiteral(node);
            if (isPropertyDescriptor(node)) ***REMOVED***
                checkPropertyDescriptor(node);
            ***REMOVED***
        ***REMOVED***

        /**
         * Checks the given class body.
         * @param ***REMOVED***ASTNode***REMOVED*** node `ClassBody` node to check.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkClassBody(node) ***REMOVED***
            const methodDefinitions = node.body.filter(m => m.type === "MethodDefinition");

            checkList(methodDefinitions.filter(m => m.static));
            checkList(methodDefinitions.filter(m => !m.static));
        ***REMOVED***

        const listeners = ***REMOVED******REMOVED***;

        if (checkSetWithoutGet || checkGetWithoutSet) ***REMOVED***
            listeners.ObjectExpression = checkObjectExpression;
            if (enforceForClassMembers) ***REMOVED***
                listeners.ClassBody = checkClassBody;
            ***REMOVED***
        ***REMOVED***

        return listeners;
    ***REMOVED***
***REMOVED***;
