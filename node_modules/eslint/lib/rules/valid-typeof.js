/**
 * @fileoverview Ensures that the results of typeof are compared against a valid string
 * @author Ian Christian Myers
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "problem",

        docs: ***REMOVED***
            description: "enforce comparing `typeof` expressions against valid strings",
            category: "Possible Errors",
            recommended: true,
            url: "https://eslint.org/docs/rules/valid-typeof"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    requireStringLiterals: ***REMOVED***
                        type: "boolean",
                        default: false
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],
        messages: ***REMOVED***
            invalidValue: "Invalid typeof comparison value.",
            notString: "Typeof comparisons should be to string literals."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        const VALID_TYPES = ["symbol", "undefined", "object", "boolean", "number", "string", "function", "bigint"],
            OPERATORS = ["==", "===", "!=", "!=="];

        const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;

        /**
         * Determines whether a node is a typeof expression.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a typeof expression
         */
        function isTypeofExpression(node) ***REMOVED***
            return node.type === "UnaryExpression" && node.operator === "typeof";
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***

            UnaryExpression(node) ***REMOVED***
                if (isTypeofExpression(node)) ***REMOVED***
                    const parent = context.getAncestors().pop();

                    if (parent.type === "BinaryExpression" && OPERATORS.indexOf(parent.operator) !== -1) ***REMOVED***
                        const sibling = parent.left === node ? parent.right : parent.left;

                        if (sibling.type === "Literal" || sibling.type === "TemplateLiteral" && !sibling.expressions.length) ***REMOVED***
                            const value = sibling.type === "Literal" ? sibling.value : sibling.quasis[0].value.cooked;

                            if (VALID_TYPES.indexOf(value) === -1) ***REMOVED***
                                context.report(***REMOVED*** node: sibling, messageId: "invalidValue" ***REMOVED***);
                            ***REMOVED***
                        ***REMOVED*** else if (requireStringLiterals && !isTypeofExpression(sibling)) ***REMOVED***
                            context.report(***REMOVED*** node: sibling, messageId: "notString" ***REMOVED***);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***

        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
