/**
 * @fileoverview A rule to set the maximum number of line of code in a function.
 * @author Pete Ward <peteward44@gmail.com>
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

const lodash = require("lodash");

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const OPTIONS_SCHEMA = ***REMOVED***
    type: "object",
    properties: ***REMOVED***
        max: ***REMOVED***
            type: "integer",
            minimum: 0
        ***REMOVED***,
        skipComments: ***REMOVED***
            type: "boolean"
        ***REMOVED***,
        skipBlankLines: ***REMOVED***
            type: "boolean"
        ***REMOVED***,
        IIFEs: ***REMOVED***
            type: "boolean"
        ***REMOVED***
    ***REMOVED***,
    additionalProperties: false
***REMOVED***;

const OPTIONS_OR_INTEGER_SCHEMA = ***REMOVED***
    oneOf: [
        OPTIONS_SCHEMA,
        ***REMOVED***
            type: "integer",
            minimum: 1
        ***REMOVED***
    ]
***REMOVED***;

/**
 * Given a list of comment nodes, return a map with numeric keys (source code line numbers) and comment token values.
 * @param ***REMOVED***Array***REMOVED*** comments An array of comment nodes.
 * @returns ***REMOVED***Map.<string,Node>***REMOVED*** A map with numeric keys (source code line numbers) and comment token values.
 */
function getCommentLineNumbers(comments) ***REMOVED***
    const map = new Map();

    if (!comments) ***REMOVED***
        return map;
    ***REMOVED***
    comments.forEach(comment => ***REMOVED***
        for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) ***REMOVED***
            map.set(i, comment);
        ***REMOVED***
    ***REMOVED***);
    return map;
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "enforce a maximum number of line of code in a function",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/max-lines-per-function"
        ***REMOVED***,

        schema: [
            OPTIONS_OR_INTEGER_SCHEMA
        ],
        messages: ***REMOVED***
            exceed: "***REMOVED******REMOVED***name***REMOVED******REMOVED*** has too many lines (***REMOVED******REMOVED***lineCount***REMOVED******REMOVED***). Maximum allowed is ***REMOVED******REMOVED***maxLines***REMOVED******REMOVED***."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();
        const lines = sourceCode.lines;

        const option = context.options[0];
        let maxLines = 50;
        let skipComments = false;
        let skipBlankLines = false;
        let IIFEs = false;

        if (typeof option === "object") ***REMOVED***
            maxLines = typeof option.max === "number" ? option.max : 50;
            skipComments = !!option.skipComments;
            skipBlankLines = !!option.skipBlankLines;
            IIFEs = !!option.IIFEs;
        ***REMOVED*** else if (typeof option === "number") ***REMOVED***
            maxLines = option;
        ***REMOVED***

        const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Tells if a comment encompasses the entire line.
         * @param ***REMOVED***string***REMOVED*** line The source line with a trailing comment
         * @param ***REMOVED***number***REMOVED*** lineNumber The one-indexed line number this is on
         * @param ***REMOVED***ASTNode***REMOVED*** comment The comment to remove
         * @returns ***REMOVED***boolean***REMOVED*** If the comment covers the entire line
         */
        function isFullLineComment(line, lineNumber, comment) ***REMOVED***
            const start = comment.loc.start,
                end = comment.loc.end,
                isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(),
                isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();

            return comment &&
                (start.line < lineNumber || isFirstTokenOnLine) &&
                (end.line > lineNumber || isLastTokenOnLine);
        ***REMOVED***

        /**
         * Identifies is a node is a FunctionExpression which is part of an IIFE
         * @param ***REMOVED***ASTNode***REMOVED*** node Node to test
         * @returns ***REMOVED***boolean***REMOVED*** True if it's an IIFE
         */
        function isIIFE(node) ***REMOVED***
            return node.type === "FunctionExpression" && node.parent && node.parent.type === "CallExpression" && node.parent.callee === node;
        ***REMOVED***

        /**
         * Identifies is a node is a FunctionExpression which is embedded within a MethodDefinition or Property
         * @param ***REMOVED***ASTNode***REMOVED*** node Node to test
         * @returns ***REMOVED***boolean***REMOVED*** True if it's a FunctionExpression embedded within a MethodDefinition or Property
         */
        function isEmbedded(node) ***REMOVED***
            if (!node.parent) ***REMOVED***
                return false;
            ***REMOVED***
            if (node !== node.parent.value) ***REMOVED***
                return false;
            ***REMOVED***
            if (node.parent.type === "MethodDefinition") ***REMOVED***
                return true;
            ***REMOVED***
            if (node.parent.type === "Property") ***REMOVED***
                return node.parent.method === true || node.parent.kind === "get" || node.parent.kind === "set";
            ***REMOVED***
            return false;
        ***REMOVED***

        /**
         * Count the lines in the function
         * @param ***REMOVED***ASTNode***REMOVED*** funcNode Function AST node
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function processFunction(funcNode) ***REMOVED***
            const node = isEmbedded(funcNode) ? funcNode.parent : funcNode;

            if (!IIFEs && isIIFE(node)) ***REMOVED***
                return;
            ***REMOVED***
            let lineCount = 0;

            for (let i = node.loc.start.line - 1; i < node.loc.end.line; ++i) ***REMOVED***
                const line = lines[i];

                if (skipComments) ***REMOVED***
                    if (commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) ***REMOVED***
                        continue;
                    ***REMOVED***
                ***REMOVED***

                if (skipBlankLines) ***REMOVED***
                    if (line.match(/^\s*$/u)) ***REMOVED***
                        continue;
                    ***REMOVED***
                ***REMOVED***

                lineCount++;
            ***REMOVED***

            if (lineCount > maxLines) ***REMOVED***
                const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(funcNode));

                context.report(***REMOVED***
                    node,
                    messageId: "exceed",
                    data: ***REMOVED*** name, lineCount, maxLines ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public API
        //--------------------------------------------------------------------------

        return ***REMOVED***
            FunctionDeclaration: processFunction,
            FunctionExpression: processFunction,
            ArrowFunctionExpression: processFunction
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
