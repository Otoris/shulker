/**
 * @fileoverview Rule to flag assignment in a conditional statement's test expression
 * @author Stephen Murray <spmurrayzzz>
 */
"use strict";

const astUtils = require("./utils/ast-utils");

const NODE_DESCRIPTIONS = ***REMOVED***
    DoWhileStatement: "a 'do...while' statement",
    ForStatement: "a 'for' statement",
    IfStatement: "an 'if' statement",
    WhileStatement: "a 'while' statement"
***REMOVED***;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "problem",

        docs: ***REMOVED***
            description: "disallow assignment operators in conditional expressions",
            category: "Possible Errors",
            recommended: true,
            url: "https://eslint.org/docs/rules/no-cond-assign"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                enum: ["except-parens", "always"]
            ***REMOVED***
        ],

        messages: ***REMOVED***
            unexpected: "Unexpected assignment within ***REMOVED******REMOVED***type***REMOVED******REMOVED***.",

            // must match JSHint's error message
            missing: "Expected a conditional expression and instead saw an assignment."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        const prohibitAssign = (context.options[0] || "except-parens");

        const sourceCode = context.getSourceCode();

        /**
         * Check whether an AST node is the test expression for a conditional statement.
         * @param ***REMOVED***!Object***REMOVED*** node The node to test.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is the text expression for a conditional statement; otherwise, `false`.
         */
        function isConditionalTestExpression(node) ***REMOVED***
            return node.parent &&
                node.parent.test &&
                node === node.parent.test;
        ***REMOVED***

        /**
         * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.
         * @param ***REMOVED***!Object***REMOVED*** node The node to use at the start of the search.
         * @returns ***REMOVED***?Object***REMOVED*** The closest ancestor node that represents a conditional statement.
         */
        function findConditionalAncestor(node) ***REMOVED***
            let currentAncestor = node;

            do ***REMOVED***
                if (isConditionalTestExpression(currentAncestor)) ***REMOVED***
                    return currentAncestor.parent;
                ***REMOVED***
            ***REMOVED*** while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));

            return null;
        ***REMOVED***

        /**
         * Check whether the code represented by an AST node is enclosed in two sets of parentheses.
         * @param ***REMOVED***!Object***REMOVED*** node The node to test.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.
         */
        function isParenthesisedTwice(node) ***REMOVED***
            const previousToken = sourceCode.getTokenBefore(node, 1),
                nextToken = sourceCode.getTokenAfter(node, 1);

            return astUtils.isParenthesised(sourceCode, node) &&
                previousToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] &&
                astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
        ***REMOVED***

        /**
         * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.
         * @param ***REMOVED***!Object***REMOVED*** node The node for the conditional statement.
         * @returns ***REMOVED***void***REMOVED***
         */
        function testForAssign(node) ***REMOVED***
            if (node.test &&
                (node.test.type === "AssignmentExpression") &&
                (node.type === "ForStatement"
                    ? !astUtils.isParenthesised(sourceCode, node.test)
                    : !isParenthesisedTwice(node.test)
                )
            ) ***REMOVED***

                context.report(***REMOVED***
                    node,
                    loc: node.test.loc.start,
                    messageId: "missing"
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Check whether an assignment expression is descended from a conditional statement's test expression.
         * @param ***REMOVED***!Object***REMOVED*** node The node for the assignment expression.
         * @returns ***REMOVED***void***REMOVED***
         */
        function testForConditionalAncestor(node) ***REMOVED***
            const ancestor = findConditionalAncestor(node);

            if (ancestor) ***REMOVED***
                context.report(***REMOVED***
                    node: ancestor,
                    messageId: "unexpected",
                    data: ***REMOVED***
                        type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        if (prohibitAssign === "always") ***REMOVED***
            return ***REMOVED***
                AssignmentExpression: testForConditionalAncestor
            ***REMOVED***;
        ***REMOVED***

        return ***REMOVED***
            DoWhileStatement: testForAssign,
            ForStatement: testForAssign,
            IfStatement: testForAssign,
            WhileStatement: testForAssign,
            ConditionalExpression: testForAssign
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
