/**
 * @fileoverview Require or disallow newlines around directives.
 * @author Kai Cataldo
 * @deprecated
 */

"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "require or disallow newlines around directives",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/lines-around-directive"
        ***REMOVED***,

        schema: [***REMOVED***
            oneOf: [
                ***REMOVED***
                    enum: ["always", "never"]
                ***REMOVED***,
                ***REMOVED***
                    type: "object",
                    properties: ***REMOVED***
                        before: ***REMOVED***
                            enum: ["always", "never"]
                        ***REMOVED***,
                        after: ***REMOVED***
                            enum: ["always", "never"]
                        ***REMOVED***
                    ***REMOVED***,
                    additionalProperties: false,
                    minProperties: 2
                ***REMOVED***
            ]
        ***REMOVED***],

        fixable: "whitespace",
        messages: ***REMOVED***
            expected: "Expected newline ***REMOVED******REMOVED***location***REMOVED******REMOVED*** \"***REMOVED******REMOVED***value***REMOVED******REMOVED***\" directive.",
            unexpected: "Unexpected newline ***REMOVED******REMOVED***location***REMOVED******REMOVED*** \"***REMOVED******REMOVED***value***REMOVED******REMOVED***\" directive."
        ***REMOVED***,
        deprecated: true,
        replacedBy: ["padding-line-between-statements"]
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();
        const config = context.options[0] || "always";
        const expectLineBefore = typeof config === "string" ? config : config.before;
        const expectLineAfter = typeof config === "string" ? config : config.after;

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Check if node is preceded by a blank newline.
         * @param ***REMOVED***ASTNode***REMOVED*** node Node to check.
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not the passed in node is preceded by a blank newline.
         */
        function hasNewlineBefore(node) ***REMOVED***
            const tokenBefore = sourceCode.getTokenBefore(node, ***REMOVED*** includeComments: true ***REMOVED***);
            const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;

            return node.loc.start.line - tokenLineBefore >= 2;
        ***REMOVED***

        /**
         * Gets the last token of a node that is on the same line as the rest of the node.
         * This will usually be the last token of the node, but it will be the second-to-last token if the node has a trailing
         * semicolon on a different line.
         * @param ***REMOVED***ASTNode***REMOVED*** node A directive node
         * @returns ***REMOVED***Token***REMOVED*** The last token of the node on the line
         */
        function getLastTokenOnLine(node) ***REMOVED***
            const lastToken = sourceCode.getLastToken(node);
            const secondToLastToken = sourceCode.getTokenBefore(lastToken);

            return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line
                ? secondToLastToken
                : lastToken;
        ***REMOVED***

        /**
         * Check if node is followed by a blank newline.
         * @param ***REMOVED***ASTNode***REMOVED*** node Node to check.
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not the passed in node is followed by a blank newline.
         */
        function hasNewlineAfter(node) ***REMOVED***
            const lastToken = getLastTokenOnLine(node);
            const tokenAfter = sourceCode.getTokenAfter(lastToken, ***REMOVED*** includeComments: true ***REMOVED***);

            return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;
        ***REMOVED***

        /**
         * Report errors for newlines around directives.
         * @param ***REMOVED***ASTNode***REMOVED*** node Node to check.
         * @param ***REMOVED***string***REMOVED*** location Whether the error was found before or after the directive.
         * @param ***REMOVED***boolean***REMOVED*** expected Whether or not a newline was expected or unexpected.
         * @returns ***REMOVED***void***REMOVED***
         */
        function reportError(node, location, expected) ***REMOVED***
            context.report(***REMOVED***
                node,
                messageId: expected ? "expected" : "unexpected",
                data: ***REMOVED***
                    value: node.expression.value,
                    location
                ***REMOVED***,
                fix(fixer) ***REMOVED***
                    const lastToken = getLastTokenOnLine(node);

                    if (expected) ***REMOVED***
                        return location === "before" ? fixer.insertTextBefore(node, "\n") : fixer.insertTextAfter(lastToken, "\n");
                    ***REMOVED***
                    return fixer.removeRange(location === "before" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        /**
         * Check lines around directives in node
         * @param ***REMOVED***ASTNode***REMOVED*** node - node to check
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkDirectives(node) ***REMOVED***
            const directives = astUtils.getDirectivePrologue(node);

            if (!directives.length) ***REMOVED***
                return;
            ***REMOVED***

            const firstDirective = directives[0];
            const leadingComments = sourceCode.getCommentsBefore(firstDirective);

            /*
             * Only check before the first directive if it is preceded by a comment or if it is at the top of
             * the file and expectLineBefore is set to "never". This is to not force a newline at the top of
             * the file if there are no comments as well as for compatibility with padded-blocks.
             */
            if (leadingComments.length) ***REMOVED***
                if (expectLineBefore === "always" && !hasNewlineBefore(firstDirective)) ***REMOVED***
                    reportError(firstDirective, "before", true);
                ***REMOVED***

                if (expectLineBefore === "never" && hasNewlineBefore(firstDirective)) ***REMOVED***
                    reportError(firstDirective, "before", false);
                ***REMOVED***
            ***REMOVED*** else if (
                node.type === "Program" &&
                expectLineBefore === "never" &&
                !leadingComments.length &&
                hasNewlineBefore(firstDirective)
            ) ***REMOVED***
                reportError(firstDirective, "before", false);
            ***REMOVED***

            const lastDirective = directives[directives.length - 1];
            const statements = node.type === "Program" ? node.body : node.body.body;

            /*
             * Do not check after the last directive if the body only
             * contains a directive prologue and isn't followed by a comment to ensure
             * this rule behaves well with padded-blocks.
             */
            if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) ***REMOVED***
                return;
            ***REMOVED***

            if (expectLineAfter === "always" && !hasNewlineAfter(lastDirective)) ***REMOVED***
                reportError(lastDirective, "after", true);
            ***REMOVED***

            if (expectLineAfter === "never" && hasNewlineAfter(lastDirective)) ***REMOVED***
                reportError(lastDirective, "after", false);
            ***REMOVED***
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***
            Program: checkDirectives,
            FunctionDeclaration: checkDirectives,
            FunctionExpression: checkDirectives,
            ArrowFunctionExpression: checkDirectives
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
