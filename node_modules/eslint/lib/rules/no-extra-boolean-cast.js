/**
 * @fileoverview Rule to flag unnecessary double negation in Boolean contexts
 * @author Brandon Mills
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow unnecessary boolean casts",
            category: "Possible Errors",
            recommended: true,
            url: "https://eslint.org/docs/rules/no-extra-boolean-cast"
        ***REMOVED***,

        schema: [],
        fixable: "code",

        messages: ***REMOVED***
            unexpectedCall: "Redundant Boolean call.",
            unexpectedNegation: "Redundant double negation."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();

        // Node types which have a test which will coerce values to booleans.
        const BOOLEAN_NODE_TYPES = [
            "IfStatement",
            "DoWhileStatement",
            "WhileStatement",
            "ConditionalExpression",
            "ForStatement"
        ];

        /**
         * Check if a node is in a context where its value would be coerced to a boolean at runtime.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node The node
         * @param ***REMOVED***ASTNode***REMOVED*** parent Its parent
         * @returns ***REMOVED***boolean***REMOVED*** If it is in a boolean context
         */
        function isInBooleanContext(node, parent) ***REMOVED***
            return (
                (BOOLEAN_NODE_TYPES.indexOf(parent.type) !== -1 &&
                    node === parent.test) ||

                // !<bool>
                (parent.type === "UnaryExpression" &&
                    parent.operator === "!")
            );
        ***REMOVED***

        /**
         * Check if a node has comments inside.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if it has comments inside.
         */
        function hasCommentsInside(node) ***REMOVED***
            return Boolean(sourceCode.getCommentsInside(node).length);
        ***REMOVED***

        return ***REMOVED***
            UnaryExpression(node) ***REMOVED***
                const ancestors = context.getAncestors(),
                    parent = ancestors.pop(),
                    grandparent = ancestors.pop();

                // Exit early if it's guaranteed not to match
                if (node.operator !== "!" ||
                        parent.type !== "UnaryExpression" ||
                        parent.operator !== "!") ***REMOVED***
                    return;
                ***REMOVED***

                if (isInBooleanContext(parent, grandparent) ||

                    // Boolean(<bool>) and new Boolean(<bool>)
                    ((grandparent.type === "CallExpression" || grandparent.type === "NewExpression") &&
                        grandparent.callee.type === "Identifier" &&
                        grandparent.callee.name === "Boolean")
                ) ***REMOVED***
                    context.report(***REMOVED***
                        node: parent,
                        messageId: "unexpectedNegation",
                        fix: fixer => ***REMOVED***
                            if (hasCommentsInside(parent)) ***REMOVED***
                                return null;
                            ***REMOVED***

                            let prefix = "";
                            const tokenBefore = sourceCode.getTokenBefore(parent);
                            const firstReplacementToken = sourceCode.getFirstToken(node.argument);

                            if (tokenBefore && tokenBefore.range[1] === parent.range[0] &&
                                    !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) ***REMOVED***
                                prefix = " ";
                            ***REMOVED***

                            return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***,
            CallExpression(node) ***REMOVED***
                const parent = node.parent;

                if (node.callee.type !== "Identifier" || node.callee.name !== "Boolean") ***REMOVED***
                    return;
                ***REMOVED***

                if (isInBooleanContext(node, parent)) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        messageId: "unexpectedCall",
                        fix: fixer => ***REMOVED***
                            if (!node.arguments.length) ***REMOVED***
                                if (parent.type === "UnaryExpression" && parent.operator === "!") ***REMOVED***

                                    // !Boolean() -> true

                                    if (hasCommentsInside(parent)) ***REMOVED***
                                        return null;
                                    ***REMOVED***

                                    const replacement = "true";
                                    let prefix = "";
                                    const tokenBefore = sourceCode.getTokenBefore(parent);

                                    if (tokenBefore && tokenBefore.range[1] === parent.range[0] &&
                                            !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) ***REMOVED***
                                        prefix = " ";
                                    ***REMOVED***

                                    return fixer.replaceText(parent, prefix + replacement);
                                ***REMOVED***

                                // Boolean() -> false
                                if (hasCommentsInside(node)) ***REMOVED***
                                    return null;
                                ***REMOVED***
                                return fixer.replaceText(node, "false");
                            ***REMOVED***

                            if (node.arguments.length > 1 || node.arguments[0].type === "SpreadElement" ||
                                    hasCommentsInside(node)) ***REMOVED***
                                return null;
                            ***REMOVED***

                            const argument = node.arguments[0];

                            if (astUtils.getPrecedence(argument) < astUtils.getPrecedence(node.parent)) ***REMOVED***
                                return fixer.replaceText(node, `($***REMOVED***sourceCode.getText(argument)***REMOVED***)`);
                            ***REMOVED***
                            return fixer.replaceText(node, sourceCode.getText(argument));
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
