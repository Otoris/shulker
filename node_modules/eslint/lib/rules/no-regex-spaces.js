/**
 * @fileoverview Rule to count multiple spaces in regular expressions
 * @author Matt DuVall <http://www.mattduvall.com/>
 */

"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow multiple spaces in regular expressions",
            category: "Possible Errors",
            recommended: true,
            url: "https://eslint.org/docs/rules/no-regex-spaces"
        ***REMOVED***,

        schema: [],
        fixable: "code"
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();

        /**
         * Validate regular expressions
         * @param ***REMOVED***ASTNode***REMOVED*** node node to validate
         * @param ***REMOVED***string***REMOVED*** value regular expression to validate
         * @param ***REMOVED***number***REMOVED*** valueStart The start location of the regex/string literal. It will always be the case that
         * `sourceCode.getText().slice(valueStart, valueStart + value.length) === value`
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkRegex(node, value, valueStart) ***REMOVED***
            const multipleSpacesRegex = /( ***REMOVED***2,***REMOVED***)( [+****REMOVED***?]|[^+****REMOVED***?]|$)/u,
                regexResults = multipleSpacesRegex.exec(value);

            if (regexResults !== null) ***REMOVED***
                const count = regexResults[1].length;

                context.report(***REMOVED***
                    node,
                    message: "Spaces are hard to count. Use ***REMOVED******REMOVED******REMOVED***count***REMOVED******REMOVED******REMOVED***.",
                    data: ***REMOVED*** count ***REMOVED***,
                    fix(fixer) ***REMOVED***
                        return fixer.replaceTextRange(
                            [valueStart + regexResults.index, valueStart + regexResults.index + count],
                            ` ***REMOVED***$***REMOVED***count***REMOVED******REMOVED***`
                        );
                    ***REMOVED***
                ***REMOVED***);

                /*
                 * TODO: (platinumazure) Fix message to use rule message
                 * substitution when api.report is fixed in lib/eslint.js.
                 */
            ***REMOVED***
        ***REMOVED***

        /**
         * Validate regular expression literals
         * @param ***REMOVED***ASTNode***REMOVED*** node node to validate
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkLiteral(node) ***REMOVED***
            const token = sourceCode.getFirstToken(node),
                nodeType = token.type,
                nodeValue = token.value;

            if (nodeType === "RegularExpression") ***REMOVED***
                checkRegex(node, nodeValue, token.range[0]);
            ***REMOVED***
        ***REMOVED***

        /**
         * Check if node is a string
         * @param ***REMOVED***ASTNode***REMOVED*** node node to evaluate
         * @returns ***REMOVED***boolean***REMOVED*** True if its a string
         * @private
         */
        function isString(node) ***REMOVED***
            return node && node.type === "Literal" && typeof node.value === "string";
        ***REMOVED***

        /**
         * Validate strings passed to the RegExp constructor
         * @param ***REMOVED***ASTNode***REMOVED*** node node to validate
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkFunction(node) ***REMOVED***
            const scope = context.getScope();
            const regExpVar = astUtils.getVariableByName(scope, "RegExp");
            const shadowed = regExpVar && regExpVar.defs.length > 0;

            if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(node.arguments[0]) && !shadowed) ***REMOVED***
                checkRegex(node, node.arguments[0].value, node.arguments[0].range[0] + 1);
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            Literal: checkLiteral,
            CallExpression: checkFunction,
            NewExpression: checkFunction
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
