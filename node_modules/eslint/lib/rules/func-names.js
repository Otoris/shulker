/**
 * @fileoverview Rule to warn when a function expression does not have a name.
 * @author Kyle T. Nunery
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

/**
 * Checks whether or not a given variable is a function name.
 * @param ***REMOVED***eslint-scope.Variable***REMOVED*** variable - A variable to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the variable is a function name.
 */
function isFunctionName(variable) ***REMOVED***
    return variable && variable.defs[0].type === "FunctionName";
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "require or disallow named `function` expressions",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/func-names"
        ***REMOVED***,

        schema: ***REMOVED***
            definitions: ***REMOVED***
                value: ***REMOVED***
                    enum: [
                        "always",
                        "as-needed",
                        "never"
                    ]
                ***REMOVED***
            ***REMOVED***,
            items: [
                ***REMOVED***
                    $ref: "#/definitions/value"
                ***REMOVED***,
                ***REMOVED***
                    type: "object",
                    properties: ***REMOVED***
                        generators: ***REMOVED***
                            $ref: "#/definitions/value"
                        ***REMOVED***
                    ***REMOVED***,
                    additionalProperties: false
                ***REMOVED***
            ]
        ***REMOVED***,

        messages: ***REMOVED***
            unnamed: "Unexpected unnamed ***REMOVED******REMOVED***name***REMOVED******REMOVED***.",
            named: "Unexpected named ***REMOVED******REMOVED***name***REMOVED******REMOVED***."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        const sourceCode = context.getSourceCode();

        /**
         * Returns the config option for the given node.
         * @param ***REMOVED***ASTNode***REMOVED*** node - A node to get the config for.
         * @returns ***REMOVED***string***REMOVED*** The config option.
         */
        function getConfigForNode(node) ***REMOVED***
            if (
                node.generator &&
                context.options.length > 1 &&
                context.options[1].generators
            ) ***REMOVED***
                return context.options[1].generators;
            ***REMOVED***

            return context.options[0] || "always";
        ***REMOVED***

        /**
         * Determines whether the current FunctionExpression node is a get, set, or
         * shorthand method in an object literal or a class.
         * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is a get, set, or shorthand method.
         */
        function isObjectOrClassMethod(node) ***REMOVED***
            const parent = node.parent;

            return (parent.type === "MethodDefinition" || (
                parent.type === "Property" && (
                    parent.method ||
                    parent.kind === "get" ||
                    parent.kind === "set"
                )
            ));
        ***REMOVED***

        /**
         * Determines whether the current FunctionExpression node has a name that would be
         * inferred from context in a conforming ES6 environment.
         * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node would have a name assigned automatically.
         */
        function hasInferredName(node) ***REMOVED***
            const parent = node.parent;

            return isObjectOrClassMethod(node) ||
                (parent.type === "VariableDeclarator" && parent.id.type === "Identifier" && parent.init === node) ||
                (parent.type === "Property" && parent.value === node) ||
                (parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node) ||
                (parent.type === "ExportDefaultDeclaration" && parent.declaration === node) ||
                (parent.type === "AssignmentPattern" && parent.right === node);
        ***REMOVED***

        /**
         * Reports that an unnamed function should be named
         * @param ***REMOVED***ASTNode***REMOVED*** node - The node to report in the event of an error.
         * @returns ***REMOVED***void***REMOVED***
         */
        function reportUnexpectedUnnamedFunction(node) ***REMOVED***
            context.report(***REMOVED***
                node,
                messageId: "unnamed",
                loc: astUtils.getFunctionHeadLoc(node, sourceCode),
                data: ***REMOVED*** name: astUtils.getFunctionNameWithKind(node) ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        /**
         * Reports that a named function should be unnamed
         * @param ***REMOVED***ASTNode***REMOVED*** node - The node to report in the event of an error.
         * @returns ***REMOVED***void***REMOVED***
         */
        function reportUnexpectedNamedFunction(node) ***REMOVED***
            context.report(***REMOVED***
                node,
                messageId: "named",
                loc: astUtils.getFunctionHeadLoc(node, sourceCode),
                data: ***REMOVED*** name: astUtils.getFunctionNameWithKind(node) ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        return ***REMOVED***
            "FunctionExpression:exit"(node) ***REMOVED***

                // Skip recursive functions.
                const nameVar = context.getDeclaredVariables(node)[0];

                if (isFunctionName(nameVar) && nameVar.references.length > 0) ***REMOVED***
                    return;
                ***REMOVED***

                const hasName = Boolean(node.id && node.id.name);
                const config = getConfigForNode(node);

                if (config === "never") ***REMOVED***
                    if (hasName) ***REMOVED***
                        reportUnexpectedNamedFunction(node);
                    ***REMOVED***
                ***REMOVED*** else if (config === "as-needed") ***REMOVED***
                    if (!hasName && !hasInferredName(node)) ***REMOVED***
                        reportUnexpectedUnnamedFunction(node);
                    ***REMOVED***
                ***REMOVED*** else ***REMOVED***
                    if (!hasName && !isObjectOrClassMethod(node)) ***REMOVED***
                        reportUnexpectedUnnamedFunction(node);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
