/**
 * @fileoverview A rule to ensure blank lines within blocks.
 * @author Mathias Schreck <https://github.com/lo1tuma>
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "require or disallow padding within blocks",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/padded-blocks"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            ***REMOVED***
                oneOf: [
                    ***REMOVED***
                        enum: ["always", "never"]
                    ***REMOVED***,
                    ***REMOVED***
                        type: "object",
                        properties: ***REMOVED***
                            blocks: ***REMOVED***
                                enum: ["always", "never"]
                            ***REMOVED***,
                            switches: ***REMOVED***
                                enum: ["always", "never"]
                            ***REMOVED***,
                            classes: ***REMOVED***
                                enum: ["always", "never"]
                            ***REMOVED***
                        ***REMOVED***,
                        additionalProperties: false,
                        minProperties: 1
                    ***REMOVED***
                ]
            ***REMOVED***,
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    allowSingleLineBlocks: ***REMOVED***
                        type: "boolean"
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***
        const options = ***REMOVED******REMOVED***;
        const typeOptions = context.options[0] || "always";
        const exceptOptions = context.options[1] || ***REMOVED******REMOVED***;

        if (typeof typeOptions === "string") ***REMOVED***
            const shouldHavePadding = typeOptions === "always";

            options.blocks = shouldHavePadding;
            options.switches = shouldHavePadding;
            options.classes = shouldHavePadding;
        ***REMOVED*** else ***REMOVED***
            if (Object.prototype.hasOwnProperty.call(typeOptions, "blocks")) ***REMOVED***
                options.blocks = typeOptions.blocks === "always";
            ***REMOVED***
            if (Object.prototype.hasOwnProperty.call(typeOptions, "switches")) ***REMOVED***
                options.switches = typeOptions.switches === "always";
            ***REMOVED***
            if (Object.prototype.hasOwnProperty.call(typeOptions, "classes")) ***REMOVED***
                options.classes = typeOptions.classes === "always";
            ***REMOVED***
        ***REMOVED***

        if (Object.prototype.hasOwnProperty.call(exceptOptions, "allowSingleLineBlocks")) ***REMOVED***
            options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;
        ***REMOVED***

        const ALWAYS_MESSAGE = "Block must be padded by blank lines.",
            NEVER_MESSAGE = "Block must not be padded by blank lines.";

        const sourceCode = context.getSourceCode();

        /**
         * Gets the open brace token from a given node.
         * @param ***REMOVED***ASTNode***REMOVED*** node - A BlockStatement or SwitchStatement node from which to get the open brace.
         * @returns ***REMOVED***Token***REMOVED*** The token of the open brace.
         */
        function getOpenBrace(node) ***REMOVED***
            if (node.type === "SwitchStatement") ***REMOVED***
                return sourceCode.getTokenBefore(node.cases[0]);
            ***REMOVED***
            return sourceCode.getFirstToken(node);
        ***REMOVED***

        /**
         * Checks if the given parameter is a comment node
         * @param ***REMOVED***ASTNode|Token***REMOVED*** node An AST node or token
         * @returns ***REMOVED***boolean***REMOVED*** True if node is a comment
         */
        function isComment(node) ***REMOVED***
            return node.type === "Line" || node.type === "Block";
        ***REMOVED***

        /**
         * Checks if there is padding between two tokens
         * @param ***REMOVED***Token***REMOVED*** first The first token
         * @param ***REMOVED***Token***REMOVED*** second The second token
         * @returns ***REMOVED***boolean***REMOVED*** True if there is at least a line between the tokens
         */
        function isPaddingBetweenTokens(first, second) ***REMOVED***
            return second.loc.start.line - first.loc.end.line >= 2;
        ***REMOVED***


        /**
         * Checks if the given token has a blank line after it.
         * @param ***REMOVED***Token***REMOVED*** token The token to check.
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not the token is followed by a blank line.
         */
        function getFirstBlockToken(token) ***REMOVED***
            let prev,
                first = token;

            do ***REMOVED***
                prev = first;
                first = sourceCode.getTokenAfter(first, ***REMOVED*** includeComments: true ***REMOVED***);
            ***REMOVED*** while (isComment(first) && first.loc.start.line === prev.loc.end.line);

            return first;
        ***REMOVED***

        /**
         * Checks if the given token is preceeded by a blank line.
         * @param ***REMOVED***Token***REMOVED*** token The token to check
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not the token is preceeded by a blank line
         */
        function getLastBlockToken(token) ***REMOVED***
            let last = token,
                next;

            do ***REMOVED***
                next = last;
                last = sourceCode.getTokenBefore(last, ***REMOVED*** includeComments: true ***REMOVED***);
            ***REMOVED*** while (isComment(last) && last.loc.end.line === next.loc.start.line);

            return last;
        ***REMOVED***

        /**
         * Checks if a node should be padded, according to the rule config.
         * @param ***REMOVED***ASTNode***REMOVED*** node The AST node to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node should be padded, false otherwise.
         */
        function requirePaddingFor(node) ***REMOVED***
            switch (node.type) ***REMOVED***
                case "BlockStatement":
                    return options.blocks;
                case "SwitchStatement":
                    return options.switches;
                case "ClassBody":
                    return options.classes;

                /* istanbul ignore next */
                default:
                    throw new Error("unreachable");
            ***REMOVED***
        ***REMOVED***

        /**
         * Checks the given BlockStatement node to be padded if the block is not empty.
         * @param ***REMOVED***ASTNode***REMOVED*** node The AST node of a BlockStatement.
         * @returns ***REMOVED***void***REMOVED*** undefined.
         */
        function checkPadding(node) ***REMOVED***
            const openBrace = getOpenBrace(node),
                firstBlockToken = getFirstBlockToken(openBrace),
                tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, ***REMOVED*** includeComments: true ***REMOVED***),
                closeBrace = sourceCode.getLastToken(node),
                lastBlockToken = getLastBlockToken(closeBrace),
                tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, ***REMOVED*** includeComments: true ***REMOVED***),
                blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken),
                blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);

            if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) ***REMOVED***
                return;
            ***REMOVED***

            if (requirePaddingFor(node)) ***REMOVED***
                if (!blockHasTopPadding) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        loc: ***REMOVED*** line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column ***REMOVED***,
                        fix(fixer) ***REMOVED***
                            return fixer.insertTextAfter(tokenBeforeFirst, "\n");
                        ***REMOVED***,
                        message: ALWAYS_MESSAGE
                    ***REMOVED***);
                ***REMOVED***
                if (!blockHasBottomPadding) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        loc: ***REMOVED*** line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 ***REMOVED***,
                        fix(fixer) ***REMOVED***
                            return fixer.insertTextBefore(tokenAfterLast, "\n");
                        ***REMOVED***,
                        message: ALWAYS_MESSAGE
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED*** else ***REMOVED***
                if (blockHasTopPadding) ***REMOVED***

                    context.report(***REMOVED***
                        node,
                        loc: ***REMOVED*** line: tokenBeforeFirst.loc.start.line, column: tokenBeforeFirst.loc.start.column ***REMOVED***,
                        fix(fixer) ***REMOVED***
                            return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], "\n");
                        ***REMOVED***,
                        message: NEVER_MESSAGE
                    ***REMOVED***);
                ***REMOVED***

                if (blockHasBottomPadding) ***REMOVED***

                    context.report(***REMOVED***
                        node,
                        loc: ***REMOVED*** line: tokenAfterLast.loc.end.line, column: tokenAfterLast.loc.end.column - 1 ***REMOVED***,
                        message: NEVER_MESSAGE,
                        fix(fixer) ***REMOVED***
                            return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], "\n");
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        const rule = ***REMOVED******REMOVED***;

        if (Object.prototype.hasOwnProperty.call(options, "switches")) ***REMOVED***
            rule.SwitchStatement = function(node) ***REMOVED***
                if (node.cases.length === 0) ***REMOVED***
                    return;
                ***REMOVED***
                checkPadding(node);
            ***REMOVED***;
        ***REMOVED***

        if (Object.prototype.hasOwnProperty.call(options, "blocks")) ***REMOVED***
            rule.BlockStatement = function(node) ***REMOVED***
                if (node.body.length === 0) ***REMOVED***
                    return;
                ***REMOVED***
                checkPadding(node);
            ***REMOVED***;
        ***REMOVED***

        if (Object.prototype.hasOwnProperty.call(options, "classes")) ***REMOVED***
            rule.ClassBody = function(node) ***REMOVED***
                if (node.body.length === 0) ***REMOVED***
                    return;
                ***REMOVED***
                checkPadding(node);
            ***REMOVED***;
        ***REMOVED***

        return rule;
    ***REMOVED***
***REMOVED***;
