/**
 * @fileoverview Look for useless escapes in strings and regexes
 * @author Onur Temizkan
 */

"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/**
 * Returns the union of two sets.
 * @param ***REMOVED***Set***REMOVED*** setA The first set
 * @param ***REMOVED***Set***REMOVED*** setB The second set
 * @returns ***REMOVED***Set***REMOVED*** The union of the two sets
 */
function union(setA, setB) ***REMOVED***
    return new Set(function *() ***REMOVED***
        yield* setA;
        yield* setB;
    ***REMOVED***());
***REMOVED***

const VALID_STRING_ESCAPES = union(new Set("\\nrvtbfux"), astUtils.LINEBREAKS);
const REGEX_GENERAL_ESCAPES = new Set("\\bcdDfnpPrsStvwWxu0123456789]");
const REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set("^/.$*+?[***REMOVED******REMOVED***|()Bk"));

/**
 * Parses a regular expression into a list of characters with character class info.
 * @param ***REMOVED***string***REMOVED*** regExpText The raw text used to create the regular expression
 * @returns ***REMOVED***Object[]***REMOVED*** A list of characters, each with info on escaping and whether they're in a character class.
 * @example
 *
 * parseRegExp('a\\b[cd-]')
 *
 * returns:
 * [
 *   ***REMOVED***text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false***REMOVED***,
 *   ***REMOVED***text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false***REMOVED***,
 *   ***REMOVED***text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false***REMOVED***,
 *   ***REMOVED***text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false***REMOVED***,
 *   ***REMOVED***text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false***REMOVED***
 * ]
 */
function parseRegExp(regExpText) ***REMOVED***
    const charList = [];

    regExpText.split("").reduce((state, char, index) => ***REMOVED***
        if (!state.escapeNextChar) ***REMOVED***
            if (char === "\\") ***REMOVED***
                return Object.assign(state, ***REMOVED*** escapeNextChar: true ***REMOVED***);
            ***REMOVED***
            if (char === "[" && !state.inCharClass) ***REMOVED***
                return Object.assign(state, ***REMOVED*** inCharClass: true, startingCharClass: true ***REMOVED***);
            ***REMOVED***
            if (char === "]" && state.inCharClass) ***REMOVED***
                if (charList.length && charList[charList.length - 1].inCharClass) ***REMOVED***
                    charList[charList.length - 1].endsCharClass = true;
                ***REMOVED***
                return Object.assign(state, ***REMOVED*** inCharClass: false, startingCharClass: false ***REMOVED***);
            ***REMOVED***
        ***REMOVED***
        charList.push(***REMOVED***
            text: char,
            index,
            escaped: state.escapeNextChar,
            inCharClass: state.inCharClass,
            startsCharClass: state.startingCharClass,
            endsCharClass: false
        ***REMOVED***);
        return Object.assign(state, ***REMOVED*** escapeNextChar: false, startingCharClass: false ***REMOVED***);
    ***REMOVED***, ***REMOVED*** escapeNextChar: false, inCharClass: false, startingCharClass: false ***REMOVED***);

    return charList;
***REMOVED***

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow unnecessary escape characters",
            category: "Best Practices",
            recommended: true,
            url: "https://eslint.org/docs/rules/no-useless-escape"
        ***REMOVED***,

        schema: []
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();

        /**
         * Reports a node
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to report
         * @param ***REMOVED***number***REMOVED*** startOffset The backslash's offset from the start of the node
         * @param ***REMOVED***string***REMOVED*** character The uselessly escaped character (not including the backslash)
         * @returns ***REMOVED***void***REMOVED***
         */
        function report(node, startOffset, character) ***REMOVED***
            const start = sourceCode.getLocFromIndex(sourceCode.getIndexFromLoc(node.loc.start) + startOffset);

            context.report(***REMOVED***
                node,
                loc: ***REMOVED***
                    start,
                    end: ***REMOVED*** line: start.line, column: start.column + 1 ***REMOVED***
                ***REMOVED***,
                message: "Unnecessary escape character: \\***REMOVED******REMOVED***character***REMOVED******REMOVED***.",
                data: ***REMOVED*** character ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        /**
         * Checks if the escape character in given string slice is unnecessary.
         *
         * @private
         * @param ***REMOVED***ASTNode***REMOVED*** node - node to validate.
         * @param ***REMOVED***string***REMOVED*** match - string slice to validate.
         * @returns ***REMOVED***void***REMOVED***
         */
        function validateString(node, match) ***REMOVED***
            const isTemplateElement = node.type === "TemplateElement";
            const escapedChar = match[0][1];
            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);
            let isQuoteEscape;

            if (isTemplateElement) ***REMOVED***
                isQuoteEscape = escapedChar === "`";

                if (escapedChar === "$") ***REMOVED***

                    // Warn if `\$` is not followed by `***REMOVED***`
                    isUnnecessaryEscape = match.input[match.index + 2] !== "***REMOVED***";
                ***REMOVED*** else if (escapedChar === "***REMOVED***") ***REMOVED***

                    /*
                     * Warn if `\***REMOVED***` is not preceded by `$`. If preceded by `$`, escaping
                     * is necessary and the rule should not warn. If preceded by `/$`, the rule
                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.
                     */
                    isUnnecessaryEscape = match.input[match.index - 1] !== "$";
                ***REMOVED***
            ***REMOVED*** else ***REMOVED***
                isQuoteEscape = escapedChar === node.raw[0];
            ***REMOVED***

            if (isUnnecessaryEscape && !isQuoteEscape) ***REMOVED***
                report(node, match.index + 1, match[0].slice(1));
            ***REMOVED***
        ***REMOVED***

        /**
         * Checks if a node has an escape.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node - node to check.
         * @returns ***REMOVED***void***REMOVED***
         */
        function check(node) ***REMOVED***
            const isTemplateElement = node.type === "TemplateElement";

            if (
                isTemplateElement &&
                node.parent &&
                node.parent.parent &&
                node.parent.parent.type === "TaggedTemplateExpression" &&
                node.parent === node.parent.parent.quasi
            ) ***REMOVED***

                // Don't report tagged template literals, because the backslash character is accessible to the tag function.
                return;
            ***REMOVED***

            if (typeof node.value === "string" || isTemplateElement) ***REMOVED***

                /*
                 * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.
                 * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.
                 */
                if (node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement" || node.parent.type === "JSXFragment") ***REMOVED***
                    return;
                ***REMOVED***

                const value = isTemplateElement ? node.value.raw : node.raw.slice(1, -1);
                const pattern = /\\[^\d]/gu;
                let match;

                while ((match = pattern.exec(value))) ***REMOVED***
                    validateString(node, match);
                ***REMOVED***
            ***REMOVED*** else if (node.regex) ***REMOVED***
                parseRegExp(node.regex.pattern)

                    /*
                     * The '-' character is a special case, because it's only valid to escape it if it's in a character
                     * class, and is not at either edge of the character class. To account for this, don't consider '-'
                     * characters to be valid in general, and filter out '-' characters that appear in the middle of a
                     * character class.
                     */
                    .filter(charInfo => !(charInfo.text === "-" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))

                    /*
                     * The '^' character is also a special case; it must always be escaped outside of character classes, but
                     * it only needs to be escaped in character classes if it's at the beginning of the character class. To
                     * account for this, consider it to be a valid escape character outside of character classes, and filter
                     * out '^' characters that appear at the start of a character class.
                     */
                    .filter(charInfo => !(charInfo.text === "^" && charInfo.startsCharClass))

                    // Filter out characters that aren't escaped.
                    .filter(charInfo => charInfo.escaped)

                    // Filter out characters that are valid to escape, based on their position in the regular expression.
                    .filter(charInfo => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text))

                    // Report all the remaining characters.
                    .forEach(charInfo => report(node, charInfo.index, charInfo.text));
            ***REMOVED***

        ***REMOVED***

        return ***REMOVED***
            Literal: check,
            TemplateElement: check
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
