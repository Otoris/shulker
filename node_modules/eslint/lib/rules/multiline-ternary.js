/**
 * @fileoverview Enforce newlines between operands of ternary expressions
 * @author Kai Cataldo
 */

"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "enforce newlines between operands of ternary expressions",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/multiline-ternary"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                enum: ["always", "always-multiline", "never"]
            ***REMOVED***
        ],
        messages: ***REMOVED***
            expectedTestCons: "Expected newline between test and consequent of ternary expression.",
            expectedConsAlt: "Expected newline between consequent and alternate of ternary expression.",
            unexpectedTestCons: "Unexpected newline between test and consequent of ternary expression.",
            unexpectedConsAlt: "Unexpected newline between consequent and alternate of ternary expression."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const option = context.options[0];
        const multiline = option !== "never";
        const allowSingleLine = option === "always-multiline";

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Tests whether node is preceded by supplied tokens
         * @param ***REMOVED***ASTNode***REMOVED*** node - node to check
         * @param ***REMOVED***ASTNode***REMOVED*** parentNode - parent of node to report
         * @param ***REMOVED***boolean***REMOVED*** expected - whether newline was expected or not
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function reportError(node, parentNode, expected) ***REMOVED***
            context.report(***REMOVED***
                node,
                messageId: `$***REMOVED***expected ? "expected" : "unexpected"***REMOVED***$***REMOVED***node === parentNode.test ? "TestCons" : "ConsAlt"***REMOVED***`
            ***REMOVED***);
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***
            ConditionalExpression(node) ***REMOVED***
                const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(node.test, node.consequent);
                const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(node.consequent, node.alternate);

                if (!multiline) ***REMOVED***
                    if (!areTestAndConsequentOnSameLine) ***REMOVED***
                        reportError(node.test, node, false);
                    ***REMOVED***

                    if (!areConsequentAndAlternateOnSameLine) ***REMOVED***
                        reportError(node.consequent, node, false);
                    ***REMOVED***
                ***REMOVED*** else ***REMOVED***
                    if (allowSingleLine && node.loc.start.line === node.loc.end.line) ***REMOVED***
                        return;
                    ***REMOVED***

                    if (areTestAndConsequentOnSameLine) ***REMOVED***
                        reportError(node.test, node, true);
                    ***REMOVED***

                    if (areConsequentAndAlternateOnSameLine) ***REMOVED***
                        reportError(node.consequent, node, true);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
