/**
 * @fileoverview Rule to replace assignment expressions with operator assignment
 * @author Brandon Mills
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether an operator is commutative and has an operator assignment
 * shorthand form.
 * @param   ***REMOVED***string***REMOVED***  operator Operator to check.
 * @returns ***REMOVED***boolean***REMOVED***          True if the operator is commutative and has a
 *     shorthand form.
 */
function isCommutativeOperatorWithShorthand(operator) ***REMOVED***
    return ["*", "&", "^", "|"].indexOf(operator) >= 0;
***REMOVED***

/**
 * Checks whether an operator is not commuatative and has an operator assignment
 * shorthand form.
 * @param   ***REMOVED***string***REMOVED***  operator Operator to check.
 * @returns ***REMOVED***boolean***REMOVED***          True if the operator is not commuatative and has
 *     a shorthand form.
 */
function isNonCommutativeOperatorWithShorthand(operator) ***REMOVED***
    return ["+", "-", "/", "%", "<<", ">>", ">>>", "**"].indexOf(operator) >= 0;
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/**
 * Checks whether two expressions reference the same value. For example:
 *     a = a
 *     a.b = a.b
 *     a[0] = a[0]
 *     a['b'] = a['b']
 * @param   ***REMOVED***ASTNode***REMOVED*** a Left side of the comparison.
 * @param   ***REMOVED***ASTNode***REMOVED*** b Right side of the comparison.
 * @returns ***REMOVED***boolean***REMOVED***   True if both sides match and reference the same value.
 */
function same(a, b) ***REMOVED***
    if (a.type !== b.type) ***REMOVED***
        return false;
    ***REMOVED***

    switch (a.type) ***REMOVED***
        case "Identifier":
            return a.name === b.name;

        case "Literal":
            return a.value === b.value;

        case "MemberExpression":

            /*
             * x[0] = x[0]
             * x[y] = x[y]
             * x.y = x.y
             */
            return same(a.object, b.object) && same(a.property, b.property);

        default:
            return false;
    ***REMOVED***
***REMOVED***

/**
 * Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)
 * toString calls regardless of whether assignment shorthand is used)
 * @param ***REMOVED***ASTNode***REMOVED*** node The node on the left side of the expression
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node can be fixed
 */
function canBeFixed(node) ***REMOVED***
    return node.type === "Identifier" ||
        node.type === "MemberExpression" && node.object.type === "Identifier" && (!node.computed || node.property.type === "Literal");
***REMOVED***

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "require or disallow assignment operator shorthand where possible",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/operator-assignment"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                enum: ["always", "never"]
            ***REMOVED***
        ],

        fixable: "code",
        messages: ***REMOVED***
            replaced: "Assignment can be replaced with operator assignment.",
            unexpected: "Unexpected operator assignment shorthand."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        const sourceCode = context.getSourceCode();

        /**
         * Returns the operator token of an AssignmentExpression or BinaryExpression
         * @param ***REMOVED***ASTNode***REMOVED*** node An AssignmentExpression or BinaryExpression node
         * @returns ***REMOVED***Token***REMOVED*** The operator token in the node
         */
        function getOperatorToken(node) ***REMOVED***
            return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
        ***REMOVED***

        /**
         * Ensures that an assignment uses the shorthand form where possible.
         * @param   ***REMOVED***ASTNode***REMOVED*** node An AssignmentExpression node.
         * @returns ***REMOVED***void***REMOVED***
         */
        function verify(node) ***REMOVED***
            if (node.operator !== "=" || node.right.type !== "BinaryExpression") ***REMOVED***
                return;
            ***REMOVED***

            const left = node.left;
            const expr = node.right;
            const operator = expr.operator;

            if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) ***REMOVED***
                if (same(left, expr.left)) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        messageId: "replaced",
                        fix(fixer) ***REMOVED***
                            if (canBeFixed(left)) ***REMOVED***
                                const equalsToken = getOperatorToken(node);
                                const operatorToken = getOperatorToken(expr);
                                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);
                                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);

                                return fixer.replaceText(node, `$***REMOVED***leftText***REMOVED***$***REMOVED***expr.operator***REMOVED***=$***REMOVED***rightText***REMOVED***`);
                            ***REMOVED***
                            return null;
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED*** else if (same(left, expr.right) && isCommutativeOperatorWithShorthand(operator)) ***REMOVED***

                    /*
                     * This case can't be fixed safely.
                     * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would
                     * change the execution order of the valueOf() functions.
                     */
                    context.report(***REMOVED***
                        node,
                        messageId: "replaced"
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Warns if an assignment expression uses operator assignment shorthand.
         * @param   ***REMOVED***ASTNode***REMOVED*** node An AssignmentExpression node.
         * @returns ***REMOVED***void***REMOVED***
         */
        function prohibit(node) ***REMOVED***
            if (node.operator !== "=") ***REMOVED***
                context.report(***REMOVED***
                    node,
                    messageId: "unexpected",
                    fix(fixer) ***REMOVED***
                        if (canBeFixed(node.left)) ***REMOVED***
                            const operatorToken = getOperatorToken(node);
                            const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);
                            const newOperator = node.operator.slice(0, -1);
                            let rightText;

                            // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.
                            if (
                                astUtils.getPrecedence(node.right) <= astUtils.getPrecedence(***REMOVED*** type: "BinaryExpression", operator: newOperator ***REMOVED***) &&
                                !astUtils.isParenthesised(sourceCode, node.right)
                            ) ***REMOVED***
                                rightText = `$***REMOVED***sourceCode.text.slice(operatorToken.range[1], node.right.range[0])***REMOVED***($***REMOVED***sourceCode.getText(node.right)***REMOVED***)`;
                            ***REMOVED*** else ***REMOVED***
                                rightText = sourceCode.text.slice(operatorToken.range[1], node.range[1]);
                            ***REMOVED***

                            return fixer.replaceText(node, `$***REMOVED***leftText***REMOVED***= $***REMOVED***leftText***REMOVED***$***REMOVED***newOperator***REMOVED***$***REMOVED***rightText***REMOVED***`);
                        ***REMOVED***
                        return null;
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            AssignmentExpression: context.options[0] !== "never" ? verify : prohibit
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
