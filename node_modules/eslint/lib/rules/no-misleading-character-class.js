/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict";

const ***REMOVED*** CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant ***REMOVED*** = require("eslint-utils");
const ***REMOVED*** RegExpParser, visitRegExpAST ***REMOVED*** = require("regexpp");
const ***REMOVED*** isCombiningCharacter, isEmojiModifier, isRegionalIndicatorSymbol, isSurrogatePair ***REMOVED*** = require("./utils/unicode");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Iterate character sequences of a given nodes.
 *
 * CharacterClassRange syntax can steal a part of character sequence,
 * so this function reverts CharacterClassRange syntax and restore the sequence.
 *
 * @param ***REMOVED***regexpp.AST.CharacterClassElement[]***REMOVED*** nodes The node list to iterate character sequences.
 * @returns ***REMOVED***IterableIterator<number[]>***REMOVED*** The list of character sequences.
 */
function *iterateCharacterSequence(nodes) ***REMOVED***
    let seq = [];

    for (const node of nodes) ***REMOVED***
        switch (node.type) ***REMOVED***
            case "Character":
                seq.push(node.value);
                break;

            case "CharacterClassRange":
                seq.push(node.min.value);
                yield seq;
                seq = [node.max.value];
                break;

            case "CharacterSet":
                if (seq.length > 0) ***REMOVED***
                    yield seq;
                    seq = [];
                ***REMOVED***
                break;

            // no default
        ***REMOVED***
    ***REMOVED***

    if (seq.length > 0) ***REMOVED***
        yield seq;
    ***REMOVED***
***REMOVED***

const hasCharacterSequence = ***REMOVED***
    surrogatePairWithoutUFlag(chars) ***REMOVED***
        return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));
    ***REMOVED***,

    combiningClass(chars) ***REMOVED***
        return chars.some((c, i) => (
            i !== 0 &&
            isCombiningCharacter(c) &&
            !isCombiningCharacter(chars[i - 1])
        ));
    ***REMOVED***,

    emojiModifier(chars) ***REMOVED***
        return chars.some((c, i) => (
            i !== 0 &&
            isEmojiModifier(c) &&
            !isEmojiModifier(chars[i - 1])
        ));
    ***REMOVED***,

    regionalIndicatorSymbol(chars) ***REMOVED***
        return chars.some((c, i) => (
            i !== 0 &&
            isRegionalIndicatorSymbol(c) &&
            isRegionalIndicatorSymbol(chars[i - 1])
        ));
    ***REMOVED***,

    zwj(chars) ***REMOVED***
        const lastIndex = chars.length - 1;

        return chars.some((c, i) => (
            i !== 0 &&
            i !== lastIndex &&
            c === 0x200d &&
            chars[i - 1] !== 0x200d &&
            chars[i + 1] !== 0x200d
        ));
    ***REMOVED***
***REMOVED***;

const kinds = Object.keys(hasCharacterSequence);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "problem",

        docs: ***REMOVED***
            description: "disallow characters which are made with multiple code points in character class syntax",
            category: "Possible Errors",
            recommended: true,
            url: "https://eslint.org/docs/rules/no-misleading-character-class"
        ***REMOVED***,

        schema: [],

        messages: ***REMOVED***
            surrogatePairWithoutUFlag: "Unexpected surrogate pair in character class. Use 'u' flag.",
            combiningClass: "Unexpected combined character in character class.",
            emojiModifier: "Unexpected modified Emoji in character class.",
            regionalIndicatorSymbol: "Unexpected national flag in character class.",
            zwj: "Unexpected joined character sequence in character class."
        ***REMOVED***
    ***REMOVED***,
    create(context) ***REMOVED***
        const parser = new RegExpParser();

        /**
         * Verify a given regular expression.
         * @param ***REMOVED***Node***REMOVED*** node The node to report.
         * @param ***REMOVED***string***REMOVED*** pattern The regular expression pattern to verify.
         * @param ***REMOVED***string***REMOVED*** flags The flags of the regular expression.
         * @returns ***REMOVED***void***REMOVED***
         */
        function verify(node, pattern, flags) ***REMOVED***
            const patternNode = parser.parsePattern(
                pattern,
                0,
                pattern.length,
                flags.includes("u")
            );
            const has = ***REMOVED***
                surrogatePairWithoutUFlag: false,
                combiningClass: false,
                variationSelector: false,
                emojiModifier: false,
                regionalIndicatorSymbol: false,
                zwj: false
            ***REMOVED***;

            visitRegExpAST(patternNode, ***REMOVED***
                onCharacterClassEnter(ccNode) ***REMOVED***
                    for (const chars of iterateCharacterSequence(ccNode.elements)) ***REMOVED***
                        for (const kind of kinds) ***REMOVED***
                            has[kind] = has[kind] || hasCharacterSequence[kind](chars);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            for (const kind of kinds) ***REMOVED***
                if (has[kind]) ***REMOVED***
                    context.report(***REMOVED*** node, messageId: kind ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            "Literal[regex]"(node) ***REMOVED***
                verify(node, node.regex.pattern, node.regex.flags);
            ***REMOVED***,
            "Program"() ***REMOVED***
                const scope = context.getScope();
                const tracker = new ReferenceTracker(scope);

                /*
                 * Iterate calls of RegExp.
                 * E.g., `new RegExp()`, `RegExp()`, `new window.RegExp()`,
                 *       `const ***REMOVED***RegExp: a***REMOVED*** = window; new a()`, etc...
                 */
                for (const ***REMOVED*** node ***REMOVED*** of tracker.iterateGlobalReferences(***REMOVED***
                    RegExp: ***REMOVED*** [CALL]: true, [CONSTRUCT]: true ***REMOVED***
                ***REMOVED***)) ***REMOVED***
                    const [patternNode, flagsNode] = node.arguments;
                    const pattern = getStringIfConstant(patternNode, scope);
                    const flags = getStringIfConstant(flagsNode, scope);

                    if (typeof pattern === "string") ***REMOVED***
                        verify(node, pattern, flags || "");
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
