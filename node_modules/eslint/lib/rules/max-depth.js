/**
 * @fileoverview A rule to set the maximum depth block can be nested in a function.
 * @author Ian Christian Myers
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "enforce a maximum depth that blocks can be nested",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/max-depth"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                oneOf: [
                    ***REMOVED***
                        type: "integer",
                        minimum: 0
                    ***REMOVED***,
                    ***REMOVED***
                        type: "object",
                        properties: ***REMOVED***
                            maximum: ***REMOVED***
                                type: "integer",
                                minimum: 0
                            ***REMOVED***,
                            max: ***REMOVED***
                                type: "integer",
                                minimum: 0
                            ***REMOVED***
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***
                ]
            ***REMOVED***
        ],
        messages: ***REMOVED***
            tooDeeply: "Blocks are nested too deeply (***REMOVED******REMOVED***depth***REMOVED******REMOVED***). Maximum allowed is ***REMOVED******REMOVED***maxDepth***REMOVED******REMOVED***."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        const functionStack = [],
            option = context.options[0];
        let maxDepth = 4;

        if (
            typeof option === "object" &&
            (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))
        ) ***REMOVED***
            maxDepth = option.maximum || option.max;
        ***REMOVED***
        if (typeof option === "number") ***REMOVED***
            maxDepth = option;
        ***REMOVED***

        /**
         * When parsing a new function, store it in our function stack
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function startFunction() ***REMOVED***
            functionStack.push(0);
        ***REMOVED***

        /**
         * When parsing is done then pop out the reference
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function endFunction() ***REMOVED***
            functionStack.pop();
        ***REMOVED***

        /**
         * Save the block and Evaluate the node
         * @param ***REMOVED***ASTNode***REMOVED*** node node to evaluate
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function pushBlock(node) ***REMOVED***
            const len = ++functionStack[functionStack.length - 1];

            if (len > maxDepth) ***REMOVED***
                context.report(***REMOVED*** node, messageId: "tooDeeply", data: ***REMOVED*** depth: len, maxDepth ***REMOVED*** ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Pop the saved block
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function popBlock() ***REMOVED***
            functionStack[functionStack.length - 1]--;
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public API
        //--------------------------------------------------------------------------

        return ***REMOVED***
            Program: startFunction,
            FunctionDeclaration: startFunction,
            FunctionExpression: startFunction,
            ArrowFunctionExpression: startFunction,

            IfStatement(node) ***REMOVED***
                if (node.parent.type !== "IfStatement") ***REMOVED***
                    pushBlock(node);
                ***REMOVED***
            ***REMOVED***,
            SwitchStatement: pushBlock,
            TryStatement: pushBlock,
            DoWhileStatement: pushBlock,
            WhileStatement: pushBlock,
            WithStatement: pushBlock,
            ForStatement: pushBlock,
            ForInStatement: pushBlock,
            ForOfStatement: pushBlock,

            "IfStatement:exit": popBlock,
            "SwitchStatement:exit": popBlock,
            "TryStatement:exit": popBlock,
            "DoWhileStatement:exit": popBlock,
            "WhileStatement:exit": popBlock,
            "WithStatement:exit": popBlock,
            "ForStatement:exit": popBlock,
            "ForInStatement:exit": popBlock,
            "ForOfStatement:exit": popBlock,

            "FunctionDeclaration:exit": endFunction,
            "FunctionExpression:exit": endFunction,
            "ArrowFunctionExpression:exit": endFunction,
            "Program:exit": endFunction
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
