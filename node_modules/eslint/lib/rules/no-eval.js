/**
 * @fileoverview Rule to flag use of eval() statement
 * @author Nicholas C. Zakas
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const candidatesOfGlobalObject = Object.freeze([
    "global",
    "window"
]);

/**
 * Checks a given node is a Identifier node of the specified name.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @param ***REMOVED***string***REMOVED*** name - A name to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a Identifier node of the name.
 */
function isIdentifier(node, name) ***REMOVED***
    return node.type === "Identifier" && node.name === name;
***REMOVED***

/**
 * Checks a given node is a Literal node of the specified string value.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @param ***REMOVED***string***REMOVED*** name - A name to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a Literal node of the name.
 */
function isConstant(node, name) ***REMOVED***
    switch (node.type) ***REMOVED***
        case "Literal":
            return node.value === name;

        case "TemplateLiteral":
            return (
                node.expressions.length === 0 &&
                node.quasis[0].value.cooked === name
            );

        default:
            return false;
    ***REMOVED***
***REMOVED***

/**
 * Checks a given node is a MemberExpression node which has the specified name's
 * property.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @param ***REMOVED***string***REMOVED*** name - A name to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a MemberExpression node which has
 *      the specified name's property
 */
function isMember(node, name) ***REMOVED***
    return (
        node.type === "MemberExpression" &&
        (node.computed ? isConstant : isIdentifier)(node.property, name)
    );
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow the use of `eval()`",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-eval"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    allowIndirect: ***REMOVED*** type: "boolean", default: false ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],

        messages: ***REMOVED***
            unexpected: "eval can be harmful."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const allowIndirect = Boolean(
            context.options[0] &&
            context.options[0].allowIndirect
        );
        const sourceCode = context.getSourceCode();
        let funcInfo = null;

        /**
         * Pushs a variable scope (Program or Function) information to the stack.
         *
         * This is used in order to check whether or not `this` binding is a
         * reference to the global object.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node - A node of the scope. This is one of Program,
         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.
         * @returns ***REMOVED***void***REMOVED***
         */
        function enterVarScope(node) ***REMOVED***
            const strict = context.getScope().isStrict;

            funcInfo = ***REMOVED***
                upper: funcInfo,
                node,
                strict,
                defaultThis: false,
                initialized: strict
            ***REMOVED***;
        ***REMOVED***

        /**
         * Pops a variable scope from the stack.
         *
         * @returns ***REMOVED***void***REMOVED***
         */
        function exitVarScope() ***REMOVED***
            funcInfo = funcInfo.upper;
        ***REMOVED***

        /**
         * Reports a given node.
         *
         * `node` is `Identifier` or `MemberExpression`.
         * The parent of `node` might be `CallExpression`.
         *
         * The location of the report is always `eval` `Identifier` (or possibly
         * `Literal`). The type of the report is `CallExpression` if the parent is
         * `CallExpression`. Otherwise, it's the given node type.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node - A node to report.
         * @returns ***REMOVED***void***REMOVED***
         */
        function report(node) ***REMOVED***
            const parent = node.parent;
            const locationNode = node.type === "MemberExpression"
                ? node.property
                : node;

            const reportNode = parent.type === "CallExpression" && parent.callee === node
                ? parent
                : node;

            context.report(***REMOVED***
                node: reportNode,
                loc: locationNode.loc.start,
                messageId: "unexpected"
            ***REMOVED***);
        ***REMOVED***

        /**
         * Reports accesses of `eval` via the global object.
         *
         * @param ***REMOVED***eslint-scope.Scope***REMOVED*** globalScope - The global scope.
         * @returns ***REMOVED***void***REMOVED***
         */
        function reportAccessingEvalViaGlobalObject(globalScope) ***REMOVED***
            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) ***REMOVED***
                const name = candidatesOfGlobalObject[i];
                const variable = astUtils.getVariableByName(globalScope, name);

                if (!variable) ***REMOVED***
                    continue;
                ***REMOVED***

                const references = variable.references;

                for (let j = 0; j < references.length; ++j) ***REMOVED***
                    const identifier = references[j].identifier;
                    let node = identifier.parent;

                    // To detect code like `window.window.eval`.
                    while (isMember(node, name)) ***REMOVED***
                        node = node.parent;
                    ***REMOVED***

                    // Reports.
                    if (isMember(node, "eval")) ***REMOVED***
                        report(node);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Reports all accesses of `eval` (excludes direct calls to eval).
         *
         * @param ***REMOVED***eslint-scope.Scope***REMOVED*** globalScope - The global scope.
         * @returns ***REMOVED***void***REMOVED***
         */
        function reportAccessingEval(globalScope) ***REMOVED***
            const variable = astUtils.getVariableByName(globalScope, "eval");

            if (!variable) ***REMOVED***
                return;
            ***REMOVED***

            const references = variable.references;

            for (let i = 0; i < references.length; ++i) ***REMOVED***
                const reference = references[i];
                const id = reference.identifier;

                if (id.name === "eval" && !astUtils.isCallee(id)) ***REMOVED***

                    // Is accessing to eval (excludes direct calls to eval)
                    report(id);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        if (allowIndirect) ***REMOVED***

            // Checks only direct calls to eval. It's simple!
            return ***REMOVED***
                "CallExpression:exit"(node) ***REMOVED***
                    const callee = node.callee;

                    if (isIdentifier(callee, "eval")) ***REMOVED***
                        report(callee);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***;
        ***REMOVED***

        return ***REMOVED***
            "CallExpression:exit"(node) ***REMOVED***
                const callee = node.callee;

                if (isIdentifier(callee, "eval")) ***REMOVED***
                    report(callee);
                ***REMOVED***
            ***REMOVED***,

            Program(node) ***REMOVED***
                const scope = context.getScope(),
                    features = context.parserOptions.ecmaFeatures || ***REMOVED******REMOVED***,
                    strict =
                        scope.isStrict ||
                        node.sourceType === "module" ||
                        (features.globalReturn && scope.childScopes[0].isStrict);

                funcInfo = ***REMOVED***
                    upper: null,
                    node,
                    strict,
                    defaultThis: true,
                    initialized: true
                ***REMOVED***;
            ***REMOVED***,

            "Program:exit"() ***REMOVED***
                const globalScope = context.getScope();

                exitVarScope();
                reportAccessingEval(globalScope);
                reportAccessingEvalViaGlobalObject(globalScope);
            ***REMOVED***,

            FunctionDeclaration: enterVarScope,
            "FunctionDeclaration:exit": exitVarScope,
            FunctionExpression: enterVarScope,
            "FunctionExpression:exit": exitVarScope,
            ArrowFunctionExpression: enterVarScope,
            "ArrowFunctionExpression:exit": exitVarScope,

            ThisExpression(node) ***REMOVED***
                if (!isMember(node.parent, "eval")) ***REMOVED***
                    return;
                ***REMOVED***

                /*
                 * `this.eval` is found.
                 * Checks whether or not the value of `this` is the global object.
                 */
                if (!funcInfo.initialized) ***REMOVED***
                    funcInfo.initialized = true;
                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(
                        funcInfo.node,
                        sourceCode
                    );
                ***REMOVED***

                if (!funcInfo.strict && funcInfo.defaultThis) ***REMOVED***

                    // `this.eval` is possible built-in `eval`.
                    report(node.parent);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
