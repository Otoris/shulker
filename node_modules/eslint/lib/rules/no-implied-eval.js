/**
 * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval
 * @author James Allardice
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow the use of `eval()`-like methods",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-implied-eval"
        ***REMOVED***,

        schema: []
    ***REMOVED***,

    create(context) ***REMOVED***
        const CALLEE_RE = /^(setTimeout|setInterval|execScript)$/u;

        /*
         * Figures out if we should inspect a given binary expression. Is a stack
         * of stacks, where the first element in each substack is a CallExpression.
         */
        const impliedEvalAncestorsStack = [];

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Get the last element of an array, without modifying arr, like pop(), but non-destructive.
         * @param ***REMOVED***Array***REMOVED*** arr What to inspect
         * @returns ***REMOVED*******REMOVED*** The last element of arr
         * @private
         */
        function last(arr) ***REMOVED***
            return arr ? arr[arr.length - 1] : null;
        ***REMOVED***

        /**
         * Checks if the given MemberExpression node is a potentially implied eval identifier on window.
         * @param ***REMOVED***ASTNode***REMOVED*** node The MemberExpression node to check.
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not the given node is potentially an implied eval.
         * @private
         */
        function isImpliedEvalMemberExpression(node) ***REMOVED***
            const object = node.object,
                property = node.property,
                hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);

            return object.name === "window" && hasImpliedEvalName;
        ***REMOVED***

        /**
         * Determines if a node represents a call to a potentially implied eval.
         *
         * This checks the callee name and that there's an argument, but not the type of the argument.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node The CallExpression to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node matches, false if not.
         * @private
         */
        function isImpliedEvalCallExpression(node) ***REMOVED***
            const isMemberExpression = (node.callee.type === "MemberExpression"),
                isIdentifier = (node.callee.type === "Identifier"),
                isImpliedEvalCallee =
                    (isIdentifier && CALLEE_RE.test(node.callee.name)) ||
                    (isMemberExpression && isImpliedEvalMemberExpression(node.callee));

            return isImpliedEvalCallee && node.arguments.length;
        ***REMOVED***

        /**
         * Checks that the parent is a direct descendent of an potential implied eval CallExpression, and if the parent is a CallExpression, that we're the first argument.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to inspect the parent of.
         * @returns ***REMOVED***boolean***REMOVED*** Was the parent a direct descendent, and is the child therefore potentially part of a dangerous argument?
         * @private
         */
        function hasImpliedEvalParent(node) ***REMOVED***

            // make sure our parent is marked
            return node.parent === last(last(impliedEvalAncestorsStack)) &&

                // if our parent is a CallExpression, make sure we're the first argument
                (node.parent.type !== "CallExpression" || node === node.parent.arguments[0]);
        ***REMOVED***

        /**
         * Checks if our parent is marked as part of an implied eval argument. If
         * so, collapses the top of impliedEvalAncestorsStack and reports on the
         * original CallExpression.
         * @param ***REMOVED***ASTNode***REMOVED*** node The CallExpression to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the node matches, false if not.
         * @private
         */
        function checkString(node) ***REMOVED***
            if (hasImpliedEvalParent(node)) ***REMOVED***

                // remove the entire substack, to avoid duplicate reports
                const substack = impliedEvalAncestorsStack.pop();

                context.report(***REMOVED*** node: substack[0], message: "Implied eval. Consider passing a function instead of a string." ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***
            CallExpression(node) ***REMOVED***
                if (isImpliedEvalCallExpression(node)) ***REMOVED***

                    // call expressions create a new substack
                    impliedEvalAncestorsStack.push([node]);
                ***REMOVED***
            ***REMOVED***,

            "CallExpression:exit"(node) ***REMOVED***
                if (node === last(last(impliedEvalAncestorsStack))) ***REMOVED***

                    /*
                     * Destroys the entire sub-stack, rather than just using
                     * last(impliedEvalAncestorsStack).pop(), as a CallExpression is
                     * always the bottom of a impliedEvalAncestorsStack substack.
                     */
                    impliedEvalAncestorsStack.pop();
                ***REMOVED***
            ***REMOVED***,

            BinaryExpression(node) ***REMOVED***
                if (node.operator === "+" && hasImpliedEvalParent(node)) ***REMOVED***
                    last(impliedEvalAncestorsStack).push(node);
                ***REMOVED***
            ***REMOVED***,

            "BinaryExpression:exit"(node) ***REMOVED***
                if (node === last(last(impliedEvalAncestorsStack))) ***REMOVED***
                    last(impliedEvalAncestorsStack).pop();
                ***REMOVED***
            ***REMOVED***,

            Literal(node) ***REMOVED***
                if (typeof node.value === "string") ***REMOVED***
                    checkString(node);
                ***REMOVED***
            ***REMOVED***,

            TemplateLiteral(node) ***REMOVED***
                checkString(node);
            ***REMOVED***
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
