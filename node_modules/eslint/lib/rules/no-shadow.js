/**
 * @fileoverview Rule to flag on declaring variables already declared in the outer scope
 * @author Ilya Volodin
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow variable declarations from shadowing variables declared in the outer scope",
            category: "Variables",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-shadow"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    builtinGlobals: ***REMOVED*** type: "boolean", default: false ***REMOVED***,
                    hoist: ***REMOVED*** enum: ["all", "functions", "never"], default: "functions" ***REMOVED***,
                    allow: ***REMOVED***
                        type: "array",
                        items: ***REMOVED***
                            type: "string"
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***

        const options = ***REMOVED***
            builtinGlobals: context.options[0] && context.options[0].builtinGlobals,
            hoist: (context.options[0] && context.options[0].hoist) || "functions",
            allow: (context.options[0] && context.options[0].allow) || []
        ***REMOVED***;

        /**
         * Check if variable name is allowed.
         *
         * @param  ***REMOVED***ASTNode***REMOVED*** variable The variable to check.
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not the variable name is allowed.
         */
        function isAllowed(variable) ***REMOVED***
            return options.allow.indexOf(variable.name) !== -1;
        ***REMOVED***

        /**
         * Checks if a variable of the class name in the class scope of ClassDeclaration.
         *
         * ClassDeclaration creates two variables of its name into its outer scope and its class scope.
         * So we should ignore the variable in the class scope.
         *
         * @param ***REMOVED***Object***REMOVED*** variable The variable to check.
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not the variable of the class name in the class scope of ClassDeclaration.
         */
        function isDuplicatedClassNameVariable(variable) ***REMOVED***
            const block = variable.scope.block;

            return block.type === "ClassDeclaration" && block.id === variable.identifiers[0];
        ***REMOVED***

        /**
         * Checks if a variable is inside the initializer of scopeVar.
         *
         * To avoid reporting at declarations such as `var a = function a() ***REMOVED******REMOVED***;`.
         * But it should report `var a = function(a) ***REMOVED******REMOVED***;` or `var a = function() ***REMOVED*** function a() ***REMOVED******REMOVED*** ***REMOVED***;`.
         *
         * @param ***REMOVED***Object***REMOVED*** variable The variable to check.
         * @param ***REMOVED***Object***REMOVED*** scopeVar The scope variable to look for.
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not the variable is inside initializer of scopeVar.
         */
        function isOnInitializer(variable, scopeVar) ***REMOVED***
            const outerScope = scopeVar.scope;
            const outerDef = scopeVar.defs[0];
            const outer = outerDef && outerDef.parent && outerDef.parent.range;
            const innerScope = variable.scope;
            const innerDef = variable.defs[0];
            const inner = innerDef && innerDef.name.range;

            return (
                outer &&
                inner &&
                outer[0] < inner[0] &&
                inner[1] < outer[1] &&
                ((innerDef.type === "FunctionName" && innerDef.node.type === "FunctionExpression") || innerDef.node.type === "ClassExpression") &&
                outerScope === innerScope.upper
            );
        ***REMOVED***

        /**
         * Get a range of a variable's identifier node.
         * @param ***REMOVED***Object***REMOVED*** variable The variable to get.
         * @returns ***REMOVED***Array|undefined***REMOVED*** The range of the variable's identifier node.
         */
        function getNameRange(variable) ***REMOVED***
            const def = variable.defs[0];

            return def && def.name.range;
        ***REMOVED***

        /**
         * Checks if a variable is in TDZ of scopeVar.
         * @param ***REMOVED***Object***REMOVED*** variable The variable to check.
         * @param ***REMOVED***Object***REMOVED*** scopeVar The variable of TDZ.
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not the variable is in TDZ of scopeVar.
         */
        function isInTdz(variable, scopeVar) ***REMOVED***
            const outerDef = scopeVar.defs[0];
            const inner = getNameRange(variable);
            const outer = getNameRange(scopeVar);

            return (
                inner &&
                outer &&
                inner[1] < outer[0] &&

                // Excepts FunctionDeclaration if is ***REMOVED***"hoist":"function"***REMOVED***.
                (options.hoist !== "functions" || !outerDef || outerDef.node.type !== "FunctionDeclaration")
            );
        ***REMOVED***

        /**
         * Checks the current context for shadowed variables.
         * @param ***REMOVED***Scope***REMOVED*** scope - Fixme
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkForShadows(scope) ***REMOVED***
            const variables = scope.variables;

            for (let i = 0; i < variables.length; ++i) ***REMOVED***
                const variable = variables[i];

                // Skips "arguments" or variables of a class name in the class scope of ClassDeclaration.
                if (variable.identifiers.length === 0 ||
                    isDuplicatedClassNameVariable(variable) ||
                    isAllowed(variable)
                ) ***REMOVED***
                    continue;
                ***REMOVED***

                // Gets shadowed variable.
                const shadowed = astUtils.getVariableByName(scope.upper, variable.name);

                if (shadowed &&
                    (shadowed.identifiers.length > 0 || (options.builtinGlobals && "writeable" in shadowed)) &&
                    !isOnInitializer(variable, shadowed) &&
                    !(options.hoist !== "all" && isInTdz(variable, shadowed))
                ) ***REMOVED***
                    context.report(***REMOVED***
                        node: variable.identifiers[0],
                        message: "'***REMOVED******REMOVED***name***REMOVED******REMOVED***' is already declared in the upper scope.",
                        data: variable
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            "Program:exit"() ***REMOVED***
                const globalScope = context.getScope();
                const stack = globalScope.childScopes.slice();

                while (stack.length) ***REMOVED***
                    const scope = stack.pop();

                    stack.push(...scope.childScopes);
                    checkForShadows(scope);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
