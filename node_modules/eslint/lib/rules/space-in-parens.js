/**
 * @fileoverview Disallows or enforces spaces inside of parentheses.
 * @author Jonathan Rajavuori
 */
"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "enforce consistent spacing inside parentheses",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/space-in-parens"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            ***REMOVED***
                enum: ["always", "never"]
            ***REMOVED***,
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    exceptions: ***REMOVED***
                        type: "array",
                        items: ***REMOVED***
                            enum: ["***REMOVED******REMOVED***", "[]", "()", "empty"]
                        ***REMOVED***,
                        uniqueItems: true
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],

        messages: ***REMOVED***
            missingOpeningSpace: "There must be a space after this paren.",
            missingClosingSpace: "There must be a space before this paren.",
            rejectedOpeningSpace: "There should be no space after this paren.",
            rejectedClosingSpace: "There should be no space before this paren."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const ALWAYS = context.options[0] === "always",
            exceptionsArrayOptions = (context.options[1] && context.options[1].exceptions) || [],
            options = ***REMOVED******REMOVED***;

        let exceptions;

        if (exceptionsArrayOptions.length) ***REMOVED***
            options.braceException = exceptionsArrayOptions.includes("***REMOVED******REMOVED***");
            options.bracketException = exceptionsArrayOptions.includes("[]");
            options.parenException = exceptionsArrayOptions.includes("()");
            options.empty = exceptionsArrayOptions.includes("empty");
        ***REMOVED***

        /**
         * Produces an object with the opener and closer exception values
         * @returns ***REMOVED***Object***REMOVED*** `openers` and `closers` exception values
         * @private
         */
        function getExceptions() ***REMOVED***
            const openers = [],
                closers = [];

            if (options.braceException) ***REMOVED***
                openers.push("***REMOVED***");
                closers.push("***REMOVED***");
            ***REMOVED***

            if (options.bracketException) ***REMOVED***
                openers.push("[");
                closers.push("]");
            ***REMOVED***

            if (options.parenException) ***REMOVED***
                openers.push("(");
                closers.push(")");
            ***REMOVED***

            if (options.empty) ***REMOVED***
                openers.push(")");
                closers.push("(");
            ***REMOVED***

            return ***REMOVED***
                openers,
                closers
            ***REMOVED***;
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------
        const sourceCode = context.getSourceCode();

        /**
         * Determines if a token is one of the exceptions for the opener paren
         * @param ***REMOVED***Object***REMOVED*** token The token to check
         * @returns ***REMOVED***boolean***REMOVED*** True if the token is one of the exceptions for the opener paren
         */
        function isOpenerException(token) ***REMOVED***
            return exceptions.openers.includes(token.value);
        ***REMOVED***

        /**
         * Determines if a token is one of the exceptions for the closer paren
         * @param ***REMOVED***Object***REMOVED*** token The token to check
         * @returns ***REMOVED***boolean***REMOVED*** True if the token is one of the exceptions for the closer paren
         */
        function isCloserException(token) ***REMOVED***
            return exceptions.closers.includes(token.value);
        ***REMOVED***

        /**
         * Determines if an opening paren is immediately followed by a required space
         * @param ***REMOVED***Object***REMOVED*** openingParenToken The paren token
         * @param ***REMOVED***Object***REMOVED*** tokenAfterOpeningParen The token after it
         * @returns ***REMOVED***boolean***REMOVED*** True if the opening paren is missing a required space
         */
        function openerMissingSpace(openingParenToken, tokenAfterOpeningParen) ***REMOVED***
            if (sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) ***REMOVED***
                return false;
            ***REMOVED***

            if (!options.empty && astUtils.isClosingParenToken(tokenAfterOpeningParen)) ***REMOVED***
                return false;
            ***REMOVED***

            if (ALWAYS) ***REMOVED***
                return !isOpenerException(tokenAfterOpeningParen);
            ***REMOVED***
            return isOpenerException(tokenAfterOpeningParen);
        ***REMOVED***

        /**
         * Determines if an opening paren is immediately followed by a disallowed space
         * @param ***REMOVED***Object***REMOVED*** openingParenToken The paren token
         * @param ***REMOVED***Object***REMOVED*** tokenAfterOpeningParen The token after it
         * @returns ***REMOVED***boolean***REMOVED*** True if the opening paren has a disallowed space
         */
        function openerRejectsSpace(openingParenToken, tokenAfterOpeningParen) ***REMOVED***
            if (!astUtils.isTokenOnSameLine(openingParenToken, tokenAfterOpeningParen)) ***REMOVED***
                return false;
            ***REMOVED***

            if (tokenAfterOpeningParen.type === "Line") ***REMOVED***
                return false;
            ***REMOVED***

            if (!sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) ***REMOVED***
                return false;
            ***REMOVED***

            if (ALWAYS) ***REMOVED***
                return isOpenerException(tokenAfterOpeningParen);
            ***REMOVED***
            return !isOpenerException(tokenAfterOpeningParen);
        ***REMOVED***

        /**
         * Determines if a closing paren is immediately preceeded by a required space
         * @param ***REMOVED***Object***REMOVED*** tokenBeforeClosingParen The token before the paren
         * @param ***REMOVED***Object***REMOVED*** closingParenToken The paren token
         * @returns ***REMOVED***boolean***REMOVED*** True if the closing paren is missing a required space
         */
        function closerMissingSpace(tokenBeforeClosingParen, closingParenToken) ***REMOVED***
            if (sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) ***REMOVED***
                return false;
            ***REMOVED***

            if (!options.empty && astUtils.isOpeningParenToken(tokenBeforeClosingParen)) ***REMOVED***
                return false;
            ***REMOVED***

            if (ALWAYS) ***REMOVED***
                return !isCloserException(tokenBeforeClosingParen);
            ***REMOVED***
            return isCloserException(tokenBeforeClosingParen);
        ***REMOVED***

        /**
         * Determines if a closer paren is immediately preceeded by a disallowed space
         * @param ***REMOVED***Object***REMOVED*** tokenBeforeClosingParen The token before the paren
         * @param ***REMOVED***Object***REMOVED*** closingParenToken The paren token
         * @returns ***REMOVED***boolean***REMOVED*** True if the closing paren has a disallowed space
         */
        function closerRejectsSpace(tokenBeforeClosingParen, closingParenToken) ***REMOVED***
            if (!astUtils.isTokenOnSameLine(tokenBeforeClosingParen, closingParenToken)) ***REMOVED***
                return false;
            ***REMOVED***

            if (!sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) ***REMOVED***
                return false;
            ***REMOVED***

            if (ALWAYS) ***REMOVED***
                return isCloserException(tokenBeforeClosingParen);
            ***REMOVED***
            return !isCloserException(tokenBeforeClosingParen);
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***
            Program: function checkParenSpaces(node) ***REMOVED***
                exceptions = getExceptions();
                const tokens = sourceCode.tokensAndComments;

                tokens.forEach((token, i) => ***REMOVED***
                    const prevToken = tokens[i - 1];
                    const nextToken = tokens[i + 1];

                    // if token is not an opening or closing paren token, do nothing
                    if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) ***REMOVED***
                        return;
                    ***REMOVED***

                    // if token is an opening paren and is not followed by a required space
                    if (token.value === "(" && openerMissingSpace(token, nextToken)) ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            loc: token.loc.start,
                            messageId: "missingOpeningSpace",
                            fix(fixer) ***REMOVED***
                                return fixer.insertTextAfter(token, " ");
                            ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED***

                    // if token is an opening paren and is followed by a disallowed space
                    if (token.value === "(" && openerRejectsSpace(token, nextToken)) ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            loc: token.loc.start,
                            messageId: "rejectedOpeningSpace",
                            fix(fixer) ***REMOVED***
                                return fixer.removeRange([token.range[1], nextToken.range[0]]);
                            ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED***

                    // if token is a closing paren and is not preceded by a required space
                    if (token.value === ")" && closerMissingSpace(prevToken, token)) ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            loc: token.loc.start,
                            messageId: "missingClosingSpace",
                            fix(fixer) ***REMOVED***
                                return fixer.insertTextBefore(token, " ");
                            ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED***

                    // if token is a closing paren and is preceded by a disallowed space
                    if (token.value === ")" && closerRejectsSpace(prevToken, token)) ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            loc: token.loc.start,
                            messageId: "rejectedClosingSpace",
                            fix(fixer) ***REMOVED***
                                return fixer.removeRange([prevToken.range[1], token.range[0]]);
                            ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
