/**
 * @fileoverview A rule to disallow or enforce spaces inside of single line blocks.
 * @author Toru Nagashima
 */

"use strict";

const util = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "disallow or enforce spaces inside of blocks after opening block and before closing block",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/block-spacing"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            ***REMOVED*** enum: ["always", "never"] ***REMOVED***
        ],

        messages: ***REMOVED***
            missing: "Requires a space ***REMOVED******REMOVED***location***REMOVED******REMOVED*** '***REMOVED******REMOVED***token***REMOVED******REMOVED***'.",
            extra: "Unexpected space(s) ***REMOVED******REMOVED***location***REMOVED******REMOVED*** '***REMOVED******REMOVED***token***REMOVED******REMOVED***'."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const always = (context.options[0] !== "never"),
            messageId = always ? "missing" : "extra",
            sourceCode = context.getSourceCode();

        /**
         * Gets the open brace token from a given node.
         * @param ***REMOVED***ASTNode***REMOVED*** node - A BlockStatement/SwitchStatement node to get.
         * @returns ***REMOVED***Token***REMOVED*** The token of the open brace.
         */
        function getOpenBrace(node) ***REMOVED***
            if (node.type === "SwitchStatement") ***REMOVED***
                if (node.cases.length > 0) ***REMOVED***
                    return sourceCode.getTokenBefore(node.cases[0]);
                ***REMOVED***
                return sourceCode.getLastToken(node, 1);
            ***REMOVED***
            return sourceCode.getFirstToken(node);
        ***REMOVED***

        /**
         * Checks whether or not:
         *   - given tokens are on same line.
         *   - there is/isn't a space between given tokens.
         * @param ***REMOVED***Token***REMOVED*** left - A token to check.
         * @param ***REMOVED***Token***REMOVED*** right - The token which is next to `left`.
         * @returns ***REMOVED***boolean***REMOVED***
         *    When the option is `"always"`, `true` if there are one or more spaces between given tokens.
         *    When the option is `"never"`, `true` if there are not any spaces between given tokens.
         *    If given tokens are not on same line, it's always `true`.
         */
        function isValid(left, right) ***REMOVED***
            return (
                !util.isTokenOnSameLine(left, right) ||
                sourceCode.isSpaceBetweenTokens(left, right) === always
            );
        ***REMOVED***

        /**
         * Reports invalid spacing style inside braces.
         * @param ***REMOVED***ASTNode***REMOVED*** node - A BlockStatement/SwitchStatement node to get.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkSpacingInsideBraces(node) ***REMOVED***

            // Gets braces and the first/last token of content.
            const openBrace = getOpenBrace(node);
            const closeBrace = sourceCode.getLastToken(node);
            const firstToken = sourceCode.getTokenAfter(openBrace, ***REMOVED*** includeComments: true ***REMOVED***);
            const lastToken = sourceCode.getTokenBefore(closeBrace, ***REMOVED*** includeComments: true ***REMOVED***);

            // Skip if the node is invalid or empty.
            if (openBrace.type !== "Punctuator" ||
                openBrace.value !== "***REMOVED***" ||
                closeBrace.type !== "Punctuator" ||
                closeBrace.value !== "***REMOVED***" ||
                firstToken === closeBrace
            ) ***REMOVED***
                return;
            ***REMOVED***

            // Skip line comments for option never
            if (!always && firstToken.type === "Line") ***REMOVED***
                return;
            ***REMOVED***

            // Check.
            if (!isValid(openBrace, firstToken)) ***REMOVED***
                context.report(***REMOVED***
                    node,
                    loc: openBrace.loc.start,
                    messageId,
                    data: ***REMOVED***
                        location: "after",
                        token: openBrace.value
                    ***REMOVED***,
                    fix(fixer) ***REMOVED***
                        if (always) ***REMOVED***
                            return fixer.insertTextBefore(firstToken, " ");
                        ***REMOVED***

                        return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
            if (!isValid(lastToken, closeBrace)) ***REMOVED***
                context.report(***REMOVED***
                    node,
                    loc: closeBrace.loc.start,
                    messageId,
                    data: ***REMOVED***
                        location: "before",
                        token: closeBrace.value
                    ***REMOVED***,
                    fix(fixer) ***REMOVED***
                        if (always) ***REMOVED***
                            return fixer.insertTextAfter(lastToken, " ");
                        ***REMOVED***

                        return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            BlockStatement: checkSpacingInsideBraces,
            SwitchStatement: checkSpacingInsideBraces
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
