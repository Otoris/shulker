/**
 * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals
 * @author Annie Zhang, Henry Zhu
 */

"use strict";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks to see if a CallExpression's callee node is `parseInt` or
 * `Number.parseInt`.
 * @param ***REMOVED***ASTNode***REMOVED*** calleeNode The callee node to evaluate.
 * @returns ***REMOVED***boolean***REMOVED*** True if the callee is `parseInt` or `Number.parseInt`,
 * false otherwise.
 */
function isParseInt(calleeNode) ***REMOVED***
    switch (calleeNode.type) ***REMOVED***
        case "Identifier":
            return calleeNode.name === "parseInt";
        case "MemberExpression":
            return calleeNode.object.type === "Identifier" &&
                calleeNode.object.name === "Number" &&
                calleeNode.property.type === "Identifier" &&
                calleeNode.property.name === "parseInt";

        // no default
    ***REMOVED***

    return false;
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals",
            category: "ECMAScript 6",
            recommended: false,
            url: "https://eslint.org/docs/rules/prefer-numeric-literals"
        ***REMOVED***,

        schema: [],
        fixable: "code"
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();

        const radixMap = ***REMOVED***
            2: "binary",
            8: "octal",
            16: "hexadecimal"
        ***REMOVED***;

        const prefixMap = ***REMOVED***
            2: "0b",
            8: "0o",
            16: "0x"
        ***REMOVED***;

        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------

        return ***REMOVED***

            CallExpression(node) ***REMOVED***

                // doesn't check parseInt() if it doesn't have a radix argument
                if (node.arguments.length !== 2) ***REMOVED***
                    return;
                ***REMOVED***

                // only error if the radix is 2, 8, or 16
                const radixName = radixMap[node.arguments[1].value];

                if (isParseInt(node.callee) &&
                    radixName &&
                    node.arguments[0].type === "Literal"
                ) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        message: "Use ***REMOVED******REMOVED***radixName***REMOVED******REMOVED*** literals instead of ***REMOVED******REMOVED***functionName***REMOVED******REMOVED***().",
                        data: ***REMOVED***
                            radixName,
                            functionName: sourceCode.getText(node.callee)
                        ***REMOVED***,
                        fix(fixer) ***REMOVED***
                            const newPrefix = prefixMap[node.arguments[1].value];

                            if (+(newPrefix + node.arguments[0].value) !== parseInt(node.arguments[0].value, node.arguments[1].value)) ***REMOVED***

                                /*
                                 * If the newly-produced literal would be invalid, (e.g. 0b1234),
                                 * or it would yield an incorrect parseInt result for some other reason, don't make a fix.
                                 */
                                return null;
                            ***REMOVED***
                            return fixer.replaceText(node, prefixMap[node.arguments[1].value] + node.arguments[0].value);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
