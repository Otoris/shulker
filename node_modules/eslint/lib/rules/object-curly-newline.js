/**
 * @fileoverview Rule to require or disallow line breaks inside braces.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");
const lodash = require("lodash");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

// Schema objects.
const OPTION_VALUE = ***REMOVED***
    oneOf: [
        ***REMOVED***
            enum: ["always", "never"]
        ***REMOVED***,
        ***REMOVED***
            type: "object",
            properties: ***REMOVED***
                multiline: ***REMOVED***
                    type: "boolean"
                ***REMOVED***,
                minProperties: ***REMOVED***
                    type: "integer",
                    minimum: 0
                ***REMOVED***,
                consistent: ***REMOVED***
                    type: "boolean"
                ***REMOVED***
            ***REMOVED***,
            additionalProperties: false,
            minProperties: 1
        ***REMOVED***
    ]
***REMOVED***;

/**
 * Normalizes a given option value.
 *
 * @param ***REMOVED***string|Object|undefined***REMOVED*** value - An option value to parse.
 * @returns ***REMOVED******REMOVED***multiline: boolean, minProperties: number, consistent: boolean***REMOVED******REMOVED*** Normalized option object.
 */
function normalizeOptionValue(value) ***REMOVED***
    let multiline = false;
    let minProperties = Number.POSITIVE_INFINITY;
    let consistent = false;

    if (value) ***REMOVED***
        if (value === "always") ***REMOVED***
            minProperties = 0;
        ***REMOVED*** else if (value === "never") ***REMOVED***
            minProperties = Number.POSITIVE_INFINITY;
        ***REMOVED*** else ***REMOVED***
            multiline = Boolean(value.multiline);
            minProperties = value.minProperties || Number.POSITIVE_INFINITY;
            consistent = Boolean(value.consistent);
        ***REMOVED***
    ***REMOVED*** else ***REMOVED***
        consistent = true;
    ***REMOVED***

    return ***REMOVED*** multiline, minProperties, consistent ***REMOVED***;
***REMOVED***

/**
 * Normalizes a given option value.
 *
 * @param ***REMOVED***string|Object|undefined***REMOVED*** options - An option value to parse.
 * @returns ***REMOVED******REMOVED***
 *   ObjectExpression: ***REMOVED***multiline: boolean, minProperties: number, consistent: boolean***REMOVED***,
 *   ObjectPattern: ***REMOVED***multiline: boolean, minProperties: number, consistent: boolean***REMOVED***,
 *   ImportDeclaration: ***REMOVED***multiline: boolean, minProperties: number, consistent: boolean***REMOVED***,
 *   ExportNamedDeclaration : ***REMOVED***multiline: boolean, minProperties: number, consistent: boolean***REMOVED***
 * ***REMOVED******REMOVED*** Normalized option object.
 */
function normalizeOptions(options) ***REMOVED***
    const isNodeSpecificOption = lodash.overSome([lodash.isPlainObject, lodash.isString]);

    if (lodash.isPlainObject(options) && lodash.some(options, isNodeSpecificOption)) ***REMOVED***
        return ***REMOVED***
            ObjectExpression: normalizeOptionValue(options.ObjectExpression),
            ObjectPattern: normalizeOptionValue(options.ObjectPattern),
            ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),
            ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)
        ***REMOVED***;
    ***REMOVED***

    const value = normalizeOptionValue(options);

    return ***REMOVED*** ObjectExpression: value, ObjectPattern: value, ImportDeclaration: value, ExportNamedDeclaration: value ***REMOVED***;
***REMOVED***

/**
 * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration
 * node needs to be checked for missing line breaks
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - Node under inspection
 * @param ***REMOVED***Object***REMOVED*** options - option specific to node type
 * @param ***REMOVED***Token***REMOVED*** first - First object property
 * @param ***REMOVED***Token***REMOVED*** last - Last object property
 * @returns ***REMOVED***boolean***REMOVED*** `true` if node needs to be checked for missing line breaks
 */
function areLineBreaksRequired(node, options, first, last) ***REMOVED***
    let objectProperties;

    if (node.type === "ObjectExpression" || node.type === "ObjectPattern") ***REMOVED***
        objectProperties = node.properties;
    ***REMOVED*** else ***REMOVED***

        // is ImportDeclaration or ExportNamedDeclaration
        objectProperties = node.specifiers
            .filter(s => s.type === "ImportSpecifier" || s.type === "ExportSpecifier");
    ***REMOVED***

    return objectProperties.length >= options.minProperties ||
        (
            options.multiline &&
            objectProperties.length > 0 &&
            first.loc.start.line !== last.loc.end.line
        );
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "enforce consistent line breaks inside braces",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/object-curly-newline"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            ***REMOVED***
                oneOf: [
                    OPTION_VALUE,
                    ***REMOVED***
                        type: "object",
                        properties: ***REMOVED***
                            ObjectExpression: OPTION_VALUE,
                            ObjectPattern: OPTION_VALUE,
                            ImportDeclaration: OPTION_VALUE,
                            ExportDeclaration: OPTION_VALUE
                        ***REMOVED***,
                        additionalProperties: false,
                        minProperties: 1
                    ***REMOVED***
                ]
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();
        const normalizedOptions = normalizeOptions(context.options[0]);

        /**
         * Reports a given node if it violated this rule.
         * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.
         * @returns ***REMOVED***void***REMOVED***
         */
        function check(node) ***REMOVED***
            const options = normalizedOptions[node.type];

            if (
                (node.type === "ImportDeclaration" &&
                    !node.specifiers.some(specifier => specifier.type === "ImportSpecifier")) ||
                (node.type === "ExportNamedDeclaration" &&
                    !node.specifiers.some(specifier => specifier.type === "ExportSpecifier"))
            ) ***REMOVED***
                return;
            ***REMOVED***

            const openBrace = sourceCode.getFirstToken(node, token => token.value === "***REMOVED***");

            let closeBrace;

            if (node.typeAnnotation) ***REMOVED***
                closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);
            ***REMOVED*** else ***REMOVED***
                closeBrace = sourceCode.getLastToken(node, token => token.value === "***REMOVED***");
            ***REMOVED***

            let first = sourceCode.getTokenAfter(openBrace, ***REMOVED*** includeComments: true ***REMOVED***);
            let last = sourceCode.getTokenBefore(closeBrace, ***REMOVED*** includeComments: true ***REMOVED***);

            const needsLineBreaks = areLineBreaksRequired(node, options, first, last);

            const hasCommentsFirstToken = astUtils.isCommentToken(first);
            const hasCommentsLastToken = astUtils.isCommentToken(last);

            /*
             * Use tokens or comments to check multiline or not.
             * But use only tokens to check whether line breaks are needed.
             * This allows:
             *     var obj = ***REMOVED*** // eslint-disable-line foo
             *         a: 1
             *     ***REMOVED***
             */
            first = sourceCode.getTokenAfter(openBrace);
            last = sourceCode.getTokenBefore(closeBrace);

            if (needsLineBreaks) ***REMOVED***
                if (astUtils.isTokenOnSameLine(openBrace, first)) ***REMOVED***
                    context.report(***REMOVED***
                        message: "Expected a line break after this opening brace.",
                        node,
                        loc: openBrace.loc.start,
                        fix(fixer) ***REMOVED***
                            if (hasCommentsFirstToken) ***REMOVED***
                                return null;
                            ***REMOVED***

                            return fixer.insertTextAfter(openBrace, "\n");
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
                if (astUtils.isTokenOnSameLine(last, closeBrace)) ***REMOVED***
                    context.report(***REMOVED***
                        message: "Expected a line break before this closing brace.",
                        node,
                        loc: closeBrace.loc.start,
                        fix(fixer) ***REMOVED***
                            if (hasCommentsLastToken) ***REMOVED***
                                return null;
                            ***REMOVED***

                            return fixer.insertTextBefore(closeBrace, "\n");
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED*** else ***REMOVED***
                const consistent = options.consistent;
                const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);
                const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);

                if (
                    (!consistent && hasLineBreakBetweenOpenBraceAndFirst) ||
                    (consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast)
                ) ***REMOVED***
                    context.report(***REMOVED***
                        message: "Unexpected line break after this opening brace.",
                        node,
                        loc: openBrace.loc.start,
                        fix(fixer) ***REMOVED***
                            if (hasCommentsFirstToken) ***REMOVED***
                                return null;
                            ***REMOVED***

                            return fixer.removeRange([
                                openBrace.range[1],
                                first.range[0]
                            ]);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
                if (
                    (!consistent && hasLineBreakBetweenCloseBraceAndLast) ||
                    (consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast)
                ) ***REMOVED***
                    context.report(***REMOVED***
                        message: "Unexpected line break before this closing brace.",
                        node,
                        loc: closeBrace.loc.start,
                        fix(fixer) ***REMOVED***
                            if (hasCommentsLastToken) ***REMOVED***
                                return null;
                            ***REMOVED***

                            return fixer.removeRange([
                                last.range[1],
                                closeBrace.range[0]
                            ]);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            ObjectExpression: check,
            ObjectPattern: check,
            ImportDeclaration: check,
            ExportNamedDeclaration: check
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
