/**
 * @fileoverview Rule to require object keys to be sorted
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils"),
    naturalCompare = require("natural-compare");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets the property name of the given `Property` node.
 *
 * - If the property's key is an `Identifier` node, this returns the key's name
 *   whether it's a computed property or not.
 * - If the property has a static name, this returns the static name.
 * - Otherwise, this returns null.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - The `Property` node to get.
 * @returns ***REMOVED***string|null***REMOVED*** The property name or null.
 * @private
 */
function getPropertyName(node) ***REMOVED***
    const staticName = astUtils.getStaticPropertyName(node);

    if (staticName !== null) ***REMOVED***
        return staticName;
    ***REMOVED***

    return node.key.name || null;
***REMOVED***

/**
 * Functions which check that the given 2 names are in specific order.
 *
 * Postfix `I` is meant insensitive.
 * Postfix `N` is meant natual.
 *
 * @private
 */
const isValidOrders = ***REMOVED***
    asc(a, b) ***REMOVED***
        return a <= b;
    ***REMOVED***,
    ascI(a, b) ***REMOVED***
        return a.toLowerCase() <= b.toLowerCase();
    ***REMOVED***,
    ascN(a, b) ***REMOVED***
        return naturalCompare(a, b) <= 0;
    ***REMOVED***,
    ascIN(a, b) ***REMOVED***
        return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;
    ***REMOVED***,
    desc(a, b) ***REMOVED***
        return isValidOrders.asc(b, a);
    ***REMOVED***,
    descI(a, b) ***REMOVED***
        return isValidOrders.ascI(b, a);
    ***REMOVED***,
    descN(a, b) ***REMOVED***
        return isValidOrders.ascN(b, a);
    ***REMOVED***,
    descIN(a, b) ***REMOVED***
        return isValidOrders.ascIN(b, a);
    ***REMOVED***
***REMOVED***;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "require object keys to be sorted",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/sort-keys"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                enum: ["asc", "desc"]
            ***REMOVED***,
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    caseSensitive: ***REMOVED***
                        type: "boolean",
                        default: true
                    ***REMOVED***,
                    natural: ***REMOVED***
                        type: "boolean",
                        default: false
                    ***REMOVED***,
                    minKeys: ***REMOVED***
                        type: "integer",
                        minimum: 2,
                        default: 2
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***

        // Parse options.
        const order = context.options[0] || "asc";
        const options = context.options[1];
        const insensitive = options && options.caseSensitive === false;
        const natual = options && options.natural;
        const minKeys = options && options.minKeys;
        const isValidOrder = isValidOrders[
            order + (insensitive ? "I" : "") + (natual ? "N" : "")
        ];

        // The stack to save the previous property's name for each object literals.
        let stack = null;

        return ***REMOVED***
            ObjectExpression(node) ***REMOVED***
                stack = ***REMOVED***
                    upper: stack,
                    prevName: null,
                    numKeys: node.properties.length
                ***REMOVED***;
            ***REMOVED***,

            "ObjectExpression:exit"() ***REMOVED***
                stack = stack.upper;
            ***REMOVED***,

            SpreadElement(node) ***REMOVED***
                if (node.parent.type === "ObjectExpression") ***REMOVED***
                    stack.prevName = null;
                ***REMOVED***
            ***REMOVED***,

            Property(node) ***REMOVED***
                if (node.parent.type === "ObjectPattern") ***REMOVED***
                    return;
                ***REMOVED***

                const prevName = stack.prevName;
                const numKeys = stack.numKeys;
                const thisName = getPropertyName(node);

                if (thisName !== null) ***REMOVED***
                    stack.prevName = thisName;
                ***REMOVED***

                if (prevName === null || thisName === null || numKeys < minKeys) ***REMOVED***
                    return;
                ***REMOVED***

                if (!isValidOrder(prevName, thisName)) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        loc: node.key.loc,
                        message: "Expected object keys to be in ***REMOVED******REMOVED***natual***REMOVED******REMOVED******REMOVED******REMOVED***insensitive***REMOVED******REMOVED******REMOVED******REMOVED***order***REMOVED******REMOVED***ending order. '***REMOVED******REMOVED***thisName***REMOVED******REMOVED***' should be before '***REMOVED******REMOVED***prevName***REMOVED******REMOVED***'.",
                        data: ***REMOVED***
                            thisName,
                            prevName,
                            order,
                            insensitive: insensitive ? "insensitive " : "",
                            natual: natual ? "natural " : ""
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
