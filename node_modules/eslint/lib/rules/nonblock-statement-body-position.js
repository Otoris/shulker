/**
 * @fileoverview enforce the location of single-line statements
 * @author Teddy Katz
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const POSITION_SCHEMA = ***REMOVED*** enum: ["beside", "below", "any"] ***REMOVED***;

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "enforce the location of single-line statements",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/nonblock-statement-body-position"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            POSITION_SCHEMA,
            ***REMOVED***
                properties: ***REMOVED***
                    overrides: ***REMOVED***
                        properties: ***REMOVED***
                            if: POSITION_SCHEMA,
                            else: POSITION_SCHEMA,
                            while: POSITION_SCHEMA,
                            do: POSITION_SCHEMA,
                            for: POSITION_SCHEMA
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();

        //----------------------------------------------------------------------
        // Helpers
        //----------------------------------------------------------------------

        /**
         * Gets the applicable preference for a particular keyword
         * @param ***REMOVED***string***REMOVED*** keywordName The name of a keyword, e.g. 'if'
         * @returns ***REMOVED***string***REMOVED*** The applicable option for the keyword, e.g. 'beside'
         */
        function getOption(keywordName) ***REMOVED***
            return context.options[1] && context.options[1].overrides && context.options[1].overrides[keywordName] ||
                context.options[0] ||
                "beside";
        ***REMOVED***

        /**
         * Validates the location of a single-line statement
         * @param ***REMOVED***ASTNode***REMOVED*** node The single-line statement
         * @param ***REMOVED***string***REMOVED*** keywordName The applicable keyword name for the single-line statement
         * @returns ***REMOVED***void***REMOVED***
         */
        function validateStatement(node, keywordName) ***REMOVED***
            const option = getOption(keywordName);

            if (node.type === "BlockStatement" || option === "any") ***REMOVED***
                return;
            ***REMOVED***

            const tokenBefore = sourceCode.getTokenBefore(node);

            if (tokenBefore.loc.end.line === node.loc.start.line && option === "below") ***REMOVED***
                context.report(***REMOVED***
                    node,
                    message: "Expected a linebreak before this statement.",
                    fix: fixer => fixer.insertTextBefore(node, "\n")
                ***REMOVED***);
            ***REMOVED*** else if (tokenBefore.loc.end.line !== node.loc.start.line && option === "beside") ***REMOVED***
                context.report(***REMOVED***
                    node,
                    message: "Expected no linebreak before this statement.",
                    fix(fixer) ***REMOVED***
                        if (sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim()) ***REMOVED***
                            return null;
                        ***REMOVED***
                        return fixer.replaceTextRange([tokenBefore.range[1], node.range[0]], " ");
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------

        return ***REMOVED***
            IfStatement(node) ***REMOVED***
                validateStatement(node.consequent, "if");

                // Check the `else` node, but don't check 'else if' statements.
                if (node.alternate && node.alternate.type !== "IfStatement") ***REMOVED***
                    validateStatement(node.alternate, "else");
                ***REMOVED***
            ***REMOVED***,
            WhileStatement: node => validateStatement(node.body, "while"),
            DoWhileStatement: node => validateStatement(node.body, "do"),
            ForStatement: node => validateStatement(node.body, "for"),
            ForInStatement: node => validateStatement(node.body, "for"),
            ForOfStatement: node => validateStatement(node.body, "for")
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
