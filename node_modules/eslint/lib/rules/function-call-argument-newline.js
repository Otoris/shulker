/**
 * @fileoverview Rule to enforce line breaks between arguments of a function call
 * @author Alexey Gonchar <https://github.com/finico>
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "enforce line breaks between arguments of a function call",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/function-call-argument-newline"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            ***REMOVED***
                enum: ["always", "never", "consistent"]
            ***REMOVED***
        ],

        messages: ***REMOVED***
            unexpectedLineBreak: "There should be no line break here.",
            missingLineBreak: "There should be a line break after this argument."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();

        const checkers = ***REMOVED***
            unexpected: ***REMOVED***
                messageId: "unexpectedLineBreak",
                check: (prevToken, currentToken) => prevToken.loc.start.line !== currentToken.loc.start.line,
                createFix: (token, tokenBefore) => fixer =>
                    fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ")
            ***REMOVED***,
            missing: ***REMOVED***
                messageId: "missingLineBreak",
                check: (prevToken, currentToken) => prevToken.loc.start.line === currentToken.loc.start.line,
                createFix: (token, tokenBefore) => fixer =>
                    fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n")
            ***REMOVED***
        ***REMOVED***;

        /**
         * Check all arguments for line breaks in the CallExpression
         * @param ***REMOVED***CallExpression***REMOVED*** node node to evaluate
         * @param ***REMOVED******REMOVED*** messageId: string, check: Function ***REMOVED******REMOVED*** checker selected checker
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkArguments(node, checker) ***REMOVED***
            for (let i = 1; i < node.arguments.length; i++) ***REMOVED***
                const prevArgToken = sourceCode.getFirstToken(node.arguments[i - 1]);
                const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);

                if (checker.check(prevArgToken, currentArgToken)) ***REMOVED***
                    const tokenBefore = sourceCode.getTokenBefore(
                        currentArgToken,
                        ***REMOVED*** includeComments: true ***REMOVED***
                    );

                    context.report(***REMOVED***
                        node,
                        loc: ***REMOVED***
                            start: tokenBefore.loc.end,
                            end: currentArgToken.loc.start
                        ***REMOVED***,
                        messageId: checker.messageId,
                        fix: checker.createFix(currentArgToken, tokenBefore)
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Check if open space is present in a function name
         * @param ***REMOVED***CallExpression***REMOVED*** node node to evaluate
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function check(node) ***REMOVED***
            if (node.arguments.length < 2) ***REMOVED***
                return;
            ***REMOVED***

            const option = context.options[0] || "always";

            if (option === "never") ***REMOVED***
                checkArguments(node, checkers.unexpected);
            ***REMOVED*** else if (option === "always") ***REMOVED***
                checkArguments(node, checkers.missing);
            ***REMOVED*** else if (option === "consistent") ***REMOVED***
                const firstArgToken = sourceCode.getFirstToken(node.arguments[0]);
                const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);

                if (firstArgToken.loc.start.line === secondArgToken.loc.start.line) ***REMOVED***
                    checkArguments(node, checkers.unexpected);
                ***REMOVED*** else ***REMOVED***
                    checkArguments(node, checkers.missing);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            CallExpression: check,
            NewExpression: check
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
