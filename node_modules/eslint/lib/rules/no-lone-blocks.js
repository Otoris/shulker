/**
 * @fileoverview Rule to flag blocks with no reason to exist
 * @author Brandon Mills
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow unnecessary nested blocks",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-lone-blocks"
        ***REMOVED***,

        schema: []
    ***REMOVED***,

    create(context) ***REMOVED***

        // A stack of lone blocks to be checked for block-level bindings
        const loneBlocks = [];
        let ruleDef;

        /**
         * Reports a node as invalid.
         * @param ***REMOVED***ASTNode***REMOVED*** node - The node to be reported.
         * @returns ***REMOVED***void***REMOVED***
         */
        function report(node) ***REMOVED***
            const message = node.parent.type === "BlockStatement" ? "Nested block is redundant." : "Block is redundant.";

            context.report(***REMOVED*** node, message ***REMOVED***);
        ***REMOVED***

        /**
         * Checks for any ocurrence of a BlockStatement in a place where lists of statements can appear
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check
         * @returns ***REMOVED***boolean***REMOVED*** True if the node is a lone block.
         */
        function isLoneBlock(node) ***REMOVED***
            return node.parent.type === "BlockStatement" ||
                node.parent.type === "Program" ||

                // Don't report blocks in switch cases if the block is the only statement of the case.
                node.parent.type === "SwitchCase" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);
        ***REMOVED***

        /**
         * Checks the enclosing block of the current node for block-level bindings,
         * and "marks it" as valid if any.
         * @returns ***REMOVED***void***REMOVED***
         */
        function markLoneBlock() ***REMOVED***
            if (loneBlocks.length === 0) ***REMOVED***
                return;
            ***REMOVED***

            const block = context.getAncestors().pop();

            if (loneBlocks[loneBlocks.length - 1] === block) ***REMOVED***
                loneBlocks.pop();
            ***REMOVED***
        ***REMOVED***

        // Default rule definition: report all lone blocks
        ruleDef = ***REMOVED***
            BlockStatement(node) ***REMOVED***
                if (isLoneBlock(node)) ***REMOVED***
                    report(node);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

        // ES6: report blocks without block-level bindings, or that's only child of another block
        if (context.parserOptions.ecmaVersion >= 6) ***REMOVED***
            ruleDef = ***REMOVED***
                BlockStatement(node) ***REMOVED***
                    if (isLoneBlock(node)) ***REMOVED***
                        loneBlocks.push(node);
                    ***REMOVED***
                ***REMOVED***,
                "BlockStatement:exit"(node) ***REMOVED***
                    if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) ***REMOVED***
                        loneBlocks.pop();
                        report(node);
                    ***REMOVED*** else if (
                        node.parent.type === "BlockStatement" &&
                        node.parent.body.length === 1
                    ) ***REMOVED***
                        report(node);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***;

            ruleDef.VariableDeclaration = function(node) ***REMOVED***
                if (node.kind === "let" || node.kind === "const") ***REMOVED***
                    markLoneBlock();
                ***REMOVED***
            ***REMOVED***;

            ruleDef.FunctionDeclaration = function() ***REMOVED***
                if (context.getScope().isStrict) ***REMOVED***
                    markLoneBlock();
                ***REMOVED***
            ***REMOVED***;

            ruleDef.ClassDeclaration = markLoneBlock;
        ***REMOVED***

        return ruleDef;
    ***REMOVED***
***REMOVED***;
