/**
 * @fileoverview Validates spacing before and after semicolon
 * @author Mathias Schreck
 */

"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "enforce consistent spacing before and after semicolons",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/semi-spacing"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    before: ***REMOVED***
                        type: "boolean",
                        default: false
                    ***REMOVED***,
                    after: ***REMOVED***
                        type: "boolean",
                        default: true
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***

        const config = context.options[0],
            sourceCode = context.getSourceCode();
        let requireSpaceBefore = false,
            requireSpaceAfter = true;

        if (typeof config === "object") ***REMOVED***
            requireSpaceBefore = config.before;
            requireSpaceAfter = config.after;
        ***REMOVED***

        /**
         * Checks if a given token has leading whitespace.
         * @param ***REMOVED***Object***REMOVED*** token The token to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the given token has leading space, false if not.
         */
        function hasLeadingSpace(token) ***REMOVED***
            const tokenBefore = sourceCode.getTokenBefore(token);

            return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);
        ***REMOVED***

        /**
         * Checks if a given token has trailing whitespace.
         * @param ***REMOVED***Object***REMOVED*** token The token to check.
         * @returns ***REMOVED***boolean***REMOVED*** True if the given token has trailing space, false if not.
         */
        function hasTrailingSpace(token) ***REMOVED***
            const tokenAfter = sourceCode.getTokenAfter(token);

            return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);
        ***REMOVED***

        /**
         * Checks if the given token is the last token in its line.
         * @param ***REMOVED***Token***REMOVED*** token The token to check.
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not the token is the last in its line.
         */
        function isLastTokenInCurrentLine(token) ***REMOVED***
            const tokenAfter = sourceCode.getTokenAfter(token);

            return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));
        ***REMOVED***

        /**
         * Checks if the given token is the first token in its line
         * @param ***REMOVED***Token***REMOVED*** token The token to check.
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not the token is the first in its line.
         */
        function isFirstTokenInCurrentLine(token) ***REMOVED***
            const tokenBefore = sourceCode.getTokenBefore(token);

            return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));
        ***REMOVED***

        /**
         * Checks if the next token of a given token is a closing parenthesis.
         * @param ***REMOVED***Token***REMOVED*** token The token to check.
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not the next token of a given token is a closing parenthesis.
         */
        function isBeforeClosingParen(token) ***REMOVED***
            const nextToken = sourceCode.getTokenAfter(token);

            return (nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken));
        ***REMOVED***

        /**
         * Reports if the given token has invalid spacing.
         * @param ***REMOVED***Token***REMOVED*** token The semicolon token to check.
         * @param ***REMOVED***ASTNode***REMOVED*** node The corresponding node of the token.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkSemicolonSpacing(token, node) ***REMOVED***
            if (astUtils.isSemicolonToken(token)) ***REMOVED***
                const location = token.loc.start;

                if (hasLeadingSpace(token)) ***REMOVED***
                    if (!requireSpaceBefore) ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            loc: location,
                            message: "Unexpected whitespace before semicolon.",
                            fix(fixer) ***REMOVED***
                                const tokenBefore = sourceCode.getTokenBefore(token);

                                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
                            ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED***
                ***REMOVED*** else ***REMOVED***
                    if (requireSpaceBefore) ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            loc: location,
                            message: "Missing whitespace before semicolon.",
                            fix(fixer) ***REMOVED***
                                return fixer.insertTextBefore(token, " ");
                            ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED***
                ***REMOVED***

                if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) ***REMOVED***
                    if (hasTrailingSpace(token)) ***REMOVED***
                        if (!requireSpaceAfter) ***REMOVED***
                            context.report(***REMOVED***
                                node,
                                loc: location,
                                message: "Unexpected whitespace after semicolon.",
                                fix(fixer) ***REMOVED***
                                    const tokenAfter = sourceCode.getTokenAfter(token);

                                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
                                ***REMOVED***
                            ***REMOVED***);
                        ***REMOVED***
                    ***REMOVED*** else ***REMOVED***
                        if (requireSpaceAfter) ***REMOVED***
                            context.report(***REMOVED***
                                node,
                                loc: location,
                                message: "Missing whitespace after semicolon.",
                                fix(fixer) ***REMOVED***
                                    return fixer.insertTextAfter(token, " ");
                                ***REMOVED***
                            ***REMOVED***);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkNode(node) ***REMOVED***
            const token = sourceCode.getLastToken(node);

            checkSemicolonSpacing(token, node);
        ***REMOVED***

        return ***REMOVED***
            VariableDeclaration: checkNode,
            ExpressionStatement: checkNode,
            BreakStatement: checkNode,
            ContinueStatement: checkNode,
            DebuggerStatement: checkNode,
            ReturnStatement: checkNode,
            ThrowStatement: checkNode,
            ImportDeclaration: checkNode,
            ExportNamedDeclaration: checkNode,
            ExportAllDeclaration: checkNode,
            ExportDefaultDeclaration: checkNode,
            ForStatement(node) ***REMOVED***
                if (node.init) ***REMOVED***
                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);
                ***REMOVED***

                if (node.test) ***REMOVED***
                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
