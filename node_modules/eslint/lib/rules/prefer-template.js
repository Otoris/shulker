/**
 * @fileoverview A rule to suggest using template literals instead of string concatenation.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given node is a concatenation.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a concatenation.
 */
function isConcatenation(node) ***REMOVED***
    return node.type === "BinaryExpression" && node.operator === "+";
***REMOVED***

/**
 * Gets the top binary expression node for concatenation in parents of a given node.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to get.
 * @returns ***REMOVED***ASTNode***REMOVED*** the top binary expression node in parents of a given node.
 */
function getTopConcatBinaryExpression(node) ***REMOVED***
    let currentNode = node;

    while (isConcatenation(currentNode.parent)) ***REMOVED***
        currentNode = currentNode.parent;
    ***REMOVED***
    return currentNode;
***REMOVED***

/**
 * Determines whether a given node is a octal escape sequence
 * @param ***REMOVED***ASTNode***REMOVED*** node A node to check
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is an octal escape sequence
 */
function isOctalEscapeSequence(node) ***REMOVED***

    // No need to check TemplateLiterals â€“ would throw error with octal escape
    const isStringLiteral = node.type === "Literal" && typeof node.value === "string";

    if (!isStringLiteral) ***REMOVED***
        return false;
    ***REMOVED***

    return astUtils.hasOctalEscapeSequence(node.raw);
***REMOVED***

/**
 * Checks whether or not a node contains a octal escape sequence
 * @param ***REMOVED***ASTNode***REMOVED*** node A node to check
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node contains an octal escape sequence
 */
function hasOctalEscapeSequence(node) ***REMOVED***
    if (isConcatenation(node)) ***REMOVED***
        return hasOctalEscapeSequence(node.left) || hasOctalEscapeSequence(node.right);
    ***REMOVED***

    return isOctalEscapeSequence(node);
***REMOVED***

/**
 * Checks whether or not a given binary expression has string literals.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node has string literals.
 */
function hasStringLiteral(node) ***REMOVED***
    if (isConcatenation(node)) ***REMOVED***

        // `left` is deeper than `right` normally.
        return hasStringLiteral(node.right) || hasStringLiteral(node.left);
    ***REMOVED***
    return astUtils.isStringLiteral(node);
***REMOVED***

/**
 * Checks whether or not a given binary expression has non string literals.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node has non string literals.
 */
function hasNonStringLiteral(node) ***REMOVED***
    if (isConcatenation(node)) ***REMOVED***

        // `left` is deeper than `right` normally.
        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);
    ***REMOVED***
    return !astUtils.isStringLiteral(node);
***REMOVED***

/**
 * Determines whether a given node will start with a template curly expression (`$***REMOVED******REMOVED***`) when being converted to a template literal.
 * @param ***REMOVED***ASTNode***REMOVED*** node The node that will be fixed to a template literal
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node will start with a template curly.
 */
function startsWithTemplateCurly(node) ***REMOVED***
    if (node.type === "BinaryExpression") ***REMOVED***
        return startsWithTemplateCurly(node.left);
    ***REMOVED***
    if (node.type === "TemplateLiteral") ***REMOVED***
        return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];
    ***REMOVED***
    return node.type !== "Literal" || typeof node.value !== "string";
***REMOVED***

/**
 * Determines whether a given node end with a template curly expression (`$***REMOVED******REMOVED***`) when being converted to a template literal.
 * @param ***REMOVED***ASTNode***REMOVED*** node The node that will be fixed to a template literal
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node will end with a template curly.
 */
function endsWithTemplateCurly(node) ***REMOVED***
    if (node.type === "BinaryExpression") ***REMOVED***
        return startsWithTemplateCurly(node.right);
    ***REMOVED***
    if (node.type === "TemplateLiteral") ***REMOVED***
        return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];
    ***REMOVED***
    return node.type !== "Literal" || typeof node.value !== "string";
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "require template literals instead of string concatenation",
            category: "ECMAScript 6",
            recommended: false,
            url: "https://eslint.org/docs/rules/prefer-template"
        ***REMOVED***,

        schema: [],
        fixable: "code"
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();
        let done = Object.create(null);

        /**
         * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.
         * @param ***REMOVED***ASTNode***REMOVED*** node1 The first node
         * @param ***REMOVED***ASTNode***REMOVED*** node2 The second node
         * @returns ***REMOVED***string***REMOVED*** The text between the nodes, excluding other tokens
         */
        function getTextBetween(node1, node2) ***REMOVED***
            const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);
            const sourceText = sourceCode.getText();

            return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), "");
        ***REMOVED***

        /**
         * Returns a template literal form of the given node.
         * @param ***REMOVED***ASTNode***REMOVED*** currentNode A node that should be converted to a template literal
         * @param ***REMOVED***string***REMOVED*** textBeforeNode Text that should appear before the node
         * @param ***REMOVED***string***REMOVED*** textAfterNode Text that should appear after the node
         * @returns ***REMOVED***string***REMOVED*** A string form of this node, represented as a template literal
         */
        function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) ***REMOVED***
            if (currentNode.type === "Literal" && typeof currentNode.value === "string") ***REMOVED***

                /*
                 * If the current node is a string literal, escape any instances of $***REMOVED*** or ` to prevent them from being interpreted
                 * as a template placeholder. However, if the code already contains a backslash before the $***REMOVED*** or `
                 * for some reason, don't add another backslash, because that would change the meaning of the code (it would cause
                 * an actual backslash character to appear before the dollar sign).
                 */
                return `\`$***REMOVED***currentNode.raw.slice(1, -1).replace(/\\*(\$\***REMOVED***|`)/gu, matched => ***REMOVED***
                    if (matched.lastIndexOf("\\") % 2) ***REMOVED***
                        return `\\$***REMOVED***matched***REMOVED***`;
                    ***REMOVED***
                    return matched;

                // Unescape any quotes that appear in the original Literal that no longer need to be escaped.
                ***REMOVED***).replace(new RegExp(`\\\\$***REMOVED***currentNode.raw[0]***REMOVED***`, "gu"), currentNode.raw[0])***REMOVED***\``;
            ***REMOVED***

            if (currentNode.type === "TemplateLiteral") ***REMOVED***
                return sourceCode.getText(currentNode);
            ***REMOVED***

            if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) ***REMOVED***
                const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, token => token.value === "+");
                const textBeforePlus = getTextBetween(currentNode.left, plusSign);
                const textAfterPlus = getTextBetween(plusSign, currentNode.right);
                const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);
                const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);

                if (leftEndsWithCurly) ***REMOVED***

                    // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.
                    // `foo$***REMOVED***bar***REMOVED***` /* comment */ + 'baz' --> `foo$***REMOVED***bar /* comment */  ***REMOVED***$***REMOVED***baz***REMOVED***`
                    return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) +
                        getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);
                ***REMOVED***
                if (rightStartsWithCurly) ***REMOVED***

                    // Otherwise, if the right side of the expression starts with a template curly, add the text there.
                    // 'foo' /* comment */ + `$***REMOVED***bar***REMOVED***baz` --> `foo$***REMOVED*** /* comment */  bar***REMOVED***baz`
                    return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) +
                        getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);
                ***REMOVED***

                /*
                 * Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put
                 * the text between them.
                 */
                return `$***REMOVED***getTemplateLiteral(currentNode.left, textBeforeNode, null)***REMOVED***$***REMOVED***textBeforePlus***REMOVED***+$***REMOVED***textAfterPlus***REMOVED***$***REMOVED***getTemplateLiteral(currentNode.right, textAfterNode, null)***REMOVED***`;
            ***REMOVED***

            return `\`\$***REMOVED***$***REMOVED***textBeforeNode || ""***REMOVED***$***REMOVED***sourceCode.getText(currentNode)***REMOVED***$***REMOVED***textAfterNode || ""***REMOVED******REMOVED***\``;
        ***REMOVED***

        /**
         * Returns a fixer object that converts a non-string binary expression to a template literal
         * @param ***REMOVED***SourceCodeFixer***REMOVED*** fixer The fixer object
         * @param ***REMOVED***ASTNode***REMOVED*** node A node that should be converted to a template literal
         * @returns ***REMOVED***Object***REMOVED*** A fix for this binary expression
         */
        function fixNonStringBinaryExpression(fixer, node) ***REMOVED***
            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);

            if (hasOctalEscapeSequence(topBinaryExpr)) ***REMOVED***
                return null;
            ***REMOVED***

            return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));
        ***REMOVED***

        /**
         * Reports if a given node is string concatenation with non string literals.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkForStringConcat(node) ***REMOVED***
            if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) ***REMOVED***
                return;
            ***REMOVED***

            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);

            // Checks whether or not this node had been checked already.
            if (done[topBinaryExpr.range[0]]) ***REMOVED***
                return;
            ***REMOVED***
            done[topBinaryExpr.range[0]] = true;

            if (hasNonStringLiteral(topBinaryExpr)) ***REMOVED***
                context.report(***REMOVED***
                    node: topBinaryExpr,
                    message: "Unexpected string concatenation.",
                    fix: fixer => fixNonStringBinaryExpression(fixer, node)
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            Program() ***REMOVED***
                done = Object.create(null);
            ***REMOVED***,

            Literal: checkForStringConcat,
            TemplateLiteral: checkForStringConcat
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
