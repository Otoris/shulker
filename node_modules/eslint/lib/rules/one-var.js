/**
 * @fileoverview A rule to control the use of single variable declarations.
 * @author Ian Christian Myers
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "enforce variables to be declared either together or separately in functions",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/one-var"
        ***REMOVED***,

        fixable: "code",

        schema: [
            ***REMOVED***
                oneOf: [
                    ***REMOVED***
                        enum: ["always", "never", "consecutive"]
                    ***REMOVED***,
                    ***REMOVED***
                        type: "object",
                        properties: ***REMOVED***
                            separateRequires: ***REMOVED***
                                type: "boolean"
                            ***REMOVED***,
                            var: ***REMOVED***
                                enum: ["always", "never", "consecutive"]
                            ***REMOVED***,
                            let: ***REMOVED***
                                enum: ["always", "never", "consecutive"]
                            ***REMOVED***,
                            const: ***REMOVED***
                                enum: ["always", "never", "consecutive"]
                            ***REMOVED***
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***,
                    ***REMOVED***
                        type: "object",
                        properties: ***REMOVED***
                            initialized: ***REMOVED***
                                enum: ["always", "never", "consecutive"]
                            ***REMOVED***,
                            uninitialized: ***REMOVED***
                                enum: ["always", "never", "consecutive"]
                            ***REMOVED***
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***
                ]
            ***REMOVED***
        ]
    ***REMOVED***,

    create(context) ***REMOVED***
        const MODE_ALWAYS = "always";
        const MODE_NEVER = "never";
        const MODE_CONSECUTIVE = "consecutive";
        const mode = context.options[0] || MODE_ALWAYS;

        const options = ***REMOVED******REMOVED***;

        if (typeof mode === "string") ***REMOVED*** // simple options configuration with just a string
            options.var = ***REMOVED*** uninitialized: mode, initialized: mode ***REMOVED***;
            options.let = ***REMOVED*** uninitialized: mode, initialized: mode ***REMOVED***;
            options.const = ***REMOVED*** uninitialized: mode, initialized: mode ***REMOVED***;
        ***REMOVED*** else if (typeof mode === "object") ***REMOVED*** // options configuration is an object
            options.separateRequires = !!mode.separateRequires;
            options.var = ***REMOVED*** uninitialized: mode.var, initialized: mode.var ***REMOVED***;
            options.let = ***REMOVED*** uninitialized: mode.let, initialized: mode.let ***REMOVED***;
            options.const = ***REMOVED*** uninitialized: mode.const, initialized: mode.const ***REMOVED***;
            if (Object.prototype.hasOwnProperty.call(mode, "uninitialized")) ***REMOVED***
                options.var.uninitialized = mode.uninitialized;
                options.let.uninitialized = mode.uninitialized;
                options.const.uninitialized = mode.uninitialized;
            ***REMOVED***
            if (Object.prototype.hasOwnProperty.call(mode, "initialized")) ***REMOVED***
                options.var.initialized = mode.initialized;
                options.let.initialized = mode.initialized;
                options.const.initialized = mode.initialized;
            ***REMOVED***
        ***REMOVED***

        const sourceCode = context.getSourceCode();

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        const functionStack = [];
        const blockStack = [];

        /**
         * Increments the blockStack counter.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function startBlock() ***REMOVED***
            blockStack.push(***REMOVED***
                let: ***REMOVED*** initialized: false, uninitialized: false ***REMOVED***,
                const: ***REMOVED*** initialized: false, uninitialized: false ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        /**
         * Increments the functionStack counter.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function startFunction() ***REMOVED***
            functionStack.push(***REMOVED*** initialized: false, uninitialized: false ***REMOVED***);
            startBlock();
        ***REMOVED***

        /**
         * Decrements the blockStack counter.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function endBlock() ***REMOVED***
            blockStack.pop();
        ***REMOVED***

        /**
         * Decrements the functionStack counter.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function endFunction() ***REMOVED***
            functionStack.pop();
            endBlock();
        ***REMOVED***

        /**
         * Check if a variable declaration is a require.
         * @param ***REMOVED***ASTNode***REMOVED*** decl variable declaration Node
         * @returns ***REMOVED***bool***REMOVED*** if decl is a require, return true; else return false.
         * @private
         */
        function isRequire(decl) ***REMOVED***
            return decl.init && decl.init.type === "CallExpression" && decl.init.callee.name === "require";
        ***REMOVED***

        /**
         * Records whether initialized/uninitialized/required variables are defined in current scope.
         * @param ***REMOVED***string***REMOVED*** statementType node.kind, one of: "var", "let", or "const"
         * @param ***REMOVED***ASTNode[]***REMOVED*** declarations List of declarations
         * @param ***REMOVED***Object***REMOVED*** currentScope The scope being investigated
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function recordTypes(statementType, declarations, currentScope) ***REMOVED***
            for (let i = 0; i < declarations.length; i++) ***REMOVED***
                if (declarations[i].init === null) ***REMOVED***
                    if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) ***REMOVED***
                        currentScope.uninitialized = true;
                    ***REMOVED***
                ***REMOVED*** else ***REMOVED***
                    if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) ***REMOVED***
                        if (options.separateRequires && isRequire(declarations[i])) ***REMOVED***
                            currentScope.required = true;
                        ***REMOVED*** else ***REMOVED***
                            currentScope.initialized = true;
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Determines the current scope (function or block)
         * @param  ***REMOVED***string***REMOVED*** statementType node.kind, one of: "var", "let", or "const"
         * @returns ***REMOVED***Object***REMOVED*** The scope associated with statementType
         */
        function getCurrentScope(statementType) ***REMOVED***
            let currentScope;

            if (statementType === "var") ***REMOVED***
                currentScope = functionStack[functionStack.length - 1];
            ***REMOVED*** else if (statementType === "let") ***REMOVED***
                currentScope = blockStack[blockStack.length - 1].let;
            ***REMOVED*** else if (statementType === "const") ***REMOVED***
                currentScope = blockStack[blockStack.length - 1].const;
            ***REMOVED***
            return currentScope;
        ***REMOVED***

        /**
         * Counts the number of initialized and uninitialized declarations in a list of declarations
         * @param ***REMOVED***ASTNode[]***REMOVED*** declarations List of declarations
         * @returns ***REMOVED***Object***REMOVED*** Counts of 'uninitialized' and 'initialized' declarations
         * @private
         */
        function countDeclarations(declarations) ***REMOVED***
            const counts = ***REMOVED*** uninitialized: 0, initialized: 0 ***REMOVED***;

            for (let i = 0; i < declarations.length; i++) ***REMOVED***
                if (declarations[i].init === null) ***REMOVED***
                    counts.uninitialized++;
                ***REMOVED*** else ***REMOVED***
                    counts.initialized++;
                ***REMOVED***
            ***REMOVED***
            return counts;
        ***REMOVED***

        /**
         * Determines if there is more than one var statement in the current scope.
         * @param ***REMOVED***string***REMOVED*** statementType node.kind, one of: "var", "let", or "const"
         * @param ***REMOVED***ASTNode[]***REMOVED*** declarations List of declarations
         * @returns ***REMOVED***boolean***REMOVED*** Returns true if it is the first var declaration, false if not.
         * @private
         */
        function hasOnlyOneStatement(statementType, declarations) ***REMOVED***

            const declarationCounts = countDeclarations(declarations);
            const currentOptions = options[statementType] || ***REMOVED******REMOVED***;
            const currentScope = getCurrentScope(statementType);
            const hasRequires = declarations.some(isRequire);

            if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) ***REMOVED***
                if (currentScope.uninitialized || currentScope.initialized) ***REMOVED***
                    if (!hasRequires) ***REMOVED***
                        return false;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***

            if (declarationCounts.uninitialized > 0) ***REMOVED***
                if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) ***REMOVED***
                    return false;
                ***REMOVED***
            ***REMOVED***
            if (declarationCounts.initialized > 0) ***REMOVED***
                if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) ***REMOVED***
                    if (!hasRequires) ***REMOVED***
                        return false;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            if (currentScope.required && hasRequires) ***REMOVED***
                return false;
            ***REMOVED***
            recordTypes(statementType, declarations, currentScope);
            return true;
        ***REMOVED***

        /**
         * Fixer to join VariableDeclaration's into a single declaration
         * @param   ***REMOVED***VariableDeclarator[]***REMOVED*** declarations The `VariableDeclaration` to join
         * @returns ***REMOVED***Function***REMOVED***                         The fixer function
         */
        function joinDeclarations(declarations) ***REMOVED***
            const declaration = declarations[0];
            const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];
            const currentIndex = body.findIndex(node => node.range[0] === declaration.parent.range[0]);
            const previousNode = body[currentIndex - 1];

            return fixer => ***REMOVED***
                const type = sourceCode.getTokenBefore(declaration);
                const prevSemi = sourceCode.getTokenBefore(type);
                const res = [];

                if (previousNode && previousNode.kind === sourceCode.getText(type)) ***REMOVED***
                    if (prevSemi.value === ";") ***REMOVED***
                        res.push(fixer.replaceText(prevSemi, ","));
                    ***REMOVED*** else ***REMOVED***
                        res.push(fixer.insertTextAfter(prevSemi, ","));
                    ***REMOVED***
                    res.push(fixer.replaceText(type, ""));
                ***REMOVED***

                return res;
            ***REMOVED***;
        ***REMOVED***

        /**
         * Fixer to split a VariableDeclaration into individual declarations
         * @param   ***REMOVED***VariableDeclaration***REMOVED***   declaration The `VariableDeclaration` to split
         * @returns ***REMOVED***Function***REMOVED***                          The fixer function
         */
        function splitDeclarations(declaration) ***REMOVED***
            return fixer => declaration.declarations.map(declarator => ***REMOVED***
                const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);

                if (tokenAfterDeclarator === null) ***REMOVED***
                    return null;
                ***REMOVED***

                const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, ***REMOVED*** includeComments: true ***REMOVED***);

                if (tokenAfterDeclarator.value !== ",") ***REMOVED***
                    return null;
                ***REMOVED***

                /*
                 * `var x,y`
                 * tokenAfterDeclarator ^^ afterComma
                 */
                if (afterComma.range[0] === tokenAfterDeclarator.range[1]) ***REMOVED***
                    return fixer.replaceText(tokenAfterDeclarator, `; $***REMOVED***declaration.kind***REMOVED*** `);
                ***REMOVED***

                /*
                 * `var x,
                 * tokenAfterDeclarator ^
                 *      y`
                 *      ^ afterComma
                 */
                if (
                    afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line ||
                    afterComma.type === "Line" ||
                    afterComma.type === "Block"
                ) ***REMOVED***
                    let lastComment = afterComma;

                    while (lastComment.type === "Line" || lastComment.type === "Block") ***REMOVED***
                        lastComment = sourceCode.getTokenAfter(lastComment, ***REMOVED*** includeComments: true ***REMOVED***);
                    ***REMOVED***

                    return fixer.replaceTextRange(
                        [tokenAfterDeclarator.range[0], lastComment.range[0]],
                        `;$***REMOVED***sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])***REMOVED***$***REMOVED***declaration.kind***REMOVED*** `
                    );
                ***REMOVED***

                return fixer.replaceText(tokenAfterDeclarator, `; $***REMOVED***declaration.kind***REMOVED***`);
            ***REMOVED***).filter(x => x);
        ***REMOVED***

        /**
         * Checks a given VariableDeclaration node for errors.
         * @param ***REMOVED***ASTNode***REMOVED*** node The VariableDeclaration node to check
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function checkVariableDeclaration(node) ***REMOVED***
            const parent = node.parent;
            const type = node.kind;

            if (!options[type]) ***REMOVED***
                return;
            ***REMOVED***

            const declarations = node.declarations;
            const declarationCounts = countDeclarations(declarations);
            const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);

            if (options[type].initialized === MODE_ALWAYS) ***REMOVED***
                if (options.separateRequires && mixedRequires) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        message: "Split requires to be separated into a single block."
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***

            // consecutive
            const nodeIndex = (parent.body && parent.body.length > 0 && parent.body.indexOf(node)) || 0;

            if (nodeIndex > 0) ***REMOVED***
                const previousNode = parent.body[nodeIndex - 1];
                const isPreviousNodeDeclaration = previousNode.type === "VariableDeclaration";
                const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);

                if (
                    isPreviousNodeDeclaration &&
                    previousNode.kind === type &&
                    !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))
                ) ***REMOVED***
                    const previousDeclCounts = countDeclarations(previousNode.declarations);

                    if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            message: "Combine this with the previous '***REMOVED******REMOVED***type***REMOVED******REMOVED***' statement.",
                            data: ***REMOVED***
                                type
                            ***REMOVED***,
                            fix: joinDeclarations(declarations)
                        ***REMOVED***);
                    ***REMOVED*** else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            message: "Combine this with the previous '***REMOVED******REMOVED***type***REMOVED******REMOVED***' statement with initialized variables.",
                            data: ***REMOVED***
                                type
                            ***REMOVED***,
                            fix: joinDeclarations(declarations)
                        ***REMOVED***);
                    ***REMOVED*** else if (options[type].uninitialized === MODE_CONSECUTIVE &&
                            declarationCounts.uninitialized > 0 &&
                            previousDeclCounts.uninitialized > 0) ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            message: "Combine this with the previous '***REMOVED******REMOVED***type***REMOVED******REMOVED***' statement with uninitialized variables.",
                            data: ***REMOVED***
                                type
                            ***REMOVED***,
                            fix: joinDeclarations(declarations)
                        ***REMOVED***);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***

            // always
            if (!hasOnlyOneStatement(type, declarations)) ***REMOVED***
                if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        message: "Combine this with the previous '***REMOVED******REMOVED***type***REMOVED******REMOVED***' statement.",
                        data: ***REMOVED***
                            type
                        ***REMOVED***,
                        fix: joinDeclarations(declarations)
                    ***REMOVED***);
                ***REMOVED*** else ***REMOVED***
                    if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            message: "Combine this with the previous '***REMOVED******REMOVED***type***REMOVED******REMOVED***' statement with initialized variables.",
                            data: ***REMOVED***
                                type
                            ***REMOVED***,
                            fix: joinDeclarations(declarations)
                        ***REMOVED***);
                    ***REMOVED***
                    if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) ***REMOVED***
                        if (node.parent.left === node && (node.parent.type === "ForInStatement" || node.parent.type === "ForOfStatement")) ***REMOVED***
                            return;
                        ***REMOVED***
                        context.report(***REMOVED***
                            node,
                            message: "Combine this with the previous '***REMOVED******REMOVED***type***REMOVED******REMOVED***' statement with uninitialized variables.",
                            data: ***REMOVED***
                                type
                            ***REMOVED***,
                            fix: joinDeclarations(declarations)
                        ***REMOVED***);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***

            // never
            if (parent.type !== "ForStatement" || parent.init !== node) ***REMOVED***
                const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;

                if (totalDeclarations > 1) ***REMOVED***
                    if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) ***REMOVED***

                        // both initialized and uninitialized
                        context.report(***REMOVED***
                            node,
                            message: "Split '***REMOVED******REMOVED***type***REMOVED******REMOVED***' declarations into multiple statements.",
                            data: ***REMOVED***
                                type
                            ***REMOVED***,
                            fix: splitDeclarations(node)
                        ***REMOVED***);
                    ***REMOVED*** else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) ***REMOVED***

                        // initialized
                        context.report(***REMOVED***
                            node,
                            message: "Split initialized '***REMOVED******REMOVED***type***REMOVED******REMOVED***' declarations into multiple statements.",
                            data: ***REMOVED***
                                type
                            ***REMOVED***,
                            fix: splitDeclarations(node)
                        ***REMOVED***);
                    ***REMOVED*** else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) ***REMOVED***

                        // uninitialized
                        context.report(***REMOVED***
                            node,
                            message: "Split uninitialized '***REMOVED******REMOVED***type***REMOVED******REMOVED***' declarations into multiple statements.",
                            data: ***REMOVED***
                                type
                            ***REMOVED***,
                            fix: splitDeclarations(node)
                        ***REMOVED***);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public API
        //--------------------------------------------------------------------------

        return ***REMOVED***
            Program: startFunction,
            FunctionDeclaration: startFunction,
            FunctionExpression: startFunction,
            ArrowFunctionExpression: startFunction,
            BlockStatement: startBlock,
            ForStatement: startBlock,
            ForInStatement: startBlock,
            ForOfStatement: startBlock,
            SwitchStatement: startBlock,
            VariableDeclaration: checkVariableDeclaration,
            "ForStatement:exit": endBlock,
            "ForOfStatement:exit": endBlock,
            "ForInStatement:exit": endBlock,
            "SwitchStatement:exit": endBlock,
            "BlockStatement:exit": endBlock,
            "Program:exit": endFunction,
            "FunctionDeclaration:exit": endFunction,
            "FunctionExpression:exit": endFunction,
            "ArrowFunctionExpression:exit": endFunction
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
