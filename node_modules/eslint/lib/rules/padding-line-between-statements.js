/**
 * @fileoverview Rule to require or disallow newlines between statements
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const LT = `[$***REMOVED***Array.from(astUtils.LINEBREAKS).join("")***REMOVED***]`;
const PADDING_LINE_SEQUENCE = new RegExp(
    String.raw`^(\s*?$***REMOVED***LT***REMOVED***)\s*$***REMOVED***LT***REMOVED***(\s*;?)$`,
    "u"
);
const CJS_EXPORT = /^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/u;
const CJS_IMPORT = /^require\(/u;

/**
 * Creates tester which check if a node starts with specific keyword.
 *
 * @param ***REMOVED***string***REMOVED*** keyword The keyword to test.
 * @returns ***REMOVED***Object***REMOVED*** the created tester.
 * @private
 */
function newKeywordTester(keyword) ***REMOVED***
    return ***REMOVED***
        test: (node, sourceCode) =>
            sourceCode.getFirstToken(node).value === keyword
    ***REMOVED***;
***REMOVED***

/**
 * Creates tester which check if a node starts with specific keyword and spans a single line.
 *
 * @param ***REMOVED***string***REMOVED*** keyword The keyword to test.
 * @returns ***REMOVED***Object***REMOVED*** the created tester.
 * @private
 */
function newSinglelineKeywordTester(keyword) ***REMOVED***
    return ***REMOVED***
        test: (node, sourceCode) =>
            node.loc.start.line === node.loc.end.line &&
            sourceCode.getFirstToken(node).value === keyword
    ***REMOVED***;
***REMOVED***

/**
 * Creates tester which check if a node starts with specific keyword and spans multiple lines.
 *
 * @param ***REMOVED***string***REMOVED*** keyword The keyword to test.
 * @returns ***REMOVED***Object***REMOVED*** the created tester.
 * @private
 */
function newMultilineKeywordTester(keyword) ***REMOVED***
    return ***REMOVED***
        test: (node, sourceCode) =>
            node.loc.start.line !== node.loc.end.line &&
            sourceCode.getFirstToken(node).value === keyword
    ***REMOVED***;
***REMOVED***

/**
 * Creates tester which check if a node is specific type.
 *
 * @param ***REMOVED***string***REMOVED*** type The node type to test.
 * @returns ***REMOVED***Object***REMOVED*** the created tester.
 * @private
 */
function newNodeTypeTester(type) ***REMOVED***
    return ***REMOVED***
        test: node =>
            node.type === type
    ***REMOVED***;
***REMOVED***

/**
 * Checks the given node is an expression statement of IIFE.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is an expression statement of IIFE.
 * @private
 */
function isIIFEStatement(node) ***REMOVED***
    if (node.type === "ExpressionStatement") ***REMOVED***
        let call = node.expression;

        if (call.type === "UnaryExpression") ***REMOVED***
            call = call.argument;
        ***REMOVED***
        return call.type === "CallExpression" && astUtils.isFunction(call.callee);
    ***REMOVED***
    return false;
***REMOVED***

/**
 * Checks whether the given node is a block-like statement.
 * This checks the last token of the node is the closing brace of a block.
 *
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode The source code to get tokens.
 * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a block-like statement.
 * @private
 */
function isBlockLikeStatement(sourceCode, node) ***REMOVED***

    // do-while with a block is a block-like statement.
    if (node.type === "DoWhileStatement" && node.body.type === "BlockStatement") ***REMOVED***
        return true;
    ***REMOVED***

    /*
     * IIFE is a block-like statement specially from
     * JSCS#disallowPaddingNewLinesAfterBlocks.
     */
    if (isIIFEStatement(node)) ***REMOVED***
        return true;
    ***REMOVED***

    // Checks the last token is a closing brace of blocks.
    const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
    const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken)
        ? sourceCode.getNodeByRangeIndex(lastToken.range[0])
        : null;

    return Boolean(belongingNode) && (
        belongingNode.type === "BlockStatement" ||
        belongingNode.type === "SwitchStatement"
    );
***REMOVED***

/**
 * Check whether the given node is a directive or not.
 * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode The source code object to get tokens.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a directive.
 */
function isDirective(node, sourceCode) ***REMOVED***
    return (
        node.type === "ExpressionStatement" &&
        (
            node.parent.type === "Program" ||
            (
                node.parent.type === "BlockStatement" &&
                astUtils.isFunction(node.parent.parent)
            )
        ) &&
        node.expression.type === "Literal" &&
        typeof node.expression.value === "string" &&
        !astUtils.isParenthesised(sourceCode, node.expression)
    );
***REMOVED***

/**
 * Check whether the given node is a part of directive prologue or not.
 * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode The source code object to get tokens.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a part of directive prologue.
 */
function isDirectivePrologue(node, sourceCode) ***REMOVED***
    if (isDirective(node, sourceCode)) ***REMOVED***
        for (const sibling of node.parent.body) ***REMOVED***
            if (sibling === node) ***REMOVED***
                break;
            ***REMOVED***
            if (!isDirective(sibling, sourceCode)) ***REMOVED***
                return false;
            ***REMOVED***
        ***REMOVED***
        return true;
    ***REMOVED***
    return false;
***REMOVED***

/**
 * Gets the actual last token.
 *
 * If a semicolon is semicolon-less style's semicolon, this ignores it.
 * For example:
 *
 *     foo()
 *     ;[1, 2, 3].forEach(bar)
 *
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode The source code to get tokens.
 * @param ***REMOVED***ASTNode***REMOVED*** node The node to get.
 * @returns ***REMOVED***Token***REMOVED*** The actual last token.
 * @private
 */
function getActualLastToken(sourceCode, node) ***REMOVED***
    const semiToken = sourceCode.getLastToken(node);
    const prevToken = sourceCode.getTokenBefore(semiToken);
    const nextToken = sourceCode.getTokenAfter(semiToken);
    const isSemicolonLessStyle = Boolean(
        prevToken &&
        nextToken &&
        prevToken.range[0] >= node.range[0] &&
        astUtils.isSemicolonToken(semiToken) &&
        semiToken.loc.start.line !== prevToken.loc.end.line &&
        semiToken.loc.end.line === nextToken.loc.start.line
    );

    return isSemicolonLessStyle ? prevToken : semiToken;
***REMOVED***

/**
 * This returns the concatenation of the first 2 captured strings.
 * @param ***REMOVED***string***REMOVED*** _ Unused. Whole matched string.
 * @param ***REMOVED***string***REMOVED*** trailingSpaces The trailing spaces of the first line.
 * @param ***REMOVED***string***REMOVED*** indentSpaces The indentation spaces of the last line.
 * @returns ***REMOVED***string***REMOVED*** The concatenation of trailingSpaces and indentSpaces.
 * @private
 */
function replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) ***REMOVED***
    return trailingSpaces + indentSpaces;
***REMOVED***

/**
 * Check and report statements for `any` configuration.
 * It does nothing.
 *
 * @returns ***REMOVED***void***REMOVED***
 * @private
 */
function verifyForAny() ***REMOVED***
***REMOVED***

/**
 * Check and report statements for `never` configuration.
 * This autofix removes blank lines between the given 2 statements.
 * However, if comments exist between 2 blank lines, it does not remove those
 * blank lines automatically.
 *
 * @param ***REMOVED***RuleContext***REMOVED*** context The rule context to report.
 * @param ***REMOVED***ASTNode***REMOVED*** _ Unused. The previous node to check.
 * @param ***REMOVED***ASTNode***REMOVED*** nextNode The next node to check.
 * @param ***REMOVED***Array<Token[]>***REMOVED*** paddingLines The array of token pairs that blank
 * lines exist between the pair.
 * @returns ***REMOVED***void***REMOVED***
 * @private
 */
function verifyForNever(context, _, nextNode, paddingLines) ***REMOVED***
    if (paddingLines.length === 0) ***REMOVED***
        return;
    ***REMOVED***

    context.report(***REMOVED***
        node: nextNode,
        message: "Unexpected blank line before this statement.",
        fix(fixer) ***REMOVED***
            if (paddingLines.length >= 2) ***REMOVED***
                return null;
            ***REMOVED***

            const prevToken = paddingLines[0][0];
            const nextToken = paddingLines[0][1];
            const start = prevToken.range[1];
            const end = nextToken.range[0];
            const text = context.getSourceCode().text
                .slice(start, end)
                .replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);

            return fixer.replaceTextRange([start, end], text);
        ***REMOVED***
    ***REMOVED***);
***REMOVED***

/**
 * Check and report statements for `always` configuration.
 * This autofix inserts a blank line between the given 2 statements.
 * If the `prevNode` has trailing comments, it inserts a blank line after the
 * trailing comments.
 *
 * @param ***REMOVED***RuleContext***REMOVED*** context The rule context to report.
 * @param ***REMOVED***ASTNode***REMOVED*** prevNode The previous node to check.
 * @param ***REMOVED***ASTNode***REMOVED*** nextNode The next node to check.
 * @param ***REMOVED***Array<Token[]>***REMOVED*** paddingLines The array of token pairs that blank
 * lines exist between the pair.
 * @returns ***REMOVED***void***REMOVED***
 * @private
 */
function verifyForAlways(context, prevNode, nextNode, paddingLines) ***REMOVED***
    if (paddingLines.length > 0) ***REMOVED***
        return;
    ***REMOVED***

    context.report(***REMOVED***
        node: nextNode,
        message: "Expected blank line before this statement.",
        fix(fixer) ***REMOVED***
            const sourceCode = context.getSourceCode();
            let prevToken = getActualLastToken(sourceCode, prevNode);
            const nextToken = sourceCode.getFirstTokenBetween(
                prevToken,
                nextNode,
                ***REMOVED***
                    includeComments: true,

                    /**
                     * Skip the trailing comments of the previous node.
                     * This inserts a blank line after the last trailing comment.
                     *
                     * For example:
                     *
                     *     foo(); // trailing comment.
                     *     // comment.
                     *     bar();
                     *
                     * Get fixed to:
                     *
                     *     foo(); // trailing comment.
                     *
                     *     // comment.
                     *     bar();
                     *
                     * @param ***REMOVED***Token***REMOVED*** token The token to check.
                     * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is not a trailing comment.
                     * @private
                     */
                    filter(token) ***REMOVED***
                        if (astUtils.isTokenOnSameLine(prevToken, token)) ***REMOVED***
                            prevToken = token;
                            return false;
                        ***REMOVED***
                        return true;
                    ***REMOVED***
                ***REMOVED***
            ) || nextNode;
            const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken)
                ? "\n\n"
                : "\n";

            return fixer.insertTextAfter(prevToken, insertText);
        ***REMOVED***
    ***REMOVED***);
***REMOVED***

/**
 * Types of blank lines.
 * `any`, `never`, and `always` are defined.
 * Those have `verify` method to check and report statements.
 * @private
 */
const PaddingTypes = ***REMOVED***
    any: ***REMOVED*** verify: verifyForAny ***REMOVED***,
    never: ***REMOVED*** verify: verifyForNever ***REMOVED***,
    always: ***REMOVED*** verify: verifyForAlways ***REMOVED***
***REMOVED***;

/**
 * Types of statements.
 * Those have `test` method to check it matches to the given statement.
 * @private
 */
const StatementTypes = ***REMOVED***
    "*": ***REMOVED*** test: () => true ***REMOVED***,
    "block-like": ***REMOVED***
        test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)
    ***REMOVED***,
    "cjs-export": ***REMOVED***
        test: (node, sourceCode) =>
            node.type === "ExpressionStatement" &&
            node.expression.type === "AssignmentExpression" &&
            CJS_EXPORT.test(sourceCode.getText(node.expression.left))
    ***REMOVED***,
    "cjs-import": ***REMOVED***
        test: (node, sourceCode) =>
            node.type === "VariableDeclaration" &&
            node.declarations.length > 0 &&
            Boolean(node.declarations[0].init) &&
            CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))
    ***REMOVED***,
    directive: ***REMOVED***
        test: isDirectivePrologue
    ***REMOVED***,
    expression: ***REMOVED***
        test: (node, sourceCode) =>
            node.type === "ExpressionStatement" &&
            !isDirectivePrologue(node, sourceCode)
    ***REMOVED***,
    iife: ***REMOVED***
        test: isIIFEStatement
    ***REMOVED***,
    "multiline-block-like": ***REMOVED***
        test: (node, sourceCode) =>
            node.loc.start.line !== node.loc.end.line &&
            isBlockLikeStatement(sourceCode, node)
    ***REMOVED***,
    "multiline-expression": ***REMOVED***
        test: (node, sourceCode) =>
            node.loc.start.line !== node.loc.end.line &&
            node.type === "ExpressionStatement" &&
            !isDirectivePrologue(node, sourceCode)
    ***REMOVED***,

    "multiline-const": newMultilineKeywordTester("const"),
    "multiline-let": newMultilineKeywordTester("let"),
    "multiline-var": newMultilineKeywordTester("var"),
    "singleline-const": newSinglelineKeywordTester("const"),
    "singleline-let": newSinglelineKeywordTester("let"),
    "singleline-var": newSinglelineKeywordTester("var"),

    block: newNodeTypeTester("BlockStatement"),
    empty: newNodeTypeTester("EmptyStatement"),
    function: newNodeTypeTester("FunctionDeclaration"),

    break: newKeywordTester("break"),
    case: newKeywordTester("case"),
    class: newKeywordTester("class"),
    const: newKeywordTester("const"),
    continue: newKeywordTester("continue"),
    debugger: newKeywordTester("debugger"),
    default: newKeywordTester("default"),
    do: newKeywordTester("do"),
    export: newKeywordTester("export"),
    for: newKeywordTester("for"),
    if: newKeywordTester("if"),
    import: newKeywordTester("import"),
    let: newKeywordTester("let"),
    return: newKeywordTester("return"),
    switch: newKeywordTester("switch"),
    throw: newKeywordTester("throw"),
    try: newKeywordTester("try"),
    var: newKeywordTester("var"),
    while: newKeywordTester("while"),
    with: newKeywordTester("with")
***REMOVED***;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "require or disallow padding lines between statements",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/padding-line-between-statements"
        ***REMOVED***,

        fixable: "whitespace",

        schema: ***REMOVED***
            definitions: ***REMOVED***
                paddingType: ***REMOVED***
                    enum: Object.keys(PaddingTypes)
                ***REMOVED***,
                statementType: ***REMOVED***
                    anyOf: [
                        ***REMOVED*** enum: Object.keys(StatementTypes) ***REMOVED***,
                        ***REMOVED***
                            type: "array",
                            items: ***REMOVED*** enum: Object.keys(StatementTypes) ***REMOVED***,
                            minItems: 1,
                            uniqueItems: true,
                            additionalItems: false
                        ***REMOVED***
                    ]
                ***REMOVED***
            ***REMOVED***,
            type: "array",
            items: ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    blankLine: ***REMOVED*** $ref: "#/definitions/paddingType" ***REMOVED***,
                    prev: ***REMOVED*** $ref: "#/definitions/statementType" ***REMOVED***,
                    next: ***REMOVED*** $ref: "#/definitions/statementType" ***REMOVED***
                ***REMOVED***,
                additionalProperties: false,
                required: ["blankLine", "prev", "next"]
            ***REMOVED***,
            additionalItems: false
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();
        const configureList = context.options || [];
        let scopeInfo = null;

        /**
         * Processes to enter to new scope.
         * This manages the current previous statement.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function enterScope() ***REMOVED***
            scopeInfo = ***REMOVED***
                upper: scopeInfo,
                prevNode: null
            ***REMOVED***;
        ***REMOVED***

        /**
         * Processes to exit from the current scope.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function exitScope() ***REMOVED***
            scopeInfo = scopeInfo.upper;
        ***REMOVED***

        /**
         * Checks whether the given node matches the given type.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node The statement node to check.
         * @param ***REMOVED***string|string[]***REMOVED*** type The statement type to check.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the statement node matched the type.
         * @private
         */
        function match(node, type) ***REMOVED***
            let innerStatementNode = node;

            while (innerStatementNode.type === "LabeledStatement") ***REMOVED***
                innerStatementNode = innerStatementNode.body;
            ***REMOVED***
            if (Array.isArray(type)) ***REMOVED***
                return type.some(match.bind(null, innerStatementNode));
            ***REMOVED***
            return StatementTypes[type].test(innerStatementNode, sourceCode);
        ***REMOVED***

        /**
         * Finds the last matched configure from configureList.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** prevNode The previous statement to match.
         * @param ***REMOVED***ASTNode***REMOVED*** nextNode The current statement to match.
         * @returns ***REMOVED***Object***REMOVED*** The tester of the last matched configure.
         * @private
         */
        function getPaddingType(prevNode, nextNode) ***REMOVED***
            for (let i = configureList.length - 1; i >= 0; --i) ***REMOVED***
                const configure = configureList[i];
                const matched =
                    match(prevNode, configure.prev) &&
                    match(nextNode, configure.next);

                if (matched) ***REMOVED***
                    return PaddingTypes[configure.blankLine];
                ***REMOVED***
            ***REMOVED***
            return PaddingTypes.any;
        ***REMOVED***

        /**
         * Gets padding line sequences between the given 2 statements.
         * Comments are separators of the padding line sequences.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** prevNode The previous statement to count.
         * @param ***REMOVED***ASTNode***REMOVED*** nextNode The current statement to count.
         * @returns ***REMOVED***Array<Token[]>***REMOVED*** The array of token pairs.
         * @private
         */
        function getPaddingLineSequences(prevNode, nextNode) ***REMOVED***
            const pairs = [];
            let prevToken = getActualLastToken(sourceCode, prevNode);

            if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) ***REMOVED***
                do ***REMOVED***
                    const token = sourceCode.getTokenAfter(
                        prevToken,
                        ***REMOVED*** includeComments: true ***REMOVED***
                    );

                    if (token.loc.start.line - prevToken.loc.end.line >= 2) ***REMOVED***
                        pairs.push([prevToken, token]);
                    ***REMOVED***
                    prevToken = token;

                ***REMOVED*** while (prevToken.range[0] < nextNode.range[0]);
            ***REMOVED***

            return pairs;
        ***REMOVED***

        /**
         * Verify padding lines between the given node and the previous node.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to verify.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function verify(node) ***REMOVED***
            const parentType = node.parent.type;
            const validParent =
                astUtils.STATEMENT_LIST_PARENTS.has(parentType) ||
                parentType === "SwitchStatement";

            if (!validParent) ***REMOVED***
                return;
            ***REMOVED***

            // Save this node as the current previous statement.
            const prevNode = scopeInfo.prevNode;

            // Verify.
            if (prevNode) ***REMOVED***
                const type = getPaddingType(prevNode, node);
                const paddingLines = getPaddingLineSequences(prevNode, node);

                type.verify(context, prevNode, node, paddingLines);
            ***REMOVED***

            scopeInfo.prevNode = node;
        ***REMOVED***

        /**
         * Verify padding lines between the given node and the previous node.
         * Then process to enter to new scope.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to verify.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function verifyThenEnterScope(node) ***REMOVED***
            verify(node);
            enterScope();
        ***REMOVED***

        return ***REMOVED***
            Program: enterScope,
            BlockStatement: enterScope,
            SwitchStatement: enterScope,
            "Program:exit": exitScope,
            "BlockStatement:exit": exitScope,
            "SwitchStatement:exit": exitScope,

            ":statement": verify,

            SwitchCase: verifyThenEnterScope,
            "SwitchCase:exit": exitScope
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
