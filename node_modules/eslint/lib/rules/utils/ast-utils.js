/**
 * @fileoverview Common utils for AST.
 * @author Gyandeep Singh
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const esutils = require("esutils");
const espree = require("espree");
const lodash = require("lodash");
const ***REMOVED***
    breakableTypePattern,
    createGlobalLinebreakMatcher,
    lineBreakPattern,
    shebangPattern
***REMOVED*** = require("../../shared/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;
const anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u;
const arrayOrTypedArrayPattern = /Array$/u;
const arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/u;
const bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/u;
const thisTagPattern = /^[\s*]*@this/mu;


const COMMENTS_IGNORE_PATTERN = /^\s*(?:eslint|jshint\s+|jslint\s+|istanbul\s+|globals?\s+|exported\s+|jscs)/u;
const LINEBREAKS = new Set(["\r\n", "\r", "\n", "\u2028", "\u2029"]);

// A set of node types that can contain a list of statements
const STATEMENT_LIST_PARENTS = new Set(["Program", "BlockStatement", "SwitchCase"]);

const DECIMAL_INTEGER_PATTERN = /^(0|[1-9]\d*)$/u;
const OCTAL_ESCAPE_PATTERN = /^(?:[^\\]|\\[^0-7]|\\0(?![0-9]))*\\(?:[1-7]|0[0-9])/u;

/**
 * Checks reference if is non initializer and writable.
 * @param ***REMOVED***Reference***REMOVED*** reference - A reference to check.
 * @param ***REMOVED***int***REMOVED*** index - The index of the reference in the references.
 * @param ***REMOVED***Reference[]***REMOVED*** references - The array that the reference belongs to.
 * @returns ***REMOVED***boolean***REMOVED*** Success/Failure
 * @private
 */
function isModifyingReference(reference, index, references) ***REMOVED***
    const identifier = reference.identifier;

    /*
     * Destructuring assignments can have multiple default value, so
     * possibly there are multiple writeable references for the same
     * identifier.
     */
    const modifyingDifferentIdentifier = index === 0 ||
        references[index - 1].identifier !== identifier;

    return (identifier &&
        reference.init === false &&
        reference.isWrite() &&
        modifyingDifferentIdentifier
    );
***REMOVED***

/**
 * Checks whether the given string starts with uppercase or not.
 *
 * @param ***REMOVED***string***REMOVED*** s - The string to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the string starts with uppercase.
 */
function startsWithUpperCase(s) ***REMOVED***
    return s[0] !== s[0].toLocaleLowerCase();
***REMOVED***

/**
 * Checks whether or not a node is a constructor.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A function node to check.
 * @returns ***REMOVED***boolean***REMOVED*** Wehether or not a node is a constructor.
 */
function isES5Constructor(node) ***REMOVED***
    return (node.id && startsWithUpperCase(node.id.name));
***REMOVED***

/**
 * Finds a function node from ancestors of a node.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A start node to find.
 * @returns ***REMOVED***Node|null***REMOVED*** A found function node.
 */
function getUpperFunction(node) ***REMOVED***
    for (let currentNode = node; currentNode; currentNode = currentNode.parent) ***REMOVED***
        if (anyFunctionPattern.test(currentNode.type)) ***REMOVED***
            return currentNode;
        ***REMOVED***
    ***REMOVED***
    return null;
***REMOVED***

/**
 * Checks whether a given node is a function node or not.
 * The following types are function nodes:
 *
 * - ArrowFunctionExpression
 * - FunctionDeclaration
 * - FunctionExpression
 *
 * @param ***REMOVED***ASTNode|null***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a function node.
 */
function isFunction(node) ***REMOVED***
    return Boolean(node && anyFunctionPattern.test(node.type));
***REMOVED***

/**
 * Checks whether a given node is a loop node or not.
 * The following types are loop nodes:
 *
 * - DoWhileStatement
 * - ForInStatement
 * - ForOfStatement
 * - ForStatement
 * - WhileStatement
 *
 * @param ***REMOVED***ASTNode|null***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a loop node.
 */
function isLoop(node) ***REMOVED***
    return Boolean(node && anyLoopPattern.test(node.type));
***REMOVED***

/**
 * Checks whether the given node is in a loop or not.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - The node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is in a loop.
 */
function isInLoop(node) ***REMOVED***
    for (let currentNode = node; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) ***REMOVED***
        if (isLoop(currentNode)) ***REMOVED***
            return true;
        ***REMOVED***
    ***REMOVED***

    return false;
***REMOVED***

/**
 * Checks whether or not a node is `null` or `undefined`.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not the node is a `null` or `undefined`.
 * @public
 */
function isNullOrUndefined(node) ***REMOVED***
    return (
        module.exports.isNullLiteral(node) ||
        (node.type === "Identifier" && node.name === "undefined") ||
        (node.type === "UnaryExpression" && node.operator === "void")
    );
***REMOVED***

/**
 * Checks whether or not a node is callee.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not the node is callee.
 */
function isCallee(node) ***REMOVED***
    return node.parent.type === "CallExpression" && node.parent.callee === node;
***REMOVED***

/**
 * Checks whether or not a node is `Reflect.apply`.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not the node is a `Reflect.apply`.
 */
function isReflectApply(node) ***REMOVED***
    return (
        node.type === "MemberExpression" &&
        node.object.type === "Identifier" &&
        node.object.name === "Reflect" &&
        node.property.type === "Identifier" &&
        node.property.name === "apply" &&
        node.computed === false
    );
***REMOVED***

/**
 * Checks whether or not a node is `Array.from`.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not the node is a `Array.from`.
 */
function isArrayFromMethod(node) ***REMOVED***
    return (
        node.type === "MemberExpression" &&
        node.object.type === "Identifier" &&
        arrayOrTypedArrayPattern.test(node.object.name) &&
        node.property.type === "Identifier" &&
        node.property.name === "from" &&
        node.computed === false
    );
***REMOVED***

/**
 * Checks whether or not a node is a method which has `thisArg`.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not the node is a method which has `thisArg`.
 */
function isMethodWhichHasThisArg(node) ***REMOVED***
    for (
        let currentNode = node;
        currentNode.type === "MemberExpression" && !currentNode.computed;
        currentNode = currentNode.property
    ) ***REMOVED***
        if (currentNode.property.type === "Identifier") ***REMOVED***
            return arrayMethodPattern.test(currentNode.property.name);
        ***REMOVED***
    ***REMOVED***

    return false;
***REMOVED***

/**
 * Creates the negate function of the given function.
 * @param ***REMOVED***Function***REMOVED*** f - The function to negate.
 * @returns ***REMOVED***Function***REMOVED*** Negated function.
 */
function negate(f) ***REMOVED***
    return token => !f(token);
***REMOVED***

/**
 * Checks whether or not a node has a `@this` tag in its comments.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode - A SourceCode instance to get comments.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not the node has a `@this` tag in its comments.
 */
function hasJSDocThisTag(node, sourceCode) ***REMOVED***
    const jsdocComment = sourceCode.getJSDocComment(node);

    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) ***REMOVED***
        return true;
    ***REMOVED***

    // Checks `@this` in its leading comments for callbacks,
    // because callbacks don't have its JSDoc comment.
    // e.g.
    //     sinon.test(/* @this sinon.Sandbox */function() ***REMOVED*** this.spy(); ***REMOVED***);
    return sourceCode.getCommentsBefore(node).some(comment => thisTagPattern.test(comment.value));
***REMOVED***

/**
 * Determines if a node is surrounded by parentheses.
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode The ESLint source code object
 * @param ***REMOVED***ASTNode***REMOVED*** node The node to be checked.
 * @returns ***REMOVED***boolean***REMOVED*** True if the node is parenthesised.
 * @private
 */
function isParenthesised(sourceCode, node) ***REMOVED***
    const previousToken = sourceCode.getTokenBefore(node),
        nextToken = sourceCode.getTokenAfter(node);

    return Boolean(previousToken && nextToken) &&
        previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
        nextToken.value === ")" && nextToken.range[0] >= node.range[1];
***REMOVED***

/**
 * Checks if the given token is an arrow token or not.
 *
 * @param ***REMOVED***Token***REMOVED*** token - The token to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is an arrow token.
 */
function isArrowToken(token) ***REMOVED***
    return token.value === "=>" && token.type === "Punctuator";
***REMOVED***

/**
 * Checks if the given token is a comma token or not.
 *
 * @param ***REMOVED***Token***REMOVED*** token - The token to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is a comma token.
 */
function isCommaToken(token) ***REMOVED***
    return token.value === "," && token.type === "Punctuator";
***REMOVED***

/**
 * Checks if the given token is a dot token or not.
 *
 * @param ***REMOVED***Token***REMOVED*** token - The token to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is a dot token.
 */
function isDotToken(token) ***REMOVED***
    return token.value === "." && token.type === "Punctuator";
***REMOVED***

/**
 * Checks if the given token is a semicolon token or not.
 *
 * @param ***REMOVED***Token***REMOVED*** token - The token to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is a semicolon token.
 */
function isSemicolonToken(token) ***REMOVED***
    return token.value === ";" && token.type === "Punctuator";
***REMOVED***

/**
 * Checks if the given token is a colon token or not.
 *
 * @param ***REMOVED***Token***REMOVED*** token - The token to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is a colon token.
 */
function isColonToken(token) ***REMOVED***
    return token.value === ":" && token.type === "Punctuator";
***REMOVED***

/**
 * Checks if the given token is an opening parenthesis token or not.
 *
 * @param ***REMOVED***Token***REMOVED*** token - The token to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is an opening parenthesis token.
 */
function isOpeningParenToken(token) ***REMOVED***
    return token.value === "(" && token.type === "Punctuator";
***REMOVED***

/**
 * Checks if the given token is a closing parenthesis token or not.
 *
 * @param ***REMOVED***Token***REMOVED*** token - The token to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is a closing parenthesis token.
 */
function isClosingParenToken(token) ***REMOVED***
    return token.value === ")" && token.type === "Punctuator";
***REMOVED***

/**
 * Checks if the given token is an opening square bracket token or not.
 *
 * @param ***REMOVED***Token***REMOVED*** token - The token to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is an opening square bracket token.
 */
function isOpeningBracketToken(token) ***REMOVED***
    return token.value === "[" && token.type === "Punctuator";
***REMOVED***

/**
 * Checks if the given token is a closing square bracket token or not.
 *
 * @param ***REMOVED***Token***REMOVED*** token - The token to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is a closing square bracket token.
 */
function isClosingBracketToken(token) ***REMOVED***
    return token.value === "]" && token.type === "Punctuator";
***REMOVED***

/**
 * Checks if the given token is an opening brace token or not.
 *
 * @param ***REMOVED***Token***REMOVED*** token - The token to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is an opening brace token.
 */
function isOpeningBraceToken(token) ***REMOVED***
    return token.value === "***REMOVED***" && token.type === "Punctuator";
***REMOVED***

/**
 * Checks if the given token is a closing brace token or not.
 *
 * @param ***REMOVED***Token***REMOVED*** token - The token to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is a closing brace token.
 */
function isClosingBraceToken(token) ***REMOVED***
    return token.value === "***REMOVED***" && token.type === "Punctuator";
***REMOVED***

/**
 * Checks if the given token is a comment token or not.
 *
 * @param ***REMOVED***Token***REMOVED*** token - The token to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is a comment token.
 */
function isCommentToken(token) ***REMOVED***
    return token.type === "Line" || token.type === "Block" || token.type === "Shebang";
***REMOVED***

/**
 * Checks if the given token is a keyword token or not.
 *
 * @param ***REMOVED***Token***REMOVED*** token - The token to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is a keyword token.
 */
function isKeywordToken(token) ***REMOVED***
    return token.type === "Keyword";
***REMOVED***

/**
 * Gets the `(` token of the given function node.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - The function node to get.
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode - The source code object to get tokens.
 * @returns ***REMOVED***Token***REMOVED*** `(` token.
 */
function getOpeningParenOfParams(node, sourceCode) ***REMOVED***
    return node.id
        ? sourceCode.getTokenAfter(node.id, isOpeningParenToken)
        : sourceCode.getFirstToken(node, isOpeningParenToken);
***REMOVED***

/**
 * Checks whether or not the tokens of two given nodes are same.
 * @param ***REMOVED***ASTNode***REMOVED*** left - A node 1 to compare.
 * @param ***REMOVED***ASTNode***REMOVED*** right - A node 2 to compare.
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode - The ESLint source code object.
 * @returns ***REMOVED***boolean***REMOVED*** the source code for the given node.
 */
function equalTokens(left, right, sourceCode) ***REMOVED***
    const tokensL = sourceCode.getTokens(left);
    const tokensR = sourceCode.getTokens(right);

    if (tokensL.length !== tokensR.length) ***REMOVED***
        return false;
    ***REMOVED***
    for (let i = 0; i < tokensL.length; ++i) ***REMOVED***
        if (tokensL[i].type !== tokensR[i].type ||
            tokensL[i].value !== tokensR[i].value
        ) ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***

    return true;
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    COMMENTS_IGNORE_PATTERN,
    LINEBREAKS,
    LINEBREAK_MATCHER: lineBreakPattern,
    SHEBANG_MATCHER: shebangPattern,
    STATEMENT_LIST_PARENTS,

    /**
     * Determines whether two adjacent tokens are on the same line.
     * @param ***REMOVED***Object***REMOVED*** left - The left token object.
     * @param ***REMOVED***Object***REMOVED*** right - The right token object.
     * @returns ***REMOVED***boolean***REMOVED*** Whether or not the tokens are on the same line.
     * @public
     */
    isTokenOnSameLine(left, right) ***REMOVED***
        return left.loc.end.line === right.loc.start.line;
    ***REMOVED***,

    isNullOrUndefined,
    isCallee,
    isES5Constructor,
    getUpperFunction,
    isFunction,
    isLoop,
    isInLoop,
    isArrayFromMethod,
    isParenthesised,
    createGlobalLinebreakMatcher,
    equalTokens,

    isArrowToken,
    isClosingBraceToken,
    isClosingBracketToken,
    isClosingParenToken,
    isColonToken,
    isCommaToken,
    isCommentToken,
    isDotToken,
    isKeywordToken,
    isNotClosingBraceToken: negate(isClosingBraceToken),
    isNotClosingBracketToken: negate(isClosingBracketToken),
    isNotClosingParenToken: negate(isClosingParenToken),
    isNotColonToken: negate(isColonToken),
    isNotCommaToken: negate(isCommaToken),
    isNotDotToken: negate(isDotToken),
    isNotOpeningBraceToken: negate(isOpeningBraceToken),
    isNotOpeningBracketToken: negate(isOpeningBracketToken),
    isNotOpeningParenToken: negate(isOpeningParenToken),
    isNotSemicolonToken: negate(isSemicolonToken),
    isOpeningBraceToken,
    isOpeningBracketToken,
    isOpeningParenToken,
    isSemicolonToken,

    /**
     * Checks whether or not a given node is a string literal.
     * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a string literal.
     */
    isStringLiteral(node) ***REMOVED***
        return (
            (node.type === "Literal" && typeof node.value === "string") ||
            node.type === "TemplateLiteral"
        );
    ***REMOVED***,

    /**
     * Checks whether a given node is a breakable statement or not.
     * The node is breakable if the node is one of the following type:
     *
     * - DoWhileStatement
     * - ForInStatement
     * - ForOfStatement
     * - ForStatement
     * - SwitchStatement
     * - WhileStatement
     *
     * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is breakable.
     */
    isBreakableStatement(node) ***REMOVED***
        return breakableTypePattern.test(node.type);
    ***REMOVED***,

    /**
     * Gets references which are non initializer and writable.
     * @param ***REMOVED***Reference[]***REMOVED*** references - An array of references.
     * @returns ***REMOVED***Reference[]***REMOVED*** An array of only references which are non initializer and writable.
     * @public
     */
    getModifyingReferences(references) ***REMOVED***
        return references.filter(isModifyingReference);
    ***REMOVED***,

    /**
     * Validate that a string passed in is surrounded by the specified character
     * @param  ***REMOVED***string***REMOVED*** val The text to check.
     * @param  ***REMOVED***string***REMOVED*** character The character to see if it's surrounded by.
     * @returns ***REMOVED***boolean***REMOVED*** True if the text is surrounded by the character, false if not.
     * @private
     */
    isSurroundedBy(val, character) ***REMOVED***
        return val[0] === character && val[val.length - 1] === character;
    ***REMOVED***,

    /**
     * Returns whether the provided node is an ESLint directive comment or not
     * @param ***REMOVED***Line|Block***REMOVED*** node The comment token to be checked
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is an ESLint directive comment
     */
    isDirectiveComment(node) ***REMOVED***
        const comment = node.value.trim();

        return (
            node.type === "Line" && comment.indexOf("eslint-") === 0 ||
            node.type === "Block" && (
                comment.indexOf("global ") === 0 ||
                comment.indexOf("eslint ") === 0 ||
                comment.indexOf("eslint-") === 0
            )
        );
    ***REMOVED***,

    /**
     * Gets the trailing statement of a given node.
     *
     *     if (code)
     *         consequent;
     *
     * When taking this `IfStatement`, returns `consequent;` statement.
     *
     * @param ***REMOVED***ASTNode***REMOVED*** A node to get.
     * @returns ***REMOVED***ASTNode|null***REMOVED*** The trailing statement's node.
     */
    getTrailingStatement: esutils.ast.trailingStatement,

    /**
     * Finds the variable by a given name in a given scope and its upper scopes.
     *
     * @param ***REMOVED***eslint-scope.Scope***REMOVED*** initScope - A scope to start find.
     * @param ***REMOVED***string***REMOVED*** name - A variable name to find.
     * @returns ***REMOVED***eslint-scope.Variable|null***REMOVED*** A found variable or `null`.
     */
    getVariableByName(initScope, name) ***REMOVED***
        let scope = initScope;

        while (scope) ***REMOVED***
            const variable = scope.set.get(name);

            if (variable) ***REMOVED***
                return variable;
            ***REMOVED***

            scope = scope.upper;
        ***REMOVED***

        return null;
    ***REMOVED***,

    /**
     * Checks whether or not a given function node is the default `this` binding.
     *
     * First, this checks the node:
     *
     * - The function name does not start with uppercase (it's a constructor).
     * - The function does not have a JSDoc comment that has a @this tag.
     *
     * Next, this checks the location of the node.
     * If the location is below, this judges `this` is valid.
     *
     * - The location is not on an object literal.
     * - The location is not assigned to a variable which starts with an uppercase letter.
     * - The location is not on an ES2015 class.
     * - Its `bind`/`call`/`apply` method is not called directly.
     * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.
     *
     * @param ***REMOVED***ASTNode***REMOVED*** node - A function node to check.
     * @param ***REMOVED***SourceCode***REMOVED*** sourceCode - A SourceCode instance to get comments.
     * @returns ***REMOVED***boolean***REMOVED*** The function node is the default `this` binding.
     */
    isDefaultThisBinding(node, sourceCode) ***REMOVED***
        if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) ***REMOVED***
            return false;
        ***REMOVED***
        const isAnonymous = node.id === null;
        let currentNode = node;

        while (currentNode) ***REMOVED***
            const parent = currentNode.parent;

            switch (parent.type) ***REMOVED***

                /*
                 * Looks up the destination.
                 * e.g., obj.foo = nativeFoo || function foo() ***REMOVED*** ... ***REMOVED***;
                 */
                case "LogicalExpression":
                case "ConditionalExpression":
                    currentNode = parent;
                    break;

                /*
                 * If the upper function is IIFE, checks the destination of the return value.
                 * e.g.
                 *   obj.foo = (function() ***REMOVED***
                 *     // setup...
                 *     return function foo() ***REMOVED*** ... ***REMOVED***;
                 *   ***REMOVED***)();
                 *   obj.foo = (() =>
                 *     function foo() ***REMOVED*** ... ***REMOVED***
                 *   )();
                 */
                case "ReturnStatement": ***REMOVED***
                    const func = getUpperFunction(parent);

                    if (func === null || !isCallee(func)) ***REMOVED***
                        return true;
                    ***REMOVED***
                    currentNode = func.parent;
                    break;
                ***REMOVED***
                case "ArrowFunctionExpression":
                    if (currentNode !== parent.body || !isCallee(parent)) ***REMOVED***
                        return true;
                    ***REMOVED***
                    currentNode = parent.parent;
                    break;

                /*
                 * e.g.
                 *   var obj = ***REMOVED*** foo() ***REMOVED*** ... ***REMOVED*** ***REMOVED***;
                 *   var obj = ***REMOVED*** foo: function() ***REMOVED*** ... ***REMOVED*** ***REMOVED***;
                 *   class A ***REMOVED*** constructor() ***REMOVED*** ... ***REMOVED*** ***REMOVED***
                 *   class A ***REMOVED*** foo() ***REMOVED*** ... ***REMOVED*** ***REMOVED***
                 *   class A ***REMOVED*** get foo() ***REMOVED*** ... ***REMOVED*** ***REMOVED***
                 *   class A ***REMOVED*** set foo() ***REMOVED*** ... ***REMOVED*** ***REMOVED***
                 *   class A ***REMOVED*** static foo() ***REMOVED*** ... ***REMOVED*** ***REMOVED***
                 */
                case "Property":
                case "MethodDefinition":
                    return parent.value !== currentNode;

                /*
                 * e.g.
                 *   obj.foo = function foo() ***REMOVED*** ... ***REMOVED***;
                 *   Foo = function() ***REMOVED*** ... ***REMOVED***;
                 *   [obj.foo = function foo() ***REMOVED*** ... ***REMOVED***] = a;
                 *   [Foo = function() ***REMOVED*** ... ***REMOVED***] = a;
                 */
                case "AssignmentExpression":
                case "AssignmentPattern":
                    if (parent.left.type === "MemberExpression") ***REMOVED***
                        return false;
                    ***REMOVED***
                    if (
                        isAnonymous &&
                        parent.left.type === "Identifier" &&
                        startsWithUpperCase(parent.left.name)
                    ) ***REMOVED***
                        return false;
                    ***REMOVED***
                    return true;

                /*
                 * e.g.
                 *   var Foo = function() ***REMOVED*** ... ***REMOVED***;
                 */
                case "VariableDeclarator":
                    return !(
                        isAnonymous &&
                        parent.init === currentNode &&
                        parent.id.type === "Identifier" &&
                        startsWithUpperCase(parent.id.name)
                    );

                /*
                 * e.g.
                 *   var foo = function foo() ***REMOVED*** ... ***REMOVED***.bind(obj);
                 *   (function foo() ***REMOVED*** ... ***REMOVED***).call(obj);
                 *   (function foo() ***REMOVED*** ... ***REMOVED***).apply(obj, []);
                 */
                case "MemberExpression":
                    return (
                        parent.object !== currentNode ||
                        parent.property.type !== "Identifier" ||
                        !bindOrCallOrApplyPattern.test(parent.property.name) ||
                        !isCallee(parent) ||
                        parent.parent.arguments.length === 0 ||
                        isNullOrUndefined(parent.parent.arguments[0])
                    );

                /*
                 * e.g.
                 *   Reflect.apply(function() ***REMOVED******REMOVED***, obj, []);
                 *   Array.from([], function() ***REMOVED******REMOVED***, obj);
                 *   list.forEach(function() ***REMOVED******REMOVED***, obj);
                 */
                case "CallExpression":
                    if (isReflectApply(parent.callee)) ***REMOVED***
                        return (
                            parent.arguments.length !== 3 ||
                            parent.arguments[0] !== currentNode ||
                            isNullOrUndefined(parent.arguments[1])
                        );
                    ***REMOVED***
                    if (isArrayFromMethod(parent.callee)) ***REMOVED***
                        return (
                            parent.arguments.length !== 3 ||
                            parent.arguments[1] !== currentNode ||
                            isNullOrUndefined(parent.arguments[2])
                        );
                    ***REMOVED***
                    if (isMethodWhichHasThisArg(parent.callee)) ***REMOVED***
                        return (
                            parent.arguments.length !== 2 ||
                            parent.arguments[0] !== currentNode ||
                            isNullOrUndefined(parent.arguments[1])
                        );
                    ***REMOVED***
                    return true;

                // Otherwise `this` is default.
                default:
                    return true;
            ***REMOVED***
        ***REMOVED***

        /* istanbul ignore next */
        return true;
    ***REMOVED***,

    /**
     * Get the precedence level based on the node type
     * @param ***REMOVED***ASTNode***REMOVED*** node node to evaluate
     * @returns ***REMOVED***int***REMOVED*** precedence level
     * @private
     */
    getPrecedence(node) ***REMOVED***
        switch (node.type) ***REMOVED***
            case "SequenceExpression":
                return 0;

            case "AssignmentExpression":
            case "ArrowFunctionExpression":
            case "YieldExpression":
                return 1;

            case "ConditionalExpression":
                return 3;

            case "LogicalExpression":
                switch (node.operator) ***REMOVED***
                    case "||":
                        return 4;
                    case "&&":
                        return 5;

                    // no default
                ***REMOVED***

                /* falls through */

            case "BinaryExpression":

                switch (node.operator) ***REMOVED***
                    case "|":
                        return 6;
                    case "^":
                        return 7;
                    case "&":
                        return 8;
                    case "==":
                    case "!=":
                    case "===":
                    case "!==":
                        return 9;
                    case "<":
                    case "<=":
                    case ">":
                    case ">=":
                    case "in":
                    case "instanceof":
                        return 10;
                    case "<<":
                    case ">>":
                    case ">>>":
                        return 11;
                    case "+":
                    case "-":
                        return 12;
                    case "*":
                    case "/":
                    case "%":
                        return 13;
                    case "**":
                        return 15;

                    // no default
                ***REMOVED***

                /* falls through */

            case "UnaryExpression":
            case "AwaitExpression":
                return 16;

            case "UpdateExpression":
                return 17;

            case "CallExpression":
            case "ImportExpression":
                return 18;

            case "NewExpression":
                return 19;

            default:
                return 20;
        ***REMOVED***
    ***REMOVED***,

    /**
     * Checks whether the given node is an empty block node or not.
     *
     * @param ***REMOVED***ASTNode|null***REMOVED*** node - The node to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is an empty block.
     */
    isEmptyBlock(node) ***REMOVED***
        return Boolean(node && node.type === "BlockStatement" && node.body.length === 0);
    ***REMOVED***,

    /**
     * Checks whether the given node is an empty function node or not.
     *
     * @param ***REMOVED***ASTNode|null***REMOVED*** node - The node to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is an empty function.
     */
    isEmptyFunction(node) ***REMOVED***
        return isFunction(node) && module.exports.isEmptyBlock(node.body);
    ***REMOVED***,

    /**
     * Gets the property name of a given node.
     * The node can be a MemberExpression, a Property, or a MethodDefinition.
     *
     * If the name is dynamic, this returns `null`.
     *
     * For examples:
     *
     *     a.b           // => "b"
     *     a["b"]        // => "b"
     *     a['b']        // => "b"
     *     a[`b`]        // => "b"
     *     a[100]        // => "100"
     *     a[b]          // => null
     *     a["a" + "b"]  // => null
     *     a[tag`b`]     // => null
     *     a[`$***REMOVED***b***REMOVED***`]     // => null
     *
     *     let a = ***REMOVED***b: 1***REMOVED***            // => "b"
     *     let a = ***REMOVED***["b"]: 1***REMOVED***        // => "b"
     *     let a = ***REMOVED***['b']: 1***REMOVED***        // => "b"
     *     let a = ***REMOVED***[`b`]: 1***REMOVED***        // => "b"
     *     let a = ***REMOVED***[100]: 1***REMOVED***        // => "100"
     *     let a = ***REMOVED***[b]: 1***REMOVED***          // => null
     *     let a = ***REMOVED***["a" + "b"]: 1***REMOVED***  // => null
     *     let a = ***REMOVED***[tag`b`]: 1***REMOVED***     // => null
     *     let a = ***REMOVED***[`$***REMOVED***b***REMOVED***`]: 1***REMOVED***     // => null
     *
     * @param ***REMOVED***ASTNode***REMOVED*** node - The node to get.
     * @returns ***REMOVED***string|null***REMOVED*** The property name if static. Otherwise, null.
     */
    getStaticPropertyName(node) ***REMOVED***
        let prop;

        switch (node && node.type) ***REMOVED***
            case "Property":
            case "MethodDefinition":
                prop = node.key;
                break;

            case "MemberExpression":
                prop = node.property;
                break;

            // no default
        ***REMOVED***

        switch (prop && prop.type) ***REMOVED***
            case "Literal":
                return String(prop.value);

            case "TemplateLiteral":
                if (prop.expressions.length === 0 && prop.quasis.length === 1) ***REMOVED***
                    return prop.quasis[0].value.cooked;
                ***REMOVED***
                break;

            case "Identifier":
                if (!node.computed) ***REMOVED***
                    return prop.name;
                ***REMOVED***
                break;

            // no default
        ***REMOVED***

        return null;
    ***REMOVED***,

    /**
     * Get directives from directive prologue of a Program or Function node.
     * @param ***REMOVED***ASTNode***REMOVED*** node - The node to check.
     * @returns ***REMOVED***ASTNode[]***REMOVED*** The directives found in the directive prologue.
     */
    getDirectivePrologue(node) ***REMOVED***
        const directives = [];

        // Directive prologues only occur at the top of files or functions.
        if (
            node.type === "Program" ||
            node.type === "FunctionDeclaration" ||
            node.type === "FunctionExpression" ||

            /*
             * Do not check arrow functions with implicit return.
             * `() => "use strict";` returns the string `"use strict"`.
             */
            (node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement")
        ) ***REMOVED***
            const statements = node.type === "Program" ? node.body : node.body.body;

            for (const statement of statements) ***REMOVED***
                if (
                    statement.type === "ExpressionStatement" &&
                    statement.expression.type === "Literal"
                ) ***REMOVED***
                    directives.push(statement);
                ***REMOVED*** else ***REMOVED***
                    break;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        return directives;
    ***REMOVED***,


    /**
     * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added
     * after the node will be parsed as a decimal point, rather than a property-access dot.
     * @param ***REMOVED***ASTNode***REMOVED*** node - The node to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if this node is a decimal integer.
     * @example
     *
     * 5       // true
     * 5.      // false
     * 5.0     // false
     * 05      // false
     * 0x5     // false
     * 0b101   // false
     * 0o5     // false
     * 5e0     // false
     * '5'     // false
     */
    isDecimalInteger(node) ***REMOVED***
        return node.type === "Literal" && typeof node.value === "number" &&
            DECIMAL_INTEGER_PATTERN.test(node.raw);
    ***REMOVED***,

    /**
     * Determines whether this token is a decimal integer numeric token.
     * This is similar to isDecimalInteger(), but for tokens.
     * @param ***REMOVED***Token***REMOVED*** token - The token to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if this token is a decimal integer.
     */
    isDecimalIntegerNumericToken(token) ***REMOVED***
        return token.type === "Numeric" && DECIMAL_INTEGER_PATTERN.test(token.value);
    ***REMOVED***,

    /**
     * Gets the name and kind of the given function node.
     *
     * - `function foo() ***REMOVED******REMOVED***`  .................... `function 'foo'`
     * - `(function foo() ***REMOVED******REMOVED***)`  .................. `function 'foo'`
     * - `(function() ***REMOVED******REMOVED***)`  ...................... `function`
     * - `function* foo() ***REMOVED******REMOVED***`  ................... `generator function 'foo'`
     * - `(function* foo() ***REMOVED******REMOVED***)`  ................. `generator function 'foo'`
     * - `(function*() ***REMOVED******REMOVED***)`  ..................... `generator function`
     * - `() => ***REMOVED******REMOVED***`  ............................. `arrow function`
     * - `async () => ***REMOVED******REMOVED***`  ....................... `async arrow function`
     * - `(***REMOVED*** foo: function foo() ***REMOVED******REMOVED*** ***REMOVED***)`  ......... `method 'foo'`
     * - `(***REMOVED*** foo: function() ***REMOVED******REMOVED*** ***REMOVED***)`  ............. `method 'foo'`
     * - `(***REMOVED*** ['foo']: function() ***REMOVED******REMOVED*** ***REMOVED***)`  ......... `method 'foo'`
     * - `(***REMOVED*** [foo]: function() ***REMOVED******REMOVED*** ***REMOVED***)`  ........... `method`
     * - `(***REMOVED*** foo() ***REMOVED******REMOVED*** ***REMOVED***)`  ....................... `method 'foo'`
     * - `(***REMOVED*** foo: function* foo() ***REMOVED******REMOVED*** ***REMOVED***)`  ........ `generator method 'foo'`
     * - `(***REMOVED*** foo: function*() ***REMOVED******REMOVED*** ***REMOVED***)`  ............ `generator method 'foo'`
     * - `(***REMOVED*** ['foo']: function*() ***REMOVED******REMOVED*** ***REMOVED***)`  ........ `generator method 'foo'`
     * - `(***REMOVED*** [foo]: function*() ***REMOVED******REMOVED*** ***REMOVED***)`  .......... `generator method`
     * - `(***REMOVED*** *foo() ***REMOVED******REMOVED*** ***REMOVED***)`  ...................... `generator method 'foo'`
     * - `(***REMOVED*** foo: async function foo() ***REMOVED******REMOVED*** ***REMOVED***)`  ... `async method 'foo'`
     * - `(***REMOVED*** foo: async function() ***REMOVED******REMOVED*** ***REMOVED***)`  ....... `async method 'foo'`
     * - `(***REMOVED*** ['foo']: async function() ***REMOVED******REMOVED*** ***REMOVED***)`  ... `async method 'foo'`
     * - `(***REMOVED*** [foo]: async function() ***REMOVED******REMOVED*** ***REMOVED***)`  ..... `async method`
     * - `(***REMOVED*** async foo() ***REMOVED******REMOVED*** ***REMOVED***)`  ................. `async method 'foo'`
     * - `(***REMOVED*** get foo() ***REMOVED******REMOVED*** ***REMOVED***)`  ................... `getter 'foo'`
     * - `(***REMOVED*** set foo(a) ***REMOVED******REMOVED*** ***REMOVED***)`  .................. `setter 'foo'`
     * - `class A ***REMOVED*** constructor() ***REMOVED******REMOVED*** ***REMOVED***`  ......... `constructor`
     * - `class A ***REMOVED*** foo() ***REMOVED******REMOVED*** ***REMOVED***`  ................. `method 'foo'`
     * - `class A ***REMOVED*** *foo() ***REMOVED******REMOVED*** ***REMOVED***`  ................ `generator method 'foo'`
     * - `class A ***REMOVED*** async foo() ***REMOVED******REMOVED*** ***REMOVED***`  ........... `async method 'foo'`
     * - `class A ***REMOVED*** ['foo']() ***REMOVED******REMOVED*** ***REMOVED***`  ............. `method 'foo'`
     * - `class A ***REMOVED*** *['foo']() ***REMOVED******REMOVED*** ***REMOVED***`  ............ `generator method 'foo'`
     * - `class A ***REMOVED*** async ['foo']() ***REMOVED******REMOVED*** ***REMOVED***`  ....... `async method 'foo'`
     * - `class A ***REMOVED*** [foo]() ***REMOVED******REMOVED*** ***REMOVED***`  ............... `method`
     * - `class A ***REMOVED*** *[foo]() ***REMOVED******REMOVED*** ***REMOVED***`  .............. `generator method`
     * - `class A ***REMOVED*** async [foo]() ***REMOVED******REMOVED*** ***REMOVED***`  ......... `async method`
     * - `class A ***REMOVED*** get foo() ***REMOVED******REMOVED*** ***REMOVED***`  ............. `getter 'foo'`
     * - `class A ***REMOVED*** set foo(a) ***REMOVED******REMOVED*** ***REMOVED***`  ............ `setter 'foo'`
     * - `class A ***REMOVED*** static foo() ***REMOVED******REMOVED*** ***REMOVED***`  .......... `static method 'foo'`
     * - `class A ***REMOVED*** static *foo() ***REMOVED******REMOVED*** ***REMOVED***`  ......... `static generator method 'foo'`
     * - `class A ***REMOVED*** static async foo() ***REMOVED******REMOVED*** ***REMOVED***`  .... `static async method 'foo'`
     * - `class A ***REMOVED*** static get foo() ***REMOVED******REMOVED*** ***REMOVED***`  ...... `static getter 'foo'`
     * - `class A ***REMOVED*** static set foo(a) ***REMOVED******REMOVED*** ***REMOVED***`  ..... `static setter 'foo'`
     *
     * @param ***REMOVED***ASTNode***REMOVED*** node - The function node to get.
     * @returns ***REMOVED***string***REMOVED*** The name and kind of the function node.
     */
    getFunctionNameWithKind(node) ***REMOVED***
        const parent = node.parent;
        const tokens = [];

        if (parent.type === "MethodDefinition" && parent.static) ***REMOVED***
            tokens.push("static");
        ***REMOVED***
        if (node.async) ***REMOVED***
            tokens.push("async");
        ***REMOVED***
        if (node.generator) ***REMOVED***
            tokens.push("generator");
        ***REMOVED***

        if (node.type === "ArrowFunctionExpression") ***REMOVED***
            tokens.push("arrow", "function");
        ***REMOVED*** else if (parent.type === "Property" || parent.type === "MethodDefinition") ***REMOVED***
            if (parent.kind === "constructor") ***REMOVED***
                return "constructor";
            ***REMOVED***
            if (parent.kind === "get") ***REMOVED***
                tokens.push("getter");
            ***REMOVED*** else if (parent.kind === "set") ***REMOVED***
                tokens.push("setter");
            ***REMOVED*** else ***REMOVED***
                tokens.push("method");
            ***REMOVED***
        ***REMOVED*** else ***REMOVED***
            tokens.push("function");
        ***REMOVED***

        if (node.id) ***REMOVED***
            tokens.push(`'$***REMOVED***node.id.name***REMOVED***'`);
        ***REMOVED*** else ***REMOVED***
            const name = module.exports.getStaticPropertyName(parent);

            if (name !== null) ***REMOVED***
                tokens.push(`'$***REMOVED***name***REMOVED***'`);
            ***REMOVED***
        ***REMOVED***

        return tokens.join(" ");
    ***REMOVED***,

    /**
     * Gets the location of the given function node for reporting.
     *
     * - `function foo() ***REMOVED******REMOVED***`
     *    ^^^^^^^^^^^^
     * - `(function foo() ***REMOVED******REMOVED***)`
     *     ^^^^^^^^^^^^
     * - `(function() ***REMOVED******REMOVED***)`
     *     ^^^^^^^^
     * - `function* foo() ***REMOVED******REMOVED***`
     *    ^^^^^^^^^^^^^
     * - `(function* foo() ***REMOVED******REMOVED***)`
     *     ^^^^^^^^^^^^^
     * - `(function*() ***REMOVED******REMOVED***)`
     *     ^^^^^^^^^
     * - `() => ***REMOVED******REMOVED***`
     *       ^^
     * - `async () => ***REMOVED******REMOVED***`
     *             ^^
     * - `(***REMOVED*** foo: function foo() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^^^^^^^^^^^
     * - `(***REMOVED*** foo: function() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^^^^^^^
     * - `(***REMOVED*** ['foo']: function() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^^^^^^^^^^^
     * - `(***REMOVED*** [foo]: function() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^^^^^^^^^
     * - `(***REMOVED*** foo() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^
     * - `(***REMOVED*** foo: function* foo() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^^^^^^^^^^^^
     * - `(***REMOVED*** foo: function*() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^^^^^^^^
     * - `(***REMOVED*** ['foo']: function*() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^^^^^^^^^^^^
     * - `(***REMOVED*** [foo]: function*() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^^^^^^^^^^
     * - `(***REMOVED*** *foo() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^
     * - `(***REMOVED*** foo: async function foo() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^^^^^^^^^^^^^^^^^
     * - `(***REMOVED*** foo: async function() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^^^^^^^^^^^^^
     * - `(***REMOVED*** ['foo']: async function() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^^^^^^^^^^^^^^^^^
     * - `(***REMOVED*** [foo]: async function() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^^^^^^^^^^^^^^^
     * - `(***REMOVED*** async foo() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^^^
     * - `(***REMOVED*** get foo() ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^
     * - `(***REMOVED*** set foo(a) ***REMOVED******REMOVED*** ***REMOVED***)`
     *       ^^^^^^^
     * - `class A ***REMOVED*** constructor() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^^^^^^^
     * - `class A ***REMOVED*** foo() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^
     * - `class A ***REMOVED*** *foo() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^
     * - `class A ***REMOVED*** async foo() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^^^^^
     * - `class A ***REMOVED*** ['foo']() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^^^
     * - `class A ***REMOVED*** *['foo']() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^^^^
     * - `class A ***REMOVED*** async ['foo']() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^^^^^^^^^
     * - `class A ***REMOVED*** [foo]() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^
     * - `class A ***REMOVED*** *[foo]() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^^
     * - `class A ***REMOVED*** async [foo]() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^^^^^^^
     * - `class A ***REMOVED*** get foo() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^^^
     * - `class A ***REMOVED*** set foo(a) ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^^^
     * - `class A ***REMOVED*** static foo() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^^^^^^
     * - `class A ***REMOVED*** static *foo() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^^^^^^^
     * - `class A ***REMOVED*** static async foo() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^^^^^^^^^^^^
     * - `class A ***REMOVED*** static get foo() ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^^^^^^^^^^
     * - `class A ***REMOVED*** static set foo(a) ***REMOVED******REMOVED*** ***REMOVED***`
     *              ^^^^^^^^^^^^^^
     *
     * @param ***REMOVED***ASTNode***REMOVED*** node - The function node to get.
     * @param ***REMOVED***SourceCode***REMOVED*** sourceCode - The source code object to get tokens.
     * @returns ***REMOVED***string***REMOVED*** The location of the function node for reporting.
     */
    getFunctionHeadLoc(node, sourceCode) ***REMOVED***
        const parent = node.parent;
        let start = null;
        let end = null;

        if (node.type === "ArrowFunctionExpression") ***REMOVED***
            const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);

            start = arrowToken.loc.start;
            end = arrowToken.loc.end;
        ***REMOVED*** else if (parent.type === "Property" || parent.type === "MethodDefinition") ***REMOVED***
            start = parent.loc.start;
            end = getOpeningParenOfParams(node, sourceCode).loc.start;
        ***REMOVED*** else ***REMOVED***
            start = node.loc.start;
            end = getOpeningParenOfParams(node, sourceCode).loc.start;
        ***REMOVED***

        return ***REMOVED***
            start: Object.assign(***REMOVED******REMOVED***, start),
            end: Object.assign(***REMOVED******REMOVED***, end)
        ***REMOVED***;
    ***REMOVED***,

    /**
     * Gets the parenthesized text of a node. This is similar to sourceCode.getText(node), but it also includes any parentheses
     * surrounding the node.
     * @param ***REMOVED***SourceCode***REMOVED*** sourceCode The source code object
     * @param ***REMOVED***ASTNode***REMOVED*** node An expression node
     * @returns ***REMOVED***string***REMOVED*** The text representing the node, with all surrounding parentheses included
     */
    getParenthesisedText(sourceCode, node) ***REMOVED***
        let leftToken = sourceCode.getFirstToken(node);
        let rightToken = sourceCode.getLastToken(node);

        while (
            sourceCode.getTokenBefore(leftToken) &&
            sourceCode.getTokenBefore(leftToken).type === "Punctuator" &&
            sourceCode.getTokenBefore(leftToken).value === "(" &&
            sourceCode.getTokenAfter(rightToken) &&
            sourceCode.getTokenAfter(rightToken).type === "Punctuator" &&
            sourceCode.getTokenAfter(rightToken).value === ")"
        ) ***REMOVED***
            leftToken = sourceCode.getTokenBefore(leftToken);
            rightToken = sourceCode.getTokenAfter(rightToken);
        ***REMOVED***

        return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);
    ***REMOVED***,

    /*
     * Determine if a node has a possiblity to be an Error object
     * @param  ***REMOVED***ASTNode***REMOVED*** node  ASTNode to check
     * @returns ***REMOVED***boolean***REMOVED*** True if there is a chance it contains an Error obj
     */
    couldBeError(node) ***REMOVED***
        switch (node.type) ***REMOVED***
            case "Identifier":
            case "CallExpression":
            case "NewExpression":
            case "MemberExpression":
            case "TaggedTemplateExpression":
            case "YieldExpression":
            case "AwaitExpression":
                return true; // possibly an error object.

            case "AssignmentExpression":
                return module.exports.couldBeError(node.right);

            case "SequenceExpression": ***REMOVED***
                const exprs = node.expressions;

                return exprs.length !== 0 && module.exports.couldBeError(exprs[exprs.length - 1]);
            ***REMOVED***

            case "LogicalExpression":
                return module.exports.couldBeError(node.left) || module.exports.couldBeError(node.right);

            case "ConditionalExpression":
                return module.exports.couldBeError(node.consequent) || module.exports.couldBeError(node.alternate);

            default:
                return false;
        ***REMOVED***
    ***REMOVED***,

    /**
     * Determines whether the given node is a `null` literal.
     * @param ***REMOVED***ASTNode***REMOVED*** node The node to check
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a `null` literal
     */
    isNullLiteral(node) ***REMOVED***

        /*
         * Checking `node.value === null` does not guarantee that a literal is a null literal.
         * When parsing values that cannot be represented in the current environment (e.g. unicode
         * regexes in Node 4), `node.value` is set to `null` because it wouldn't be possible to
         * set `node.value` to a unicode regex. To make sure a literal is actually `null`, check
         * `node.regex` instead. Also see: https://github.com/eslint/eslint/issues/8020
         */
        return node.type === "Literal" && node.value === null && !node.regex && !node.bigint;
    ***REMOVED***,

    /**
     * Determines whether two tokens can safely be placed next to each other without merging into a single token
     * @param ***REMOVED***Token|string***REMOVED*** leftValue The left token. If this is a string, it will be tokenized and the last token will be used.
     * @param ***REMOVED***Token|string***REMOVED*** rightValue The right token. If this is a string, it will be tokenized and the first token will be used.
     * @returns ***REMOVED***boolean***REMOVED*** If the tokens cannot be safely placed next to each other, returns `false`. If the tokens can be placed
     * next to each other, behavior is undefined (although it should return `true` in most cases).
     */
    canTokensBeAdjacent(leftValue, rightValue) ***REMOVED***
        let leftToken;

        if (typeof leftValue === "string") ***REMOVED***
            const leftTokens = espree.tokenize(leftValue, ***REMOVED*** ecmaVersion: 2015 ***REMOVED***);

            leftToken = leftTokens[leftTokens.length - 1];
        ***REMOVED*** else ***REMOVED***
            leftToken = leftValue;
        ***REMOVED***

        const rightToken = typeof rightValue === "string" ? espree.tokenize(rightValue, ***REMOVED*** ecmaVersion: 2015 ***REMOVED***)[0] : rightValue;

        if (leftToken.type === "Punctuator" || rightToken.type === "Punctuator") ***REMOVED***
            if (leftToken.type === "Punctuator" && rightToken.type === "Punctuator") ***REMOVED***
                const PLUS_TOKENS = new Set(["+", "++"]);
                const MINUS_TOKENS = new Set(["-", "--"]);

                return !(
                    PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) ||
                    MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value)
                );
            ***REMOVED***
            return true;
        ***REMOVED***

        if (
            leftToken.type === "String" || rightToken.type === "String" ||
            leftToken.type === "Template" || rightToken.type === "Template"
        ) ***REMOVED***
            return true;
        ***REMOVED***

        if (leftToken.type !== "Numeric" && rightToken.type === "Numeric" && rightToken.value.startsWith(".")) ***REMOVED***
            return true;
        ***REMOVED***

        return false;
    ***REMOVED***,

    /**
     * Get the `loc` object of a given name in a `/*globals` directive comment.
     * @param ***REMOVED***SourceCode***REMOVED*** sourceCode The source code to convert index to loc.
     * @param ***REMOVED***Comment***REMOVED*** comment The `/*globals` directive comment which include the name.
     * @param ***REMOVED***string***REMOVED*** name The name to find.
     * @returns ***REMOVED***SourceLocation***REMOVED*** The `loc` object.
     */
    getNameLocationInGlobalDirectiveComment(sourceCode, comment, name) ***REMOVED***
        const namePattern = new RegExp(`[\\s,]$***REMOVED***lodash.escapeRegExp(name)***REMOVED***(?:$|[\\s,:])`, "gu");

        // To ignore the first text "global".
        namePattern.lastIndex = comment.value.indexOf("global") + 6;

        // Search a given variable name.
        const match = namePattern.exec(comment.value);

        // Convert the index to loc.
        return sourceCode.getLocFromIndex(
            comment.range[0] +
            "/*".length +
            (match ? match.index + 1 : 0)
        );
    ***REMOVED***,

    /**
     * Determines whether the given raw string contains an octal escape sequence.
     *
     * "\1", "\2" ... "\7"
     * "\00", "\01" ... "\09"
     *
     * "\0", when not followed by a digit, is not an octal escape sequence.
     *
     * @param ***REMOVED***string***REMOVED*** rawString A string in its raw representation.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the string contains at least one octal escape sequence.
     */
    hasOctalEscapeSequence(rawString) ***REMOVED***
        return OCTAL_ESCAPE_PATTERN.test(rawString);
    ***REMOVED***
***REMOVED***;
