/**
 * @fileoverview Helper class to aid in constructing fix commands.
 * @author Alan Pierce
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./ast-utils");

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * A helper class to combine fix options into a fix command. Currently, it
 * exposes some "retain" methods that extend the range of the text being
 * replaced so that other fixes won't touch that region in the same pass.
 */
class FixTracker ***REMOVED***

    /**
     * Create a new FixTracker.
     *
     * @param ***REMOVED***ruleFixer***REMOVED*** fixer A ruleFixer instance.
     * @param ***REMOVED***SourceCode***REMOVED*** sourceCode A SourceCode object for the current code.
     */
    constructor(fixer, sourceCode) ***REMOVED***
        this.fixer = fixer;
        this.sourceCode = sourceCode;
        this.retainedRange = null;
    ***REMOVED***

    /**
     * Mark the given range as "retained", meaning that other fixes may not
     * may not modify this region in the same pass.
     *
     * @param ***REMOVED***int[]***REMOVED*** range The range to retain.
     * @returns ***REMOVED***FixTracker***REMOVED*** The same RuleFixer, for chained calls.
     */
    retainRange(range) ***REMOVED***
        this.retainedRange = range;
        return this;
    ***REMOVED***

    /**
     * Given a node, find the function containing it (or the entire program) and
     * mark it as retained, meaning that other fixes may not modify it in this
     * pass. This is useful for avoiding conflicts in fixes that modify control
     * flow.
     *
     * @param ***REMOVED***ASTNode***REMOVED*** node The node to use as a starting point.
     * @returns ***REMOVED***FixTracker***REMOVED*** The same RuleFixer, for chained calls.
     */
    retainEnclosingFunction(node) ***REMOVED***
        const functionNode = astUtils.getUpperFunction(node);

        return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);
    ***REMOVED***

    /**
     * Given a node or token, find the token before and afterward, and mark that
     * range as retained, meaning that other fixes may not modify it in this
     * pass. This is useful for avoiding conflicts in fixes that make a small
     * change to the code where the AST should not be changed.
     *
     * @param ***REMOVED***ASTNode|Token***REMOVED*** nodeOrToken The node or token to use as a starting
     *      point. The token to the left and right are use in the range.
     * @returns ***REMOVED***FixTracker***REMOVED*** The same RuleFixer, for chained calls.
     */
    retainSurroundingTokens(nodeOrToken) ***REMOVED***
        const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;
        const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;

        return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);
    ***REMOVED***

    /**
     * Create a fix command that replaces the given range with the given text,
     * accounting for any retained ranges.
     *
     * @param ***REMOVED***int[]***REMOVED*** range The range to remove in the fix.
     * @param ***REMOVED***string***REMOVED*** text The text to insert in place of the range.
     * @returns ***REMOVED***Object***REMOVED*** The fix command.
     */
    replaceTextRange(range, text) ***REMOVED***
        let actualRange;

        if (this.retainedRange) ***REMOVED***
            actualRange = [
                Math.min(this.retainedRange[0], range[0]),
                Math.max(this.retainedRange[1], range[1])
            ];
        ***REMOVED*** else ***REMOVED***
            actualRange = range;
        ***REMOVED***

        return this.fixer.replaceTextRange(
            actualRange,
            this.sourceCode.text.slice(actualRange[0], range[0]) +
                text +
                this.sourceCode.text.slice(range[1], actualRange[1])
        );
    ***REMOVED***

    /**
     * Create a fix command that removes the given node or token, accounting for
     * any retained ranges.
     *
     * @param ***REMOVED***ASTNode|Token***REMOVED*** nodeOrToken The node or token to remove.
     * @returns ***REMOVED***Object***REMOVED*** The fix command.
     */
    remove(nodeOrToken) ***REMOVED***
        return this.replaceTextRange(nodeOrToken.range, "");
    ***REMOVED***
***REMOVED***

module.exports = FixTracker;
