/**
 * @fileoverview `Map` to load rules lazily.
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict";

const debug = require("debug")("eslint:rules");

/** @typedef ***REMOVED***import("./types").Rule***REMOVED*** Rule */

/**
 * The `Map` object that loads each rule when it's accessed.
 *
 * @example
 * const rules = new LazyLoadingRuleMap([
 *     ["eqeqeq", () => require("eqeqeq")],
 *     ["semi", () => require("semi")],
 *     ["no-unused-vars", () => require("no-unused-vars")],
 * ])
 *
 * rules.get("semi") // call `() => require("semi")` here.
 *
 * @extends ***REMOVED***Map<string, () => Rule>***REMOVED***
 */
class LazyLoadingRuleMap extends Map ***REMOVED***

    /**
     * Initialize this map.
     * @param ***REMOVED***Array<[string, function(): Rule]>***REMOVED*** loaders The rule loaders.
     */
    constructor(loaders) ***REMOVED***
        let remaining = loaders.length;

        super(
            debug.enabled
                ? loaders.map(([ruleId, load]) => ***REMOVED***
                    let cache = null;

                    return [
                        ruleId,
                        () => ***REMOVED***
                            if (!cache) ***REMOVED***
                                debug("Loading rule %o (remaining=%d)", ruleId, --remaining);
                                cache = load();
                            ***REMOVED***
                            return cache;
                        ***REMOVED***
                    ];
                ***REMOVED***)
                : loaders
        );

        // `super(...iterable)` uses `this.set()`, so disable it here.
        Object.defineProperty(LazyLoadingRuleMap.prototype, "set", ***REMOVED***
            configurable: true,
            value: void 0
        ***REMOVED***);
    ***REMOVED***

    /**
     * Get a rule.
     * Each rule will be loaded on the first access.
     * @param ***REMOVED***string***REMOVED*** ruleId The rule ID to get.
     * @returns ***REMOVED***Rule|undefined***REMOVED*** The rule.
     */
    get(ruleId) ***REMOVED***
        const load = super.get(ruleId);

        return load && load();
    ***REMOVED***

    /**
     * Iterate rules.
     * @returns ***REMOVED***IterableIterator<Rule>***REMOVED*** Rules.
     */
    *values() ***REMOVED***
        for (const load of super.values()) ***REMOVED***
            yield load();
        ***REMOVED***
    ***REMOVED***

    /**
     * Iterate rules.
     * @returns ***REMOVED***IterableIterator<[string, Rule]>***REMOVED*** Rules.
     */
    *entries() ***REMOVED***
        for (const [ruleId, load] of super.entries()) ***REMOVED***
            yield [ruleId, load()];
        ***REMOVED***
    ***REMOVED***

    /**
     * Call a function with each rule.
     * @param ***REMOVED***Function***REMOVED*** callbackFn The callback function.
     * @param ***REMOVED***any***REMOVED*** [thisArg] The object to pass to `this` of the callback function.
     * @returns ***REMOVED***void***REMOVED***
     */
    forEach(callbackFn, thisArg) ***REMOVED***
        for (const [ruleId, load] of super.entries()) ***REMOVED***
            callbackFn.call(thisArg, load(), ruleId, this);
        ***REMOVED***
    ***REMOVED***
***REMOVED***

// Forbid mutation.
Object.defineProperties(LazyLoadingRuleMap.prototype, ***REMOVED***
    clear: ***REMOVED*** configurable: true, value: void 0 ***REMOVED***,
    delete: ***REMOVED*** configurable: true, value: void 0 ***REMOVED***,
    [Symbol.iterator]: ***REMOVED***
        configurable: true,
        writable: true,
        value: LazyLoadingRuleMap.prototype.entries
    ***REMOVED***
***REMOVED***);

module.exports = ***REMOVED*** LazyLoadingRuleMap ***REMOVED***;
