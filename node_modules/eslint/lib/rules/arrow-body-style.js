/**
 * @fileoverview Rule to require braces in arrow function body.
 * @author Alberto RodrÃ­guez
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "require braces around arrow function bodies",
            category: "ECMAScript 6",
            recommended: false,
            url: "https://eslint.org/docs/rules/arrow-body-style"
        ***REMOVED***,

        schema: ***REMOVED***
            anyOf: [
                ***REMOVED***
                    type: "array",
                    items: [
                        ***REMOVED***
                            enum: ["always", "never"]
                        ***REMOVED***
                    ],
                    minItems: 0,
                    maxItems: 1
                ***REMOVED***,
                ***REMOVED***
                    type: "array",
                    items: [
                        ***REMOVED***
                            enum: ["as-needed"]
                        ***REMOVED***,
                        ***REMOVED***
                            type: "object",
                            properties: ***REMOVED***
                                requireReturnForObjectLiteral: ***REMOVED*** type: "boolean" ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***
                    ],
                    minItems: 0,
                    maxItems: 2
                ***REMOVED***
            ]
        ***REMOVED***,

        fixable: "code",

        messages: ***REMOVED***
            unexpectedOtherBlock: "Unexpected block statement surrounding arrow body.",
            unexpectedEmptyBlock: "Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.",
            unexpectedObjectBlock: "Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.",
            unexpectedSingleBlock: "Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.",
            expectedBlock: "Expected block statement surrounding arrow body."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***
        const options = context.options;
        const always = options[0] === "always";
        const asNeeded = !options[0] || options[0] === "as-needed";
        const never = options[0] === "never";
        const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;
        const sourceCode = context.getSourceCode();

        /**
         * Checks whether the given node has ASI problem or not.
         * @param ***REMOVED***Token***REMOVED*** token The token to check.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if it changes semantics if `;` or `***REMOVED***` followed by the token are removed.
         */
        function hasASIProblem(token) ***REMOVED***
            return token && token.type === "Punctuator" && /^[([/`+-]/u.test(token.value);
        ***REMOVED***

        /**
         * Gets the closing parenthesis which is the pair of the given opening parenthesis.
         * @param ***REMOVED***Token***REMOVED*** token The opening parenthesis token to get.
         * @returns ***REMOVED***Token***REMOVED*** The found closing parenthesis token.
         */
        function findClosingParen(token) ***REMOVED***
            let node = sourceCode.getNodeByRangeIndex(token.range[1]);

            while (!astUtils.isParenthesised(sourceCode, node)) ***REMOVED***
                node = node.parent;
            ***REMOVED***
            return sourceCode.getTokenAfter(node);
        ***REMOVED***

        /**
         * Determines whether a arrow function body needs braces
         * @param ***REMOVED***ASTNode***REMOVED*** node The arrow function node.
         * @returns ***REMOVED***void***REMOVED***
         */
        function validate(node) ***REMOVED***
            const arrowBody = node.body;

            if (arrowBody.type === "BlockStatement") ***REMOVED***
                const blockBody = arrowBody.body;

                if (blockBody.length !== 1 && !never) ***REMOVED***
                    return;
                ***REMOVED***

                if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === "ReturnStatement" &&
                    blockBody[0].argument && blockBody[0].argument.type === "ObjectExpression") ***REMOVED***
                    return;
                ***REMOVED***

                if (never || asNeeded && blockBody[0].type === "ReturnStatement") ***REMOVED***
                    let messageId;

                    if (blockBody.length === 0) ***REMOVED***
                        messageId = "unexpectedEmptyBlock";
                    ***REMOVED*** else if (blockBody.length > 1) ***REMOVED***
                        messageId = "unexpectedOtherBlock";
                    ***REMOVED*** else if (blockBody[0].argument === null) ***REMOVED***
                        messageId = "unexpectedSingleBlock";
                    ***REMOVED*** else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], ***REMOVED*** skip: 1 ***REMOVED***))) ***REMOVED***
                        messageId = "unexpectedObjectBlock";
                    ***REMOVED*** else ***REMOVED***
                        messageId = "unexpectedSingleBlock";
                    ***REMOVED***

                    context.report(***REMOVED***
                        node,
                        loc: arrowBody.loc.start,
                        messageId,
                        fix(fixer) ***REMOVED***
                            const fixes = [];

                            if (blockBody.length !== 1 ||
                                blockBody[0].type !== "ReturnStatement" ||
                                !blockBody[0].argument ||
                                hasASIProblem(sourceCode.getTokenAfter(arrowBody))
                            ) ***REMOVED***
                                return fixes;
                            ***REMOVED***

                            const openingBrace = sourceCode.getFirstToken(arrowBody);
                            const closingBrace = sourceCode.getLastToken(arrowBody);
                            const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);
                            const lastValueToken = sourceCode.getLastToken(blockBody[0]);
                            const commentsExist =
                                sourceCode.commentsExistBetween(openingBrace, firstValueToken) ||
                                sourceCode.commentsExistBetween(lastValueToken, closingBrace);

                            /*
                             * Remove tokens around the return value.
                             * If comments don't exist, remove extra spaces as well.
                             */
                            if (commentsExist) ***REMOVED***
                                fixes.push(
                                    fixer.remove(openingBrace),
                                    fixer.remove(closingBrace),
                                    fixer.remove(sourceCode.getTokenAfter(openingBrace)) // return keyword
                                );
                            ***REMOVED*** else ***REMOVED***
                                fixes.push(
                                    fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]),
                                    fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]])
                                );
                            ***REMOVED***

                            /*
                             * If the first token of the reutrn value is `***REMOVED***` or the return value is a sequence expression,
                             * enclose the return value by parentheses to avoid syntax error.
                             */
                            if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === "SequenceExpression") ***REMOVED***
                                fixes.push(
                                    fixer.insertTextBefore(firstValueToken, "("),
                                    fixer.insertTextAfter(lastValueToken, ")")
                                );
                            ***REMOVED***

                            /*
                             * If the last token of the return statement is semicolon, remove it.
                             * Non-block arrow body is an expression, not a statement.
                             */
                            if (astUtils.isSemicolonToken(lastValueToken)) ***REMOVED***
                                fixes.push(fixer.remove(lastValueToken));
                            ***REMOVED***

                            return fixes;
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED*** else ***REMOVED***
                if (always || (asNeeded && requireReturnForObjectLiteral && arrowBody.type === "ObjectExpression")) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        loc: arrowBody.loc.start,
                        messageId: "expectedBlock",
                        fix(fixer) ***REMOVED***
                            const fixes = [];
                            const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);
                            const firstBodyToken = sourceCode.getTokenAfter(arrowToken);
                            const lastBodyToken = sourceCode.getLastToken(node);
                            const isParenthesisedObjectLiteral =
                                astUtils.isOpeningParenToken(firstBodyToken) &&
                                astUtils.isOpeningBraceToken(sourceCode.getTokenAfter(firstBodyToken));

                            // Wrap the value by a block and a return statement.
                            fixes.push(
                                fixer.insertTextBefore(firstBodyToken, "***REMOVED***return "),
                                fixer.insertTextAfter(lastBodyToken, "***REMOVED***")
                            );

                            // If the value is object literal, remove parentheses which were forced by syntax.
                            if (isParenthesisedObjectLiteral) ***REMOVED***
                                fixes.push(
                                    fixer.remove(firstBodyToken),
                                    fixer.remove(findClosingParen(firstBodyToken))
                                );
                            ***REMOVED***

                            return fixes;
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            "ArrowFunctionExpression:exit": validate
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
