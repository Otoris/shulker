/**
 * @fileoverview Rule to enforce that all class methods use 'this'.
 * @author Patrick Williams
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "enforce that class methods utilize `this`",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/class-methods-use-this"
        ***REMOVED***,

        schema: [***REMOVED***
            type: "object",
            properties: ***REMOVED***
                exceptMethods: ***REMOVED***
                    type: "array",
                    items: ***REMOVED***
                        type: "string"
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***,
            additionalProperties: false
        ***REMOVED***],

        messages: ***REMOVED***
            missingThis: "Expected 'this' to be used by class ***REMOVED******REMOVED***name***REMOVED******REMOVED***."
        ***REMOVED***
    ***REMOVED***,
    create(context) ***REMOVED***
        const config = Object.assign(***REMOVED******REMOVED***, context.options[0]);
        const exceptMethods = new Set(config.exceptMethods || []);

        const stack = [];

        /**
         * Initializes the current context to false and pushes it onto the stack.
         * These booleans represent whether 'this' has been used in the context.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function enterFunction() ***REMOVED***
            stack.push(false);
        ***REMOVED***

        /**
         * Check if the node is an instance method
         * @param ***REMOVED***ASTNode***REMOVED*** node - node to check
         * @returns ***REMOVED***boolean***REMOVED*** True if its an instance method
         * @private
         */
        function isInstanceMethod(node) ***REMOVED***
            return !node.static && node.kind !== "constructor" && node.type === "MethodDefinition";
        ***REMOVED***

        /**
         * Check if the node is an instance method not excluded by config
         * @param ***REMOVED***ASTNode***REMOVED*** node - node to check
         * @returns ***REMOVED***boolean***REMOVED*** True if it is an instance method, and not excluded by config
         * @private
         */
        function isIncludedInstanceMethod(node) ***REMOVED***
            return isInstanceMethod(node) &&
                (node.computed || !exceptMethods.has(node.key.name));
        ***REMOVED***

        /**
         * Checks if we are leaving a function that is a method, and reports if 'this' has not been used.
         * Static methods and the constructor are exempt.
         * Then pops the context off the stack.
         * @param ***REMOVED***ASTNode***REMOVED*** node - A function node that was entered.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function exitFunction(node) ***REMOVED***
            const methodUsesThis = stack.pop();

            if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) ***REMOVED***
                context.report(***REMOVED***
                    node,
                    messageId: "missingThis",
                    data: ***REMOVED***
                        name: astUtils.getFunctionNameWithKind(node)
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Mark the current context as having used 'this'.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function markThisUsed() ***REMOVED***
            if (stack.length) ***REMOVED***
                stack[stack.length - 1] = true;
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            FunctionDeclaration: enterFunction,
            "FunctionDeclaration:exit": exitFunction,
            FunctionExpression: enterFunction,
            "FunctionExpression:exit": exitFunction,
            ThisExpression: markThisUsed,
            Super: markThisUsed
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
