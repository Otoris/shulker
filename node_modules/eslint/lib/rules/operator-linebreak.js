/**
 * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before
 * @author BenoÃ®t Zugmeyer
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "enforce consistent linebreak style for operators",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/operator-linebreak"
        ***REMOVED***,

        schema: [
            ***REMOVED***
                enum: ["after", "before", "none", null]
            ***REMOVED***,
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    overrides: ***REMOVED***
                        type: "object",
                        properties: ***REMOVED***
                            anyOf: ***REMOVED***
                                type: "string",
                                enum: ["after", "before", "none", "ignore"]
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],

        fixable: "code"
    ***REMOVED***,

    create(context) ***REMOVED***

        const usedDefaultGlobal = !context.options[0];
        const globalStyle = context.options[0] || "after";
        const options = context.options[1] || ***REMOVED******REMOVED***;
        const styleOverrides = options.overrides ? Object.assign(***REMOVED******REMOVED***, options.overrides) : ***REMOVED******REMOVED***;

        if (usedDefaultGlobal && !styleOverrides["?"]) ***REMOVED***
            styleOverrides["?"] = "before";
        ***REMOVED***

        if (usedDefaultGlobal && !styleOverrides[":"]) ***REMOVED***
            styleOverrides[":"] = "before";
        ***REMOVED***

        const sourceCode = context.getSourceCode();

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Gets a fixer function to fix rule issues
         * @param ***REMOVED***Token***REMOVED*** operatorToken The operator token of an expression
         * @param ***REMOVED***string***REMOVED*** desiredStyle The style for the rule. One of 'before', 'after', 'none'
         * @returns ***REMOVED***Function***REMOVED*** A fixer function
         */
        function getFixer(operatorToken, desiredStyle) ***REMOVED***
            return fixer => ***REMOVED***
                const tokenBefore = sourceCode.getTokenBefore(operatorToken);
                const tokenAfter = sourceCode.getTokenAfter(operatorToken);
                const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);
                const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);
                const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);
                const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);
                let newTextBefore, newTextAfter;

                if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== "none") ***REMOVED***

                    // If there is a comment before and after the operator, don't do a fix.
                    if (sourceCode.getTokenBefore(operatorToken, ***REMOVED*** includeComments: true ***REMOVED***) !== tokenBefore &&
                        sourceCode.getTokenAfter(operatorToken, ***REMOVED*** includeComments: true ***REMOVED***) !== tokenAfter) ***REMOVED***

                        return null;
                    ***REMOVED***

                    /*
                     * If there is only one linebreak and it's on the wrong side of the operator, swap the text before and after the operator.
                     * foo &&
                     *           bar
                     * would get fixed to
                     * foo
                     *        && bar
                     */
                    newTextBefore = textAfter;
                    newTextAfter = textBefore;
                ***REMOVED*** else ***REMOVED***
                    const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();

                    // Otherwise, if no linebreak is desired and no comments interfere, replace the linebreaks with empty strings.
                    newTextBefore = desiredStyle === "before" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, "");
                    newTextAfter = desiredStyle === "after" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, "");

                    // If there was no change (due to interfering comments), don't output a fix.
                    if (newTextBefore === textBefore && newTextAfter === textAfter) ***REMOVED***
                        return null;
                    ***REMOVED***
                ***REMOVED***

                if (newTextAfter === "" && tokenAfter.type === "Punctuator" && "+-".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) ***REMOVED***

                    // To avoid accidentally creating a ++ or -- operator, insert a space if the operator is a +/- and the following token is a unary +/-.
                    newTextAfter += " ";
                ***REMOVED***

                return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);
            ***REMOVED***;
        ***REMOVED***

        /**
         * Checks the operator placement
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check
         * @param ***REMOVED***ASTNode***REMOVED*** leftSide The node that comes before the operator in `node`
         * @private
         * @returns ***REMOVED***void***REMOVED***
         */
        function validateNode(node, leftSide) ***REMOVED***

            /*
             * When the left part of a binary expression is a single expression wrapped in
             * parentheses (ex: `(a) + b`), leftToken will be the last token of the expression
             * and operatorToken will be the closing parenthesis.
             * The leftToken should be the last closing parenthesis, and the operatorToken
             * should be the token right after that.
             */
            const operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);
            const leftToken = sourceCode.getTokenBefore(operatorToken);
            const rightToken = sourceCode.getTokenAfter(operatorToken);
            const operator = operatorToken.value;
            const operatorStyleOverride = styleOverrides[operator];
            const style = operatorStyleOverride || globalStyle;
            const fix = getFixer(operatorToken, style);

            // if single line
            if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&
                    astUtils.isTokenOnSameLine(operatorToken, rightToken)) ***REMOVED***

                // do nothing.

            ***REMOVED*** else if (operatorStyleOverride !== "ignore" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&
                    !astUtils.isTokenOnSameLine(operatorToken, rightToken)) ***REMOVED***

                // lone operator
                context.report(***REMOVED***
                    node,
                    loc: ***REMOVED***
                        line: operatorToken.loc.end.line,
                        column: operatorToken.loc.end.column
                    ***REMOVED***,
                    message: "Bad line breaking before and after '***REMOVED******REMOVED***operator***REMOVED******REMOVED***'.",
                    data: ***REMOVED***
                        operator
                    ***REMOVED***,
                    fix
                ***REMOVED***);

            ***REMOVED*** else if (style === "before" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) ***REMOVED***

                context.report(***REMOVED***
                    node,
                    loc: ***REMOVED***
                        line: operatorToken.loc.end.line,
                        column: operatorToken.loc.end.column
                    ***REMOVED***,
                    message: "'***REMOVED******REMOVED***operator***REMOVED******REMOVED***' should be placed at the beginning of the line.",
                    data: ***REMOVED***
                        operator
                    ***REMOVED***,
                    fix
                ***REMOVED***);

            ***REMOVED*** else if (style === "after" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) ***REMOVED***

                context.report(***REMOVED***
                    node,
                    loc: ***REMOVED***
                        line: operatorToken.loc.end.line,
                        column: operatorToken.loc.end.column
                    ***REMOVED***,
                    message: "'***REMOVED******REMOVED***operator***REMOVED******REMOVED***' should be placed at the end of the line.",
                    data: ***REMOVED***
                        operator
                    ***REMOVED***,
                    fix
                ***REMOVED***);

            ***REMOVED*** else if (style === "none") ***REMOVED***

                context.report(***REMOVED***
                    node,
                    loc: ***REMOVED***
                        line: operatorToken.loc.end.line,
                        column: operatorToken.loc.end.column
                    ***REMOVED***,
                    message: "There should be no line break before or after '***REMOVED******REMOVED***operator***REMOVED******REMOVED***'.",
                    data: ***REMOVED***
                        operator
                    ***REMOVED***,
                    fix
                ***REMOVED***);

            ***REMOVED***
        ***REMOVED***

        /**
         * Validates a binary expression using `validateNode`
         * @param ***REMOVED***BinaryExpression|LogicalExpression|AssignmentExpression***REMOVED*** node node to be validated
         * @returns ***REMOVED***void***REMOVED***
         */
        function validateBinaryExpression(node) ***REMOVED***
            validateNode(node, node.left);
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***
            BinaryExpression: validateBinaryExpression,
            LogicalExpression: validateBinaryExpression,
            AssignmentExpression: validateBinaryExpression,
            VariableDeclarator(node) ***REMOVED***
                if (node.init) ***REMOVED***
                    validateNode(node, node.id);
                ***REMOVED***
            ***REMOVED***,
            ConditionalExpression(node) ***REMOVED***
                validateNode(node, node.test);
                validateNode(node, node.consequent);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
