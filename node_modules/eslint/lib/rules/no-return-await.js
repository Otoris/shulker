/**
 * @fileoverview Disallows unnecessary `return await`
 * @author Jordan Harband
 */
"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const message = "Redundant use of `await` on a return value.";

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow unnecessary `return await`",
            category: "Best Practices",

            recommended: false,

            url: "https://eslint.org/docs/rules/no-return-await"
        ***REMOVED***,

        fixable: null,

        schema: [
        ]
    ***REMOVED***,

    create(context) ***REMOVED***

        /**
         * Reports a found unnecessary `await` expression.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node representing the `await` expression to report
         * @returns ***REMOVED***void***REMOVED***
         */
        function reportUnnecessaryAwait(node) ***REMOVED***
            context.report(***REMOVED***
                node: context.getSourceCode().getFirstToken(node),
                loc: node.loc,
                message
            ***REMOVED***);
        ***REMOVED***

        /**
         * Determines whether a thrown error from this node will be caught/handled within this function rather than immediately halting
         * this function. For example, a statement in a `try` block will always have an error handler. A statement in
         * a `catch` block will only have an error handler if there is also a `finally` block.
         * @param ***REMOVED***ASTNode***REMOVED*** node A node representing a location where an could be thrown
         * @returns ***REMOVED***boolean***REMOVED*** `true` if a thrown error will be caught/handled in this function
         */
        function hasErrorHandler(node) ***REMOVED***
            let ancestor = node;

            while (!astUtils.isFunction(ancestor) && ancestor.type !== "Program") ***REMOVED***
                if (ancestor.parent.type === "TryStatement" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) ***REMOVED***
                    return true;
                ***REMOVED***
                ancestor = ancestor.parent;
            ***REMOVED***
            return false;
        ***REMOVED***

        /**
         * Checks if a node is placed in tail call position. Once `return` arguments (or arrow function expressions) can be a complex expression,
         * an `await` expression could or could not be unnecessary by the definition of this rule. So we're looking for `await` expressions that are in tail position.
         * @param ***REMOVED***ASTNode***REMOVED*** node A node representing the `await` expression to check
         * @returns ***REMOVED***boolean***REMOVED*** The checking result
         */
        function isInTailCallPosition(node) ***REMOVED***
            if (node.parent.type === "ArrowFunctionExpression") ***REMOVED***
                return true;
            ***REMOVED***
            if (node.parent.type === "ReturnStatement") ***REMOVED***
                return !hasErrorHandler(node.parent);
            ***REMOVED***
            if (node.parent.type === "ConditionalExpression" && (node === node.parent.consequent || node === node.parent.alternate)) ***REMOVED***
                return isInTailCallPosition(node.parent);
            ***REMOVED***
            if (node.parent.type === "LogicalExpression" && node === node.parent.right) ***REMOVED***
                return isInTailCallPosition(node.parent);
            ***REMOVED***
            if (node.parent.type === "SequenceExpression" && node === node.parent.expressions[node.parent.expressions.length - 1]) ***REMOVED***
                return isInTailCallPosition(node.parent);
            ***REMOVED***
            return false;
        ***REMOVED***

        return ***REMOVED***
            AwaitExpression(node) ***REMOVED***
                if (isInTailCallPosition(node) && !hasErrorHandler(node)) ***REMOVED***
                    reportUnnecessaryAwait(node);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
