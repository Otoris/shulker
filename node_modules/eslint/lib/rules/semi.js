/**
 * @fileoverview Rule to flag missing semicolons.
 * @author Nicholas C. Zakas
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const FixTracker = require("./utils/fix-tracker");
const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "require or disallow semicolons instead of ASI",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/semi"
        ***REMOVED***,

        fixable: "code",

        schema: ***REMOVED***
            anyOf: [
                ***REMOVED***
                    type: "array",
                    items: [
                        ***REMOVED***
                            enum: ["never"]
                        ***REMOVED***,
                        ***REMOVED***
                            type: "object",
                            properties: ***REMOVED***
                                beforeStatementContinuationChars: ***REMOVED***
                                    enum: ["always", "any", "never"]
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***
                    ],
                    minItems: 0,
                    maxItems: 2
                ***REMOVED***,
                ***REMOVED***
                    type: "array",
                    items: [
                        ***REMOVED***
                            enum: ["always"]
                        ***REMOVED***,
                        ***REMOVED***
                            type: "object",
                            properties: ***REMOVED***
                                omitLastInOneLineBlock: ***REMOVED*** type: "boolean" ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***
                    ],
                    minItems: 0,
                    maxItems: 2
                ***REMOVED***
            ]
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        const OPT_OUT_PATTERN = /^[-[(/+`]/u; // One of [(/+-`
        const options = context.options[1];
        const never = context.options[0] === "never";
        const exceptOneLine = Boolean(options && options.omitLastInOneLineBlock);
        const beforeStatementContinuationChars = options && options.beforeStatementContinuationChars || "any";
        const sourceCode = context.getSourceCode();

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Reports a semicolon error with appropriate location and message.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node with an extra or missing semicolon.
         * @param ***REMOVED***boolean***REMOVED*** missing True if the semicolon is missing.
         * @returns ***REMOVED***void***REMOVED***
         */
        function report(node, missing) ***REMOVED***
            const lastToken = sourceCode.getLastToken(node);
            let message,
                fix,
                loc = lastToken.loc;

            if (!missing) ***REMOVED***
                message = "Missing semicolon.";
                loc = loc.end;
                fix = function(fixer) ***REMOVED***
                    return fixer.insertTextAfter(lastToken, ";");
                ***REMOVED***;
            ***REMOVED*** else ***REMOVED***
                message = "Extra semicolon.";
                loc = loc.start;
                fix = function(fixer) ***REMOVED***

                    /*
                     * Expand the replacement range to include the surrounding
                     * tokens to avoid conflicting with no-extra-semi.
                     * https://github.com/eslint/eslint/issues/7928
                     */
                    return new FixTracker(fixer, sourceCode)
                        .retainSurroundingTokens(lastToken)
                        .remove(lastToken);
                ***REMOVED***;
            ***REMOVED***

            context.report(***REMOVED***
                node,
                loc,
                message,
                fix
            ***REMOVED***);

        ***REMOVED***

        /**
         * Check whether a given semicolon token is redandant.
         * @param ***REMOVED***Token***REMOVED*** semiToken A semicolon token to check.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the next token is `;` or `***REMOVED***`.
         */
        function isRedundantSemi(semiToken) ***REMOVED***
            const nextToken = sourceCode.getTokenAfter(semiToken);

            return (
                !nextToken ||
                astUtils.isClosingBraceToken(nextToken) ||
                astUtils.isSemicolonToken(nextToken)
            );
        ***REMOVED***

        /**
         * Check whether a given token is the closing brace of an arrow function.
         * @param ***REMOVED***Token***REMOVED*** lastToken A token to check.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is the closing brace of an arrow function.
         */
        function isEndOfArrowBlock(lastToken) ***REMOVED***
            if (!astUtils.isClosingBraceToken(lastToken)) ***REMOVED***
                return false;
            ***REMOVED***
            const node = sourceCode.getNodeByRangeIndex(lastToken.range[0]);

            return (
                node.type === "BlockStatement" &&
                node.parent.type === "ArrowFunctionExpression"
            );
        ***REMOVED***

        /**
         * Check whether a given node is on the same line with the next token.
         * @param ***REMOVED***Node***REMOVED*** node A statement node to check.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is on the same line with the next token.
         */
        function isOnSameLineWithNextToken(node) ***REMOVED***
            const prevToken = sourceCode.getLastToken(node, 1);
            const nextToken = sourceCode.getTokenAfter(node);

            return !!nextToken && astUtils.isTokenOnSameLine(prevToken, nextToken);
        ***REMOVED***

        /**
         * Check whether a given node can connect the next line if the next line is unreliable.
         * @param ***REMOVED***Node***REMOVED*** node A statement node to check.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the node can connect the next line.
         */
        function maybeAsiHazardAfter(node) ***REMOVED***
            const t = node.type;

            if (t === "DoWhileStatement" ||
                t === "BreakStatement" ||
                t === "ContinueStatement" ||
                t === "DebuggerStatement" ||
                t === "ImportDeclaration" ||
                t === "ExportAllDeclaration"
            ) ***REMOVED***
                return false;
            ***REMOVED***
            if (t === "ReturnStatement") ***REMOVED***
                return Boolean(node.argument);
            ***REMOVED***
            if (t === "ExportNamedDeclaration") ***REMOVED***
                return Boolean(node.declaration);
            ***REMOVED***
            if (isEndOfArrowBlock(sourceCode.getLastToken(node, 1))) ***REMOVED***
                return false;
            ***REMOVED***

            return true;
        ***REMOVED***

        /**
         * Check whether a given token can connect the previous statement.
         * @param ***REMOVED***Token***REMOVED*** token A token to check.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the token is one of `[`, `(`, `/`, `+`, `-`, ```, `++`, and `--`.
         */
        function maybeAsiHazardBefore(token) ***REMOVED***
            return (
                Boolean(token) &&
                OPT_OUT_PATTERN.test(token.value) &&
                token.value !== "++" &&
                token.value !== "--"
            );
        ***REMOVED***

        /**
         * Check if the semicolon of a given node is unnecessary, only true if:
         *   - next token is a valid statement divider (`;` or `***REMOVED***`).
         *   - next token is on a new line and the node is not connectable to the new line.
         * @param ***REMOVED***Node***REMOVED*** node A statement node to check.
         * @returns ***REMOVED***boolean***REMOVED*** whether the semicolon is unnecessary.
         */
        function canRemoveSemicolon(node) ***REMOVED***
            if (isRedundantSemi(sourceCode.getLastToken(node))) ***REMOVED***
                return true; // `;;` or `;***REMOVED***`
            ***REMOVED***
            if (isOnSameLineWithNextToken(node)) ***REMOVED***
                return false; // One liner.
            ***REMOVED***
            if (beforeStatementContinuationChars === "never" && !maybeAsiHazardAfter(node)) ***REMOVED***
                return true; // ASI works. This statement doesn't connect to the next.
            ***REMOVED***
            if (!maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) ***REMOVED***
                return true; // ASI works. The next token doesn't connect to this statement.
            ***REMOVED***

            return false;
        ***REMOVED***

        /**
         * Checks a node to see if it's in a one-liner block statement.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
         * @returns ***REMOVED***boolean***REMOVED*** whether the node is in a one-liner block statement.
         */
        function isOneLinerBlock(node) ***REMOVED***
            const parent = node.parent;
            const nextToken = sourceCode.getTokenAfter(node);

            if (!nextToken || nextToken.value !== "***REMOVED***") ***REMOVED***
                return false;
            ***REMOVED***
            return (
                !!parent &&
                parent.type === "BlockStatement" &&
                parent.loc.start.line === parent.loc.end.line
            );
        ***REMOVED***

        /**
         * Checks a node to see if it's followed by a semicolon.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkForSemicolon(node) ***REMOVED***
            const isSemi = astUtils.isSemicolonToken(sourceCode.getLastToken(node));

            if (never) ***REMOVED***
                if (isSemi && canRemoveSemicolon(node)) ***REMOVED***
                    report(node, true);
                ***REMOVED*** else if (!isSemi && beforeStatementContinuationChars === "always" && maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) ***REMOVED***
                    report(node);
                ***REMOVED***
            ***REMOVED*** else ***REMOVED***
                const oneLinerBlock = (exceptOneLine && isOneLinerBlock(node));

                if (isSemi && oneLinerBlock) ***REMOVED***
                    report(node, true);
                ***REMOVED*** else if (!isSemi && !oneLinerBlock) ***REMOVED***
                    report(node);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Checks to see if there's a semicolon after a variable declaration.
         * @param ***REMOVED***ASTNode***REMOVED*** node The node to check.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkForSemicolonForVariableDeclaration(node) ***REMOVED***
            const parent = node.parent;

            if ((parent.type !== "ForStatement" || parent.init !== node) &&
                (!/^For(?:In|Of)Statement/u.test(parent.type) || parent.left !== node)
            ) ***REMOVED***
                checkForSemicolon(node);
            ***REMOVED***
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public API
        //--------------------------------------------------------------------------

        return ***REMOVED***
            VariableDeclaration: checkForSemicolonForVariableDeclaration,
            ExpressionStatement: checkForSemicolon,
            ReturnStatement: checkForSemicolon,
            ThrowStatement: checkForSemicolon,
            DoWhileStatement: checkForSemicolon,
            DebuggerStatement: checkForSemicolon,
            BreakStatement: checkForSemicolon,
            ContinueStatement: checkForSemicolon,
            ImportDeclaration: checkForSemicolon,
            ExportAllDeclaration: checkForSemicolon,
            ExportNamedDeclaration(node) ***REMOVED***
                if (!node.declaration) ***REMOVED***
                    checkForSemicolon(node);
                ***REMOVED***
            ***REMOVED***,
            ExportDefaultDeclaration(node) ***REMOVED***
                if (!/(?:Class|Function)Declaration/u.test(node.declaration.type)) ***REMOVED***
                    checkForSemicolon(node);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
