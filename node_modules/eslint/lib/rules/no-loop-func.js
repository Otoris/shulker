/**
 * @fileoverview Rule to flag creation of function inside a loop
 * @author Ilya Volodin
 */

"use strict";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets the containing loop node of a specified node.
 *
 * We don't need to check nested functions, so this ignores those.
 * `Scope.through` contains references of nested functions.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - An AST node to get.
 * @returns ***REMOVED***ASTNode|null***REMOVED*** The containing loop node of the specified node, or
 *      `null`.
 */
function getContainingLoopNode(node) ***REMOVED***
    for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) ***REMOVED***
        const parent = currentNode.parent;

        switch (parent.type) ***REMOVED***
            case "WhileStatement":
            case "DoWhileStatement":
                return parent;

            case "ForStatement":

                // `init` is outside of the loop.
                if (parent.init !== currentNode) ***REMOVED***
                    return parent;
                ***REMOVED***
                break;

            case "ForInStatement":
            case "ForOfStatement":

                // `right` is outside of the loop.
                if (parent.right !== currentNode) ***REMOVED***
                    return parent;
                ***REMOVED***
                break;

            case "ArrowFunctionExpression":
            case "FunctionExpression":
            case "FunctionDeclaration":

                // We don't need to check nested functions.
                return null;

            default:
                break;
        ***REMOVED***
    ***REMOVED***

    return null;
***REMOVED***

/**
 * Gets the containing loop node of a given node.
 * If the loop was nested, this returns the most outer loop.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to get. This is a loop node.
 * @param ***REMOVED***ASTNode|null***REMOVED*** excludedNode - A node that the result node should not
 *      include.
 * @returns ***REMOVED***ASTNode***REMOVED*** The most outer loop node.
 */
function getTopLoopNode(node, excludedNode) ***REMOVED***
    const border = excludedNode ? excludedNode.range[1] : 0;
    let retv = node;
    let containingLoopNode = node;

    while (containingLoopNode && containingLoopNode.range[0] >= border) ***REMOVED***
        retv = containingLoopNode;
        containingLoopNode = getContainingLoopNode(containingLoopNode);
    ***REMOVED***

    return retv;
***REMOVED***

/**
 * Checks whether a given reference which refers to an upper scope's variable is
 * safe or not.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** loopNode - A containing loop node.
 * @param ***REMOVED***eslint-scope.Reference***REMOVED*** reference - A reference to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the reference is safe or not.
 */
function isSafe(loopNode, reference) ***REMOVED***
    const variable = reference.resolved;
    const definition = variable && variable.defs[0];
    const declaration = definition && definition.parent;
    const kind = (declaration && declaration.type === "VariableDeclaration")
        ? declaration.kind
        : "";

    // Variables which are declared by `const` is safe.
    if (kind === "const") ***REMOVED***
        return true;
    ***REMOVED***

    /*
     * Variables which are declared by `let` in the loop is safe.
     * It's a different instance from the next loop step's.
     */
    if (kind === "let" &&
        declaration.range[0] > loopNode.range[0] &&
        declaration.range[1] < loopNode.range[1]
    ) ***REMOVED***
        return true;
    ***REMOVED***

    /*
     * WriteReferences which exist after this border are unsafe because those
     * can modify the variable.
     */
    const border = getTopLoopNode(
        loopNode,
        (kind === "let") ? declaration : null
    ).range[0];

    /**
     * Checks whether a given reference is safe or not.
     * The reference is every reference of the upper scope's variable we are
     * looking now.
     *
     * It's safeafe if the reference matches one of the following condition.
     * - is readonly.
     * - doesn't exist inside a local function and after the border.
     *
     * @param ***REMOVED***eslint-scope.Reference***REMOVED*** upperRef - A reference to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the reference is safe.
     */
    function isSafeReference(upperRef) ***REMOVED***
        const id = upperRef.identifier;

        return (
            !upperRef.isWrite() ||
            variable.scope.variableScope === upperRef.from.variableScope &&
            id.range[0] < border
        );
    ***REMOVED***

    return Boolean(variable) && variable.references.every(isSafeReference);
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "suggestion",

        docs: ***REMOVED***
            description: "disallow function declarations that contain unsafe references inside loop statements",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-loop-func"
        ***REMOVED***,

        schema: [],

        messages: ***REMOVED***
            unsafeRefs: "Function declared in a loop contains unsafe references to variable(s) ***REMOVED******REMOVED*** varNames ***REMOVED******REMOVED***."
        ***REMOVED***
    ***REMOVED***,

    create(context) ***REMOVED***

        /**
         * Reports functions which match the following condition:
         *
         * - has a loop node in ancestors.
         * - has any references which refers to an unsafe variable.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node The AST node to check.
         * @returns ***REMOVED***boolean***REMOVED*** Whether or not the node is within a loop.
         */
        function checkForLoops(node) ***REMOVED***
            const loopNode = getContainingLoopNode(node);

            if (!loopNode) ***REMOVED***
                return;
            ***REMOVED***

            const references = context.getScope().through;
            const unsafeRefs = references.filter(r => !isSafe(loopNode, r)).map(r => r.identifier.name);

            if (unsafeRefs.length > 0) ***REMOVED***
                context.report(***REMOVED***
                    node,
                    messageId: "unsafeRefs",
                    data: ***REMOVED*** varNames: `'$***REMOVED***unsafeRefs.join("', '")***REMOVED***'` ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            ArrowFunctionExpression: checkForLoops,
            FunctionExpression: checkForLoops,
            FunctionDeclaration: checkForLoops
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
