/**
 * @fileoverview Require or disallow newline at the end of files
 * @author Nodeca Team <https://github.com/nodeca>
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const lodash = require("lodash");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "layout",

        docs: ***REMOVED***
            description: "require or disallow newline at the end of files",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/eol-last"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            ***REMOVED***
                enum: ["always", "never", "unix", "windows"]
            ***REMOVED***
        ],

        messages: ***REMOVED***
            missing: "Newline required at end of file but not found.",
            unexpected: "Newline not allowed at end of file."
        ***REMOVED***
    ***REMOVED***,
    create(context) ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return ***REMOVED***
            Program: function checkBadEOF(node) ***REMOVED***
                const sourceCode = context.getSourceCode(),
                    src = sourceCode.getText(),
                    location = ***REMOVED***
                        column: lodash.last(sourceCode.lines).length,
                        line: sourceCode.lines.length
                    ***REMOVED***,
                    LF = "\n",
                    CRLF = `\r$***REMOVED***LF***REMOVED***`,
                    endsWithNewline = lodash.endsWith(src, LF);

                /*
                 * Empty source is always valid: No content in file so we don't
                 * need to lint for a newline on the last line of content.
                 */
                if (!src.length) ***REMOVED***
                    return;
                ***REMOVED***

                let mode = context.options[0] || "always",
                    appendCRLF = false;

                if (mode === "unix") ***REMOVED***

                    // `"unix"` should behave exactly as `"always"`
                    mode = "always";
                ***REMOVED***
                if (mode === "windows") ***REMOVED***

                    // `"windows"` should behave exactly as `"always"`, but append CRLF in the fixer for backwards compatibility
                    mode = "always";
                    appendCRLF = true;
                ***REMOVED***
                if (mode === "always" && !endsWithNewline) ***REMOVED***

                    // File is not newline-terminated, but should be
                    context.report(***REMOVED***
                        node,
                        loc: location,
                        messageId: "missing",
                        fix(fixer) ***REMOVED***
                            return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED*** else if (mode === "never" && endsWithNewline) ***REMOVED***

                    // File is newline-terminated, but shouldn't be
                    context.report(***REMOVED***
                        node,
                        loc: location,
                        messageId: "unexpected",
                        fix(fixer) ***REMOVED***
                            const finalEOLs = /(?:\r?\n)+$/u,
                                match = finalEOLs.exec(sourceCode.text),
                                start = match.index,
                                end = sourceCode.text.length;

                            return fixer.replaceTextRange([start, end], "");
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
