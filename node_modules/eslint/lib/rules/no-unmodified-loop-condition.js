/**
 * @fileoverview Rule to disallow use of unmodified expressions in loop conditions
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const Traverser = require("../shared/traverser"),
    astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u;
const LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/u; // for-in/of statements don't have `test` property.
const GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/u;
const SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/u;
const DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;

/**
 * @typedef ***REMOVED***Object***REMOVED*** LoopConditionInfo
 * @property ***REMOVED***eslint-scope.Reference***REMOVED*** reference - The reference.
 * @property ***REMOVED***ASTNode***REMOVED*** group - BinaryExpression or ConditionalExpression nodes
 *      that the reference is belonging to.
 * @property ***REMOVED***Function***REMOVED*** isInLoop - The predicate which checks a given reference
 *      is in this loop.
 * @property ***REMOVED***boolean***REMOVED*** modified - The flag that the reference is modified in
 *      this loop.
 */

/**
 * Checks whether or not a given reference is a write reference.
 *
 * @param ***REMOVED***eslint-scope.Reference***REMOVED*** reference - A reference to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the reference is a write reference.
 */
function isWriteReference(reference) ***REMOVED***
    if (reference.init) ***REMOVED***
        const def = reference.resolved && reference.resolved.defs[0];

        if (!def || def.type !== "Variable" || def.parent.kind !== "var") ***REMOVED***
            return false;
        ***REMOVED***
    ***REMOVED***
    return reference.isWrite();
***REMOVED***

/**
 * Checks whether or not a given loop condition info does not have the modified
 * flag.
 *
 * @param ***REMOVED***LoopConditionInfo***REMOVED*** condition - A loop condition info to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the loop condition info is "unmodified".
 */
function isUnmodified(condition) ***REMOVED***
    return !condition.modified;
***REMOVED***

/**
 * Checks whether or not a given loop condition info does not have the modified
 * flag and does not have the group this condition belongs to.
 *
 * @param ***REMOVED***LoopConditionInfo***REMOVED*** condition - A loop condition info to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the loop condition info is "unmodified".
 */
function isUnmodifiedAndNotBelongToGroup(condition) ***REMOVED***
    return !(condition.modified || condition.group);
***REMOVED***

/**
 * Checks whether or not a given reference is inside of a given node.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @param ***REMOVED***eslint-scope.Reference***REMOVED*** reference - A reference to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the reference is inside of the node.
 */
function isInRange(node, reference) ***REMOVED***
    const or = node.range;
    const ir = reference.identifier.range;

    return or[0] <= ir[0] && ir[1] <= or[1];
***REMOVED***

/**
 * Checks whether or not a given reference is inside of a loop node's condition.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @param ***REMOVED***eslint-scope.Reference***REMOVED*** reference - A reference to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the reference is inside of the loop node's
 *      condition.
 */
const isInLoop = ***REMOVED***
    WhileStatement: isInRange,
    DoWhileStatement: isInRange,
    ForStatement(node, reference) ***REMOVED***
        return (
            isInRange(node, reference) &&
            !(node.init && isInRange(node.init, reference))
        );
    ***REMOVED***
***REMOVED***;

/**
 * Gets the function which encloses a given reference.
 * This supports only FunctionDeclaration.
 *
 * @param ***REMOVED***eslint-scope.Reference***REMOVED*** reference - A reference to get.
 * @returns ***REMOVED***ASTNode|null***REMOVED*** The function node or null.
 */
function getEncloseFunctionDeclaration(reference) ***REMOVED***
    let node = reference.identifier;

    while (node) ***REMOVED***
        if (node.type === "FunctionDeclaration") ***REMOVED***
            return node.id ? node : null;
        ***REMOVED***

        node = node.parent;
    ***REMOVED***

    return null;
***REMOVED***

/**
 * Updates the "modified" flags of given loop conditions with given modifiers.
 *
 * @param ***REMOVED***LoopConditionInfo[]***REMOVED*** conditions - The loop conditions to be updated.
 * @param ***REMOVED***eslint-scope.Reference[]***REMOVED*** modifiers - The references to update.
 * @returns ***REMOVED***void***REMOVED***
 */
function updateModifiedFlag(conditions, modifiers) ***REMOVED***

    for (let i = 0; i < conditions.length; ++i) ***REMOVED***
        const condition = conditions[i];

        for (let j = 0; !condition.modified && j < modifiers.length; ++j) ***REMOVED***
            const modifier = modifiers[j];
            let funcNode, funcVar;

            /*
             * Besides checking for the condition being in the loop, we want to
             * check the function that this modifier is belonging to is called
             * in the loop.
             * FIXME: This should probably be extracted to a function.
             */
            const inLoop = condition.isInLoop(modifier) || Boolean(
                (funcNode = getEncloseFunctionDeclaration(modifier)) &&
                (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) &&
                funcVar.references.some(condition.isInLoop)
            );

            condition.modified = inLoop;
        ***REMOVED***
    ***REMOVED***
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "problem",

        docs: ***REMOVED***
            description: "disallow unmodified loop conditions",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-unmodified-loop-condition"
        ***REMOVED***,

        schema: []
    ***REMOVED***,

    create(context) ***REMOVED***
        const sourceCode = context.getSourceCode();
        let groupMap = null;

        /**
         * Reports a given condition info.
         *
         * @param ***REMOVED***LoopConditionInfo***REMOVED*** condition - A loop condition info to report.
         * @returns ***REMOVED***void***REMOVED***
         */
        function report(condition) ***REMOVED***
            const node = condition.reference.identifier;

            context.report(***REMOVED***
                node,
                message: "'***REMOVED******REMOVED***name***REMOVED******REMOVED***' is not modified in this loop.",
                data: node
            ***REMOVED***);
        ***REMOVED***

        /**
         * Registers given conditions to the group the condition belongs to.
         *
         * @param ***REMOVED***LoopConditionInfo[]***REMOVED*** conditions - A loop condition info to
         *      register.
         * @returns ***REMOVED***void***REMOVED***
         */
        function registerConditionsToGroup(conditions) ***REMOVED***
            for (let i = 0; i < conditions.length; ++i) ***REMOVED***
                const condition = conditions[i];

                if (condition.group) ***REMOVED***
                    let group = groupMap.get(condition.group);

                    if (!group) ***REMOVED***
                        group = [];
                        groupMap.set(condition.group, group);
                    ***REMOVED***
                    group.push(condition);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Reports references which are inside of unmodified groups.
         *
         * @param ***REMOVED***LoopConditionInfo[]***REMOVED*** conditions - A loop condition info to report.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkConditionsInGroup(conditions) ***REMOVED***
            if (conditions.every(isUnmodified)) ***REMOVED***
                conditions.forEach(report);
            ***REMOVED***
        ***REMOVED***

        /**
         * Checks whether or not a given group node has any dynamic elements.
         *
         * @param ***REMOVED***ASTNode***REMOVED*** root - A node to check.
         *      This node is one of BinaryExpression or ConditionalExpression.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is dynamic.
         */
        function hasDynamicExpressions(root) ***REMOVED***
            let retv = false;

            Traverser.traverse(root, ***REMOVED***
                visitorKeys: sourceCode.visitorKeys,
                enter(node) ***REMOVED***
                    if (DYNAMIC_PATTERN.test(node.type)) ***REMOVED***
                        retv = true;
                        this.break();
                    ***REMOVED*** else if (SKIP_PATTERN.test(node.type)) ***REMOVED***
                        this.skip();
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            return retv;
        ***REMOVED***

        /**
         * Creates the loop condition information from a given reference.
         *
         * @param ***REMOVED***eslint-scope.Reference***REMOVED*** reference - A reference to create.
         * @returns ***REMOVED***LoopConditionInfo|null***REMOVED*** Created loop condition info, or null.
         */
        function toLoopCondition(reference) ***REMOVED***
            if (reference.init) ***REMOVED***
                return null;
            ***REMOVED***

            let group = null;
            let child = reference.identifier;
            let node = child.parent;

            while (node) ***REMOVED***
                if (SENTINEL_PATTERN.test(node.type)) ***REMOVED***
                    if (LOOP_PATTERN.test(node.type) && node.test === child) ***REMOVED***

                        // This reference is inside of a loop condition.
                        return ***REMOVED***
                            reference,
                            group,
                            isInLoop: isInLoop[node.type].bind(null, node),
                            modified: false
                        ***REMOVED***;
                    ***REMOVED***

                    // This reference is outside of a loop condition.
                    break;
                ***REMOVED***

                /*
                 * If it's inside of a group, OK if either operand is modified.
                 * So stores the group this reference belongs to.
                 */
                if (GROUP_PATTERN.test(node.type)) ***REMOVED***

                    // If this expression is dynamic, no need to check.
                    if (hasDynamicExpressions(node)) ***REMOVED***
                        break;
                    ***REMOVED*** else ***REMOVED***
                        group = node;
                    ***REMOVED***
                ***REMOVED***

                child = node;
                node = node.parent;
            ***REMOVED***

            return null;
        ***REMOVED***

        /**
         * Finds unmodified references which are inside of a loop condition.
         * Then reports the references which are outside of groups.
         *
         * @param ***REMOVED***eslint-scope.Variable***REMOVED*** variable - A variable to report.
         * @returns ***REMOVED***void***REMOVED***
         */
        function checkReferences(variable) ***REMOVED***

            // Gets references that exist in loop conditions.
            const conditions = variable
                .references
                .map(toLoopCondition)
                .filter(Boolean);

            if (conditions.length === 0) ***REMOVED***
                return;
            ***REMOVED***

            // Registers the conditions to belonging groups.
            registerConditionsToGroup(conditions);

            // Check the conditions are modified.
            const modifiers = variable.references.filter(isWriteReference);

            if (modifiers.length > 0) ***REMOVED***
                updateModifiedFlag(conditions, modifiers);
            ***REMOVED***

            /*
             * Reports the conditions which are not belonging to groups.
             * Others will be reported after all variables are done.
             */
            conditions
                .filter(isUnmodifiedAndNotBelongToGroup)
                .forEach(report);
        ***REMOVED***

        return ***REMOVED***
            "Program:exit"() ***REMOVED***
                const queue = [context.getScope()];

                groupMap = new Map();

                let scope;

                while ((scope = queue.pop())) ***REMOVED***
                    queue.push(...scope.childScopes);
                    scope.variables.forEach(checkReferences);
                ***REMOVED***

                groupMap.forEach(checkConditionsInGroup);
                groupMap = null;
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
