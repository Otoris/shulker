/**
 * @fileoverview A rule to disallow using `this`/`super` before `super()`.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given node is a constructor.
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check. This node type is one of
 *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and
 *   `ArrowFunctionExpression`.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is a constructor.
 */
function isConstructorFunction(node) ***REMOVED***
    return (
        node.type === "FunctionExpression" &&
        node.parent.type === "MethodDefinition" &&
        node.parent.kind === "constructor"
    );
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = ***REMOVED***
    meta: ***REMOVED***
        type: "problem",

        docs: ***REMOVED***
            description: "disallow `this`/`super` before calling `super()` in constructors",
            category: "ECMAScript 6",
            recommended: true,
            url: "https://eslint.org/docs/rules/no-this-before-super"
        ***REMOVED***,

        schema: []
    ***REMOVED***,

    create(context) ***REMOVED***

        /*
         * Information for each constructor.
         * - upper:      Information of the upper constructor.
         * - hasExtends: A flag which shows whether the owner class has a valid
         *   `extends` part.
         * - scope:      The scope of the owner class.
         * - codePath:   The code path of this constructor.
         */
        let funcInfo = null;

        /*
         * Information for each code path segment.
         * Each key is the id of a code path segment.
         * Each value is an object:
         * - superCalled:  The flag which shows `super()` called in all code paths.
         * - invalidNodes: The array of invalid ThisExpression and Super nodes.
         */
        let segInfoMap = Object.create(null);

        /**
         * Gets whether or not `super()` is called in a given code path segment.
         * @param ***REMOVED***CodePathSegment***REMOVED*** segment - A code path segment to get.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if `super()` is called.
         */
        function isCalled(segment) ***REMOVED***
            return !segment.reachable || segInfoMap[segment.id].superCalled;
        ***REMOVED***

        /**
         * Checks whether or not this is in a constructor.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if this is in a constructor.
         */
        function isInConstructorOfDerivedClass() ***REMOVED***
            return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);
        ***REMOVED***

        /**
         * Checks whether or not this is before `super()` is called.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if this is before `super()` is called.
         */
        function isBeforeCallOfSuper() ***REMOVED***
            return (
                isInConstructorOfDerivedClass() &&
                !funcInfo.codePath.currentSegments.every(isCalled)
            );
        ***REMOVED***

        /**
         * Sets a given node as invalid.
         * @param ***REMOVED***ASTNode***REMOVED*** node - A node to set as invalid. This is one of
         *      a ThisExpression and a Super.
         * @returns ***REMOVED***void***REMOVED***
         */
        function setInvalid(node) ***REMOVED***
            const segments = funcInfo.codePath.currentSegments;

            for (let i = 0; i < segments.length; ++i) ***REMOVED***
                const segment = segments[i];

                if (segment.reachable) ***REMOVED***
                    segInfoMap[segment.id].invalidNodes.push(node);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Sets the current segment as `super` was called.
         * @returns ***REMOVED***void***REMOVED***
         */
        function setSuperCalled() ***REMOVED***
            const segments = funcInfo.codePath.currentSegments;

            for (let i = 0; i < segments.length; ++i) ***REMOVED***
                const segment = segments[i];

                if (segment.reachable) ***REMOVED***
                    segInfoMap[segment.id].superCalled = true;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***

            /**
             * Adds information of a constructor into the stack.
             * @param ***REMOVED***CodePath***REMOVED*** codePath - A code path which was started.
             * @param ***REMOVED***ASTNode***REMOVED*** node - The current node.
             * @returns ***REMOVED***void***REMOVED***
             */
            onCodePathStart(codePath, node) ***REMOVED***
                if (isConstructorFunction(node)) ***REMOVED***

                    // Class > ClassBody > MethodDefinition > FunctionExpression
                    const classNode = node.parent.parent.parent;

                    funcInfo = ***REMOVED***
                        upper: funcInfo,
                        isConstructor: true,
                        hasExtends: Boolean(
                            classNode.superClass &&
                            !astUtils.isNullOrUndefined(classNode.superClass)
                        ),
                        codePath
                    ***REMOVED***;
                ***REMOVED*** else ***REMOVED***
                    funcInfo = ***REMOVED***
                        upper: funcInfo,
                        isConstructor: false,
                        hasExtends: false,
                        codePath
                    ***REMOVED***;
                ***REMOVED***
            ***REMOVED***,

            /**
             * Removes the top of stack item.
             *
             * And this treverses all segments of this code path then reports every
             * invalid node.
             *
             * @param ***REMOVED***CodePath***REMOVED*** codePath - A code path which was ended.
             * @returns ***REMOVED***void***REMOVED***
             */
            onCodePathEnd(codePath) ***REMOVED***
                const isDerivedClass = funcInfo.hasExtends;

                funcInfo = funcInfo.upper;
                if (!isDerivedClass) ***REMOVED***
                    return;
                ***REMOVED***

                codePath.traverseSegments((segment, controller) => ***REMOVED***
                    const info = segInfoMap[segment.id];

                    for (let i = 0; i < info.invalidNodes.length; ++i) ***REMOVED***
                        const invalidNode = info.invalidNodes[i];

                        context.report(***REMOVED***
                            message: "'***REMOVED******REMOVED***kind***REMOVED******REMOVED***' is not allowed before 'super()'.",
                            node: invalidNode,
                            data: ***REMOVED***
                                kind: invalidNode.type === "Super" ? "super" : "this"
                            ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED***

                    if (info.superCalled) ***REMOVED***
                        controller.skip();
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***,

            /**
             * Initialize information of a given code path segment.
             * @param ***REMOVED***CodePathSegment***REMOVED*** segment - A code path segment to initialize.
             * @returns ***REMOVED***void***REMOVED***
             */
            onCodePathSegmentStart(segment) ***REMOVED***
                if (!isInConstructorOfDerivedClass()) ***REMOVED***
                    return;
                ***REMOVED***

                // Initialize info.
                segInfoMap[segment.id] = ***REMOVED***
                    superCalled: (
                        segment.prevSegments.length > 0 &&
                        segment.prevSegments.every(isCalled)
                    ),
                    invalidNodes: []
                ***REMOVED***;
            ***REMOVED***,

            /**
             * Update information of the code path segment when a code path was
             * looped.
             * @param ***REMOVED***CodePathSegment***REMOVED*** fromSegment - The code path segment of the
             *      end of a loop.
             * @param ***REMOVED***CodePathSegment***REMOVED*** toSegment - A code path segment of the head
             *      of a loop.
             * @returns ***REMOVED***void***REMOVED***
             */
            onCodePathSegmentLoop(fromSegment, toSegment) ***REMOVED***
                if (!isInConstructorOfDerivedClass()) ***REMOVED***
                    return;
                ***REMOVED***

                // Update information inside of the loop.
                funcInfo.codePath.traverseSegments(
                    ***REMOVED*** first: toSegment, last: fromSegment ***REMOVED***,
                    (segment, controller) => ***REMOVED***
                        const info = segInfoMap[segment.id];

                        if (info.superCalled) ***REMOVED***
                            info.invalidNodes = [];
                            controller.skip();
                        ***REMOVED*** else if (
                            segment.prevSegments.length > 0 &&
                            segment.prevSegments.every(isCalled)
                        ) ***REMOVED***
                            info.superCalled = true;
                            info.invalidNodes = [];
                        ***REMOVED***
                    ***REMOVED***
                );
            ***REMOVED***,

            /**
             * Reports if this is before `super()`.
             * @param ***REMOVED***ASTNode***REMOVED*** node - A target node.
             * @returns ***REMOVED***void***REMOVED***
             */
            ThisExpression(node) ***REMOVED***
                if (isBeforeCallOfSuper()) ***REMOVED***
                    setInvalid(node);
                ***REMOVED***
            ***REMOVED***,

            /**
             * Reports if this is before `super()`.
             * @param ***REMOVED***ASTNode***REMOVED*** node - A target node.
             * @returns ***REMOVED***void***REMOVED***
             */
            Super(node) ***REMOVED***
                if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) ***REMOVED***
                    setInvalid(node);
                ***REMOVED***
            ***REMOVED***,

            /**
             * Marks `super()` called.
             * @param ***REMOVED***ASTNode***REMOVED*** node - A target node.
             * @returns ***REMOVED***void***REMOVED***
             */
            "CallExpression:exit"(node) ***REMOVED***
                if (node.callee.type === "Super" && isBeforeCallOfSuper()) ***REMOVED***
                    setSuperCalled();
                ***REMOVED***
            ***REMOVED***,

            /**
             * Resets state.
             * @returns ***REMOVED***void***REMOVED***
             */
            "Program:exit"() ***REMOVED***
                segInfoMap = Object.create(null);
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
