/**
 * @fileoverview Abstraction of JavaScript source code.
 * @author Nicholas C. Zakas
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const
    ***REMOVED*** isCommentToken ***REMOVED*** = require("eslint-utils"),
    TokenStore = require("./token-store"),
    astUtils = require("../shared/ast-utils"),
    Traverser = require("../shared/traverser"),
    lodash = require("lodash");

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

/**
 * Validates that the given AST has the required information.
 * @param ***REMOVED***ASTNode***REMOVED*** ast The Program node of the AST to check.
 * @throws ***REMOVED***Error***REMOVED*** If the AST doesn't contain the correct information.
 * @returns ***REMOVED***void***REMOVED***
 * @private
 */
function validate(ast) ***REMOVED***
    if (!ast.tokens) ***REMOVED***
        throw new Error("AST is missing the tokens array.");
    ***REMOVED***

    if (!ast.comments) ***REMOVED***
        throw new Error("AST is missing the comments array.");
    ***REMOVED***

    if (!ast.loc) ***REMOVED***
        throw new Error("AST is missing location information.");
    ***REMOVED***

    if (!ast.range) ***REMOVED***
        throw new Error("AST is missing range information");
    ***REMOVED***
***REMOVED***

/**
 * Check to see if its a ES6 export declaration.
 * @param ***REMOVED***ASTNode***REMOVED*** astNode An AST node.
 * @returns ***REMOVED***boolean***REMOVED*** whether the given node represents an export declaration.
 * @private
 */
function looksLikeExport(astNode) ***REMOVED***
    return astNode.type === "ExportDefaultDeclaration" || astNode.type === "ExportNamedDeclaration" ||
        astNode.type === "ExportAllDeclaration" || astNode.type === "ExportSpecifier";
***REMOVED***

/**
 * Merges two sorted lists into a larger sorted list in O(n) time.
 * @param ***REMOVED***Token[]***REMOVED*** tokens The list of tokens.
 * @param ***REMOVED***Token[]***REMOVED*** comments The list of comments.
 * @returns ***REMOVED***Token[]***REMOVED*** A sorted list of tokens and comments.
 * @private
 */
function sortedMerge(tokens, comments) ***REMOVED***
    const result = [];
    let tokenIndex = 0;
    let commentIndex = 0;

    while (tokenIndex < tokens.length || commentIndex < comments.length) ***REMOVED***
        if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) ***REMOVED***
            result.push(tokens[tokenIndex++]);
        ***REMOVED*** else ***REMOVED***
            result.push(comments[commentIndex++]);
        ***REMOVED***
    ***REMOVED***

    return result;
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

class SourceCode extends TokenStore ***REMOVED***

    /**
     * Represents parsed source code.
     * @param ***REMOVED***string|Object***REMOVED*** textOrConfig - The source code text or config object.
     * @param ***REMOVED***string***REMOVED*** textOrConfig.text - The source code text.
     * @param ***REMOVED***ASTNode***REMOVED*** textOrConfig.ast - The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.
     * @param ***REMOVED***Object|null***REMOVED*** textOrConfig.parserServices - The parser services.
     * @param ***REMOVED***ScopeManager|null***REMOVED*** textOrConfig.scopeManager - The scope of this source code.
     * @param ***REMOVED***Object|null***REMOVED*** textOrConfig.visitorKeys - The visitor keys to traverse AST.
     * @param ***REMOVED***ASTNode***REMOVED*** [astIfNoConfig] - The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.
     * @constructor
     */
    constructor(textOrConfig, astIfNoConfig) ***REMOVED***
        let text, ast, parserServices, scopeManager, visitorKeys;

        // Process overloading.
        if (typeof textOrConfig === "string") ***REMOVED***
            text = textOrConfig;
            ast = astIfNoConfig;
        ***REMOVED*** else if (typeof textOrConfig === "object" && textOrConfig !== null) ***REMOVED***
            text = textOrConfig.text;
            ast = textOrConfig.ast;
            parserServices = textOrConfig.parserServices;
            scopeManager = textOrConfig.scopeManager;
            visitorKeys = textOrConfig.visitorKeys;
        ***REMOVED***

        validate(ast);
        super(ast.tokens, ast.comments);

        /**
         * The flag to indicate that the source code has Unicode BOM.
         * @type boolean
         */
        this.hasBOM = (text.charCodeAt(0) === 0xFEFF);

        /**
         * The original text source code.
         * BOM was stripped from this text.
         * @type string
         */
        this.text = (this.hasBOM ? text.slice(1) : text);

        /**
         * The parsed AST for the source code.
         * @type ASTNode
         */
        this.ast = ast;

        /**
         * The parser services of this source code.
         * @type ***REMOVED***Object***REMOVED***
         */
        this.parserServices = parserServices || ***REMOVED******REMOVED***;

        /**
         * The scope of this source code.
         * @type ***REMOVED***ScopeManager|null***REMOVED***
         */
        this.scopeManager = scopeManager || null;

        /**
         * The visitor keys to traverse AST.
         * @type ***REMOVED***Object***REMOVED***
         */
        this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;

        // Check the source text for the presence of a shebang since it is parsed as a standard line comment.
        const shebangMatched = this.text.match(astUtils.shebangPattern);
        const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];

        if (hasShebang) ***REMOVED***
            ast.comments[0].type = "Shebang";
        ***REMOVED***

        this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);

        /**
         * The source code split into lines according to ECMA-262 specification.
         * This is done to avoid each rule needing to do so separately.
         * @type string[]
         */
        this.lines = [];
        this.lineStartIndices = [0];

        const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();
        let match;

        /*
         * Previously, this was implemented using a regex that
         * matched a sequence of non-linebreak characters followed by a
         * linebreak, then adding the lengths of the matches. However,
         * this caused a catastrophic backtracking issue when the end
         * of a file contained a large number of non-newline characters.
         * To avoid this, the current implementation just matches newlines
         * and uses match.index to get the correct line start indices.
         */
        while ((match = lineEndingPattern.exec(this.text))) ***REMOVED***
            this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));
            this.lineStartIndices.push(match.index + match[0].length);
        ***REMOVED***
        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));

        // Cache for comments found using getComments().
        this._commentCache = new WeakMap();

        // don't allow modification of this object
        Object.freeze(this);
        Object.freeze(this.lines);
    ***REMOVED***

    /**
     * Split the source code into multiple lines based on the line delimiters.
     * @param ***REMOVED***string***REMOVED*** text Source code as a string.
     * @returns ***REMOVED***string[]***REMOVED*** Array of source code lines.
     * @public
     */
    static splitLines(text) ***REMOVED***
        return text.split(astUtils.createGlobalLinebreakMatcher());
    ***REMOVED***

    /**
     * Gets the source code for the given node.
     * @param ***REMOVED***ASTNode=***REMOVED*** node The AST node to get the text for.
     * @param ***REMOVED***int=***REMOVED*** beforeCount The number of characters before the node to retrieve.
     * @param ***REMOVED***int=***REMOVED*** afterCount The number of characters after the node to retrieve.
     * @returns ***REMOVED***string***REMOVED*** The text representing the AST node.
     * @public
     */
    getText(node, beforeCount, afterCount) ***REMOVED***
        if (node) ***REMOVED***
            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),
                node.range[1] + (afterCount || 0));
        ***REMOVED***
        return this.text;
    ***REMOVED***

    /**
     * Gets the entire source text split into an array of lines.
     * @returns ***REMOVED***Array***REMOVED*** The source text as an array of lines.
     * @public
     */
    getLines() ***REMOVED***
        return this.lines;
    ***REMOVED***

    /**
     * Retrieves an array containing all comments in the source code.
     * @returns ***REMOVED***ASTNode[]***REMOVED*** An array of comment nodes.
     * @public
     */
    getAllComments() ***REMOVED***
        return this.ast.comments;
    ***REMOVED***

    /**
     * Gets all comments for the given node.
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node to get the comments for.
     * @returns ***REMOVED***Object***REMOVED*** An object containing a leading and trailing array
     *      of comments indexed by their position.
     * @public
     */
    getComments(node) ***REMOVED***
        if (this._commentCache.has(node)) ***REMOVED***
            return this._commentCache.get(node);
        ***REMOVED***

        const comments = ***REMOVED***
            leading: [],
            trailing: []
        ***REMOVED***;

        /*
         * Return all comments as leading comments of the Program node when
         * there is no executable code.
         */
        if (node.type === "Program") ***REMOVED***
            if (node.body.length === 0) ***REMOVED***
                comments.leading = node.comments;
            ***REMOVED***
        ***REMOVED*** else ***REMOVED***

            /*
             * Return comments as trailing comments of nodes that only contain
             * comments (to mimic the comment attachment behavior present in Espree).
             */
            if ((node.type === "BlockStatement" || node.type === "ClassBody") && node.body.length === 0 ||
                node.type === "ObjectExpression" && node.properties.length === 0 ||
                node.type === "ArrayExpression" && node.elements.length === 0 ||
                node.type === "SwitchStatement" && node.cases.length === 0
            ) ***REMOVED***
                comments.trailing = this.getTokens(node, ***REMOVED***
                    includeComments: true,
                    filter: isCommentToken
                ***REMOVED***);
            ***REMOVED***

            /*
             * Iterate over tokens before and after node and collect comment tokens.
             * Do not include comments that exist outside of the parent node
             * to avoid duplication.
             */
            let currentToken = this.getTokenBefore(node, ***REMOVED*** includeComments: true ***REMOVED***);

            while (currentToken && isCommentToken(currentToken)) ***REMOVED***
                if (node.parent && (currentToken.start < node.parent.start)) ***REMOVED***
                    break;
                ***REMOVED***
                comments.leading.push(currentToken);
                currentToken = this.getTokenBefore(currentToken, ***REMOVED*** includeComments: true ***REMOVED***);
            ***REMOVED***

            comments.leading.reverse();

            currentToken = this.getTokenAfter(node, ***REMOVED*** includeComments: true ***REMOVED***);

            while (currentToken && isCommentToken(currentToken)) ***REMOVED***
                if (node.parent && (currentToken.end > node.parent.end)) ***REMOVED***
                    break;
                ***REMOVED***
                comments.trailing.push(currentToken);
                currentToken = this.getTokenAfter(currentToken, ***REMOVED*** includeComments: true ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        this._commentCache.set(node, comments);
        return comments;
    ***REMOVED***

    /**
     * Retrieves the JSDoc comment for a given node.
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node to get the comment for.
     * @returns ***REMOVED***Token|null***REMOVED*** The Block comment token containing the JSDoc comment
     *      for the given node or null if not found.
     * @public
     * @deprecated
     */
    getJSDocComment(node) ***REMOVED***

        /**
         * Checks for the presence of a JSDoc comment for the given node and returns it.
         * @param ***REMOVED***ASTNode***REMOVED*** astNode The AST node to get the comment for.
         * @returns ***REMOVED***Token|null***REMOVED*** The Block comment token containing the JSDoc comment
         *      for the given node or null if not found.
         * @private
         */
        const findJSDocComment = astNode => ***REMOVED***
            const tokenBefore = this.getTokenBefore(astNode, ***REMOVED*** includeComments: true ***REMOVED***);

            if (
                tokenBefore &&
                isCommentToken(tokenBefore) &&
                tokenBefore.type === "Block" &&
                tokenBefore.value.charAt(0) === "*" &&
                astNode.loc.start.line - tokenBefore.loc.end.line <= 1
            ) ***REMOVED***
                return tokenBefore;
            ***REMOVED***

            return null;
        ***REMOVED***;
        let parent = node.parent;

        switch (node.type) ***REMOVED***
            case "ClassDeclaration":
            case "FunctionDeclaration":
                return findJSDocComment(looksLikeExport(parent) ? parent : node);

            case "ClassExpression":
                return findJSDocComment(parent.parent);

            case "ArrowFunctionExpression":
            case "FunctionExpression":
                if (parent.type !== "CallExpression" && parent.type !== "NewExpression") ***REMOVED***
                    while (
                        !this.getCommentsBefore(parent).length &&
                        !/Function/u.test(parent.type) &&
                        parent.type !== "MethodDefinition" &&
                        parent.type !== "Property"
                    ) ***REMOVED***
                        parent = parent.parent;

                        if (!parent) ***REMOVED***
                            break;
                        ***REMOVED***
                    ***REMOVED***

                    if (parent && parent.type !== "FunctionDeclaration" && parent.type !== "Program") ***REMOVED***
                        return findJSDocComment(parent);
                    ***REMOVED***
                ***REMOVED***

                return findJSDocComment(node);

            // falls through
            default:
                return null;
        ***REMOVED***
    ***REMOVED***

    /**
     * Gets the deepest node containing a range index.
     * @param ***REMOVED***int***REMOVED*** index Range index of the desired node.
     * @returns ***REMOVED***ASTNode***REMOVED*** The node if found or null if not found.
     * @public
     */
    getNodeByRangeIndex(index) ***REMOVED***
        let result = null;

        Traverser.traverse(this.ast, ***REMOVED***
            visitorKeys: this.visitorKeys,
            enter(node) ***REMOVED***
                if (node.range[0] <= index && index < node.range[1]) ***REMOVED***
                    result = node;
                ***REMOVED*** else ***REMOVED***
                    this.skip();
                ***REMOVED***
            ***REMOVED***,
            leave(node) ***REMOVED***
                if (node === result) ***REMOVED***
                    this.break();
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***);

        return result;
    ***REMOVED***

    /**
     * Determines if two tokens have at least one whitespace character
     * between them. This completely disregards comments in making the
     * determination, so comments count as zero-length substrings.
     * @param ***REMOVED***Token***REMOVED*** first The token to check after.
     * @param ***REMOVED***Token***REMOVED*** second The token to check before.
     * @returns ***REMOVED***boolean***REMOVED*** True if there is only space between tokens, false
     *  if there is anything other than whitespace between tokens.
     * @public
     */
    isSpaceBetweenTokens(first, second) ***REMOVED***
        const text = this.text.slice(first.range[1], second.range[0]);

        return /\s/u.test(text.replace(/\/\*.*?\*\//gu, ""));
    ***REMOVED***

    /**
     * Converts a source text index into a (line, column) pair.
     * @param ***REMOVED***number***REMOVED*** index The index of a character in a file
     * @returns ***REMOVED***Object***REMOVED*** A ***REMOVED***line, column***REMOVED*** location object with a 0-indexed column
     * @public
     */
    getLocFromIndex(index) ***REMOVED***
        if (typeof index !== "number") ***REMOVED***
            throw new TypeError("Expected `index` to be a number.");
        ***REMOVED***

        if (index < 0 || index > this.text.length) ***REMOVED***
            throw new RangeError(`Index out of range (requested index $***REMOVED***index***REMOVED***, but source text has length $***REMOVED***this.text.length***REMOVED***).`);
        ***REMOVED***

        /*
         * For an argument of this.text.length, return the location one "spot" past the last character
         * of the file. If the last character is a linebreak, the location will be column 0 of the next
         * line; otherwise, the location will be in the next column on the same line.
         *
         * See getIndexFromLoc for the motivation for this special case.
         */
        if (index === this.text.length) ***REMOVED***
            return ***REMOVED*** line: this.lines.length, column: this.lines[this.lines.length - 1].length ***REMOVED***;
        ***REMOVED***

        /*
         * To figure out which line rangeIndex is on, determine the last index at which rangeIndex could
         * be inserted into lineIndices to keep the list sorted.
         */
        const lineNumber = lodash.sortedLastIndex(this.lineStartIndices, index);

        return ***REMOVED*** line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1] ***REMOVED***;
    ***REMOVED***

    /**
     * Converts a (line, column) pair into a range index.
     * @param ***REMOVED***Object***REMOVED*** loc A line/column location
     * @param ***REMOVED***number***REMOVED*** loc.line The line number of the location (1-indexed)
     * @param ***REMOVED***number***REMOVED*** loc.column The column number of the location (0-indexed)
     * @returns ***REMOVED***number***REMOVED*** The range index of the location in the file.
     * @public
     */
    getIndexFromLoc(loc) ***REMOVED***
        if (typeof loc !== "object" || typeof loc.line !== "number" || typeof loc.column !== "number") ***REMOVED***
            throw new TypeError("Expected `loc` to be an object with numeric `line` and `column` properties.");
        ***REMOVED***

        if (loc.line <= 0) ***REMOVED***
            throw new RangeError(`Line number out of range (line $***REMOVED***loc.line***REMOVED*** requested). Line numbers should be 1-based.`);
        ***REMOVED***

        if (loc.line > this.lineStartIndices.length) ***REMOVED***
            throw new RangeError(`Line number out of range (line $***REMOVED***loc.line***REMOVED*** requested, but only $***REMOVED***this.lineStartIndices.length***REMOVED*** lines present).`);
        ***REMOVED***

        const lineStartIndex = this.lineStartIndices[loc.line - 1];
        const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];
        const positionIndex = lineStartIndex + loc.column;

        /*
         * By design, getIndexFromLoc(***REMOVED*** line: lineNum, column: 0 ***REMOVED***) should return the start index of
         * the given line, provided that the line number is valid element of this.lines. Since the
         * last element of this.lines is an empty string for files with trailing newlines, add a
         * special case where getting the index for the first location after the end of the file
         * will return the length of the file, rather than throwing an error. This allows rules to
         * use getIndexFromLoc consistently without worrying about edge cases at the end of a file.
         */
        if (
            loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex ||
            loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex
        ) ***REMOVED***
            throw new RangeError(`Column number out of range (column $***REMOVED***loc.column***REMOVED*** requested, but the length of line $***REMOVED***loc.line***REMOVED*** is $***REMOVED***lineEndIndex - lineStartIndex***REMOVED***).`);
        ***REMOVED***

        return positionIndex;
    ***REMOVED***
***REMOVED***

module.exports = SourceCode;
