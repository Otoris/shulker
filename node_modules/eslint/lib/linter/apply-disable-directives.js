/**
 * @fileoverview A module that filters reported problems based on `eslint-disable` and `eslint-enable` comments
 * @author Teddy Katz
 */

"use strict";

const lodash = require("lodash");

/**
 * Compares the locations of two objects in a source file
 * @param ***REMOVED******REMOVED***line: number, column: number***REMOVED******REMOVED*** itemA The first object
 * @param ***REMOVED******REMOVED***line: number, column: number***REMOVED******REMOVED*** itemB The second object
 * @returns ***REMOVED***number***REMOVED*** A value less than 1 if itemA appears before itemB in the source file, greater than 1 if
 * itemA appears after itemB in the source file, or 0 if itemA and itemB have the same location.
 */
function compareLocations(itemA, itemB) ***REMOVED***
    return itemA.line - itemB.line || itemA.column - itemB.column;
***REMOVED***

/**
 * This is the same as the exported function, except that it
 * doesn't handle disable-line and disable-next-line directives, and it always reports unused
 * disable directives.
 * @param ***REMOVED***Object***REMOVED*** options options for applying directives. This is the same as the options
 * for the exported function, except that `reportUnusedDisableDirectives` is not supported
 * (this function always reports unused disable directives).
 * @returns ***REMOVED******REMOVED***problems: Problem[], unusedDisableDirectives: Problem[]***REMOVED******REMOVED*** An object with a list
 * of filtered problems and unused eslint-disable directives
 */
function applyDirectives(options) ***REMOVED***
    const problems = [];
    let nextDirectiveIndex = 0;
    let currentGlobalDisableDirective = null;
    const disabledRuleMap = new Map();

    // enabledRules is only used when there is a current global disable directive.
    const enabledRules = new Set();
    const usedDisableDirectives = new Set();

    for (const problem of options.problems) ***REMOVED***
        while (
            nextDirectiveIndex < options.directives.length &&
            compareLocations(options.directives[nextDirectiveIndex], problem) <= 0
        ) ***REMOVED***
            const directive = options.directives[nextDirectiveIndex++];

            switch (directive.type) ***REMOVED***
                case "disable":
                    if (directive.ruleId === null) ***REMOVED***
                        currentGlobalDisableDirective = directive;
                        disabledRuleMap.clear();
                        enabledRules.clear();
                    ***REMOVED*** else if (currentGlobalDisableDirective) ***REMOVED***
                        enabledRules.delete(directive.ruleId);
                        disabledRuleMap.set(directive.ruleId, directive);
                    ***REMOVED*** else ***REMOVED***
                        disabledRuleMap.set(directive.ruleId, directive);
                    ***REMOVED***
                    break;

                case "enable":
                    if (directive.ruleId === null) ***REMOVED***
                        currentGlobalDisableDirective = null;
                        disabledRuleMap.clear();
                    ***REMOVED*** else if (currentGlobalDisableDirective) ***REMOVED***
                        enabledRules.add(directive.ruleId);
                        disabledRuleMap.delete(directive.ruleId);
                    ***REMOVED*** else ***REMOVED***
                        disabledRuleMap.delete(directive.ruleId);
                    ***REMOVED***
                    break;

                // no default
            ***REMOVED***
        ***REMOVED***

        if (disabledRuleMap.has(problem.ruleId)) ***REMOVED***
            usedDisableDirectives.add(disabledRuleMap.get(problem.ruleId));
        ***REMOVED*** else if (currentGlobalDisableDirective && !enabledRules.has(problem.ruleId)) ***REMOVED***
            usedDisableDirectives.add(currentGlobalDisableDirective);
        ***REMOVED*** else ***REMOVED***
            problems.push(problem);
        ***REMOVED***
    ***REMOVED***

    const unusedDisableDirectives = options.directives
        .filter(directive => directive.type === "disable" && !usedDisableDirectives.has(directive))
        .map(directive => (***REMOVED***
            ruleId: null,
            message: directive.ruleId
                ? `Unused eslint-disable directive (no problems were reported from '$***REMOVED***directive.ruleId***REMOVED***').`
                : "Unused eslint-disable directive (no problems were reported).",
            line: directive.unprocessedDirective.line,
            column: directive.unprocessedDirective.column,
            severity: options.reportUnusedDisableDirectives === "warn" ? 1 : 2,
            nodeType: null
        ***REMOVED***));

    return ***REMOVED*** problems, unusedDisableDirectives ***REMOVED***;
***REMOVED***

/**
 * Given a list of directive comments (i.e. metadata about eslint-disable and eslint-enable comments) and a list
 * of reported problems, determines which problems should be reported.
 * @param ***REMOVED***Object***REMOVED*** options Information about directives and problems
 * @param ***REMOVED******REMOVED***
 *      type: ("disable"|"enable"|"disable-line"|"disable-next-line"),
 *      ruleId: (string|null),
 *      line: number,
 *      column: number
 * ***REMOVED******REMOVED*** options.directives Directive comments found in the file, with one-based columns.
 * Two directive comments can only have the same location if they also have the same type (e.g. a single eslint-disable
 * comment for two different rules is represented as two directives).
 * @param ***REMOVED******REMOVED***ruleId: (string|null), line: number, column: number***REMOVED***[]***REMOVED*** options.problems
 * A list of problems reported by rules, sorted by increasing location in the file, with one-based columns.
 * @param ***REMOVED***"off" | "warn" | "error"***REMOVED*** options.reportUnusedDisableDirectives If `"warn"` or `"error"`, adds additional problems for unused directives
 * @returns ***REMOVED******REMOVED***ruleId: (string|null), line: number, column: number***REMOVED***[]***REMOVED***
 * A list of reported problems that were not disabled by the directive comments.
 */
module.exports = (***REMOVED*** directives, problems, reportUnusedDisableDirectives = "off" ***REMOVED***) => ***REMOVED***
    const blockDirectives = directives
        .filter(directive => directive.type === "disable" || directive.type === "enable")
        .map(directive => Object.assign(***REMOVED******REMOVED***, directive, ***REMOVED*** unprocessedDirective: directive ***REMOVED***))
        .sort(compareLocations);

    const lineDirectives = lodash.flatMap(directives, directive => ***REMOVED***
        switch (directive.type) ***REMOVED***
            case "disable":
            case "enable":
                return [];

            case "disable-line":
                return [
                    ***REMOVED*** type: "disable", line: directive.line, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive ***REMOVED***,
                    ***REMOVED*** type: "enable", line: directive.line + 1, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive ***REMOVED***
                ];

            case "disable-next-line":
                return [
                    ***REMOVED*** type: "disable", line: directive.line + 1, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive ***REMOVED***,
                    ***REMOVED*** type: "enable", line: directive.line + 2, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive ***REMOVED***
                ];

            default:
                throw new TypeError(`Unrecognized directive type '$***REMOVED***directive.type***REMOVED***'`);
        ***REMOVED***
    ***REMOVED***).sort(compareLocations);

    const blockDirectivesResult = applyDirectives(***REMOVED***
        problems,
        directives: blockDirectives,
        reportUnusedDisableDirectives
    ***REMOVED***);
    const lineDirectivesResult = applyDirectives(***REMOVED***
        problems: blockDirectivesResult.problems,
        directives: lineDirectives,
        reportUnusedDisableDirectives
    ***REMOVED***);

    return reportUnusedDisableDirectives !== "off"
        ? lineDirectivesResult.problems
            .concat(blockDirectivesResult.unusedDisableDirectives)
            .concat(lineDirectivesResult.unusedDisableDirectives)
            .sort(compareLocations)
        : lineDirectivesResult.problems;
***REMOVED***;
