/**
 * @fileoverview A helper that translates context.report() calls from the rule API into generic problem objects
 * @author Teddy Katz
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const assert = require("assert");
const ruleFixer = require("./rule-fixer");
const interpolate = require("./interpolate");

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/**
 * An error message description
 * @typedef ***REMOVED***Object***REMOVED*** MessageDescriptor
 * @property ***REMOVED***ASTNode***REMOVED*** [node] The reported node
 * @property ***REMOVED***Location***REMOVED*** loc The location of the problem.
 * @property ***REMOVED***string***REMOVED*** message The problem message.
 * @property ***REMOVED***Object***REMOVED*** [data] Optional data to use to fill in placeholders in the
 *      message.
 * @property ***REMOVED***Function***REMOVED*** [fix] The function to call that creates a fix command.
 */

/**
 * Information about the report
 * @typedef ***REMOVED***Object***REMOVED*** ReportInfo
 * @property ***REMOVED***string***REMOVED*** ruleId
 * @property ***REMOVED***(0|1|2)***REMOVED*** severity
 * @property ***REMOVED***(string|undefined)***REMOVED*** message
 * @property ***REMOVED***(string|undefined)***REMOVED*** messageId
 * @property ***REMOVED***number***REMOVED*** line
 * @property ***REMOVED***number***REMOVED*** column
 * @property ***REMOVED***(number|undefined)***REMOVED*** endLine
 * @property ***REMOVED***(number|undefined)***REMOVED*** endColumn
 * @property ***REMOVED***(string|null)***REMOVED*** nodeType
 * @property ***REMOVED***string***REMOVED*** source
 * @property ***REMOVED***(***REMOVED***text: string, range: (number[]|null)***REMOVED***|null)***REMOVED*** fix
 */

//------------------------------------------------------------------------------
// Module Definition
//------------------------------------------------------------------------------


/**
 * Translates a multi-argument context.report() call into a single object argument call
 * @param ***REMOVED***...****REMOVED*** args A list of arguments passed to `context.report`
 * @returns ***REMOVED***MessageDescriptor***REMOVED*** A normalized object containing report information
 */
function normalizeMultiArgReportCall(...args) ***REMOVED***

    // If there is one argument, it is considered to be a new-style call already.
    if (args.length === 1) ***REMOVED***

        // Shallow clone the object to avoid surprises if reusing the descriptor
        return Object.assign(***REMOVED******REMOVED***, args[0]);
    ***REMOVED***

    // If the second argument is a string, the arguments are interpreted as [node, message, data, fix].
    if (typeof args[1] === "string") ***REMOVED***
        return ***REMOVED***
            node: args[0],
            message: args[1],
            data: args[2],
            fix: args[3]
        ***REMOVED***;
    ***REMOVED***

    // Otherwise, the arguments are interpreted as [node, loc, message, data, fix].
    return ***REMOVED***
        node: args[0],
        loc: args[1],
        message: args[2],
        data: args[3],
        fix: args[4]
    ***REMOVED***;
***REMOVED***

/**
 * Asserts that either a loc or a node was provided, and the node is valid if it was provided.
 * @param ***REMOVED***MessageDescriptor***REMOVED*** descriptor A descriptor to validate
 * @returns ***REMOVED***void***REMOVED***
 * @throws AssertionError if neither a node nor a loc was provided, or if the node is not an object
 */
function assertValidNodeInfo(descriptor) ***REMOVED***
    if (descriptor.node) ***REMOVED***
        assert(typeof descriptor.node === "object", "Node must be an object");
    ***REMOVED*** else ***REMOVED***
        assert(descriptor.loc, "Node must be provided when reporting error if location is not provided");
    ***REMOVED***
***REMOVED***

/**
 * Normalizes a MessageDescriptor to always have a `loc` with `start` and `end` properties
 * @param ***REMOVED***MessageDescriptor***REMOVED*** descriptor A descriptor for the report from a rule.
 * @returns ***REMOVED******REMOVED***start: Location, end: (Location|null)***REMOVED******REMOVED*** An updated location that infers the `start` and `end` properties
 * from the `node` of the original descriptor, or infers the `start` from the `loc` of the original descriptor.
 */
function normalizeReportLoc(descriptor) ***REMOVED***
    if (descriptor.loc) ***REMOVED***
        if (descriptor.loc.start) ***REMOVED***
            return descriptor.loc;
        ***REMOVED***
        return ***REMOVED*** start: descriptor.loc, end: null ***REMOVED***;
    ***REMOVED***
    return descriptor.node.loc;
***REMOVED***

/**
 * Compares items in a fixes array by range.
 * @param ***REMOVED***Fix***REMOVED*** a The first message.
 * @param ***REMOVED***Fix***REMOVED*** b The second message.
 * @returns ***REMOVED***int***REMOVED*** -1 if a comes before b, 1 if a comes after b, 0 if equal.
 * @private
 */
function compareFixesByRange(a, b) ***REMOVED***
    return a.range[0] - b.range[0] || a.range[1] - b.range[1];
***REMOVED***

/**
 * Merges the given fixes array into one.
 * @param ***REMOVED***Fix[]***REMOVED*** fixes The fixes to merge.
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode The source code object to get the text between fixes.
 * @returns ***REMOVED******REMOVED***text: string, range: number[]***REMOVED******REMOVED*** The merged fixes
 */
function mergeFixes(fixes, sourceCode) ***REMOVED***
    if (fixes.length === 0) ***REMOVED***
        return null;
    ***REMOVED***
    if (fixes.length === 1) ***REMOVED***
        return fixes[0];
    ***REMOVED***

    fixes.sort(compareFixesByRange);

    const originalText = sourceCode.text;
    const start = fixes[0].range[0];
    const end = fixes[fixes.length - 1].range[1];
    let text = "";
    let lastPos = Number.MIN_SAFE_INTEGER;

    for (const fix of fixes) ***REMOVED***
        assert(fix.range[0] >= lastPos, "Fix objects must not be overlapped in a report.");

        if (fix.range[0] >= 0) ***REMOVED***
            text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);
        ***REMOVED***
        text += fix.text;
        lastPos = fix.range[1];
    ***REMOVED***
    text += originalText.slice(Math.max(0, start, lastPos), end);

    return ***REMOVED*** range: [start, end], text ***REMOVED***;
***REMOVED***

/**
 * Gets one fix object from the given descriptor.
 * If the descriptor retrieves multiple fixes, this merges those to one.
 * @param ***REMOVED***MessageDescriptor***REMOVED*** descriptor The report descriptor.
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode The source code object to get text between fixes.
 * @returns ***REMOVED***(***REMOVED***text: string, range: number[]***REMOVED***|null)***REMOVED*** The fix for the descriptor
 */
function normalizeFixes(descriptor, sourceCode) ***REMOVED***
    if (typeof descriptor.fix !== "function") ***REMOVED***
        return null;
    ***REMOVED***

    // @type ***REMOVED***null | Fix | Fix[] | IterableIterator<Fix>***REMOVED***
    const fix = descriptor.fix(ruleFixer);

    // Merge to one.
    if (fix && Symbol.iterator in fix) ***REMOVED***
        return mergeFixes(Array.from(fix), sourceCode);
    ***REMOVED***
    return fix;
***REMOVED***

/**
 * Creates information about the report from a descriptor
 * @param ***REMOVED***Object***REMOVED*** options Information about the problem
 * @param ***REMOVED***string***REMOVED*** options.ruleId Rule ID
 * @param ***REMOVED***(0|1|2)***REMOVED*** options.severity Rule severity
 * @param ***REMOVED***(ASTNode|null)***REMOVED*** options.node Node
 * @param ***REMOVED***string***REMOVED*** options.message Error message
 * @param ***REMOVED***string***REMOVED*** [options.messageId] The error message ID.
 * @param ***REMOVED******REMOVED***start: SourceLocation, end: (SourceLocation|null)***REMOVED******REMOVED*** options.loc Start and end location
 * @param ***REMOVED******REMOVED***text: string, range: (number[]|null)***REMOVED******REMOVED*** options.fix The fix object
 * @returns ***REMOVED***function(...args): ReportInfo***REMOVED*** Function that returns information about the report
 */
function createProblem(options) ***REMOVED***
    const problem = ***REMOVED***
        ruleId: options.ruleId,
        severity: options.severity,
        message: options.message,
        line: options.loc.start.line,
        column: options.loc.start.column + 1,
        nodeType: options.node && options.node.type || null
    ***REMOVED***;

    /*
     * If this isnâ€™t in the conditional, some of the tests fail
     * because `messageId` is present in the problem object
     */
    if (options.messageId) ***REMOVED***
        problem.messageId = options.messageId;
    ***REMOVED***

    if (options.loc.end) ***REMOVED***
        problem.endLine = options.loc.end.line;
        problem.endColumn = options.loc.end.column + 1;
    ***REMOVED***

    if (options.fix) ***REMOVED***
        problem.fix = options.fix;
    ***REMOVED***

    return problem;
***REMOVED***

/**
 * Returns a function that converts the arguments of a `context.report` call from a rule into a reported
 * problem for the Node.js API.
 * @param ***REMOVED******REMOVED***ruleId: string, severity: number, sourceCode: SourceCode, messageIds: Object, disableFixes: boolean***REMOVED******REMOVED*** metadata Metadata for the reported problem
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode The `SourceCode` instance for the text being linted
 * @returns ***REMOVED***function(...args): ReportInfo***REMOVED*** Function that returns information about the report
 */

module.exports = function createReportTranslator(metadata) ***REMOVED***

    /*
     * `createReportTranslator` gets called once per enabled rule per file. It needs to be very performant.
     * The report translator itself (i.e. the function that `createReportTranslator` returns) gets
     * called every time a rule reports a problem, which happens much less frequently (usually, the vast
     * majority of rules don't report any problems for a given file).
     */
    return (...args) => ***REMOVED***
        const descriptor = normalizeMultiArgReportCall(...args);

        assertValidNodeInfo(descriptor);

        let computedMessage;

        if (descriptor.messageId) ***REMOVED***
            if (!metadata.messageIds) ***REMOVED***
                throw new TypeError("context.report() called with a messageId, but no messages were present in the rule metadata.");
            ***REMOVED***
            const id = descriptor.messageId;
            const messages = metadata.messageIds;

            if (descriptor.message) ***REMOVED***
                throw new TypeError("context.report() called with a message and a messageId. Please only pass one.");
            ***REMOVED***
            if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) ***REMOVED***
                throw new TypeError(`context.report() called with a messageId of '$***REMOVED***id***REMOVED***' which is not present in the 'messages' config: $***REMOVED***JSON.stringify(messages, null, 2)***REMOVED***`);
            ***REMOVED***
            computedMessage = messages[id];
        ***REMOVED*** else if (descriptor.message) ***REMOVED***
            computedMessage = descriptor.message;
        ***REMOVED*** else ***REMOVED***
            throw new TypeError("Missing `message` property in report() call; add a message that describes the linting problem.");
        ***REMOVED***


        return createProblem(***REMOVED***
            ruleId: metadata.ruleId,
            severity: metadata.severity,
            node: descriptor.node,
            message: interpolate(computedMessage, descriptor.data),
            messageId: descriptor.messageId,
            loc: normalizeReportLoc(descriptor),
            fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode)
        ***REMOVED***);
    ***REMOVED***;
***REMOVED***;
