/**
 * @fileoverview An object that caches and applies source code fixes.
 * @author Nicholas C. Zakas
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const debug = require("debug")("eslint:source-code-fixer");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const BOM = "\uFEFF";

/**
 * Compares items in a messages array by range.
 * @param ***REMOVED***Message***REMOVED*** a The first message.
 * @param ***REMOVED***Message***REMOVED*** b The second message.
 * @returns ***REMOVED***int***REMOVED*** -1 if a comes before b, 1 if a comes after b, 0 if equal.
 * @private
 */
function compareMessagesByFixRange(a, b) ***REMOVED***
    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];
***REMOVED***

/**
 * Compares items in a messages array by line and column.
 * @param ***REMOVED***Message***REMOVED*** a The first message.
 * @param ***REMOVED***Message***REMOVED*** b The second message.
 * @returns ***REMOVED***int***REMOVED*** -1 if a comes before b, 1 if a comes after b, 0 if equal.
 * @private
 */
function compareMessagesByLocation(a, b) ***REMOVED***
    return a.line - b.line || a.column - b.column;
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * Utility for apply fixes to source code.
 * @constructor
 */
function SourceCodeFixer() ***REMOVED***
    Object.freeze(this);
***REMOVED***

/**
 * Applies the fixes specified by the messages to the given text. Tries to be
 * smart about the fixes and won't apply fixes over the same area in the text.
 * @param ***REMOVED***string***REMOVED*** sourceText The text to apply the changes to.
 * @param ***REMOVED***Message[]***REMOVED*** messages The array of messages reported by ESLint.
 * @param ***REMOVED***boolean|Function***REMOVED*** [shouldFix=true] Determines whether each message should be fixed
 * @returns ***REMOVED***Object***REMOVED*** An object containing the fixed text and any unfixed messages.
 */
SourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) ***REMOVED***
    debug("Applying fixes");

    if (shouldFix === false) ***REMOVED***
        debug("shouldFix parameter was false, not attempting fixes");
        return ***REMOVED***
            fixed: false,
            messages,
            output: sourceText
        ***REMOVED***;
    ***REMOVED***

    // clone the array
    const remainingMessages = [],
        fixes = [],
        bom = sourceText.startsWith(BOM) ? BOM : "",
        text = bom ? sourceText.slice(1) : sourceText;
    let lastPos = Number.NEGATIVE_INFINITY,
        output = bom;

    /**
     * Try to use the 'fix' from a problem.
     * @param   ***REMOVED***Message***REMOVED*** problem The message object to apply fixes from
     * @returns ***REMOVED***boolean***REMOVED***         Whether fix was successfully applied
     */
    function attemptFix(problem) ***REMOVED***
        const fix = problem.fix;
        const start = fix.range[0];
        const end = fix.range[1];

        // Remain it as a problem if it's overlapped or it's a negative range
        if (lastPos >= start || start > end) ***REMOVED***
            remainingMessages.push(problem);
            return false;
        ***REMOVED***

        // Remove BOM.
        if ((start < 0 && end >= 0) || (start === 0 && fix.text.startsWith(BOM))) ***REMOVED***
            output = "";
        ***REMOVED***

        // Make output to this fix.
        output += text.slice(Math.max(0, lastPos), Math.max(0, start));
        output += fix.text;
        lastPos = end;
        return true;
    ***REMOVED***

    messages.forEach(problem => ***REMOVED***
        if (Object.prototype.hasOwnProperty.call(problem, "fix")) ***REMOVED***
            fixes.push(problem);
        ***REMOVED*** else ***REMOVED***
            remainingMessages.push(problem);
        ***REMOVED***
    ***REMOVED***);

    if (fixes.length) ***REMOVED***
        debug("Found fixes to apply");
        let fixesWereApplied = false;

        for (const problem of fixes.sort(compareMessagesByFixRange)) ***REMOVED***
            if (typeof shouldFix !== "function" || shouldFix(problem)) ***REMOVED***
                attemptFix(problem);

                /*
                 * The only time attemptFix will fail is if a previous fix was
                 * applied which conflicts with it.  So we can mark this as true.
                 */
                fixesWereApplied = true;
            ***REMOVED*** else ***REMOVED***
                remainingMessages.push(problem);
            ***REMOVED***
        ***REMOVED***
        output += text.slice(Math.max(0, lastPos));

        return ***REMOVED***
            fixed: fixesWereApplied,
            messages: remainingMessages.sort(compareMessagesByLocation),
            output
        ***REMOVED***;
    ***REMOVED***

    debug("No fixes to apply");
    return ***REMOVED***
        fixed: false,
        messages,
        output: bom + text
    ***REMOVED***;

***REMOVED***;

module.exports = SourceCodeFixer;
