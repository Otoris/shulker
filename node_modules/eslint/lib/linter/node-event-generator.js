/**
 * @fileoverview The event generator for AST nodes.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const esquery = require("esquery");
const lodash = require("lodash");

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/**
 * An object describing an AST selector
 * @typedef ***REMOVED***Object***REMOVED*** ASTSelector
 * @property ***REMOVED***string***REMOVED*** rawSelector The string that was parsed into this selector
 * @property ***REMOVED***boolean***REMOVED*** isExit `true` if this should be emitted when exiting the node rather than when entering
 * @property ***REMOVED***Object***REMOVED*** parsedSelector An object (from esquery) describing the matching behavior of the selector
 * @property ***REMOVED***string[]|null***REMOVED*** listenerTypes A list of node types that could possibly cause the selector to match,
 * or `null` if all node types could cause a match
 * @property ***REMOVED***number***REMOVED*** attributeCount The total number of classes, pseudo-classes, and attribute queries in this selector
 * @property ***REMOVED***number***REMOVED*** identifierCount The total number of identifier queries in this selector
 */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets the possible types of a selector
 * @param ***REMOVED***Object***REMOVED*** parsedSelector An object (from esquery) describing the matching behavior of the selector
 * @returns ***REMOVED***string[]|null***REMOVED*** The node types that could possibly trigger this selector, or `null` if all node types could trigger it
 */
function getPossibleTypes(parsedSelector) ***REMOVED***
    switch (parsedSelector.type) ***REMOVED***
        case "identifier":
            return [parsedSelector.value];

        case "matches": ***REMOVED***
            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);

            if (typesForComponents.every(Boolean)) ***REMOVED***
                return lodash.union(...typesForComponents);
            ***REMOVED***
            return null;
        ***REMOVED***

        case "compound": ***REMOVED***
            const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter(typesForComponent => typesForComponent);

            // If all of the components could match any type, then the compound could also match any type.
            if (!typesForComponents.length) ***REMOVED***
                return null;
            ***REMOVED***

            /*
             * If at least one of the components could only match a particular type, the compound could only match
             * the intersection of those types.
             */
            return lodash.intersection(...typesForComponents);
        ***REMOVED***

        case "child":
        case "descendant":
        case "sibling":
        case "adjacent":
            return getPossibleTypes(parsedSelector.right);

        default:
            return null;

    ***REMOVED***
***REMOVED***

/**
 * Counts the number of class, pseudo-class, and attribute queries in this selector
 * @param ***REMOVED***Object***REMOVED*** parsedSelector An object (from esquery) describing the selector's matching behavior
 * @returns ***REMOVED***number***REMOVED*** The number of class, pseudo-class, and attribute queries in this selector
 */
function countClassAttributes(parsedSelector) ***REMOVED***
    switch (parsedSelector.type) ***REMOVED***
        case "child":
        case "descendant":
        case "sibling":
        case "adjacent":
            return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);

        case "compound":
        case "not":
        case "matches":
            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);

        case "attribute":
        case "field":
        case "nth-child":
        case "nth-last-child":
            return 1;

        default:
            return 0;
    ***REMOVED***
***REMOVED***

/**
 * Counts the number of identifier queries in this selector
 * @param ***REMOVED***Object***REMOVED*** parsedSelector An object (from esquery) describing the selector's matching behavior
 * @returns ***REMOVED***number***REMOVED*** The number of identifier queries
 */
function countIdentifiers(parsedSelector) ***REMOVED***
    switch (parsedSelector.type) ***REMOVED***
        case "child":
        case "descendant":
        case "sibling":
        case "adjacent":
            return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);

        case "compound":
        case "not":
        case "matches":
            return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);

        case "identifier":
            return 1;

        default:
            return 0;
    ***REMOVED***
***REMOVED***

/**
 * Compares the specificity of two selector objects, with CSS-like rules.
 * @param ***REMOVED***ASTSelector***REMOVED*** selectorA An AST selector descriptor
 * @param ***REMOVED***ASTSelector***REMOVED*** selectorB Another AST selector descriptor
 * @returns ***REMOVED***number***REMOVED***
 * a value less than 0 if selectorA is less specific than selectorB
 * a value greater than 0 if selectorA is more specific than selectorB
 * a value less than 0 if selectorA and selectorB have the same specificity, and selectorA <= selectorB alphabetically
 * a value greater than 0 if selectorA and selectorB have the same specificity, and selectorA > selectorB alphabetically
 */
function compareSpecificity(selectorA, selectorB) ***REMOVED***
    return selectorA.attributeCount - selectorB.attributeCount ||
        selectorA.identifierCount - selectorB.identifierCount ||
        (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);
***REMOVED***

/**
 * Parses a raw selector string, and throws a useful error if parsing fails.
 * @param ***REMOVED***string***REMOVED*** rawSelector A raw AST selector
 * @returns ***REMOVED***Object***REMOVED*** An object (from esquery) describing the matching behavior of this selector
 * @throws ***REMOVED***Error***REMOVED*** An error if the selector is invalid
 */
function tryParseSelector(rawSelector) ***REMOVED***
    try ***REMOVED***
        return esquery.parse(rawSelector.replace(/:exit$/u, ""));
    ***REMOVED*** catch (err) ***REMOVED***
        if (typeof err.offset === "number") ***REMOVED***
            throw new SyntaxError(`Syntax error in selector "$***REMOVED***rawSelector***REMOVED***" at position $***REMOVED***err.offset***REMOVED***: $***REMOVED***err.message***REMOVED***`);
        ***REMOVED***
        throw err;
    ***REMOVED***
***REMOVED***

/**
 * Parses a raw selector string, and returns the parsed selector along with specificity and type information.
 * @param ***REMOVED***string***REMOVED*** rawSelector A raw AST selector
 * @returns ***REMOVED***ASTSelector***REMOVED*** A selector descriptor
 */
const parseSelector = lodash.memoize(rawSelector => ***REMOVED***
    const parsedSelector = tryParseSelector(rawSelector);

    return ***REMOVED***
        rawSelector,
        isExit: rawSelector.endsWith(":exit"),
        parsedSelector,
        listenerTypes: getPossibleTypes(parsedSelector),
        attributeCount: countClassAttributes(parsedSelector),
        identifierCount: countIdentifiers(parsedSelector)
    ***REMOVED***;
***REMOVED***);

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * The event generator for AST nodes.
 * This implements below interface.
 *
 * ```ts
 * interface EventGenerator ***REMOVED***
 *     emitter: SafeEmitter;
 *     enterNode(node: ASTNode): void;
 *     leaveNode(node: ASTNode): void;
 * ***REMOVED***
 * ```
 */
class NodeEventGenerator ***REMOVED***

    /**
     * @param ***REMOVED***SafeEmitter***REMOVED*** emitter
     * An SafeEmitter which is the destination of events. This emitter must already
     * have registered listeners for all of the events that it needs to listen for.
     * (See lib/linter/safe-emitter.js for more details on `SafeEmitter`.)
     * @returns ***REMOVED***NodeEventGenerator***REMOVED*** new instance
     */
    constructor(emitter) ***REMOVED***
        this.emitter = emitter;
        this.currentAncestry = [];
        this.enterSelectorsByNodeType = new Map();
        this.exitSelectorsByNodeType = new Map();
        this.anyTypeEnterSelectors = [];
        this.anyTypeExitSelectors = [];

        emitter.eventNames().forEach(rawSelector => ***REMOVED***
            const selector = parseSelector(rawSelector);

            if (selector.listenerTypes) ***REMOVED***
                const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;

                selector.listenerTypes.forEach(nodeType => ***REMOVED***
                    if (!typeMap.has(nodeType)) ***REMOVED***
                        typeMap.set(nodeType, []);
                    ***REMOVED***
                    typeMap.get(nodeType).push(selector);
                ***REMOVED***);
                return;
            ***REMOVED***
            const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;

            selectors.push(selector);
        ***REMOVED***);

        this.anyTypeEnterSelectors.sort(compareSpecificity);
        this.anyTypeExitSelectors.sort(compareSpecificity);
        this.enterSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));
        this.exitSelectorsByNodeType.forEach(selectorList => selectorList.sort(compareSpecificity));
    ***REMOVED***

    /**
     * Checks a selector against a node, and emits it if it matches
     * @param ***REMOVED***ASTNode***REMOVED*** node The node to check
     * @param ***REMOVED***ASTSelector***REMOVED*** selector An AST selector descriptor
     * @returns ***REMOVED***void***REMOVED***
     */
    applySelector(node, selector) ***REMOVED***
        if (esquery.matches(node, selector.parsedSelector, this.currentAncestry)) ***REMOVED***
            this.emitter.emit(selector.rawSelector, node);
        ***REMOVED***
    ***REMOVED***

    /**
     * Applies all appropriate selectors to a node, in specificity order
     * @param ***REMOVED***ASTNode***REMOVED*** node The node to check
     * @param ***REMOVED***boolean***REMOVED*** isExit `false` if the node is currently being entered, `true` if it's currently being exited
     * @returns ***REMOVED***void***REMOVED***
     */
    applySelectors(node, isExit) ***REMOVED***
        const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];
        const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;

        /*
         * selectorsByNodeType and anyTypeSelectors were already sorted by specificity in the constructor.
         * Iterate through each of them, applying selectors in the right order.
         */
        let selectorsByTypeIndex = 0;
        let anyTypeSelectorsIndex = 0;

        while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) ***REMOVED***
            if (
                selectorsByTypeIndex >= selectorsByNodeType.length ||
                anyTypeSelectorsIndex < anyTypeSelectors.length &&
                compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0
            ) ***REMOVED***
                this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);
            ***REMOVED*** else ***REMOVED***
                this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    /**
     * Emits an event of entering AST node.
     * @param ***REMOVED***ASTNode***REMOVED*** node - A node which was entered.
     * @returns ***REMOVED***void***REMOVED***
     */
    enterNode(node) ***REMOVED***
        if (node.parent) ***REMOVED***
            this.currentAncestry.unshift(node.parent);
        ***REMOVED***
        this.applySelectors(node, false);
    ***REMOVED***

    /**
     * Emits an event of leaving AST node.
     * @param ***REMOVED***ASTNode***REMOVED*** node - A node which was left.
     * @returns ***REMOVED***void***REMOVED***
     */
    leaveNode(node) ***REMOVED***
        this.applySelectors(node, true);
        this.currentAncestry.shift();
    ***REMOVED***
***REMOVED***

module.exports = NodeEventGenerator;
