/**
 * @fileoverview Main Linter Class
 * @author Gyandeep Singh
 * @author aladdin-add
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const
    path = require("path"),
    eslintScope = require("eslint-scope"),
    evk = require("eslint-visitor-keys"),
    espree = require("espree"),
    lodash = require("lodash"),
    BuiltInEnvironments = require("../../conf/environments"),
    pkg = require("../../package.json"),
    astUtils = require("../shared/ast-utils"),
    ConfigOps = require("../shared/config-ops"),
    validator = require("../shared/config-validator"),
    Traverser = require("../shared/traverser"),
    ***REMOVED*** SourceCode ***REMOVED*** = require("../source-code"),
    CodePathAnalyzer = require("./code-path-analysis/code-path-analyzer"),
    applyDisableDirectives = require("./apply-disable-directives"),
    ConfigCommentParser = require("./config-comment-parser"),
    NodeEventGenerator = require("./node-event-generator"),
    createReportTranslator = require("./report-translator"),
    Rules = require("./rules"),
    createEmitter = require("./safe-emitter"),
    SourceCodeFixer = require("./source-code-fixer"),
    timing = require("./timing"),
    ruleReplacements = require("../../conf/replacements.json");

const debug = require("debug")("eslint:linter");
const MAX_AUTOFIX_PASSES = 10;
const DEFAULT_PARSER_NAME = "espree";
const commentParser = new ConfigCommentParser();
const DEFAULT_ERROR_LOC = ***REMOVED*** start: ***REMOVED*** line: 1, column: 0 ***REMOVED***, end: ***REMOVED*** line: 1, column: 1 ***REMOVED*** ***REMOVED***;

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/** @typedef ***REMOVED***InstanceType<import("../cli-engine/config-array")["ConfigArray"]>***REMOVED*** ConfigArray */
/** @typedef ***REMOVED***InstanceType<import("../cli-engine/config-array")["ExtractedConfig"]>***REMOVED*** ExtractedConfig */
/** @typedef ***REMOVED***import("../shared/types").ConfigData***REMOVED*** ConfigData */
/** @typedef ***REMOVED***import("../shared/types").Environment***REMOVED*** Environment */
/** @typedef ***REMOVED***import("../shared/types").GlobalConf***REMOVED*** GlobalConf */
/** @typedef ***REMOVED***import("../shared/types").LintMessage***REMOVED*** LintMessage */
/** @typedef ***REMOVED***import("../shared/types").ParserOptions***REMOVED*** ParserOptions */
/** @typedef ***REMOVED***import("../shared/types").Processor***REMOVED*** Processor */
/** @typedef ***REMOVED***import("../shared/types").Rule***REMOVED*** Rule */

/**
 * @template T
 * @typedef ***REMOVED******REMOVED*** [P in keyof T]-?: T[P] ***REMOVED******REMOVED*** Required
 */

/**
 * @typedef ***REMOVED***Object***REMOVED*** DisableDirective
 * @property ***REMOVED***("disable"|"enable"|"disable-line"|"disable-next-line")***REMOVED*** type
 * @property ***REMOVED***number***REMOVED*** line
 * @property ***REMOVED***number***REMOVED*** column
 * @property ***REMOVED***(string|null)***REMOVED*** ruleId
 */

/**
 * The private data for `Linter` instance.
 * @typedef ***REMOVED***Object***REMOVED*** LinterInternalSlots
 * @property ***REMOVED***ConfigArray|null***REMOVED*** lastConfigArray The `ConfigArray` instance that the last `verify()` call used.
 * @property ***REMOVED***SourceCode|null***REMOVED*** lastSourceCode The `SourceCode` instance that the last `verify()` call used.
 * @property ***REMOVED***Map<string, Parser>***REMOVED*** parserMap The loaded parsers.
 * @property ***REMOVED***Rules***REMOVED*** ruleMap The loaded rules.
 */

/**
 * @typedef ***REMOVED***Object***REMOVED*** VerifyOptions
 * @property ***REMOVED***boolean***REMOVED*** [allowInlineConfig] Allow/disallow inline comments' ability
 *      to change config once it is set. Defaults to true if not supplied.
 *      Useful if you want to validate JS without comments overriding rules.
 * @property ***REMOVED***boolean***REMOVED*** [disableFixes] if `true` then the linter doesn't make `fix`
 *      properties into the lint result.
 * @property ***REMOVED***string***REMOVED*** [filename] the filename of the source code.
 * @property ***REMOVED***boolean | "off" | "warn" | "error"***REMOVED*** [reportUnusedDisableDirectives] Adds reported errors for
 *      unused `eslint-disable` directives.
 */

/**
 * @typedef ***REMOVED***Object***REMOVED*** ProcessorOptions
 * @property ***REMOVED***(filename:string, text:string) => boolean***REMOVED*** [filterCodeBlock] the
 *      predicate function that selects adopt code blocks.
 * @property ***REMOVED***Processor["postprocess"]***REMOVED*** [postprocess] postprocessor for report
 *      messages. If provided, this should accept an array of the message lists
 *      for each code block returned from the preprocessor, apply a mapping to
 *      the messages as appropriate, and return a one-dimensional array of
 *      messages.
 * @property ***REMOVED***Processor["preprocess"]***REMOVED*** [preprocess] preprocessor for source text.
 *      If provided, this should accept a string of source text, and return an
 *      array of code blocks to lint.
 */

/**
 * @typedef ***REMOVED***Object***REMOVED*** FixOptions
 * @property ***REMOVED***boolean | ((message: LintMessage) => boolean)***REMOVED*** [fix] Determines
 *      whether fixes should be applied.
 */

/**
 * @typedef ***REMOVED***Object***REMOVED*** InternalOptions
 * @property ***REMOVED***string | null***REMOVED*** warnInlineConfig The config name what `noInlineConfig` setting came from. If `noInlineConfig` setting didn't exist, this is null. If this is a config name, then the linter warns directive comments.
 * @property ***REMOVED***"off" | "warn" | "error"***REMOVED*** reportUnusedDisableDirectives (boolean values were normalized)
 */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Ensures that variables representing built-in properties of the Global Object,
 * and any globals declared by special block comments, are present in the global
 * scope.
 * @param ***REMOVED***Scope***REMOVED*** globalScope The global scope.
 * @param ***REMOVED***Object***REMOVED*** configGlobals The globals declared in configuration
 * @param ***REMOVED******REMOVED***exportedVariables: Object, enabledGlobals: Object***REMOVED******REMOVED*** commentDirectives Directives from comment configuration
 * @returns ***REMOVED***void***REMOVED***
 */
function addDeclaredGlobals(globalScope, configGlobals, ***REMOVED*** exportedVariables, enabledGlobals ***REMOVED***) ***REMOVED***

    // Define configured global variables.
    for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(enabledGlobals)])) ***REMOVED***

        /*
         * `ConfigOps.normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would
         * typically be caught when validating a config anyway (validity for inline global comments is checked separately).
         */
        const configValue = configGlobals[id] === void 0 ? void 0 : ConfigOps.normalizeConfigGlobal(configGlobals[id]);
        const commentValue = enabledGlobals[id] && enabledGlobals[id].value;
        const value = commentValue || configValue;
        const sourceComments = enabledGlobals[id] && enabledGlobals[id].comments;

        if (value === "off") ***REMOVED***
            continue;
        ***REMOVED***

        let variable = globalScope.set.get(id);

        if (!variable) ***REMOVED***
            variable = new eslintScope.Variable(id, globalScope);

            globalScope.variables.push(variable);
            globalScope.set.set(id, variable);
        ***REMOVED***

        variable.eslintImplicitGlobalSetting = configValue;
        variable.eslintExplicitGlobal = sourceComments !== void 0;
        variable.eslintExplicitGlobalComments = sourceComments;
        variable.writeable = (value === "writable");
    ***REMOVED***

    // mark all exported variables as such
    Object.keys(exportedVariables).forEach(name => ***REMOVED***
        const variable = globalScope.set.get(name);

        if (variable) ***REMOVED***
            variable.eslintUsed = true;
        ***REMOVED***
    ***REMOVED***);

    /*
     * "through" contains all references which definitions cannot be found.
     * Since we augment the global scope using configuration, we need to update
     * references and remove the ones that were added by configuration.
     */
    globalScope.through = globalScope.through.filter(reference => ***REMOVED***
        const name = reference.identifier.name;
        const variable = globalScope.set.get(name);

        if (variable) ***REMOVED***

            /*
             * Links the variable and the reference.
             * And this reference is removed from `Scope#through`.
             */
            reference.resolved = variable;
            variable.references.push(reference);

            return false;
        ***REMOVED***

        return true;
    ***REMOVED***);
***REMOVED***

/**
 * creates a missing-rule message.
 * @param ***REMOVED***string***REMOVED*** ruleId the ruleId to create
 * @returns ***REMOVED***string***REMOVED*** created error message
 * @private
 */
function createMissingRuleMessage(ruleId) ***REMOVED***
    return Object.prototype.hasOwnProperty.call(ruleReplacements.rules, ruleId)
        ? `Rule '$***REMOVED***ruleId***REMOVED***' was removed and replaced by: $***REMOVED***ruleReplacements.rules[ruleId].join(", ")***REMOVED***`
        : `Definition for rule '$***REMOVED***ruleId***REMOVED***' was not found.`;
***REMOVED***

/**
 * creates a linting problem
 * @param ***REMOVED***Object***REMOVED*** options to create linting error
 * @param ***REMOVED***string***REMOVED*** [options.ruleId] the ruleId to report
 * @param ***REMOVED***Object***REMOVED*** [options.loc] the loc to report
 * @param ***REMOVED***string***REMOVED*** [options.message] the error message to report
 * @param ***REMOVED***string***REMOVED*** [options.severity] the error message to report
 * @returns ***REMOVED***LintMessage***REMOVED*** created problem, returns a missing-rule problem if only provided ruleId.
 * @private
 */
function createLintingProblem(options) ***REMOVED***
    const ***REMOVED***
        ruleId = null,
        loc = DEFAULT_ERROR_LOC,
        message = createMissingRuleMessage(options.ruleId),
        severity = 2
    ***REMOVED*** = options;

    return ***REMOVED***
        ruleId,
        message,
        line: loc.start.line,
        column: loc.start.column + 1,
        endLine: loc.end.line,
        endColumn: loc.end.column + 1,
        severity,
        nodeType: null
    ***REMOVED***;
***REMOVED***

/**
 * Creates a collection of disable directives from a comment
 * @param ***REMOVED***Object***REMOVED*** options to create disable directives
 * @param ***REMOVED***("disable"|"enable"|"disable-line"|"disable-next-line")***REMOVED*** options.type The type of directive comment
 * @param ***REMOVED******REMOVED***line: number, column: number***REMOVED******REMOVED*** options.loc The 0-based location of the comment token
 * @param ***REMOVED***string***REMOVED*** options.value The value after the directive in the comment
 * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)
 * @param ***REMOVED***function(string): ***REMOVED***create: Function***REMOVED******REMOVED*** options.ruleMapper A map from rule IDs to defined rules
 * @returns ***REMOVED***Object***REMOVED*** Directives and problems from the comment
 */
function createDisableDirectives(options) ***REMOVED***
    const ***REMOVED*** type, loc, value, ruleMapper ***REMOVED*** = options;
    const ruleIds = Object.keys(commentParser.parseListConfig(value));
    const directiveRules = ruleIds.length ? ruleIds : [null];
    const result = ***REMOVED***
        directives: [], // valid disable directives
        directiveProblems: [] // problems in directives
    ***REMOVED***;

    for (const ruleId of directiveRules) ***REMOVED***

        // push to directives, if the rule is defined(including null, e.g. /*eslint enable*/)
        if (ruleId === null || ruleMapper(ruleId) !== null) ***REMOVED***
            result.directives.push(***REMOVED*** type, line: loc.start.line, column: loc.start.column + 1, ruleId ***REMOVED***);
        ***REMOVED*** else ***REMOVED***
            result.directiveProblems.push(createLintingProblem(***REMOVED*** ruleId, loc ***REMOVED***));
        ***REMOVED***
    ***REMOVED***
    return result;
***REMOVED***

/**
 * Parses comments in file to extract file-specific config of rules, globals
 * and environments and merges them with global config; also code blocks
 * where reporting is disabled or enabled and merges them with reporting config.
 * @param ***REMOVED***string***REMOVED*** filename The file being checked.
 * @param ***REMOVED***ASTNode***REMOVED*** ast The top node of the AST.
 * @param ***REMOVED***function(string): ***REMOVED***create: Function***REMOVED******REMOVED*** ruleMapper A map from rule IDs to defined rules
 * @param ***REMOVED***string|null***REMOVED*** warnInlineConfig If a string then it should warn directive comments as disabled. The string value is the config name what the setting came from.
 * @returns ***REMOVED******REMOVED***configuredRules: Object, enabledGlobals: ***REMOVED***value:string,comment:Token***REMOVED***[], exportedVariables: Object, problems: Problem[], disableDirectives: DisableDirective[]***REMOVED******REMOVED***
 * A collection of the directive comments that were found, along with any problems that occurred when parsing
 */
function getDirectiveComments(filename, ast, ruleMapper, warnInlineConfig) ***REMOVED***
    const configuredRules = ***REMOVED******REMOVED***;
    const enabledGlobals = Object.create(null);
    const exportedVariables = ***REMOVED******REMOVED***;
    const problems = [];
    const disableDirectives = [];

    ast.comments.filter(token => token.type !== "Shebang").forEach(comment => ***REMOVED***
        const trimmedCommentText = comment.value.trim();
        const match = /^(eslint(?:-env|-enable|-disable(?:(?:-next)?-line)?)?|exported|globals?)(?:\s|$)/u.exec(trimmedCommentText);

        if (!match) ***REMOVED***
            return;
        ***REMOVED***
        const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(match[1]);

        if (warnInlineConfig && (lineCommentSupported || comment.type === "Block")) ***REMOVED***
            const kind = comment.type === "Block" ? `/*$***REMOVED***match[1]***REMOVED****/` : `//$***REMOVED***match[1]***REMOVED***`;

            problems.push(createLintingProblem(***REMOVED***
                ruleId: null,
                message: `'$***REMOVED***kind***REMOVED***' has no effect because you have 'noInlineConfig' setting in $***REMOVED***warnInlineConfig***REMOVED***.`,
                loc: comment.loc,
                severity: 1
            ***REMOVED***));
            return;
        ***REMOVED***

        const directiveValue = trimmedCommentText.slice(match.index + match[1].length);
        let directiveType = "";

        if (lineCommentSupported) ***REMOVED***
            if (comment.loc.start.line === comment.loc.end.line) ***REMOVED***
                directiveType = match[1].slice("eslint-".length);
            ***REMOVED*** else ***REMOVED***
                const message = `$***REMOVED***match[1]***REMOVED*** comment should not span multiple lines.`;

                problems.push(createLintingProblem(***REMOVED***
                    ruleId: null,
                    message,
                    loc: comment.loc
                ***REMOVED***));
            ***REMOVED***
        ***REMOVED*** else if (comment.type === "Block") ***REMOVED***
            switch (match[1]) ***REMOVED***
                case "exported":
                    Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));
                    break;

                case "globals":
                case "global":
                    for (const [id, ***REMOVED*** value ***REMOVED***] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) ***REMOVED***
                        let normalizedValue;

                        try ***REMOVED***
                            normalizedValue = ConfigOps.normalizeConfigGlobal(value);
                        ***REMOVED*** catch (err) ***REMOVED***
                            problems.push(createLintingProblem(***REMOVED***
                                ruleId: null,
                                loc: comment.loc,
                                message: err.message
                            ***REMOVED***));
                            continue;
                        ***REMOVED***

                        if (enabledGlobals[id]) ***REMOVED***
                            enabledGlobals[id].comments.push(comment);
                            enabledGlobals[id].value = normalizedValue;
                        ***REMOVED*** else ***REMOVED***
                            enabledGlobals[id] = ***REMOVED***
                                comments: [comment],
                                value: normalizedValue
                            ***REMOVED***;
                        ***REMOVED***
                    ***REMOVED***
                    break;

                case "eslint-disable":
                    directiveType = "disable";
                    break;

                case "eslint-enable":
                    directiveType = "enable";
                    break;

                case "eslint": ***REMOVED***
                    const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);

                    if (parseResult.success) ***REMOVED***
                        Object.keys(parseResult.config).forEach(name => ***REMOVED***
                            const rule = ruleMapper(name);
                            const ruleValue = parseResult.config[name];

                            if (rule === null) ***REMOVED***
                                problems.push(createLintingProblem(***REMOVED*** ruleId: name, loc: comment.loc ***REMOVED***));
                                return;
                            ***REMOVED***

                            try ***REMOVED***
                                validator.validateRuleOptions(rule, name, ruleValue);
                            ***REMOVED*** catch (err) ***REMOVED***
                                problems.push(createLintingProblem(***REMOVED***
                                    ruleId: name,
                                    message: err.message,
                                    loc: comment.loc
                                ***REMOVED***));

                                // do not apply the config, if found invalid options.
                                return;
                            ***REMOVED***

                            configuredRules[name] = ruleValue;
                        ***REMOVED***);
                    ***REMOVED*** else ***REMOVED***
                        problems.push(parseResult.error);
                    ***REMOVED***

                    break;
                ***REMOVED***

                // no default
            ***REMOVED***
        ***REMOVED***

        if (directiveType !== "") ***REMOVED***
            const options = ***REMOVED*** type: directiveType, loc: comment.loc, value: directiveValue, ruleMapper ***REMOVED***;
            const ***REMOVED*** directives, directiveProblems ***REMOVED*** = createDisableDirectives(options);

            disableDirectives.push(...directives);
            problems.push(...directiveProblems);
        ***REMOVED***
    ***REMOVED***);

    return ***REMOVED***
        configuredRules,
        enabledGlobals,
        exportedVariables,
        problems,
        disableDirectives
    ***REMOVED***;
***REMOVED***

/**
 * Normalize ECMAScript version from the initial config
 * @param  ***REMOVED***number***REMOVED*** ecmaVersion ECMAScript version from the initial config
 * @returns ***REMOVED***number***REMOVED*** normalized ECMAScript version
 */
function normalizeEcmaVersion(ecmaVersion) ***REMOVED***

    /*
     * Calculate ECMAScript edition number from official year version starting with
     * ES2015, which corresponds with ES6 (or a difference of 2009).
     */
    return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;
***REMOVED***

const eslintEnvPattern = /\/\*\s*eslint-env\s(.+?)\*\//gu;

/**
 * Checks whether or not there is a comment which has "eslint-env *" in a given text.
 * @param ***REMOVED***string***REMOVED*** text - A source code text to check.
 * @returns ***REMOVED***Object|null***REMOVED*** A result of parseListConfig() with "eslint-env *" comment.
 */
function findEslintEnv(text) ***REMOVED***
    let match, retv;

    eslintEnvPattern.lastIndex = 0;

    while ((match = eslintEnvPattern.exec(text))) ***REMOVED***
        retv = Object.assign(retv || ***REMOVED******REMOVED***, commentParser.parseListConfig(match[1]));
    ***REMOVED***

    return retv;
***REMOVED***

/**
 * Convert "/path/to/<text>" to "<text>".
 * `CLIEngine#executeOnText()` method gives "/path/to/<text>" if the filename
 * was omitted because `configArray.extractConfig()` requires an absolute path.
 * But the linter should pass `<text>` to `RuleContext#getFilename()` in that
 * case.
 * Also, code blocks can have their virtual filename. If the parent filename was
 * `<text>`, the virtual filename is `<text>/0_foo.js` or something like (i.e.,
 * it's not an absolute path).
 * @param ***REMOVED***string***REMOVED*** filename The filename to normalize.
 * @returns ***REMOVED***string***REMOVED*** The normalized filename.
 */
function normalizeFilename(filename) ***REMOVED***
    const parts = filename.split(path.sep);
    const index = parts.lastIndexOf("<text>");

    return index === -1 ? filename : parts.slice(index).join(path.sep);
***REMOVED***

// eslint-disable-next-line valid-jsdoc
/**
 * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a
 * consistent shape.
 * @param ***REMOVED***VerifyOptions***REMOVED*** providedOptions Options
 * @param ***REMOVED***ConfigData***REMOVED*** config Config.
 * @returns ***REMOVED***Required<VerifyOptions> & InternalOptions***REMOVED*** Normalized options
 */
function normalizeVerifyOptions(providedOptions, config) ***REMOVED***
    const disableInlineConfig = config.noInlineConfig === true;
    const ignoreInlineConfig = providedOptions.allowInlineConfig === false;
    const configNameOfNoInlineConfig = config.configNameOfNoInlineConfig
        ? ` ($***REMOVED***config.configNameOfNoInlineConfig***REMOVED***)`
        : "";

    let reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;

    if (typeof reportUnusedDisableDirectives === "boolean") ***REMOVED***
        reportUnusedDisableDirectives = reportUnusedDisableDirectives ? "error" : "off";
    ***REMOVED***
    if (typeof reportUnusedDisableDirectives !== "string") ***REMOVED***
        reportUnusedDisableDirectives = config.reportUnusedDisableDirectives ? "warn" : "off";
    ***REMOVED***

    return ***REMOVED***
        filename: normalizeFilename(providedOptions.filename || "<input>"),
        allowInlineConfig: !ignoreInlineConfig,
        warnInlineConfig: disableInlineConfig && !ignoreInlineConfig
            ? `your config$***REMOVED***configNameOfNoInlineConfig***REMOVED***`
            : null,
        reportUnusedDisableDirectives,
        disableFixes: Boolean(providedOptions.disableFixes)
    ***REMOVED***;
***REMOVED***

/**
 * Combines the provided parserOptions with the options from environments
 * @param ***REMOVED***string***REMOVED*** parserName The parser name which uses this options.
 * @param ***REMOVED***ParserOptions***REMOVED*** providedOptions The provided 'parserOptions' key in a config
 * @param ***REMOVED***Environment[]***REMOVED*** enabledEnvironments The environments enabled in configuration and with inline comments
 * @returns ***REMOVED***ParserOptions***REMOVED*** Resulting parser options after merge
 */
function resolveParserOptions(parserName, providedOptions, enabledEnvironments) ***REMOVED***
    const parserOptionsFromEnv = enabledEnvironments
        .filter(env => env.parserOptions)
        .reduce((parserOptions, env) => lodash.merge(parserOptions, env.parserOptions), ***REMOVED******REMOVED***);
    const mergedParserOptions = lodash.merge(parserOptionsFromEnv, providedOptions || ***REMOVED******REMOVED***);
    const isModule = mergedParserOptions.sourceType === "module";

    if (isModule) ***REMOVED***

        /*
         * can't have global return inside of modules
         * TODO: espree validate parserOptions.globalReturn when sourceType is setting to module.(@aladdin-add)
         */
        mergedParserOptions.ecmaFeatures = Object.assign(***REMOVED******REMOVED***, mergedParserOptions.ecmaFeatures, ***REMOVED*** globalReturn: false ***REMOVED***);
    ***REMOVED***

    /*
     * TODO: @aladdin-add
     * 1. for a 3rd-party parser, do not normalize parserOptions
     * 2. for espree, no need to do this (espree will do it)
     */
    mergedParserOptions.ecmaVersion = normalizeEcmaVersion(mergedParserOptions.ecmaVersion);

    return mergedParserOptions;
***REMOVED***

/**
 * Combines the provided globals object with the globals from environments
 * @param ***REMOVED***Record<string, GlobalConf>***REMOVED*** providedGlobals The 'globals' key in a config
 * @param ***REMOVED***Environment[]***REMOVED*** enabledEnvironments The environments enabled in configuration and with inline comments
 * @returns ***REMOVED***Record<string, GlobalConf>***REMOVED*** The resolved globals object
 */
function resolveGlobals(providedGlobals, enabledEnvironments) ***REMOVED***
    return Object.assign(
        ***REMOVED******REMOVED***,
        ...enabledEnvironments.filter(env => env.globals).map(env => env.globals),
        providedGlobals
    );
***REMOVED***

/**
 * Strips Unicode BOM from a given text.
 *
 * @param ***REMOVED***string***REMOVED*** text - A text to strip.
 * @returns ***REMOVED***string***REMOVED*** The stripped text.
 */
function stripUnicodeBOM(text) ***REMOVED***

    /*
     * Check Unicode BOM.
     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.
     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters
     */
    if (text.charCodeAt(0) === 0xFEFF) ***REMOVED***
        return text.slice(1);
    ***REMOVED***
    return text;
***REMOVED***

/**
 * Get the options for a rule (not including severity), if any
 * @param ***REMOVED***Array|number***REMOVED*** ruleConfig rule configuration
 * @returns ***REMOVED***Array***REMOVED*** of rule options, empty Array if none
 */
function getRuleOptions(ruleConfig) ***REMOVED***
    if (Array.isArray(ruleConfig)) ***REMOVED***
        return ruleConfig.slice(1);
    ***REMOVED***
    return [];

***REMOVED***

/**
 * Analyze scope of the given AST.
 * @param ***REMOVED***ASTNode***REMOVED*** ast The `Program` node to analyze.
 * @param ***REMOVED***ParserOptions***REMOVED*** parserOptions The parser options.
 * @param ***REMOVED***Record<string, string[]>***REMOVED*** visitorKeys The visitor keys.
 * @returns ***REMOVED***ScopeManager***REMOVED*** The analysis result.
 */
function analyzeScope(ast, parserOptions, visitorKeys) ***REMOVED***
    const ecmaFeatures = parserOptions.ecmaFeatures || ***REMOVED******REMOVED***;
    const ecmaVersion = parserOptions.ecmaVersion || 5;

    return eslintScope.analyze(ast, ***REMOVED***
        ignoreEval: true,
        nodejsScope: ecmaFeatures.globalReturn,
        impliedStrict: ecmaFeatures.impliedStrict,
        ecmaVersion,
        sourceType: parserOptions.sourceType || "script",
        childVisitorKeys: visitorKeys || evk.KEYS,
        fallback: Traverser.getKeys
    ***REMOVED***);
***REMOVED***

/**
 * Parses text into an AST. Moved out here because the try-catch prevents
 * optimization of functions, so it's best to keep the try-catch as isolated
 * as possible
 * @param ***REMOVED***string***REMOVED*** text The text to parse.
 * @param ***REMOVED***Parser***REMOVED*** parser The parser to parse.
 * @param ***REMOVED***ParserOptions***REMOVED*** providedParserOptions Options to pass to the parser
 * @param ***REMOVED***string***REMOVED*** filePath The path to the file being parsed.
 * @returns ***REMOVED******REMOVED***success: false, error: Problem***REMOVED***|***REMOVED***success: true, sourceCode: SourceCode***REMOVED******REMOVED***
 * An object containing the AST and parser services if parsing was successful, or the error if parsing failed
 * @private
 */
function parse(text, parser, providedParserOptions, filePath) ***REMOVED***
    const textToParse = stripUnicodeBOM(text).replace(astUtils.shebangPattern, (match, captured) => `//$***REMOVED***captured***REMOVED***`);
    const parserOptions = Object.assign(***REMOVED******REMOVED***, providedParserOptions, ***REMOVED***
        loc: true,
        range: true,
        raw: true,
        tokens: true,
        comment: true,
        eslintVisitorKeys: true,
        eslintScopeManager: true,
        filePath
    ***REMOVED***);

    /*
     * Check for parsing errors first. If there's a parsing error, nothing
     * else can happen. However, a parsing error does not throw an error
     * from this method - it's just considered a fatal error message, a
     * problem that ESLint identified just like any other.
     */
    try ***REMOVED***
        const parseResult = (typeof parser.parseForESLint === "function")
            ? parser.parseForESLint(textToParse, parserOptions)
            : ***REMOVED*** ast: parser.parse(textToParse, parserOptions) ***REMOVED***;
        const ast = parseResult.ast;
        const parserServices = parseResult.services || ***REMOVED******REMOVED***;
        const visitorKeys = parseResult.visitorKeys || evk.KEYS;
        const scopeManager = parseResult.scopeManager || analyzeScope(ast, parserOptions, visitorKeys);

        return ***REMOVED***
            success: true,

            /*
             * Save all values that `parseForESLint()` returned.
             * If a `SourceCode` object is given as the first parameter instead of source code text,
             * linter skips the parsing process and reuses the source code object.
             * In that case, linter needs all the values that `parseForESLint()` returned.
             */
            sourceCode: new SourceCode(***REMOVED***
                text,
                ast,
                parserServices,
                scopeManager,
                visitorKeys
            ***REMOVED***)
        ***REMOVED***;
    ***REMOVED*** catch (ex) ***REMOVED***

        // If the message includes a leading line number, strip it:
        const message = `Parsing error: $***REMOVED***ex.message.replace(/^line \d+:/iu, "").trim()***REMOVED***`;

        return ***REMOVED***
            success: false,
            error: ***REMOVED***
                ruleId: null,
                fatal: true,
                severity: 2,
                message,
                line: ex.lineNumber,
                column: ex.column
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***

/**
 * Gets the scope for the current node
 * @param ***REMOVED***ScopeManager***REMOVED*** scopeManager The scope manager for this AST
 * @param ***REMOVED***ASTNode***REMOVED*** currentNode The node to get the scope of
 * @returns ***REMOVED***eslint-scope.Scope***REMOVED*** The scope information for this node
 */
function getScope(scopeManager, currentNode) ***REMOVED***

    // On Program node, get the outermost scope to avoid return Node.js special function scope or ES modules scope.
    const inner = currentNode.type !== "Program";

    for (let node = currentNode; node; node = node.parent) ***REMOVED***
        const scope = scopeManager.acquire(node, inner);

        if (scope) ***REMOVED***
            if (scope.type === "function-expression-name") ***REMOVED***
                return scope.childScopes[0];
            ***REMOVED***
            return scope;
        ***REMOVED***
    ***REMOVED***

    return scopeManager.scopes[0];
***REMOVED***

/**
 * Marks a variable as used in the current scope
 * @param ***REMOVED***ScopeManager***REMOVED*** scopeManager The scope manager for this AST. The scope may be mutated by this function.
 * @param ***REMOVED***ASTNode***REMOVED*** currentNode The node currently being traversed
 * @param ***REMOVED***Object***REMOVED*** parserOptions The options used to parse this text
 * @param ***REMOVED***string***REMOVED*** name The name of the variable that should be marked as used.
 * @returns ***REMOVED***boolean***REMOVED*** True if the variable was found and marked as used, false if not.
 */
function markVariableAsUsed(scopeManager, currentNode, parserOptions, name) ***REMOVED***
    const hasGlobalReturn = parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn;
    const specialScope = hasGlobalReturn || parserOptions.sourceType === "module";
    const currentScope = getScope(scopeManager, currentNode);

    // Special Node.js scope means we need to start one level deeper
    const initialScope = currentScope.type === "global" && specialScope ? currentScope.childScopes[0] : currentScope;

    for (let scope = initialScope; scope; scope = scope.upper) ***REMOVED***
        const variable = scope.variables.find(scopeVar => scopeVar.name === name);

        if (variable) ***REMOVED***
            variable.eslintUsed = true;
            return true;
        ***REMOVED***
    ***REMOVED***

    return false;
***REMOVED***

/**
 * Runs a rule, and gets its listeners
 * @param ***REMOVED***Rule***REMOVED*** rule A normalized rule with a `create` method
 * @param ***REMOVED***Context***REMOVED*** ruleContext The context that should be passed to the rule
 * @returns ***REMOVED***Object***REMOVED*** A map of selector listeners provided by the rule
 */
function createRuleListeners(rule, ruleContext) ***REMOVED***
    try ***REMOVED***
        return rule.create(ruleContext);
    ***REMOVED*** catch (ex) ***REMOVED***
        ex.message = `Error while loading rule '$***REMOVED***ruleContext.id***REMOVED***': $***REMOVED***ex.message***REMOVED***`;
        throw ex;
    ***REMOVED***
***REMOVED***

/**
 * Gets all the ancestors of a given node
 * @param ***REMOVED***ASTNode***REMOVED*** node The node
 * @returns ***REMOVED***ASTNode[]***REMOVED*** All the ancestor nodes in the AST, not including the provided node, starting
 * from the root node and going inwards to the parent node.
 */
function getAncestors(node) ***REMOVED***
    const ancestorsStartingAtParent = [];

    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) ***REMOVED***
        ancestorsStartingAtParent.push(ancestor);
    ***REMOVED***

    return ancestorsStartingAtParent.reverse();
***REMOVED***

// methods that exist on SourceCode object
const DEPRECATED_SOURCECODE_PASSTHROUGHS = ***REMOVED***
    getSource: "getText",
    getSourceLines: "getLines",
    getAllComments: "getAllComments",
    getNodeByRangeIndex: "getNodeByRangeIndex",
    getComments: "getComments",
    getCommentsBefore: "getCommentsBefore",
    getCommentsAfter: "getCommentsAfter",
    getCommentsInside: "getCommentsInside",
    getJSDocComment: "getJSDocComment",
    getFirstToken: "getFirstToken",
    getFirstTokens: "getFirstTokens",
    getLastToken: "getLastToken",
    getLastTokens: "getLastTokens",
    getTokenAfter: "getTokenAfter",
    getTokenBefore: "getTokenBefore",
    getTokenByRangeStart: "getTokenByRangeStart",
    getTokens: "getTokens",
    getTokensAfter: "getTokensAfter",
    getTokensBefore: "getTokensBefore",
    getTokensBetween: "getTokensBetween"
***REMOVED***;

const BASE_TRAVERSAL_CONTEXT = Object.freeze(
    Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce(
        (contextInfo, methodName) =>
            Object.assign(contextInfo, ***REMOVED***
                [methodName](...args) ***REMOVED***
                    return this.getSourceCode()[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]](...args);
                ***REMOVED***
            ***REMOVED***),
        ***REMOVED******REMOVED***
    )
);

/**
 * Runs the given rules on the given SourceCode object
 * @param ***REMOVED***SourceCode***REMOVED*** sourceCode A SourceCode object for the given text
 * @param ***REMOVED***Object***REMOVED*** configuredRules The rules configuration
 * @param ***REMOVED***function(string): Rule***REMOVED*** ruleMapper A mapper function from rule names to rules
 * @param ***REMOVED***Object***REMOVED*** parserOptions The options that were passed to the parser
 * @param ***REMOVED***string***REMOVED*** parserName The name of the parser in the config
 * @param ***REMOVED***Object***REMOVED*** settings The settings that were enabled in the config
 * @param ***REMOVED***string***REMOVED*** filename The reported filename of the code
 * @param ***REMOVED***boolean***REMOVED*** disableFixes If true, it doesn't make `fix` properties.
 * @returns ***REMOVED***Problem[]***REMOVED*** An array of reported problems
 */
function runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parserName, settings, filename, disableFixes) ***REMOVED***
    const emitter = createEmitter();
    const nodeQueue = [];
    let currentNode = sourceCode.ast;

    Traverser.traverse(sourceCode.ast, ***REMOVED***
        enter(node, parent) ***REMOVED***
            node.parent = parent;
            nodeQueue.push(***REMOVED*** isEntering: true, node ***REMOVED***);
        ***REMOVED***,
        leave(node) ***REMOVED***
            nodeQueue.push(***REMOVED*** isEntering: false, node ***REMOVED***);
        ***REMOVED***,
        visitorKeys: sourceCode.visitorKeys
    ***REMOVED***);

    /*
     * Create a frozen object with the ruleContext properties and methods that are shared by all rules.
     * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the
     * properties once for each rule.
     */
    const sharedTraversalContext = Object.freeze(
        Object.assign(
            Object.create(BASE_TRAVERSAL_CONTEXT),
            ***REMOVED***
                getAncestors: () => getAncestors(currentNode),
                getDeclaredVariables: sourceCode.scopeManager.getDeclaredVariables.bind(sourceCode.scopeManager),
                getFilename: () => filename,
                getScope: () => getScope(sourceCode.scopeManager, currentNode),
                getSourceCode: () => sourceCode,
                markVariableAsUsed: name => markVariableAsUsed(sourceCode.scopeManager, currentNode, parserOptions, name),
                parserOptions,
                parserPath: parserName,
                parserServices: sourceCode.parserServices,
                settings
            ***REMOVED***
        )
    );


    const lintingProblems = [];

    Object.keys(configuredRules).forEach(ruleId => ***REMOVED***
        const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);

        // not load disabled rules
        if (severity === 0) ***REMOVED***
            return;
        ***REMOVED***

        const rule = ruleMapper(ruleId);

        if (rule === null) ***REMOVED***
            lintingProblems.push(createLintingProblem(***REMOVED*** ruleId ***REMOVED***));
            return;
        ***REMOVED***

        const messageIds = rule.meta && rule.meta.messages;
        let reportTranslator = null;
        const ruleContext = Object.freeze(
            Object.assign(
                Object.create(sharedTraversalContext),
                ***REMOVED***
                    id: ruleId,
                    options: getRuleOptions(configuredRules[ruleId]),
                    report(...args) ***REMOVED***

                        /*
                         * Create a report translator lazily.
                         * In a vast majority of cases, any given rule reports zero errors on a given
                         * piece of code. Creating a translator lazily avoids the performance cost of
                         * creating a new translator function for each rule that usually doesn't get
                         * called.
                         *
                         * Using lazy report translators improves end-to-end performance by about 3%
                         * with Node 8.4.0.
                         */
                        if (reportTranslator === null) ***REMOVED***
                            reportTranslator = createReportTranslator(***REMOVED***
                                ruleId,
                                severity,
                                sourceCode,
                                messageIds,
                                disableFixes
                            ***REMOVED***);
                        ***REMOVED***
                        const problem = reportTranslator(...args);

                        if (problem.fix && rule.meta && !rule.meta.fixable) ***REMOVED***
                            throw new Error("Fixable rules should export a `meta.fixable` property.");
                        ***REMOVED***
                        lintingProblems.push(problem);
                    ***REMOVED***
                ***REMOVED***
            )
        );

        const ruleListeners = createRuleListeners(rule, ruleContext);

        // add all the selectors from the rule as listeners
        Object.keys(ruleListeners).forEach(selector => ***REMOVED***
            emitter.on(
                selector,
                timing.enabled
                    ? timing.time(ruleId, ruleListeners[selector])
                    : ruleListeners[selector]
            );
        ***REMOVED***);
    ***REMOVED***);

    const eventGenerator = new CodePathAnalyzer(new NodeEventGenerator(emitter));

    nodeQueue.forEach(traversalInfo => ***REMOVED***
        currentNode = traversalInfo.node;

        try ***REMOVED***
            if (traversalInfo.isEntering) ***REMOVED***
                eventGenerator.enterNode(currentNode);
            ***REMOVED*** else ***REMOVED***
                eventGenerator.leaveNode(currentNode);
            ***REMOVED***
        ***REMOVED*** catch (err) ***REMOVED***
            err.currentNode = currentNode;
            throw err;
        ***REMOVED***
    ***REMOVED***);

    return lintingProblems;
***REMOVED***

/**
 * Ensure the source code to be a string.
 * @param ***REMOVED***string|SourceCode***REMOVED*** textOrSourceCode The text or source code object.
 * @returns ***REMOVED***string***REMOVED*** The source code text.
 */
function ensureText(textOrSourceCode) ***REMOVED***
    if (typeof textOrSourceCode === "object") ***REMOVED***
        const ***REMOVED*** hasBOM, text ***REMOVED*** = textOrSourceCode;
        const bom = hasBOM ? "\uFEFF" : "";

        return bom + text;
    ***REMOVED***

    return String(textOrSourceCode);
***REMOVED***

/**
 * Get an environment.
 * @param ***REMOVED***LinterInternalSlots***REMOVED*** slots The internal slots of Linter.
 * @param ***REMOVED***string***REMOVED*** envId The environment ID to get.
 * @returns ***REMOVED***Environment|null***REMOVED*** The environment.
 */
function getEnv(slots, envId) ***REMOVED***
    return (
        (slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId)) ||
        BuiltInEnvironments.get(envId) ||
        null
    );
***REMOVED***

/**
 * Get a rule.
 * @param ***REMOVED***LinterInternalSlots***REMOVED*** slots The internal slots of Linter.
 * @param ***REMOVED***string***REMOVED*** ruleId The rule ID to get.
 * @returns ***REMOVED***Rule|null***REMOVED*** The rule.
 */
function getRule(slots, ruleId) ***REMOVED***
    return (
        (slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId)) ||
        slots.ruleMap.get(ruleId)
    );
***REMOVED***

/**
 * The map to store private data.
 * @type ***REMOVED***WeakMap<Linter, LinterInternalSlots>***REMOVED***
 */
const internalSlotsMap = new WeakMap();

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * Object that is responsible for verifying JavaScript text
 * @name eslint
 */
class Linter ***REMOVED***

    constructor() ***REMOVED***
        internalSlotsMap.set(this, ***REMOVED***
            lastConfigArray: null,
            lastSourceCode: null,
            parserMap: new Map([["espree", espree]]),
            ruleMap: new Rules()
        ***REMOVED***);

        this.version = pkg.version;
    ***REMOVED***

    /**
     * Getter for package version.
     * @static
     * @returns ***REMOVED***string***REMOVED*** The version from package.json.
     */
    static get version() ***REMOVED***
        return pkg.version;
    ***REMOVED***

    /**
     * Same as linter.verify, except without support for processors.
     * @param ***REMOVED***string|SourceCode***REMOVED*** textOrSourceCode The text to parse or a SourceCode object.
     * @param ***REMOVED***ConfigData***REMOVED*** providedConfig An ESLintConfig instance to configure everything.
     * @param ***REMOVED***VerifyOptions***REMOVED*** [providedOptions] The optional filename of the file being checked.
     * @returns ***REMOVED***LintMessage[]***REMOVED*** The results as an array of messages or an empty array if no messages.
     */
    _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) ***REMOVED***
        const slots = internalSlotsMap.get(this);
        const config = providedConfig || ***REMOVED******REMOVED***;
        const options = normalizeVerifyOptions(providedOptions, config);
        let text;

        // evaluate arguments
        if (typeof textOrSourceCode === "string") ***REMOVED***
            slots.lastSourceCode = null;
            text = textOrSourceCode;
        ***REMOVED*** else ***REMOVED***
            slots.lastSourceCode = textOrSourceCode;
            text = textOrSourceCode.text;
        ***REMOVED***

        // Resolve parser.
        let parserName = DEFAULT_PARSER_NAME;
        let parser = espree;

        if (typeof config.parser === "object" && config.parser !== null) ***REMOVED***
            parserName = config.parser.filePath;
            parser = config.parser.definition;
        ***REMOVED*** else if (typeof config.parser === "string") ***REMOVED***
            if (!slots.parserMap.has(config.parser)) ***REMOVED***
                return [***REMOVED***
                    ruleId: null,
                    fatal: true,
                    severity: 2,
                    message: `Configured parser '$***REMOVED***config.parser***REMOVED***' was not found.`,
                    line: 0,
                    column: 0
                ***REMOVED***];
            ***REMOVED***
            parserName = config.parser;
            parser = slots.parserMap.get(config.parser);
        ***REMOVED***

        // search and apply "eslint-env *".
        const envInFile = options.allowInlineConfig && !options.warnInlineConfig
            ? findEslintEnv(text)
            : ***REMOVED******REMOVED***;
        const resolvedEnvConfig = Object.assign(***REMOVED*** builtin: true ***REMOVED***, config.env, envInFile);
        const enabledEnvs = Object.keys(resolvedEnvConfig)
            .filter(envName => resolvedEnvConfig[envName])
            .map(envName => getEnv(slots, envName))
            .filter(env => env);

        const parserOptions = resolveParserOptions(parserName, config.parserOptions || ***REMOVED******REMOVED***, enabledEnvs);
        const configuredGlobals = resolveGlobals(config.globals || ***REMOVED******REMOVED***, enabledEnvs);
        const settings = config.settings || ***REMOVED******REMOVED***;

        if (!slots.lastSourceCode) ***REMOVED***
            const parseResult = parse(
                text,
                parser,
                parserOptions,
                options.filename
            );

            if (!parseResult.success) ***REMOVED***
                return [parseResult.error];
            ***REMOVED***

            slots.lastSourceCode = parseResult.sourceCode;
        ***REMOVED*** else ***REMOVED***

            /*
             * If the given source code object as the first argument does not have scopeManager, analyze the scope.
             * This is for backward compatibility (SourceCode is frozen so it cannot rebind).
             */
            if (!slots.lastSourceCode.scopeManager) ***REMOVED***
                slots.lastSourceCode = new SourceCode(***REMOVED***
                    text: slots.lastSourceCode.text,
                    ast: slots.lastSourceCode.ast,
                    parserServices: slots.lastSourceCode.parserServices,
                    visitorKeys: slots.lastSourceCode.visitorKeys,
                    scopeManager: analyzeScope(slots.lastSourceCode.ast, parserOptions)
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        const sourceCode = slots.lastSourceCode;
        const commentDirectives = options.allowInlineConfig
            ? getDirectiveComments(options.filename, sourceCode.ast, ruleId => getRule(slots, ruleId), options.warnInlineConfig)
            : ***REMOVED*** configuredRules: ***REMOVED******REMOVED***, enabledGlobals: ***REMOVED******REMOVED***, exportedVariables: ***REMOVED******REMOVED***, problems: [], disableDirectives: [] ***REMOVED***;

        // augment global scope with declared global variables
        addDeclaredGlobals(
            sourceCode.scopeManager.scopes[0],
            configuredGlobals,
            ***REMOVED*** exportedVariables: commentDirectives.exportedVariables, enabledGlobals: commentDirectives.enabledGlobals ***REMOVED***
        );

        const configuredRules = Object.assign(***REMOVED******REMOVED***, config.rules, commentDirectives.configuredRules);

        let lintingProblems;

        try ***REMOVED***
            lintingProblems = runRules(
                sourceCode,
                configuredRules,
                ruleId => getRule(slots, ruleId),
                parserOptions,
                parserName,
                settings,
                options.filename,
                options.disableFixes
            );
        ***REMOVED*** catch (err) ***REMOVED***
            err.message += `\nOccurred while linting $***REMOVED***options.filename***REMOVED***`;
            debug("An error occurred while traversing");
            debug("Filename:", options.filename);
            if (err.currentNode) ***REMOVED***
                const ***REMOVED*** line ***REMOVED*** = err.currentNode.loc.start;

                debug("Line:", line);
                err.message += `:$***REMOVED***line***REMOVED***`;
            ***REMOVED***
            debug("Parser Options:", parserOptions);
            debug("Parser Path:", parserName);
            debug("Settings:", settings);
            throw err;
        ***REMOVED***

        return applyDisableDirectives(***REMOVED***
            directives: commentDirectives.disableDirectives,
            problems: lintingProblems
                .concat(commentDirectives.problems)
                .sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),
            reportUnusedDisableDirectives: options.reportUnusedDisableDirectives
        ***REMOVED***);
    ***REMOVED***

    /**
     * Verifies the text against the rules specified by the second argument.
     * @param ***REMOVED***string|SourceCode***REMOVED*** textOrSourceCode The text to parse or a SourceCode object.
     * @param ***REMOVED***ConfigData|ConfigArray***REMOVED*** config An ESLintConfig instance to configure everything.
     * @param ***REMOVED***(string|(VerifyOptions&ProcessorOptions))***REMOVED*** [filenameOrOptions] The optional filename of the file being checked.
     *      If this is not set, the filename will default to '<input>' in the rule context. If
     *      an object, then it has "filename", "allowInlineConfig", and some properties.
     * @returns ***REMOVED***LintMessage[]***REMOVED*** The results as an array of messages or an empty array if no messages.
     */
    verify(textOrSourceCode, config, filenameOrOptions) ***REMOVED***
        debug("Verify");
        const options = typeof filenameOrOptions === "string"
            ? ***REMOVED*** filename: filenameOrOptions ***REMOVED***
            : filenameOrOptions || ***REMOVED******REMOVED***;

        // CLIEngine passes a `ConfigArray` object.
        if (config && typeof config.extractConfig === "function") ***REMOVED***
            return this._verifyWithConfigArray(textOrSourceCode, config, options);
        ***REMOVED***

        /*
         * `Linter` doesn't support `overrides` property in configuration.
         * So we cannot apply multiple processors.
         */
        if (options.preprocess || options.postprocess) ***REMOVED***
            return this._verifyWithProcessor(textOrSourceCode, config, options);
        ***REMOVED***
        return this._verifyWithoutProcessors(textOrSourceCode, config, options);
    ***REMOVED***

    /**
     * Verify a given code with `ConfigArray`.
     * @param ***REMOVED***string|SourceCode***REMOVED*** textOrSourceCode The source code.
     * @param ***REMOVED***ConfigArray***REMOVED*** configArray The config array.
     * @param ***REMOVED***VerifyOptions&ProcessorOptions***REMOVED*** options The options.
     * @returns ***REMOVED***LintMessage[]***REMOVED*** The found problems.
     */
    _verifyWithConfigArray(textOrSourceCode, configArray, options) ***REMOVED***
        debug("With ConfigArray: %s", options.filename);

        // Store the config array in order to get plugin envs and rules later.
        internalSlotsMap.get(this).lastConfigArray = configArray;

        // Extract the final config for this file.
        const config = configArray.extractConfig(options.filename);
        const processor =
            config.processor &&
            configArray.pluginProcessors.get(config.processor);

        // Verify.
        if (processor) ***REMOVED***
            debug("Apply the processor: %o", config.processor);
            const ***REMOVED*** preprocess, postprocess, supportsAutofix ***REMOVED*** = processor;
            const disableFixes = options.disableFixes || !supportsAutofix;

            return this._verifyWithProcessor(
                textOrSourceCode,
                config,
                ***REMOVED*** ...options, disableFixes, postprocess, preprocess ***REMOVED***,
                configArray
            );
        ***REMOVED***
        return this._verifyWithoutProcessors(textOrSourceCode, config, options);
    ***REMOVED***

    /**
     * Verify with a processor.
     * @param ***REMOVED***string|SourceCode***REMOVED*** textOrSourceCode The source code.
     * @param ***REMOVED***ConfigData|ExtractedConfig***REMOVED*** config The config array.
     * @param ***REMOVED***VerifyOptions&ProcessorOptions***REMOVED*** options The options.
     * @param ***REMOVED***ConfigArray***REMOVED*** [configForRecursive] The `CofnigArray` object to apply multiple processors recursively.
     * @returns ***REMOVED***LintMessage[]***REMOVED*** The found problems.
     */
    _verifyWithProcessor(textOrSourceCode, config, options, configForRecursive) ***REMOVED***
        const filename = options.filename || "<input>";
        const filenameToExpose = normalizeFilename(filename);
        const text = ensureText(textOrSourceCode);
        const preprocess = options.preprocess || (rawText => [rawText]);
        const postprocess = options.postprocess || lodash.flatten;
        const filterCodeBlock =
            options.filterCodeBlock ||
            (blockFilename => blockFilename.endsWith(".js"));
        const originalExtname = path.extname(filename);
        const messageLists = preprocess(text, filenameToExpose).map((block, i) => ***REMOVED***
            debug("A code block was found: %o", block.filename || "(unnamed)");

            // Keep the legacy behavior.
            if (typeof block === "string") ***REMOVED***
                return this._verifyWithoutProcessors(block, config, options);
            ***REMOVED***

            const blockText = block.text;
            const blockName = path.join(filename, `$***REMOVED***i***REMOVED***_$***REMOVED***block.filename***REMOVED***`);

            // Skip this block if filtered.
            if (!filterCodeBlock(blockName, blockText)) ***REMOVED***
                debug("This code block was skipped.");
                return [];
            ***REMOVED***

            // Resolve configuration again if the file extension was changed.
            if (configForRecursive && path.extname(blockName) !== originalExtname) ***REMOVED***
                debug("Resolving configuration again because the file extension was changed.");
                return this._verifyWithConfigArray(
                    blockText,
                    configForRecursive,
                    ***REMOVED*** ...options, filename: blockName ***REMOVED***
                );
            ***REMOVED***

            // Does lint.
            return this._verifyWithoutProcessors(
                blockText,
                config,
                ***REMOVED*** ...options, filename: blockName ***REMOVED***
            );
        ***REMOVED***);

        return postprocess(messageLists, filenameToExpose);
    ***REMOVED***

    /**
     * Gets the SourceCode object representing the parsed source.
     * @returns ***REMOVED***SourceCode***REMOVED*** The SourceCode object.
     */
    getSourceCode() ***REMOVED***
        return internalSlotsMap.get(this).lastSourceCode;
    ***REMOVED***

    /**
     * Defines a new linting rule.
     * @param ***REMOVED***string***REMOVED*** ruleId A unique rule identifier
     * @param ***REMOVED***Function | Rule***REMOVED*** ruleModule Function from context to object mapping AST node types to event handlers
     * @returns ***REMOVED***void***REMOVED***
     */
    defineRule(ruleId, ruleModule) ***REMOVED***
        internalSlotsMap.get(this).ruleMap.define(ruleId, ruleModule);
    ***REMOVED***

    /**
     * Defines many new linting rules.
     * @param ***REMOVED***Record<string, Function | Rule>***REMOVED*** rulesToDefine map from unique rule identifier to rule
     * @returns ***REMOVED***void***REMOVED***
     */
    defineRules(rulesToDefine) ***REMOVED***
        Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => ***REMOVED***
            this.defineRule(ruleId, rulesToDefine[ruleId]);
        ***REMOVED***);
    ***REMOVED***

    /**
     * Gets an object with all loaded rules.
     * @returns ***REMOVED***Map<string, Rule>***REMOVED*** All loaded rules
     */
    getRules() ***REMOVED***
        const ***REMOVED*** lastConfigArray, ruleMap ***REMOVED*** = internalSlotsMap.get(this);

        return new Map(function *() ***REMOVED***
            yield* ruleMap;

            if (lastConfigArray) ***REMOVED***
                yield* lastConfigArray.pluginRules;
            ***REMOVED***
        ***REMOVED***());
    ***REMOVED***

    /**
     * Define a new parser module
     * @param ***REMOVED***string***REMOVED*** parserId Name of the parser
     * @param ***REMOVED***Parser***REMOVED*** parserModule The parser object
     * @returns ***REMOVED***void***REMOVED***
     */
    defineParser(parserId, parserModule) ***REMOVED***
        internalSlotsMap.get(this).parserMap.set(parserId, parserModule);
    ***REMOVED***

    /**
     * Performs multiple autofix passes over the text until as many fixes as possible
     * have been applied.
     * @param ***REMOVED***string***REMOVED*** text The source text to apply fixes to.
     * @param ***REMOVED***ConfigData|ConfigArray***REMOVED*** config The ESLint config object to use.
     * @param ***REMOVED***VerifyOptions&ProcessorOptions&FixOptions***REMOVED*** options The ESLint options object to use.
     * @returns ***REMOVED******REMOVED***fixed:boolean,messages:LintMessage[],output:string***REMOVED******REMOVED*** The result of the fix operation as returned from the
     *      SourceCodeFixer.
     */
    verifyAndFix(text, config, options) ***REMOVED***
        let messages = [],
            fixedResult,
            fixed = false,
            passNumber = 0,
            currentText = text;
        const debugTextDescription = options && options.filename || `$***REMOVED***text.slice(0, 10)***REMOVED***...`;
        const shouldFix = options && typeof options.fix !== "undefined" ? options.fix : true;

        /**
         * This loop continues until one of the following is true:
         *
         * 1. No more fixes have been applied.
         * 2. Ten passes have been made.
         *
         * That means anytime a fix is successfully applied, there will be another pass.
         * Essentially, guaranteeing a minimum of two passes.
         */
        do ***REMOVED***
            passNumber++;

            debug(`Linting code for $***REMOVED***debugTextDescription***REMOVED*** (pass $***REMOVED***passNumber***REMOVED***)`);
            messages = this.verify(currentText, config, options);

            debug(`Generating fixed text for $***REMOVED***debugTextDescription***REMOVED*** (pass $***REMOVED***passNumber***REMOVED***)`);
            fixedResult = SourceCodeFixer.applyFixes(currentText, messages, shouldFix);

            /*
             * stop if there are any syntax errors.
             * 'fixedResult.output' is a empty string.
             */
            if (messages.length === 1 && messages[0].fatal) ***REMOVED***
                break;
            ***REMOVED***

            // keep track if any fixes were ever applied - important for return value
            fixed = fixed || fixedResult.fixed;

            // update to use the fixed output instead of the original text
            currentText = fixedResult.output;

        ***REMOVED*** while (
            fixedResult.fixed &&
            passNumber < MAX_AUTOFIX_PASSES
        );

        /*
         * If the last result had fixes, we need to lint again to be sure we have
         * the most up-to-date information.
         */
        if (fixedResult.fixed) ***REMOVED***
            fixedResult.messages = this.verify(currentText, config, options);
        ***REMOVED***

        // ensure the last result properly reflects if fixes were done
        fixedResult.fixed = fixed;
        fixedResult.output = currentText;

        return fixedResult;
    ***REMOVED***
***REMOVED***

module.exports = ***REMOVED***
    Linter,

    /**
     * Get the internal slots of a given Linter instance for tests.
     * @param ***REMOVED***Linter***REMOVED*** instance The Linter instance to get.
     * @returns ***REMOVED***LinterInternalSlots***REMOVED*** The internal slots.
     */
    getLinterInternalSlots(instance) ***REMOVED***
        return internalSlotsMap.get(instance);
    ***REMOVED***
***REMOVED***;
