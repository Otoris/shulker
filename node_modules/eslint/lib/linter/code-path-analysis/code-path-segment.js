/**
 * @fileoverview A class of the code path segment.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const debug = require("./debug-helpers");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given segment is reachable.
 *
 * @param ***REMOVED***CodePathSegment***REMOVED*** segment - A segment to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the segment is reachable.
 */
function isReachable(segment) ***REMOVED***
    return segment.reachable;
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * A code path segment.
 */
class CodePathSegment ***REMOVED***

    /**
     * @param ***REMOVED***string***REMOVED*** id - An identifier.
     * @param ***REMOVED***CodePathSegment[]***REMOVED*** allPrevSegments - An array of the previous segments.
     *   This array includes unreachable segments.
     * @param ***REMOVED***boolean***REMOVED*** reachable - A flag which shows this is reachable.
     */
    constructor(id, allPrevSegments, reachable) ***REMOVED***

        /**
         * The identifier of this code path.
         * Rules use it to store additional information of each rule.
         * @type ***REMOVED***string***REMOVED***
         */
        this.id = id;

        /**
         * An array of the next segments.
         * @type ***REMOVED***CodePathSegment[]***REMOVED***
         */
        this.nextSegments = [];

        /**
         * An array of the previous segments.
         * @type ***REMOVED***CodePathSegment[]***REMOVED***
         */
        this.prevSegments = allPrevSegments.filter(isReachable);

        /**
         * An array of the next segments.
         * This array includes unreachable segments.
         * @type ***REMOVED***CodePathSegment[]***REMOVED***
         */
        this.allNextSegments = [];

        /**
         * An array of the previous segments.
         * This array includes unreachable segments.
         * @type ***REMOVED***CodePathSegment[]***REMOVED***
         */
        this.allPrevSegments = allPrevSegments;

        /**
         * A flag which shows this is reachable.
         * @type ***REMOVED***boolean***REMOVED***
         */
        this.reachable = reachable;

        // Internal data.
        Object.defineProperty(this, "internal", ***REMOVED***
            value: ***REMOVED***
                used: false,
                loopedPrevSegments: []
            ***REMOVED***
        ***REMOVED***);

        /* istanbul ignore if */
        if (debug.enabled) ***REMOVED***
            this.internal.nodes = [];
            this.internal.exitNodes = [];
        ***REMOVED***
    ***REMOVED***

    /**
     * Checks a given previous segment is coming from the end of a loop.
     *
     * @param ***REMOVED***CodePathSegment***REMOVED*** segment - A previous segment to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the segment is coming from the end of a loop.
     */
    isLoopedPrevSegment(segment) ***REMOVED***
        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;
    ***REMOVED***

    /**
     * Creates the root segment.
     *
     * @param ***REMOVED***string***REMOVED*** id - An identifier.
     * @returns ***REMOVED***CodePathSegment***REMOVED*** The created segment.
     */
    static newRoot(id) ***REMOVED***
        return new CodePathSegment(id, [], true);
    ***REMOVED***

    /**
     * Creates a segment that follows given segments.
     *
     * @param ***REMOVED***string***REMOVED*** id - An identifier.
     * @param ***REMOVED***CodePathSegment[]***REMOVED*** allPrevSegments - An array of the previous segments.
     * @returns ***REMOVED***CodePathSegment***REMOVED*** The created segment.
     */
    static newNext(id, allPrevSegments) ***REMOVED***
        return new CodePathSegment(
            id,
            CodePathSegment.flattenUnusedSegments(allPrevSegments),
            allPrevSegments.some(isReachable)
        );
    ***REMOVED***

    /**
     * Creates an unreachable segment that follows given segments.
     *
     * @param ***REMOVED***string***REMOVED*** id - An identifier.
     * @param ***REMOVED***CodePathSegment[]***REMOVED*** allPrevSegments - An array of the previous segments.
     * @returns ***REMOVED***CodePathSegment***REMOVED*** The created segment.
     */
    static newUnreachable(id, allPrevSegments) ***REMOVED***
        const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);

        /*
         * In `if (a) return a; foo();` case, the unreachable segment preceded by
         * the return statement is not used but must not be remove.
         */
        CodePathSegment.markUsed(segment);

        return segment;
    ***REMOVED***

    /**
     * Creates a segment that follows given segments.
     * This factory method does not connect with `allPrevSegments`.
     * But this inherits `reachable` flag.
     *
     * @param ***REMOVED***string***REMOVED*** id - An identifier.
     * @param ***REMOVED***CodePathSegment[]***REMOVED*** allPrevSegments - An array of the previous segments.
     * @returns ***REMOVED***CodePathSegment***REMOVED*** The created segment.
     */
    static newDisconnected(id, allPrevSegments) ***REMOVED***
        return new CodePathSegment(id, [], allPrevSegments.some(isReachable));
    ***REMOVED***

    /**
     * Makes a given segment being used.
     *
     * And this function registers the segment into the previous segments as a next.
     *
     * @param ***REMOVED***CodePathSegment***REMOVED*** segment - A segment to mark.
     * @returns ***REMOVED***void***REMOVED***
     */
    static markUsed(segment) ***REMOVED***
        if (segment.internal.used) ***REMOVED***
            return;
        ***REMOVED***
        segment.internal.used = true;

        let i;

        if (segment.reachable) ***REMOVED***
            for (i = 0; i < segment.allPrevSegments.length; ++i) ***REMOVED***
                const prevSegment = segment.allPrevSegments[i];

                prevSegment.allNextSegments.push(segment);
                prevSegment.nextSegments.push(segment);
            ***REMOVED***
        ***REMOVED*** else ***REMOVED***
            for (i = 0; i < segment.allPrevSegments.length; ++i) ***REMOVED***
                segment.allPrevSegments[i].allNextSegments.push(segment);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    /**
     * Marks a previous segment as looped.
     *
     * @param ***REMOVED***CodePathSegment***REMOVED*** segment - A segment.
     * @param ***REMOVED***CodePathSegment***REMOVED*** prevSegment - A previous segment to mark.
     * @returns ***REMOVED***void***REMOVED***
     */
    static markPrevSegmentAsLooped(segment, prevSegment) ***REMOVED***
        segment.internal.loopedPrevSegments.push(prevSegment);
    ***REMOVED***

    /**
     * Replaces unused segments with the previous segments of each unused segment.
     *
     * @param ***REMOVED***CodePathSegment[]***REMOVED*** segments - An array of segments to replace.
     * @returns ***REMOVED***CodePathSegment[]***REMOVED*** The replaced array.
     */
    static flattenUnusedSegments(segments) ***REMOVED***
        const done = Object.create(null);
        const retv = [];

        for (let i = 0; i < segments.length; ++i) ***REMOVED***
            const segment = segments[i];

            // Ignores duplicated.
            if (done[segment.id]) ***REMOVED***
                continue;
            ***REMOVED***

            // Use previous segments if unused.
            if (!segment.internal.used) ***REMOVED***
                for (let j = 0; j < segment.allPrevSegments.length; ++j) ***REMOVED***
                    const prevSegment = segment.allPrevSegments[j];

                    if (!done[prevSegment.id]) ***REMOVED***
                        done[prevSegment.id] = true;
                        retv.push(prevSegment);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED*** else ***REMOVED***
                done[segment.id] = true;
                retv.push(segment);
            ***REMOVED***
        ***REMOVED***

        return retv;
    ***REMOVED***
***REMOVED***

module.exports = CodePathSegment;
