/**
 * @fileoverview Helpers to debug for code path analysis.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const debug = require("debug")("eslint:code-path");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets id of a given segment.
 * @param ***REMOVED***CodePathSegment***REMOVED*** segment - A segment to get.
 * @returns ***REMOVED***string***REMOVED*** Id of the segment.
 */
/* istanbul ignore next */
function getId(segment) ***REMOVED*** // eslint-disable-line require-jsdoc
    return segment.id + (segment.reachable ? "" : "!");
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = ***REMOVED***

    /**
     * A flag that debug dumping is enabled or not.
     * @type ***REMOVED***boolean***REMOVED***
     */
    enabled: debug.enabled,

    /**
     * Dumps given objects.
     *
     * @param ***REMOVED***...any***REMOVED*** args - objects to dump.
     * @returns ***REMOVED***void***REMOVED***
     */
    dump: debug,

    /**
     * Dumps the current analyzing state.
     *
     * @param ***REMOVED***ASTNode***REMOVED*** node - A node to dump.
     * @param ***REMOVED***CodePathState***REMOVED*** state - A state to dump.
     * @param ***REMOVED***boolean***REMOVED*** leaving - A flag whether or not it's leaving
     * @returns ***REMOVED***void***REMOVED***
     */
    dumpState: !debug.enabled ? debug : /* istanbul ignore next */ function(node, state, leaving) ***REMOVED***
        for (let i = 0; i < state.currentSegments.length; ++i) ***REMOVED***
            const segInternal = state.currentSegments[i].internal;

            if (leaving) ***REMOVED***
                segInternal.exitNodes.push(node);
            ***REMOVED*** else ***REMOVED***
                segInternal.nodes.push(node);
            ***REMOVED***
        ***REMOVED***

        debug([
            `$***REMOVED***state.currentSegments.map(getId).join(",")***REMOVED***)`,
            `$***REMOVED***node.type***REMOVED***$***REMOVED***leaving ? ":exit" : ""***REMOVED***`
        ].join(" "));
    ***REMOVED***,

    /**
     * Dumps a DOT code of a given code path.
     * The DOT code can be visialized with Graphvis.
     *
     * @param ***REMOVED***CodePath***REMOVED*** codePath - A code path to dump.
     * @returns ***REMOVED***void***REMOVED***
     * @see http://www.graphviz.org
     * @see http://www.webgraphviz.com
     */
    dumpDot: !debug.enabled ? debug : /* istanbul ignore next */ function(codePath) ***REMOVED***
        let text =
            "\n" +
            "digraph ***REMOVED***\n" +
            "node[shape=box,style=\"rounded,filled\",fillcolor=white];\n" +
            "initial[label=\"\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";

        if (codePath.returnedSegments.length > 0) ***REMOVED***
            text += "final[label=\"\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";
        ***REMOVED***
        if (codePath.thrownSegments.length > 0) ***REMOVED***
            text += "thrown[label=\"âœ˜\",shape=circle,width=0.3,height=0.3,fixedsize];\n";
        ***REMOVED***

        const traceMap = Object.create(null);
        const arrows = this.makeDotArrows(codePath, traceMap);

        for (const id in traceMap) ***REMOVED*** // eslint-disable-line guard-for-in
            const segment = traceMap[id];

            text += `$***REMOVED***id***REMOVED***[`;

            if (segment.reachable) ***REMOVED***
                text += "label=\"";
            ***REMOVED*** else ***REMOVED***
                text += "style=\"rounded,dashed,filled\",fillcolor=\"#FF9800\",label=\"<<unreachable>>\\n";
            ***REMOVED***

            if (segment.internal.nodes.length > 0 || segment.internal.exitNodes.length > 0) ***REMOVED***
                text += [].concat(
                    segment.internal.nodes.map(node => ***REMOVED***
                        switch (node.type) ***REMOVED***
                            case "Identifier": return `$***REMOVED***node.type***REMOVED*** ($***REMOVED***node.name***REMOVED***)`;
                            case "Literal": return `$***REMOVED***node.type***REMOVED*** ($***REMOVED***node.value***REMOVED***)`;
                            default: return node.type;
                        ***REMOVED***
                    ***REMOVED***),
                    segment.internal.exitNodes.map(node => ***REMOVED***
                        switch (node.type) ***REMOVED***
                            case "Identifier": return `$***REMOVED***node.type***REMOVED***:exit ($***REMOVED***node.name***REMOVED***)`;
                            case "Literal": return `$***REMOVED***node.type***REMOVED***:exit ($***REMOVED***node.value***REMOVED***)`;
                            default: return `$***REMOVED***node.type***REMOVED***:exit`;
                        ***REMOVED***
                    ***REMOVED***)
                ).join("\\n");
            ***REMOVED*** else ***REMOVED***
                text += "????";
            ***REMOVED***

            text += "\"];\n";
        ***REMOVED***

        text += `$***REMOVED***arrows***REMOVED***\n`;
        text += "***REMOVED***";
        debug("DOT", text);
    ***REMOVED***,

    /**
     * Makes a DOT code of a given code path.
     * The DOT code can be visialized with Graphvis.
     *
     * @param ***REMOVED***CodePath***REMOVED*** codePath - A code path to make DOT.
     * @param ***REMOVED***Object***REMOVED*** traceMap - Optional. A map to check whether or not segments had been done.
     * @returns ***REMOVED***string***REMOVED*** A DOT code of the code path.
     */
    makeDotArrows(codePath, traceMap) ***REMOVED***
        const stack = [[codePath.initialSegment, 0]];
        const done = traceMap || Object.create(null);
        let lastId = codePath.initialSegment.id;
        let text = `initial->$***REMOVED***codePath.initialSegment.id***REMOVED***`;

        while (stack.length > 0) ***REMOVED***
            const item = stack.pop();
            const segment = item[0];
            const index = item[1];

            if (done[segment.id] && index === 0) ***REMOVED***
                continue;
            ***REMOVED***
            done[segment.id] = segment;

            const nextSegment = segment.allNextSegments[index];

            if (!nextSegment) ***REMOVED***
                continue;
            ***REMOVED***

            if (lastId === segment.id) ***REMOVED***
                text += `->$***REMOVED***nextSegment.id***REMOVED***`;
            ***REMOVED*** else ***REMOVED***
                text += `;\n$***REMOVED***segment.id***REMOVED***->$***REMOVED***nextSegment.id***REMOVED***`;
            ***REMOVED***
            lastId = nextSegment.id;

            stack.unshift([segment, 1 + index]);
            stack.push([nextSegment, 0]);
        ***REMOVED***

        codePath.returnedSegments.forEach(finalSegment => ***REMOVED***
            if (lastId === finalSegment.id) ***REMOVED***
                text += "->final";
            ***REMOVED*** else ***REMOVED***
                text += `;\n$***REMOVED***finalSegment.id***REMOVED***->final`;
            ***REMOVED***
            lastId = null;
        ***REMOVED***);

        codePath.thrownSegments.forEach(finalSegment => ***REMOVED***
            if (lastId === finalSegment.id) ***REMOVED***
                text += "->thrown";
            ***REMOVED*** else ***REMOVED***
                text += `;\n$***REMOVED***finalSegment.id***REMOVED***->thrown`;
            ***REMOVED***
            lastId = null;
        ***REMOVED***);

        return `$***REMOVED***text***REMOVED***;`;
    ***REMOVED***
***REMOVED***;
