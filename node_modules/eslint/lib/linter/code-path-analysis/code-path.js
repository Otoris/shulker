/**
 * @fileoverview A class of the code path.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const CodePathState = require("./code-path-state");
const IdGenerator = require("./id-generator");

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * A code path.
 */
class CodePath ***REMOVED***

    /**
     * @param ***REMOVED***string***REMOVED*** id - An identifier.
     * @param ***REMOVED***CodePath|null***REMOVED*** upper - The code path of the upper function scope.
     * @param ***REMOVED***Function***REMOVED*** onLooped - A callback function to notify looping.
     */
    constructor(id, upper, onLooped) ***REMOVED***

        /**
         * The identifier of this code path.
         * Rules use it to store additional information of each rule.
         * @type ***REMOVED***string***REMOVED***
         */
        this.id = id;

        /**
         * The code path of the upper function scope.
         * @type ***REMOVED***CodePath|null***REMOVED***
         */
        this.upper = upper;

        /**
         * The code paths of nested function scopes.
         * @type ***REMOVED***CodePath[]***REMOVED***
         */
        this.childCodePaths = [];

        // Initializes internal state.
        Object.defineProperty(
            this,
            "internal",
            ***REMOVED*** value: new CodePathState(new IdGenerator(`$***REMOVED***id***REMOVED***_`), onLooped) ***REMOVED***
        );

        // Adds this into `childCodePaths` of `upper`.
        if (upper) ***REMOVED***
            upper.childCodePaths.push(this);
        ***REMOVED***
    ***REMOVED***

    /**
     * Gets the state of a given code path.
     *
     * @param ***REMOVED***CodePath***REMOVED*** codePath - A code path to get.
     * @returns ***REMOVED***CodePathState***REMOVED*** The state of the code path.
     */
    static getState(codePath) ***REMOVED***
        return codePath.internal;
    ***REMOVED***

    /**
     * The initial code path segment.
     * @type ***REMOVED***CodePathSegment***REMOVED***
     */
    get initialSegment() ***REMOVED***
        return this.internal.initialSegment;
    ***REMOVED***

    /**
     * Final code path segments.
     * This array is a mix of `returnedSegments` and `thrownSegments`.
     * @type ***REMOVED***CodePathSegment[]***REMOVED***
     */
    get finalSegments() ***REMOVED***
        return this.internal.finalSegments;
    ***REMOVED***

    /**
     * Final code path segments which is with `return` statements.
     * This array contains the last path segment if it's reachable.
     * Since the reachable last path returns `undefined`.
     * @type ***REMOVED***CodePathSegment[]***REMOVED***
     */
    get returnedSegments() ***REMOVED***
        return this.internal.returnedForkContext;
    ***REMOVED***

    /**
     * Final code path segments which is with `throw` statements.
     * @type ***REMOVED***CodePathSegment[]***REMOVED***
     */
    get thrownSegments() ***REMOVED***
        return this.internal.thrownForkContext;
    ***REMOVED***

    /**
     * Current code path segments.
     * @type ***REMOVED***CodePathSegment[]***REMOVED***
     */
    get currentSegments() ***REMOVED***
        return this.internal.currentSegments;
    ***REMOVED***

    /**
     * Traverses all segments in this code path.
     *
     *     codePath.traverseSegments(function(segment, controller) ***REMOVED***
     *         // do something.
     *     ***REMOVED***);
     *
     * This method enumerates segments in order from the head.
     *
     * The `controller` object has two methods.
     *
     * - `controller.skip()` - Skip the following segments in this branch.
     * - `controller.break()` - Skip all following segments.
     *
     * @param ***REMOVED***Object***REMOVED*** [options] - Omittable.
     * @param ***REMOVED***CodePathSegment***REMOVED*** [options.first] - The first segment to traverse.
     * @param ***REMOVED***CodePathSegment***REMOVED*** [options.last] - The last segment to traverse.
     * @param ***REMOVED***Function***REMOVED*** callback - A callback function.
     * @returns ***REMOVED***void***REMOVED***
     */
    traverseSegments(options, callback) ***REMOVED***
        let resolvedOptions;
        let resolvedCallback;

        if (typeof options === "function") ***REMOVED***
            resolvedCallback = options;
            resolvedOptions = ***REMOVED******REMOVED***;
        ***REMOVED*** else ***REMOVED***
            resolvedOptions = options || ***REMOVED******REMOVED***;
            resolvedCallback = callback;
        ***REMOVED***

        const startSegment = resolvedOptions.first || this.internal.initialSegment;
        const lastSegment = resolvedOptions.last;

        let item = null;
        let index = 0;
        let end = 0;
        let segment = null;
        const visited = Object.create(null);
        const stack = [[startSegment, 0]];
        let skippedSegment = null;
        let broken = false;
        const controller = ***REMOVED***
            skip() ***REMOVED***
                if (stack.length <= 1) ***REMOVED***
                    broken = true;
                ***REMOVED*** else ***REMOVED***
                    skippedSegment = stack[stack.length - 2][0];
                ***REMOVED***
            ***REMOVED***,
            break() ***REMOVED***
                broken = true;
            ***REMOVED***
        ***REMOVED***;

        /**
         * Checks a given previous segment has been visited.
         * @param ***REMOVED***CodePathSegment***REMOVED*** prevSegment - A previous segment to check.
         * @returns ***REMOVED***boolean***REMOVED*** `true` if the segment has been visited.
         */
        function isVisited(prevSegment) ***REMOVED***
            return (
                visited[prevSegment.id] ||
                segment.isLoopedPrevSegment(prevSegment)
            );
        ***REMOVED***

        while (stack.length > 0) ***REMOVED***
            item = stack[stack.length - 1];
            segment = item[0];
            index = item[1];

            if (index === 0) ***REMOVED***

                // Skip if this segment has been visited already.
                if (visited[segment.id]) ***REMOVED***
                    stack.pop();
                    continue;
                ***REMOVED***

                // Skip if all previous segments have not been visited.
                if (segment !== startSegment &&
                    segment.prevSegments.length > 0 &&
                    !segment.prevSegments.every(isVisited)
                ) ***REMOVED***
                    stack.pop();
                    continue;
                ***REMOVED***

                // Reset the flag of skipping if all branches have been skipped.
                if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) ***REMOVED***
                    skippedSegment = null;
                ***REMOVED***
                visited[segment.id] = true;

                // Call the callback when the first time.
                if (!skippedSegment) ***REMOVED***
                    resolvedCallback.call(this, segment, controller);
                    if (segment === lastSegment) ***REMOVED***
                        controller.skip();
                    ***REMOVED***
                    if (broken) ***REMOVED***
                        break;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***

            // Update the stack.
            end = segment.nextSegments.length - 1;
            if (index < end) ***REMOVED***
                item[1] += 1;
                stack.push([segment.nextSegments[index], 0]);
            ***REMOVED*** else if (index === end) ***REMOVED***
                item[0] = segment.nextSegments[index];
                item[1] = 0;
            ***REMOVED*** else ***REMOVED***
                stack.pop();
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
***REMOVED***

module.exports = CodePath;
