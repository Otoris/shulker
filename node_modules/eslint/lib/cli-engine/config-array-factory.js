/**
 * @fileoverview The factory of `ConfigArray` objects.
 *
 * This class provides methods to create `ConfigArray` instance.
 *
 * - `create(configData, options)`
 *     Create a `ConfigArray` instance from a config data. This is to handle CLI
 *     options except `--config`.
 * - `loadFile(filePath, options)`
 *     Create a `ConfigArray` instance from a config file. This is to handle
 *     `--config` option. If the file was not found, throws the following error:
 *      - If the filename was `*.js`, a `MODULE_NOT_FOUND` error.
 *      - If the filename was `package.json`, an IO error or an
 *        `ESLINT_CONFIG_FIELD_NOT_FOUND` error.
 *      - Otherwise, an IO error such as `ENOENT`.
 * - `loadInDirectory(directoryPath, options)`
 *     Create a `ConfigArray` instance from a config file which is on a given
 *     directory. This tries to load `.eslintrc.*` or `package.json`. If not
 *     found, returns an empty `ConfigArray`.
 *
 * `ConfigArrayFactory` class has the responsibility that loads configuration
 * files, including loading `extends`, `parser`, and `plugins`. The created
 * `ConfigArray` instance has the loaded `extends`, `parser`, and `plugins`.
 *
 * But this class doesn't handle cascading. `CascadingConfigArrayFactory` class
 * handles cascading and hierarchy.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const fs = require("fs");
const path = require("path");
const importFresh = require("import-fresh");
const stripComments = require("strip-json-comments");
const ***REMOVED*** validateConfigSchema ***REMOVED*** = require("../shared/config-validator");
const naming = require("../shared/naming");
const ModuleResolver = require("../shared/relative-module-resolver");
const ***REMOVED*** ConfigArray, ConfigDependency, OverrideTester ***REMOVED*** = require("./config-array");
const debug = require("debug")("eslint:config-array-factory");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const eslintRecommendedPath = path.resolve(__dirname, "../../conf/eslint-recommended.js");
const eslintAllPath = path.resolve(__dirname, "../../conf/eslint-all.js");
const configFilenames = [
    ".eslintrc.js",
    ".eslintrc.yaml",
    ".eslintrc.yml",
    ".eslintrc.json",
    ".eslintrc",
    "package.json"
];

// Define types for VSCode IntelliSense.
/** @typedef ***REMOVED***import("../shared/types").ConfigData***REMOVED*** ConfigData */
/** @typedef ***REMOVED***import("../shared/types").OverrideConfigData***REMOVED*** OverrideConfigData */
/** @typedef ***REMOVED***import("../shared/types").Parser***REMOVED*** Parser */
/** @typedef ***REMOVED***import("../shared/types").Plugin***REMOVED*** Plugin */
/** @typedef ***REMOVED***import("./config-array/config-dependency").DependentParser***REMOVED*** DependentParser */
/** @typedef ***REMOVED***import("./config-array/config-dependency").DependentPlugin***REMOVED*** DependentPlugin */
/** @typedef ***REMOVED***ConfigArray[0]***REMOVED*** ConfigArrayElement */

/**
 * @typedef ***REMOVED***Object***REMOVED*** ConfigArrayFactoryOptions
 * @property ***REMOVED***Map<string,Plugin>***REMOVED*** [additionalPluginPool] The map for additional plugins.
 * @property ***REMOVED***string***REMOVED*** [cwd] The path to the current working directory.
 * @property ***REMOVED***string***REMOVED*** [resolvePluginsRelativeTo] A path to the directory that plugins should be resolved from. Defaults to `cwd`.
 */

/**
 * @typedef ***REMOVED***Object***REMOVED*** ConfigArrayFactoryInternalSlots
 * @property ***REMOVED***Map<string,Plugin>***REMOVED*** additionalPluginPool The map for additional plugins.
 * @property ***REMOVED***string***REMOVED*** cwd The path to the current working directory.
 * @property ***REMOVED***string***REMOVED*** resolvePluginsRelativeTo An absolute path the the directory that plugins should be resolved from.
 */

/** @type ***REMOVED***WeakMap<ConfigArrayFactory, ConfigArrayFactoryInternalSlots>***REMOVED*** */
const internalSlotsMap = new WeakMap();

/**
 * Check if a given string is a file path.
 * @param ***REMOVED***string***REMOVED*** nameOrPath A module name or file path.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the `nameOrPath` is a file path.
 */
function isFilePath(nameOrPath) ***REMOVED***
    return (
        /^\.***REMOVED***1,2***REMOVED***[/\\]/u.test(nameOrPath) ||
        path.isAbsolute(nameOrPath)
    );
***REMOVED***

/**
 * Convenience wrapper for synchronously reading file contents.
 * @param ***REMOVED***string***REMOVED*** filePath The filename to read.
 * @returns ***REMOVED***string***REMOVED*** The file contents, with the BOM removed.
 * @private
 */
function readFile(filePath) ***REMOVED***
    return fs.readFileSync(filePath, "utf8").replace(/^\ufeff/u, "");
***REMOVED***

/**
 * Loads a YAML configuration from a file.
 * @param ***REMOVED***string***REMOVED*** filePath The filename to load.
 * @returns ***REMOVED***ConfigData***REMOVED*** The configuration object from the file.
 * @throws ***REMOVED***Error***REMOVED*** If the file cannot be read.
 * @private
 */
function loadYAMLConfigFile(filePath) ***REMOVED***
    debug(`Loading YAML config file: $***REMOVED***filePath***REMOVED***`);

    // lazy load YAML to improve performance when not used
    const yaml = require("js-yaml");

    try ***REMOVED***

        // empty YAML file can be null, so always use
        return yaml.safeLoad(readFile(filePath)) || ***REMOVED******REMOVED***;
    ***REMOVED*** catch (e) ***REMOVED***
        debug(`Error reading YAML file: $***REMOVED***filePath***REMOVED***`);
        e.message = `Cannot read config file: $***REMOVED***filePath***REMOVED***\nError: $***REMOVED***e.message***REMOVED***`;
        throw e;
    ***REMOVED***
***REMOVED***

/**
 * Loads a JSON configuration from a file.
 * @param ***REMOVED***string***REMOVED*** filePath The filename to load.
 * @returns ***REMOVED***ConfigData***REMOVED*** The configuration object from the file.
 * @throws ***REMOVED***Error***REMOVED*** If the file cannot be read.
 * @private
 */
function loadJSONConfigFile(filePath) ***REMOVED***
    debug(`Loading JSON config file: $***REMOVED***filePath***REMOVED***`);

    try ***REMOVED***
        return JSON.parse(stripComments(readFile(filePath)));
    ***REMOVED*** catch (e) ***REMOVED***
        debug(`Error reading JSON file: $***REMOVED***filePath***REMOVED***`);
        e.message = `Cannot read config file: $***REMOVED***filePath***REMOVED***\nError: $***REMOVED***e.message***REMOVED***`;
        e.messageTemplate = "failed-to-read-json";
        e.messageData = ***REMOVED***
            path: filePath,
            message: e.message
        ***REMOVED***;
        throw e;
    ***REMOVED***
***REMOVED***

/**
 * Loads a legacy (.eslintrc) configuration from a file.
 * @param ***REMOVED***string***REMOVED*** filePath The filename to load.
 * @returns ***REMOVED***ConfigData***REMOVED*** The configuration object from the file.
 * @throws ***REMOVED***Error***REMOVED*** If the file cannot be read.
 * @private
 */
function loadLegacyConfigFile(filePath) ***REMOVED***
    debug(`Loading legacy config file: $***REMOVED***filePath***REMOVED***`);

    // lazy load YAML to improve performance when not used
    const yaml = require("js-yaml");

    try ***REMOVED***
        return yaml.safeLoad(stripComments(readFile(filePath))) || /* istanbul ignore next */ ***REMOVED******REMOVED***;
    ***REMOVED*** catch (e) ***REMOVED***
        debug("Error reading YAML file: %s\n%o", filePath, e);
        e.message = `Cannot read config file: $***REMOVED***filePath***REMOVED***\nError: $***REMOVED***e.message***REMOVED***`;
        throw e;
    ***REMOVED***
***REMOVED***

/**
 * Loads a JavaScript configuration from a file.
 * @param ***REMOVED***string***REMOVED*** filePath The filename to load.
 * @returns ***REMOVED***ConfigData***REMOVED*** The configuration object from the file.
 * @throws ***REMOVED***Error***REMOVED*** If the file cannot be read.
 * @private
 */
function loadJSConfigFile(filePath) ***REMOVED***
    debug(`Loading JS config file: $***REMOVED***filePath***REMOVED***`);
    try ***REMOVED***
        return importFresh(filePath);
    ***REMOVED*** catch (e) ***REMOVED***
        debug(`Error reading JavaScript file: $***REMOVED***filePath***REMOVED***`);
        e.message = `Cannot read config file: $***REMOVED***filePath***REMOVED***\nError: $***REMOVED***e.message***REMOVED***`;
        throw e;
    ***REMOVED***
***REMOVED***

/**
 * Loads a configuration from a package.json file.
 * @param ***REMOVED***string***REMOVED*** filePath The filename to load.
 * @returns ***REMOVED***ConfigData***REMOVED*** The configuration object from the file.
 * @throws ***REMOVED***Error***REMOVED*** If the file cannot be read.
 * @private
 */
function loadPackageJSONConfigFile(filePath) ***REMOVED***
    debug(`Loading package.json config file: $***REMOVED***filePath***REMOVED***`);
    try ***REMOVED***
        const packageData = loadJSONConfigFile(filePath);

        if (!Object.hasOwnProperty.call(packageData, "eslintConfig")) ***REMOVED***
            throw Object.assign(
                new Error("package.json file doesn't have 'eslintConfig' field."),
                ***REMOVED*** code: "ESLINT_CONFIG_FIELD_NOT_FOUND" ***REMOVED***
            );
        ***REMOVED***

        return packageData.eslintConfig;
    ***REMOVED*** catch (e) ***REMOVED***
        debug(`Error reading package.json file: $***REMOVED***filePath***REMOVED***`);
        e.message = `Cannot read config file: $***REMOVED***filePath***REMOVED***\nError: $***REMOVED***e.message***REMOVED***`;
        throw e;
    ***REMOVED***
***REMOVED***

/**
 * Creates an error to notify about a missing config to extend from.
 * @param ***REMOVED***string***REMOVED*** configName The name of the missing config.
 * @param ***REMOVED***string***REMOVED*** importerName The name of the config that imported the missing config
 * @returns ***REMOVED***Error***REMOVED*** The error object to throw
 * @private
 */
function configMissingError(configName, importerName) ***REMOVED***
    return Object.assign(
        new Error(`Failed to load config "$***REMOVED***configName***REMOVED***" to extend from.`),
        ***REMOVED***
            messageTemplate: "extend-config-missing",
            messageData: ***REMOVED*** configName, importerName ***REMOVED***
        ***REMOVED***
    );
***REMOVED***

/**
 * Loads a configuration file regardless of the source. Inspects the file path
 * to determine the correctly way to load the config file.
 * @param ***REMOVED***string***REMOVED*** filePath The path to the configuration.
 * @returns ***REMOVED***ConfigData|null***REMOVED*** The configuration information.
 * @private
 */
function loadConfigFile(filePath) ***REMOVED***
    switch (path.extname(filePath)) ***REMOVED***
        case ".js":
            return loadJSConfigFile(filePath);

        case ".json":
            if (path.basename(filePath) === "package.json") ***REMOVED***
                return loadPackageJSONConfigFile(filePath);
            ***REMOVED***
            return loadJSONConfigFile(filePath);

        case ".yaml":
        case ".yml":
            return loadYAMLConfigFile(filePath);

        default:
            return loadLegacyConfigFile(filePath);
    ***REMOVED***
***REMOVED***

/**
 * Write debug log.
 * @param ***REMOVED***string***REMOVED*** request The requested module name.
 * @param ***REMOVED***string***REMOVED*** relativeTo The file path to resolve the request relative to.
 * @param ***REMOVED***string***REMOVED*** filePath The resolved file path.
 * @returns ***REMOVED***void***REMOVED***
 */
function writeDebugLogForLoading(request, relativeTo, filePath) ***REMOVED***
    /* istanbul ignore next */
    if (debug.enabled) ***REMOVED***
        let nameAndVersion = null;

        try ***REMOVED***
            const packageJsonPath = ModuleResolver.resolve(
                `$***REMOVED***request***REMOVED***/package.json`,
                relativeTo
            );
            const ***REMOVED*** version = "unknown" ***REMOVED*** = require(packageJsonPath);

            nameAndVersion = `$***REMOVED***request***REMOVED***@$***REMOVED***version***REMOVED***`;
        ***REMOVED*** catch (error) ***REMOVED***
            debug("package.json was not found:", error.message);
            nameAndVersion = request;
        ***REMOVED***

        debug("Loaded: %s (%s)", nameAndVersion, filePath);
    ***REMOVED***
***REMOVED***

/**
 * Concatenate two config data.
 * @param ***REMOVED***IterableIterator<ConfigArrayElement>|null***REMOVED*** elements The config elements.
 * @param ***REMOVED***ConfigArray|null***REMOVED*** parentConfigArray The parent config array.
 * @returns ***REMOVED***ConfigArray***REMOVED*** The concatenated config array.
 */
function createConfigArray(elements, parentConfigArray) ***REMOVED***
    if (!elements) ***REMOVED***
        return parentConfigArray || new ConfigArray();
    ***REMOVED***
    const configArray = new ConfigArray(...elements);

    if (parentConfigArray && !configArray.isRoot()) ***REMOVED***
        configArray.unshift(...parentConfigArray);
    ***REMOVED***
    return configArray;
***REMOVED***

/**
 * Normalize a given plugin.
 * - Ensure the object to have four properties: configs, environments, processors, and rules.
 * - Ensure the object to not have other properties.
 * @param ***REMOVED***Plugin***REMOVED*** plugin The plugin to normalize.
 * @returns ***REMOVED***Plugin***REMOVED*** The normalized plugin.
 */
function normalizePlugin(plugin) ***REMOVED***
    return ***REMOVED***
        configs: plugin.configs || ***REMOVED******REMOVED***,
        environments: plugin.environments || ***REMOVED******REMOVED***,
        processors: plugin.processors || ***REMOVED******REMOVED***,
        rules: plugin.rules || ***REMOVED******REMOVED***
    ***REMOVED***;
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * The factory of `ConfigArray` objects.
 */
class ConfigArrayFactory ***REMOVED***

    /**
     * Initialize this instance.
     * @param ***REMOVED***ConfigArrayFactoryOptions***REMOVED*** [options] The map for additional plugins.
     */
    constructor(***REMOVED***
        additionalPluginPool = new Map(),
        cwd = process.cwd(),
        resolvePluginsRelativeTo = cwd
    ***REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
        internalSlotsMap.set(this, ***REMOVED*** additionalPluginPool, cwd, resolvePluginsRelativeTo: path.resolve(cwd, resolvePluginsRelativeTo) ***REMOVED***);
    ***REMOVED***

    /**
     * Create `ConfigArray` instance from a config data.
     * @param ***REMOVED***ConfigData|null***REMOVED*** configData The config data to create.
     * @param ***REMOVED***Object***REMOVED*** [options] The options.
     * @param ***REMOVED***string***REMOVED*** [options.filePath] The path to this config data.
     * @param ***REMOVED***string***REMOVED*** [options.name] The config name.
     * @param ***REMOVED***ConfigArray***REMOVED*** [options.parent] The parent config array.
     * @returns ***REMOVED***ConfigArray***REMOVED*** Loaded config.
     */
    create(configData, ***REMOVED*** filePath, name, parent ***REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
        return createConfigArray(
            configData
                ? this._normalizeConfigData(configData, filePath, name)
                : null,
            parent
        );
    ***REMOVED***

    /**
     * Load a config file.
     * @param ***REMOVED***string***REMOVED*** filePath The path to a config file.
     * @param ***REMOVED***Object***REMOVED*** [options] The options.
     * @param ***REMOVED***string***REMOVED*** [options.name] The config name.
     * @param ***REMOVED***ConfigArray***REMOVED*** [options.parent] The parent config array.
     * @returns ***REMOVED***ConfigArray***REMOVED*** Loaded config.
     */
    loadFile(filePath, ***REMOVED*** name, parent ***REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
        const ***REMOVED*** cwd ***REMOVED*** = internalSlotsMap.get(this);
        const absolutePath = path.resolve(cwd, filePath);

        return createConfigArray(
            this._loadConfigData(absolutePath, name),
            parent
        );
    ***REMOVED***

    /**
     * Load the config file on a given directory if exists.
     * @param ***REMOVED***string***REMOVED*** directoryPath The path to a directory.
     * @param ***REMOVED***Object***REMOVED*** [options] The options.
     * @param ***REMOVED***string***REMOVED*** [options.name] The config name.
     * @param ***REMOVED***ConfigArray***REMOVED*** [options.parent] The parent config array.
     * @returns ***REMOVED***ConfigArray***REMOVED*** Loaded config. An empty `ConfigArray` if any config doesn't exist.
     */
    loadInDirectory(directoryPath, ***REMOVED*** name, parent ***REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
        const ***REMOVED*** cwd ***REMOVED*** = internalSlotsMap.get(this);
        const absolutePath = path.resolve(cwd, directoryPath);

        return createConfigArray(
            this._loadConfigDataInDirectory(absolutePath, name),
            parent
        );
    ***REMOVED***

    /**
     * Load a given config file.
     * @param ***REMOVED***string***REMOVED*** filePath The path to a config file.
     * @param ***REMOVED***string***REMOVED*** name The config name.
     * @returns ***REMOVED***IterableIterator<ConfigArrayElement>***REMOVED*** Loaded config.
     * @private
     */
    _loadConfigData(filePath, name) ***REMOVED***
        return this._normalizeConfigData(
            loadConfigFile(filePath),
            filePath,
            name
        );
    ***REMOVED***

    /**
     * Load the config file in a given directory if exists.
     * @param ***REMOVED***string***REMOVED*** directoryPath The path to a directory.
     * @param ***REMOVED***string***REMOVED*** name The config name.
     * @returns ***REMOVED***IterableIterator<ConfigArrayElement> | null***REMOVED*** Loaded config. `null` if any config doesn't exist.
     * @private
     */
    _loadConfigDataInDirectory(directoryPath, name) ***REMOVED***
        for (const filename of configFilenames) ***REMOVED***
            const filePath = path.join(directoryPath, filename);

            if (fs.existsSync(filePath)) ***REMOVED***
                let configData;

                try ***REMOVED***
                    configData = loadConfigFile(filePath);
                ***REMOVED*** catch (error) ***REMOVED***
                    if (!error || error.code !== "ESLINT_CONFIG_FIELD_NOT_FOUND") ***REMOVED***
                        throw error;
                    ***REMOVED***
                ***REMOVED***

                if (configData) ***REMOVED***
                    debug(`Config file found: $***REMOVED***filePath***REMOVED***`);
                    return this._normalizeConfigData(configData, filePath, name);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        debug(`Config file not found on $***REMOVED***directoryPath***REMOVED***`);
        return null;
    ***REMOVED***

    /**
     * Normalize a given config to an array.
     * @param ***REMOVED***ConfigData***REMOVED*** configData The config data to normalize.
     * @param ***REMOVED***string|undefined***REMOVED*** providedFilePath The file path of this config.
     * @param ***REMOVED***string|undefined***REMOVED*** providedName The name of this config.
     * @returns ***REMOVED***IterableIterator<ConfigArrayElement>***REMOVED*** The normalized config.
     * @private
     */
    _normalizeConfigData(configData, providedFilePath, providedName) ***REMOVED***
        const ***REMOVED*** cwd ***REMOVED*** = internalSlotsMap.get(this);
        const filePath = providedFilePath
            ? path.resolve(cwd, providedFilePath)
            : "";
        const name = providedName || (filePath && path.relative(cwd, filePath));

        validateConfigSchema(configData, name || filePath);

        return this._normalizeObjectConfigData(configData, filePath, name);
    ***REMOVED***

    /**
     * Normalize a given config to an array.
     * @param ***REMOVED***ConfigData|OverrideConfigData***REMOVED*** configData The config data to normalize.
     * @param ***REMOVED***string***REMOVED*** filePath The file path of this config.
     * @param ***REMOVED***string***REMOVED*** name The name of this config.
     * @returns ***REMOVED***IterableIterator<ConfigArrayElement>***REMOVED*** The normalized config.
     * @private
     */
    *_normalizeObjectConfigData(configData, filePath, name) ***REMOVED***
        const ***REMOVED*** cwd ***REMOVED*** = internalSlotsMap.get(this);
        const ***REMOVED*** files, excludedFiles, ...configBody ***REMOVED*** = configData;
        const basePath = filePath ? path.dirname(filePath) : cwd;
        const criteria = OverrideTester.create(files, excludedFiles, basePath);
        const elements =
            this._normalizeObjectConfigDataBody(configBody, filePath, name);

        // Apply the criteria to every element.
        for (const element of elements) ***REMOVED***

            // Adopt the base path of the entry file (the outermost base path).
            if (element.criteria) ***REMOVED***
                element.criteria.basePath = basePath;
            ***REMOVED***

            /*
             * Merge the criteria; this is for only file extension processors in
             * `overrides` section for now.
             */
            element.criteria = OverrideTester.and(criteria, element.criteria);

            /*
             * Remove `root` property to ignore `root` settings which came from
             * `extends` in `overrides`.
             */
            if (element.criteria) ***REMOVED***
                element.root = void 0;
            ***REMOVED***

            yield element;
        ***REMOVED***
    ***REMOVED***

    /**
     * Normalize a given config to an array.
     * @param ***REMOVED***ConfigData***REMOVED*** configData The config data to normalize.
     * @param ***REMOVED***string***REMOVED*** filePath The file path of this config.
     * @param ***REMOVED***string***REMOVED*** name The name of this config.
     * @returns ***REMOVED***IterableIterator<ConfigArrayElement>***REMOVED*** The normalized config.
     * @private
     */
    *_normalizeObjectConfigDataBody(
        ***REMOVED***
            env,
            extends: extend,
            globals,
            noInlineConfig,
            parser: parserName,
            parserOptions,
            plugins: pluginList,
            processor,
            reportUnusedDisableDirectives,
            root,
            rules,
            settings,
            overrides: overrideList = []
        ***REMOVED***,
        filePath,
        name
    ) ***REMOVED***
        const extendList = Array.isArray(extend) ? extend : [extend];

        // Flatten `extends`.
        for (const extendName of extendList.filter(Boolean)) ***REMOVED***
            yield* this._loadExtends(extendName, filePath, name);
        ***REMOVED***

        // Load parser & plugins.
        const parser =
            parserName && this._loadParser(parserName, filePath, name);
        const plugins =
            pluginList && this._loadPlugins(pluginList, filePath, name);

        // Yield pseudo config data for file extension processors.
        if (plugins) ***REMOVED***
            yield* this._takeFileExtensionProcessors(plugins, filePath, name);
        ***REMOVED***

        // Yield the config data except `extends` and `overrides`.
        yield ***REMOVED***

            // Debug information.
            name,
            filePath,

            // Config data.
            criteria: null,
            env,
            globals,
            noInlineConfig,
            parser,
            parserOptions,
            plugins,
            processor,
            reportUnusedDisableDirectives,
            root,
            rules,
            settings
        ***REMOVED***;

        // Flatten `overries`.
        for (let i = 0; i < overrideList.length; ++i) ***REMOVED***
            yield* this._normalizeObjectConfigData(
                overrideList[i],
                filePath,
                `$***REMOVED***name***REMOVED***#overrides[$***REMOVED***i***REMOVED***]`
            );
        ***REMOVED***
    ***REMOVED***

    /**
     * Load configs of an element in `extends`.
     * @param ***REMOVED***string***REMOVED*** extendName The name of a base config.
     * @param ***REMOVED***string***REMOVED*** importerPath The file path which has the `extends` property.
     * @param ***REMOVED***string***REMOVED*** importerName The name of the config which has the `extends` property.
     * @returns ***REMOVED***IterableIterator<ConfigArrayElement>***REMOVED*** The normalized config.
     * @private
     */
    _loadExtends(extendName, importerPath, importerName) ***REMOVED***
        debug("Loading ***REMOVED***extends:%j***REMOVED*** relative to %s", extendName, importerPath);
        try ***REMOVED***
            if (extendName.startsWith("eslint:")) ***REMOVED***
                return this._loadExtendedBuiltInConfig(
                    extendName,
                    importerName
                );
            ***REMOVED***
            if (extendName.startsWith("plugin:")) ***REMOVED***
                return this._loadExtendedPluginConfig(
                    extendName,
                    importerPath,
                    importerName
                );
            ***REMOVED***
            return this._loadExtendedShareableConfig(
                extendName,
                importerPath,
                importerName
            );
        ***REMOVED*** catch (error) ***REMOVED***
            error.message += `\nReferenced from: $***REMOVED***importerPath || importerName***REMOVED***`;
            throw error;
        ***REMOVED***
    ***REMOVED***

    /**
     * Load configs of an element in `extends`.
     * @param ***REMOVED***string***REMOVED*** extendName The name of a base config.
     * @param ***REMOVED***string***REMOVED*** importerName The name of the config which has the `extends` property.
     * @returns ***REMOVED***IterableIterator<ConfigArrayElement>***REMOVED*** The normalized config.
     * @private
     */
    _loadExtendedBuiltInConfig(extendName, importerName) ***REMOVED***
        const name = `$***REMOVED***importerName***REMOVED*** » $***REMOVED***extendName***REMOVED***`;

        if (extendName === "eslint:recommended") ***REMOVED***
            return this._loadConfigData(eslintRecommendedPath, name);
        ***REMOVED***
        if (extendName === "eslint:all") ***REMOVED***
            return this._loadConfigData(eslintAllPath, name);
        ***REMOVED***

        throw configMissingError(extendName, importerName);
    ***REMOVED***

    /**
     * Load configs of an element in `extends`.
     * @param ***REMOVED***string***REMOVED*** extendName The name of a base config.
     * @param ***REMOVED***string***REMOVED*** importerPath The file path which has the `extends` property.
     * @param ***REMOVED***string***REMOVED*** importerName The name of the config which has the `extends` property.
     * @returns ***REMOVED***IterableIterator<ConfigArrayElement>***REMOVED*** The normalized config.
     * @private
     */
    _loadExtendedPluginConfig(extendName, importerPath, importerName) ***REMOVED***
        const slashIndex = extendName.lastIndexOf("/");
        const pluginName = extendName.slice("plugin:".length, slashIndex);
        const configName = extendName.slice(slashIndex + 1);

        if (isFilePath(pluginName)) ***REMOVED***
            throw new Error("'extends' cannot use a file path for plugins.");
        ***REMOVED***

        const plugin = this._loadPlugin(pluginName, importerPath, importerName);
        const configData =
            plugin.definition &&
            plugin.definition.configs[configName];

        if (configData) ***REMOVED***
            return this._normalizeConfigData(
                configData,
                plugin.filePath,
                `$***REMOVED***importerName***REMOVED*** » plugin:$***REMOVED***plugin.id***REMOVED***/$***REMOVED***configName***REMOVED***`
            );
        ***REMOVED***

        throw plugin.error || configMissingError(extendName, importerPath);
    ***REMOVED***

    /**
     * Load configs of an element in `extends`.
     * @param ***REMOVED***string***REMOVED*** extendName The name of a base config.
     * @param ***REMOVED***string***REMOVED*** importerPath The file path which has the `extends` property.
     * @param ***REMOVED***string***REMOVED*** importerName The name of the config which has the `extends` property.
     * @returns ***REMOVED***IterableIterator<ConfigArrayElement>***REMOVED*** The normalized config.
     * @private
     */
    _loadExtendedShareableConfig(extendName, importerPath, importerName) ***REMOVED***
        const ***REMOVED*** cwd ***REMOVED*** = internalSlotsMap.get(this);
        const relativeTo = importerPath || path.join(cwd, "__placeholder__.js");
        let request;

        if (isFilePath(extendName)) ***REMOVED***
            request = extendName;
        ***REMOVED*** else if (extendName.startsWith(".")) ***REMOVED***
            request = `./$***REMOVED***extendName***REMOVED***`; // For backward compatibility. A ton of tests depended on this behavior.
        ***REMOVED*** else ***REMOVED***
            request = naming.normalizePackageName(
                extendName,
                "eslint-config"
            );
        ***REMOVED***

        let filePath;

        try ***REMOVED***
            filePath = ModuleResolver.resolve(request, relativeTo);
        ***REMOVED*** catch (error) ***REMOVED***
            /* istanbul ignore else */
            if (error && error.code === "MODULE_NOT_FOUND") ***REMOVED***
                throw configMissingError(extendName, importerPath);
            ***REMOVED***
            throw error;
        ***REMOVED***

        writeDebugLogForLoading(request, relativeTo, filePath);
        return this._loadConfigData(filePath, `$***REMOVED***importerName***REMOVED*** » $***REMOVED***request***REMOVED***`);
    ***REMOVED***

    /**
     * Load given plugins.
     * @param ***REMOVED***string[]***REMOVED*** names The plugin names to load.
     * @param ***REMOVED***string***REMOVED*** importerPath The path to a config file that imports it. This is just a debug info.
     * @param ***REMOVED***string***REMOVED*** importerName The name of a config file that imports it. This is just a debug info.
     * @returns ***REMOVED***Record<string,DependentPlugin>***REMOVED*** The loaded parser.
     * @private
     */
    _loadPlugins(names, importerPath, importerName) ***REMOVED***
        return names.reduce((map, name) => ***REMOVED***
            if (isFilePath(name)) ***REMOVED***
                throw new Error("Plugins array cannot includes file paths.");
            ***REMOVED***
            const plugin = this._loadPlugin(name, importerPath, importerName);

            map[plugin.id] = plugin;

            return map;
        ***REMOVED***, ***REMOVED******REMOVED***);
    ***REMOVED***

    /**
     * Load a given parser.
     * @param ***REMOVED***string***REMOVED*** nameOrPath The package name or the path to a parser file.
     * @param ***REMOVED***string***REMOVED*** importerPath The path to a config file that imports it.
     * @param ***REMOVED***string***REMOVED*** importerName The name of a config file that imports it. This is just a debug info.
     * @returns ***REMOVED***DependentParser***REMOVED*** The loaded parser.
     */
    _loadParser(nameOrPath, importerPath, importerName) ***REMOVED***
        debug("Loading parser %j from %s", nameOrPath, importerPath);

        const ***REMOVED*** cwd ***REMOVED*** = internalSlotsMap.get(this);
        const relativeTo = importerPath || path.join(cwd, "__placeholder__.js");

        try ***REMOVED***
            const filePath = ModuleResolver.resolve(nameOrPath, relativeTo);

            writeDebugLogForLoading(nameOrPath, relativeTo, filePath);

            return new ConfigDependency(***REMOVED***
                definition: require(filePath),
                filePath,
                id: nameOrPath,
                importerName,
                importerPath
            ***REMOVED***);
        ***REMOVED*** catch (error) ***REMOVED***

            // If the parser name is "espree", load the espree of ESLint.
            if (nameOrPath === "espree") ***REMOVED***
                debug("Fallback espree.");
                return new ConfigDependency(***REMOVED***
                    definition: require("espree"),
                    filePath: require.resolve("espree"),
                    id: nameOrPath,
                    importerName,
                    importerPath
                ***REMOVED***);
            ***REMOVED***

            debug("Failed to load parser '%s' declared in '%s'.", nameOrPath, importerName);
            error.message = `Failed to load parser '$***REMOVED***nameOrPath***REMOVED***' declared in '$***REMOVED***importerName***REMOVED***': $***REMOVED***error.message***REMOVED***`;

            return new ConfigDependency(***REMOVED***
                error,
                id: nameOrPath,
                importerName,
                importerPath
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***

    /**
     * Load a given plugin.
     * @param ***REMOVED***string***REMOVED*** name The plugin name to load.
     * @param ***REMOVED***string***REMOVED*** importerPath The path to a config file that imports it. This is just a debug info.
     * @param ***REMOVED***string***REMOVED*** importerName The name of a config file that imports it. This is just a debug info.
     * @returns ***REMOVED***DependentPlugin***REMOVED*** The loaded plugin.
     * @private
     */
    _loadPlugin(name, importerPath, importerName) ***REMOVED***
        debug("Loading plugin %j from %s", name, importerPath);

        const ***REMOVED*** additionalPluginPool, resolvePluginsRelativeTo ***REMOVED*** = internalSlotsMap.get(this);
        const request = naming.normalizePackageName(name, "eslint-plugin");
        const id = naming.getShorthandName(request, "eslint-plugin");
        const relativeTo = path.join(resolvePluginsRelativeTo, "__placeholder__.js");

        if (name.match(/\s+/u)) ***REMOVED***
            const error = Object.assign(
                new Error(`Whitespace found in plugin name '$***REMOVED***name***REMOVED***'`),
                ***REMOVED***
                    messageTemplate: "whitespace-found",
                    messageData: ***REMOVED*** pluginName: request ***REMOVED***
                ***REMOVED***
            );

            return new ConfigDependency(***REMOVED***
                error,
                id,
                importerName,
                importerPath
            ***REMOVED***);
        ***REMOVED***

        // Check for additional pool.
        const plugin =
            additionalPluginPool.get(request) ||
            additionalPluginPool.get(id);

        if (plugin) ***REMOVED***
            return new ConfigDependency(***REMOVED***
                definition: normalizePlugin(plugin),
                filePath: importerPath,
                id,
                importerName,
                importerPath
            ***REMOVED***);
        ***REMOVED***

        let filePath;
        let error;

        try ***REMOVED***
            filePath = ModuleResolver.resolve(request, relativeTo);
        ***REMOVED*** catch (resolveError) ***REMOVED***
            error = resolveError;
            /* istanbul ignore else */
            if (error && error.code === "MODULE_NOT_FOUND") ***REMOVED***
                error.messageTemplate = "plugin-missing";
                error.messageData = ***REMOVED***
                    pluginName: request,
                    resolvePluginsRelativeTo,
                    importerName
                ***REMOVED***;
            ***REMOVED***
        ***REMOVED***

        if (filePath) ***REMOVED***
            try ***REMOVED***
                writeDebugLogForLoading(request, relativeTo, filePath);
                return new ConfigDependency(***REMOVED***
                    definition: normalizePlugin(require(filePath)),
                    filePath,
                    id,
                    importerName,
                    importerPath
                ***REMOVED***);
            ***REMOVED*** catch (loadError) ***REMOVED***
                error = loadError;
            ***REMOVED***
        ***REMOVED***

        debug("Failed to load plugin '%s' declared in '%s'.", name, importerName);
        error.message = `Failed to load plugin '$***REMOVED***name***REMOVED***' declared in '$***REMOVED***importerName***REMOVED***': $***REMOVED***error.message***REMOVED***`;
        return new ConfigDependency(***REMOVED***
            error,
            id,
            importerName,
            importerPath
        ***REMOVED***);
    ***REMOVED***

    /**
     * Take file expression processors as config array elements.
     * @param ***REMOVED***Record<string,DependentPlugin>***REMOVED*** plugins The plugin definitions.
     * @param ***REMOVED***string***REMOVED*** filePath The file path of this config.
     * @param ***REMOVED***string***REMOVED*** name The name of this config.
     * @returns ***REMOVED***IterableIterator<ConfigArrayElement>***REMOVED*** The config array elements of file expression processors.
     * @private
     */
    *_takeFileExtensionProcessors(plugins, filePath, name) ***REMOVED***
        for (const pluginId of Object.keys(plugins)) ***REMOVED***
            const processors =
                plugins[pluginId] &&
                plugins[pluginId].definition &&
                plugins[pluginId].definition.processors;

            if (!processors) ***REMOVED***
                continue;
            ***REMOVED***

            for (const processorId of Object.keys(processors)) ***REMOVED***
                if (processorId.startsWith(".")) ***REMOVED***
                    yield* this._normalizeObjectConfigData(
                        ***REMOVED***
                            files: [`*$***REMOVED***processorId***REMOVED***`],
                            processor: `$***REMOVED***pluginId***REMOVED***/$***REMOVED***processorId***REMOVED***`
                        ***REMOVED***,
                        filePath,
                        `$***REMOVED***name***REMOVED***#processors["$***REMOVED***pluginId***REMOVED***/$***REMOVED***processorId***REMOVED***"]`
                    );
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
***REMOVED***

module.exports = ***REMOVED*** ConfigArrayFactory ***REMOVED***;
