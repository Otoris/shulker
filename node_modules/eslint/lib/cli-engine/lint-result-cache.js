/**
 * @fileoverview Utility for caching lint results.
 * @author Kevin Partington
 */
"use strict";

//-----------------------------------------------------------------------------
// Requirements
//-----------------------------------------------------------------------------

const assert = require("assert");
const fs = require("fs");
const fileEntryCache = require("file-entry-cache");
const stringify = require("json-stable-stringify-without-jsonify");
const pkg = require("../../package.json");
const hash = require("./hash");

//-----------------------------------------------------------------------------
// Helpers
//-----------------------------------------------------------------------------

const configHashCache = new WeakMap();

/**
 * Calculates the hash of the config
 * @param ***REMOVED***ConfigArray***REMOVED*** config The config.
 * @returns ***REMOVED***string***REMOVED*** The hash of the config
 */
function hashOfConfigFor(config) ***REMOVED***
    if (!configHashCache.has(config)) ***REMOVED***
        configHashCache.set(config, hash(`$***REMOVED***pkg.version***REMOVED***_$***REMOVED***stringify(config)***REMOVED***`));
    ***REMOVED***

    return configHashCache.get(config);
***REMOVED***

//-----------------------------------------------------------------------------
// Public Interface
//-----------------------------------------------------------------------------

/**
 * Lint result cache. This wraps around the file-entry-cache module,
 * transparently removing properties that are difficult or expensive to
 * serialize and adding them back in on retrieval.
 */
class LintResultCache ***REMOVED***

    /**
     * Creates a new LintResultCache instance.
     * @constructor
     * @param ***REMOVED***string***REMOVED*** cacheFileLocation The cache file location.
     *   configuration lookup by file path).
     */
    constructor(cacheFileLocation) ***REMOVED***
        assert(cacheFileLocation, "Cache file location is required");

        this.fileEntryCache = fileEntryCache.create(cacheFileLocation);
    ***REMOVED***

    /**
     * Retrieve cached lint results for a given file path, if present in the
     * cache. If the file is present and has not been changed, rebuild any
     * missing result information.
     * @param ***REMOVED***string***REMOVED*** filePath The file for which to retrieve lint results.
     * @param ***REMOVED***ConfigArray***REMOVED*** config The config of the file.
     * @returns ***REMOVED***Object|null***REMOVED*** The rebuilt lint results, or null if the file is
     *   changed or not in the filesystem.
     */
    getCachedLintResults(filePath, config) ***REMOVED***

        /*
         * Cached lint results are valid if and only if:
         * 1. The file is present in the filesystem
         * 2. The file has not changed since the time it was previously linted
         * 3. The ESLint configuration has not changed since the time the file
         *    was previously linted
         * If any of these are not true, we will not reuse the lint results.
         */

        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);
        const hashOfConfig = hashOfConfigFor(config);
        const changed = fileDescriptor.changed || fileDescriptor.meta.hashOfConfig !== hashOfConfig;

        if (fileDescriptor.notFound || changed) ***REMOVED***
            return null;
        ***REMOVED***

        // If source is present but null, need to reread the file from the filesystem.
        if (fileDescriptor.meta.results && fileDescriptor.meta.results.source === null) ***REMOVED***
            fileDescriptor.meta.results.source = fs.readFileSync(filePath, "utf-8");
        ***REMOVED***

        return fileDescriptor.meta.results;
    ***REMOVED***

    /**
     * Set the cached lint results for a given file path, after removing any
     * information that will be both unnecessary and difficult to serialize.
     * Avoids caching results with an "output" property (meaning fixes were
     * applied), to prevent potentially incorrect results if fixes are not
     * written to disk.
     * @param ***REMOVED***string***REMOVED*** filePath The file for which to set lint results.
     * @param ***REMOVED***ConfigArray***REMOVED*** config The config of the file.
     * @param ***REMOVED***Object***REMOVED*** result The lint result to be set for the file.
     * @returns ***REMOVED***void***REMOVED***
     */
    setCachedLintResults(filePath, config, result) ***REMOVED***
        if (result && Object.prototype.hasOwnProperty.call(result, "output")) ***REMOVED***
            return;
        ***REMOVED***

        const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);

        if (fileDescriptor && !fileDescriptor.notFound) ***REMOVED***

            // Serialize the result, except that we want to remove the file source if present.
            const resultToSerialize = Object.assign(***REMOVED******REMOVED***, result);

            /*
             * Set result.source to null.
             * In `getCachedLintResults`, if source is explicitly null, we will
             * read the file from the filesystem to set the value again.
             */
            if (Object.prototype.hasOwnProperty.call(resultToSerialize, "source")) ***REMOVED***
                resultToSerialize.source = null;
            ***REMOVED***

            fileDescriptor.meta.results = resultToSerialize;
            fileDescriptor.meta.hashOfConfig = hashOfConfigFor(config);
        ***REMOVED***
    ***REMOVED***

    /**
     * Persists the in-memory cache to disk.
     * @returns ***REMOVED***void***REMOVED***
     */
    reconcile() ***REMOVED***
        this.fileEntryCache.reconcile();
    ***REMOVED***
***REMOVED***

module.exports = LintResultCache;
