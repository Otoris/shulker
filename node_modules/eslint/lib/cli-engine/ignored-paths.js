/**
 * @fileoverview Responsible for loading ignore config files and managing ignore patterns
 * @author Jonathan Rajavuori
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const fs = require("fs"),
    path = require("path"),
    ignore = require("ignore");

const debug = require("debug")("eslint:ignored-paths");

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const ESLINT_IGNORE_FILENAME = ".eslintignore";

/**
 * Adds `"*"` at the end of `"node_modules/"`,
 * so that subtle directories could be re-included by .gitignore patterns
 * such as `"!node_modules/should_not_ignored"`
 */
const DEFAULT_IGNORE_DIRS = [
    "/node_modules/*",
    "/bower_components/*"
];
const DEFAULT_OPTIONS = ***REMOVED***
    dotfiles: false,
    cwd: process.cwd()
***REMOVED***;

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Find a file in the current directory.
 * @param ***REMOVED***string***REMOVED*** cwd Current working directory
 * @param ***REMOVED***string***REMOVED*** name File name
 * @returns ***REMOVED***string***REMOVED*** Path of ignore file or an empty string.
 */
function findFile(cwd, name) ***REMOVED***
    const ignoreFilePath = path.resolve(cwd, name);

    return fs.existsSync(ignoreFilePath) && fs.statSync(ignoreFilePath).isFile() ? ignoreFilePath : "";
***REMOVED***

/**
 * Find an ignore file in the current directory.
 * @param ***REMOVED***string***REMOVED*** cwd Current working directory
 * @returns ***REMOVED***string***REMOVED*** Path of ignore file or an empty string.
 */
function findIgnoreFile(cwd) ***REMOVED***
    return findFile(cwd, ESLINT_IGNORE_FILENAME);
***REMOVED***

/**
 * Find an package.json file in the current directory.
 * @param ***REMOVED***string***REMOVED*** cwd Current working directory
 * @returns ***REMOVED***string***REMOVED*** Path of package.json file or an empty string.
 */
function findPackageJSONFile(cwd) ***REMOVED***
    return findFile(cwd, "package.json");
***REMOVED***

/**
 * Merge options with defaults
 * @param ***REMOVED***Object***REMOVED*** options Options to merge with DEFAULT_OPTIONS constant
 * @returns ***REMOVED***Object***REMOVED*** Merged options
 */
function mergeDefaultOptions(options) ***REMOVED***
    return Object.assign(***REMOVED******REMOVED***, DEFAULT_OPTIONS, options);
***REMOVED***

/* eslint-disable valid-jsdoc */
/**
 * Normalize the path separators in a given string.
 * On Windows environment, this replaces `\` by `/`.
 * Otherwrise, this does nothing.
 * @param ***REMOVED***string***REMOVED*** str The path string to normalize.
 * @returns ***REMOVED***string***REMOVED*** The normalized path.
 */
const normalizePathSeps = path.sep === "/"
    ? (str => str)
    : ((seps, str) => str.replace(seps, "/")).bind(null, new RegExp(`\\$***REMOVED***path.sep***REMOVED***`, "gu"));
/* eslint-enable valid-jsdoc */

/**
 * Converts a glob pattern to a new glob pattern relative to a different directory
 * @param ***REMOVED***string***REMOVED*** globPattern The glob pattern, relative the the old base directory
 * @param ***REMOVED***string***REMOVED*** relativePathToOldBaseDir A relative path from the new base directory to the old one
 * @returns ***REMOVED***string***REMOVED*** A glob pattern relative to the new base directory
 */
function relativize(globPattern, relativePathToOldBaseDir) ***REMOVED***
    if (relativePathToOldBaseDir === "") ***REMOVED***
        return globPattern;
    ***REMOVED***

    const prefix = globPattern.startsWith("!") ? "!" : "";
    const globWithoutPrefix = globPattern.replace(/^!/u, "");

    if (globWithoutPrefix.startsWith("/")) ***REMOVED***
        return `$***REMOVED***prefix***REMOVED***/$***REMOVED***normalizePathSeps(relativePathToOldBaseDir)***REMOVED***$***REMOVED***globWithoutPrefix***REMOVED***`;
    ***REMOVED***

    return globPattern;
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * IgnoredPaths class
 */
class IgnoredPaths ***REMOVED***

    /**
     * @param ***REMOVED***Object***REMOVED*** providedOptions object containing 'ignore', 'ignorePath' and 'patterns' properties
     */
    constructor(providedOptions) ***REMOVED***
        const options = mergeDefaultOptions(providedOptions);

        this.cache = ***REMOVED******REMOVED***;

        this.defaultPatterns = [].concat(DEFAULT_IGNORE_DIRS, options.patterns || []);

        this.ignoreFileDir = options.ignore !== false && options.ignorePath
            ? path.dirname(path.resolve(options.cwd, options.ignorePath))
            : options.cwd;
        this.options = options;
        this._baseDir = null;

        this.ig = ***REMOVED***
            custom: ignore(),
            default: ignore()
        ***REMOVED***;

        this.defaultPatterns.forEach(pattern => this.addPatternRelativeToCwd(this.ig.default, pattern));
        if (options.dotfiles !== true) ***REMOVED***

            /*
             * ignore files beginning with a dot, but not files in a parent or
             * ancestor directory (which in relative format will begin with `../`).
             */
            this.addPatternRelativeToCwd(this.ig.default, ".*");
            this.addPatternRelativeToCwd(this.ig.default, "!../");
        ***REMOVED***

        /*
         * Add a way to keep track of ignored files.  This was present in node-ignore
         * 2.x, but dropped for now as of 3.0.10.
         */
        this.ig.custom.ignoreFiles = [];
        this.ig.default.ignoreFiles = [];

        if (options.ignore !== false) ***REMOVED***
            let ignorePath;

            if (options.ignorePath) ***REMOVED***
                debug("Using specific ignore file");

                try ***REMOVED***
                    const stat = fs.statSync(options.ignorePath);

                    if (!stat.isFile()) ***REMOVED***
                        throw new Error(`$***REMOVED***options.ignorePath***REMOVED*** is not a file`);
                    ***REMOVED***
                    ignorePath = options.ignorePath;
                ***REMOVED*** catch (e) ***REMOVED***
                    e.message = `Cannot read ignore file: $***REMOVED***options.ignorePath***REMOVED***\nError: $***REMOVED***e.message***REMOVED***`;
                    throw e;
                ***REMOVED***
            ***REMOVED*** else ***REMOVED***
                debug(`Looking for ignore file in $***REMOVED***options.cwd***REMOVED***`);
                ignorePath = findIgnoreFile(options.cwd);

                try ***REMOVED***
                    fs.statSync(ignorePath);
                    debug(`Loaded ignore file $***REMOVED***ignorePath***REMOVED***`);
                ***REMOVED*** catch (e) ***REMOVED***
                    debug("Could not find ignore file in cwd");
                ***REMOVED***
            ***REMOVED***

            if (ignorePath) ***REMOVED***
                debug(`Adding $***REMOVED***ignorePath***REMOVED***`);
                this.addIgnoreFile(this.ig.custom, ignorePath);
                this.addIgnoreFile(this.ig.default, ignorePath);
            ***REMOVED*** else ***REMOVED***
                try ***REMOVED***

                    // if the ignoreFile does not exist, check package.json for eslintIgnore
                    const packageJSONPath = findPackageJSONFile(options.cwd);

                    if (packageJSONPath) ***REMOVED***
                        let packageJSONOptions;

                        try ***REMOVED***
                            packageJSONOptions = JSON.parse(fs.readFileSync(packageJSONPath, "utf8"));
                        ***REMOVED*** catch (e) ***REMOVED***
                            debug("Could not read package.json file to check eslintIgnore property");
                            e.messageTemplate = "failed-to-read-json";
                            e.messageData = ***REMOVED***
                                path: packageJSONPath,
                                message: e.message
                            ***REMOVED***;
                            throw e;
                        ***REMOVED***

                        if (packageJSONOptions.eslintIgnore) ***REMOVED***
                            if (Array.isArray(packageJSONOptions.eslintIgnore)) ***REMOVED***
                                packageJSONOptions.eslintIgnore.forEach(pattern => ***REMOVED***
                                    this.addPatternRelativeToIgnoreFile(this.ig.custom, pattern);
                                    this.addPatternRelativeToIgnoreFile(this.ig.default, pattern);
                                ***REMOVED***);
                            ***REMOVED*** else ***REMOVED***
                                throw new TypeError("Package.json eslintIgnore property requires an array of paths");
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED*** catch (e) ***REMOVED***
                    debug("Could not find package.json to check eslintIgnore property");
                    throw e;
                ***REMOVED***
            ***REMOVED***

            if (options.ignorePattern) ***REMOVED***
                this.addPatternRelativeToCwd(this.ig.custom, options.ignorePattern);
                this.addPatternRelativeToCwd(this.ig.default, options.ignorePattern);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    /*
     * If `ignoreFileDir` is a subdirectory of `cwd`, all paths will be normalized to be relative to `cwd`.
     * Otherwise, all paths will be normalized to be relative to `ignoreFileDir`.
     * This ensures that the final normalized ignore rule will not contain `..`, which is forbidden in
     * ignore rules.
     */

    addPatternRelativeToCwd(ig, pattern) ***REMOVED***
        const baseDir = this.getBaseDir();
        const cookedPattern = baseDir === this.options.cwd
            ? pattern
            : relativize(pattern, path.relative(baseDir, this.options.cwd));

        ig.addPattern(cookedPattern);
        debug("addPatternRelativeToCwd:\n  original = %j\n  cooked   = %j", pattern, cookedPattern);
    ***REMOVED***

    addPatternRelativeToIgnoreFile(ig, pattern) ***REMOVED***
        const baseDir = this.getBaseDir();
        const cookedPattern = baseDir === this.ignoreFileDir
            ? pattern
            : relativize(pattern, path.relative(baseDir, this.ignoreFileDir));

        ig.addPattern(cookedPattern);
        debug("addPatternRelativeToIgnoreFile:\n  original = %j\n  cooked   = %j", pattern, cookedPattern);
    ***REMOVED***

    // Detect the common ancestor
    getBaseDir() ***REMOVED***
        if (!this._baseDir) ***REMOVED***
            const a = path.resolve(this.options.cwd);
            const b = path.resolve(this.ignoreFileDir);
            let lastSepPos = 0;

            // Set the shorter one (it's the common ancestor if one includes the other).
            this._baseDir = a.length < b.length ? a : b;

            // Set the common ancestor.
            for (let i = 0; i < a.length && i < b.length; ++i) ***REMOVED***
                if (a[i] !== b[i]) ***REMOVED***
                    this._baseDir = a.slice(0, lastSepPos);
                    break;
                ***REMOVED***
                if (a[i] === path.sep) ***REMOVED***
                    lastSepPos = i;
                ***REMOVED***
            ***REMOVED***

            // If it's only Windows drive letter, it needs \
            if (/^[A-Z]:$/u.test(this._baseDir)) ***REMOVED***
                this._baseDir += "\\";
            ***REMOVED***

            debug("baseDir = %j", this._baseDir);
        ***REMOVED***
        return this._baseDir;
    ***REMOVED***

    /**
     * read ignore filepath
     * @param ***REMOVED***string***REMOVED*** filePath, file to add to ig
     * @returns ***REMOVED***Array***REMOVED*** raw ignore rules
     */
    readIgnoreFile(filePath) ***REMOVED***
        if (typeof this.cache[filePath] === "undefined") ***REMOVED***
            this.cache[filePath] = fs.readFileSync(filePath, "utf8").split(/\r?\n/gu).filter(Boolean);
        ***REMOVED***
        return this.cache[filePath];
    ***REMOVED***

    /**
     * add ignore file to node-ignore instance
     * @param ***REMOVED***Object***REMOVED*** ig instance of node-ignore
     * @param ***REMOVED***string***REMOVED*** filePath file to add to ig
     * @returns ***REMOVED***void***REMOVED***
     */
    addIgnoreFile(ig, filePath) ***REMOVED***
        ig.ignoreFiles.push(filePath);
        this
            .readIgnoreFile(filePath)
            .forEach(ignoreRule => this.addPatternRelativeToIgnoreFile(ig, ignoreRule));
    ***REMOVED***

    /**
     * Determine whether a file path is included in the default or custom ignore patterns
     * @param ***REMOVED***string***REMOVED*** filepath Path to check
     * @param ***REMOVED***string***REMOVED*** [category=undefined] check 'default', 'custom' or both (undefined)
     * @returns ***REMOVED***boolean***REMOVED*** true if the file path matches one or more patterns, false otherwise
     */
    contains(filepath, category) ***REMOVED***
        const isDir = filepath.endsWith(path.sep) ||
            (path.sep === "\\" && filepath.endsWith("/"));
        let result = false;
        const basePath = this.getBaseDir();
        const absolutePath = path.resolve(this.options.cwd, filepath);
        let relativePath = path.relative(basePath, absolutePath);

        if (relativePath) ***REMOVED***
            if (isDir) ***REMOVED***
                relativePath += path.sep;
            ***REMOVED***
            if (typeof category === "undefined") ***REMOVED***
                result =
                    (this.ig.default.filter([relativePath]).length === 0) ||
                    (this.ig.custom.filter([relativePath]).length === 0);
            ***REMOVED*** else ***REMOVED***
                result =
                    (this.ig[category].filter([relativePath]).length === 0);
            ***REMOVED***
        ***REMOVED***
        debug("contains:");
        debug("  target   = %j", filepath);
        debug("  base     = %j", basePath);
        debug("  relative = %j", relativePath);
        debug("  result   = %j", result);

        return result;

    ***REMOVED***
***REMOVED***

module.exports = ***REMOVED*** IgnoredPaths ***REMOVED***;
