/**
 * @fileoverview `FileEnumerator` class.
 *
 * `FileEnumerator` class has two responsibilities:
 *
 * 1. Find target files by processing glob patterns.
 * 2. Tie each target file and appropriate configuration.
 *
 * It provies a method:
 *
 * - `iterateFiles(patterns)`
 *     Iterate files which are matched by given patterns together with the
 *     corresponded configuration. This is for `CLIEngine#executeOnFiles()`.
 *     While iterating files, it loads the configuration file of each directory
 *     before iterate files on the directory, so we can use the configuration
 *     files to determine target files.
 *
 * @example
 * const enumerator = new FileEnumerator();
 * const linter = new Linter();
 *
 * for (const ***REMOVED*** config, filePath ***REMOVED*** of enumerator.iterateFiles(["*.js"])) ***REMOVED***
 *     const code = fs.readFileSync(filePath, "utf8");
 *     const messages = linter.verify(code, config, filePath);
 *
 *     console.log(messages);
 * ***REMOVED***
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const fs = require("fs");
const path = require("path");
const getGlobParent = require("glob-parent");
const isGlob = require("is-glob");
const ***REMOVED*** escapeRegExp ***REMOVED*** = require("lodash");
const ***REMOVED*** Minimatch ***REMOVED*** = require("minimatch");
const ***REMOVED*** CascadingConfigArrayFactory ***REMOVED*** = require("./cascading-config-array-factory");
const ***REMOVED*** IgnoredPaths ***REMOVED*** = require("./ignored-paths");
const debug = require("debug")("eslint:file-enumerator");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const minimatchOpts = ***REMOVED*** dot: true, matchBase: true ***REMOVED***;
const dotfilesPattern = /(?:(?:^\.)|(?:[/\\]\.))[^/\\.].*/u;
const NONE = 0;
const IGNORED_SILENTLY = 1;
const IGNORED = 2;

// For VSCode intellisense
/** @typedef ***REMOVED***ReturnType<CascadingConfigArrayFactory["getConfigArrayForFile"]>***REMOVED*** ConfigArray */

/**
 * @typedef ***REMOVED***Object***REMOVED*** FileEnumeratorOptions
 * @property ***REMOVED***CascadingConfigArrayFactory***REMOVED*** [configArrayFactory] The factory for config arrays.
 * @property ***REMOVED***string***REMOVED*** [cwd] The base directory to start lookup.
 * @property ***REMOVED***string[]***REMOVED*** [extensions] The extensions to match files for directory patterns.
 * @property ***REMOVED***boolean***REMOVED*** [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.
 * @property ***REMOVED***boolean***REMOVED*** [ignore] The flag to check ignored files.
 * @property ***REMOVED***IgnoredPaths***REMOVED*** [ignoredPaths] The ignored paths.
 * @property ***REMOVED***string[]***REMOVED*** [rulePaths] The value of `--rulesdir` option.
 */

/**
 * @typedef ***REMOVED***Object***REMOVED*** FileAndConfig
 * @property ***REMOVED***string***REMOVED*** filePath The path to a target file.
 * @property ***REMOVED***ConfigArray***REMOVED*** config The config entries of that file.
 * @property ***REMOVED***boolean***REMOVED*** ignored If `true` then this file should be ignored and warned because it was directly specified.
 */

/**
 * @typedef ***REMOVED***Object***REMOVED*** FileEntry
 * @property ***REMOVED***string***REMOVED*** filePath The path to a target file.
 * @property ***REMOVED***ConfigArray***REMOVED*** config The config entries of that file.
 * @property ***REMOVED***NONE|IGNORED_SILENTLY|IGNORED***REMOVED*** flag The flag.
 * - `NONE` means the file is a target file.
 * - `IGNORED_SILENTLY` means the file should be ignored silently.
 * - `IGNORED` means the file should be ignored and warned because it was directly specified.
 */

/**
 * @typedef ***REMOVED***Object***REMOVED*** FileEnumeratorInternalSlots
 * @property ***REMOVED***CascadingConfigArrayFactory***REMOVED*** configArrayFactory The factory for config arrays.
 * @property ***REMOVED***string***REMOVED*** cwd The base directory to start lookup.
 * @property ***REMOVED***RegExp***REMOVED*** extensionRegExp The RegExp to test if a string ends with specific file extensions.
 * @property ***REMOVED***boolean***REMOVED*** globInputPaths Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.
 * @property ***REMOVED***boolean***REMOVED*** ignoreFlag The flag to check ignored files.
 * @property ***REMOVED***IgnoredPaths***REMOVED*** ignoredPathsWithDotfiles The ignored paths but don't include dot files.
 * @property ***REMOVED***IgnoredPaths***REMOVED*** ignoredPaths The ignored paths.
 */

/** @type ***REMOVED***WeakMap<FileEnumerator, FileEnumeratorInternalSlots>***REMOVED*** */
const internalSlotsMap = new WeakMap();

/**
 * Check if a string is a glob pattern or not.
 * @param ***REMOVED***string***REMOVED*** pattern A glob pattern.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the string is a glob pattern.
 */
function isGlobPattern(pattern) ***REMOVED***
    return isGlob(path.sep === "\\" ? pattern.replace(/\\/gu, "/") : pattern);
***REMOVED***

/**
 * Get stats of a given path.
 * @param ***REMOVED***string***REMOVED*** filePath The path to target file.
 * @returns ***REMOVED***fs.Stats|null***REMOVED*** The stats.
 * @private
 */
function statSafeSync(filePath) ***REMOVED***
    try ***REMOVED***
        return fs.statSync(filePath);
    ***REMOVED*** catch (error) ***REMOVED***
        /* istanbul ignore next */
        if (error.code !== "ENOENT") ***REMOVED***
            throw error;
        ***REMOVED***
        return null;
    ***REMOVED***
***REMOVED***

/**
 * Get filenames in a given path to a directory.
 * @param ***REMOVED***string***REMOVED*** directoryPath The path to target directory.
 * @returns ***REMOVED***string[]***REMOVED*** The filenames.
 * @private
 */
function readdirSafeSync(directoryPath) ***REMOVED***
    try ***REMOVED***
        return fs.readdirSync(directoryPath);
    ***REMOVED*** catch (error) ***REMOVED***
        /* istanbul ignore next */
        if (error.code !== "ENOENT") ***REMOVED***
            throw error;
        ***REMOVED***
        return [];
    ***REMOVED***
***REMOVED***

/**
 * The error type when no files match a glob.
 */
class NoFilesFoundError extends Error ***REMOVED***

    /**
     * @param ***REMOVED***string***REMOVED*** pattern - The glob pattern which was not found.
     * @param ***REMOVED***boolean***REMOVED*** globDisabled - If `true` then the pattern was a glob pattern, but glob was disabled.
     */
    constructor(pattern, globDisabled) ***REMOVED***
        super(`No files matching '$***REMOVED***pattern***REMOVED***' were found$***REMOVED***globDisabled ? " (glob was disabled)" : ""***REMOVED***.`);
        this.messageTemplate = "file-not-found";
        this.messageData = ***REMOVED*** pattern, globDisabled ***REMOVED***;
    ***REMOVED***
***REMOVED***

/**
 * The error type when there are files matched by a glob, but all of them have been ignored.
 */
class AllFilesIgnoredError extends Error ***REMOVED***

    /**
     * @param ***REMOVED***string***REMOVED*** pattern - The glob pattern which was not found.
     */
    constructor(pattern) ***REMOVED***
        super(`All files matched by '$***REMOVED***pattern***REMOVED***' are ignored.`);
        this.messageTemplate = "all-files-ignored";
        this.messageData = ***REMOVED*** pattern ***REMOVED***;
    ***REMOVED***
***REMOVED***

/**
 * This class provides the functionality that enumerates every file which is
 * matched by given glob patterns and that configuration.
 */
class FileEnumerator ***REMOVED***

    /**
     * Initialize this enumerator.
     * @param ***REMOVED***FileEnumeratorOptions***REMOVED*** options The options.
     */
    constructor(***REMOVED***
        cwd = process.cwd(),
        configArrayFactory = new CascadingConfigArrayFactory(***REMOVED*** cwd ***REMOVED***),
        extensions = [".js"],
        globInputPaths = true,
        ignore = true,
        ignoredPaths = new IgnoredPaths(***REMOVED*** cwd, ignore ***REMOVED***)
    ***REMOVED*** = ***REMOVED******REMOVED***) ***REMOVED***
        internalSlotsMap.set(this, ***REMOVED***
            configArrayFactory,
            cwd,
            extensionRegExp: new RegExp(
                `.\\.(?:$***REMOVED***extensions
                    .map(ext => escapeRegExp(
                        ext.startsWith(".")
                            ? ext.slice(1)
                            : ext
                    ))
                    .join("|")
                ***REMOVED***)$`,
                "u"
            ),
            globInputPaths,
            ignoreFlag: ignore,
            ignoredPaths,
            ignoredPathsWithDotfiles: new IgnoredPaths(***REMOVED***
                ...ignoredPaths.options,
                dotfiles: true
            ***REMOVED***)
        ***REMOVED***);
    ***REMOVED***

    /**
     * The `RegExp` object that tests if a file path has the allowed file extensions.
     * @type ***REMOVED***RegExp***REMOVED***
     */
    get extensionRegExp() ***REMOVED***
        return internalSlotsMap.get(this).extensionRegExp;
    ***REMOVED***

    /**
     * Iterate files which are matched by given glob patterns.
     * @param ***REMOVED***string|string[]***REMOVED*** patternOrPatterns The glob patterns to iterate files.
     * @returns ***REMOVED***IterableIterator<FileAndConfig>***REMOVED*** The found files.
     */
    *iterateFiles(patternOrPatterns) ***REMOVED***
        const ***REMOVED*** globInputPaths ***REMOVED*** = internalSlotsMap.get(this);
        const patterns = Array.isArray(patternOrPatterns)
            ? patternOrPatterns
            : [patternOrPatterns];

        debug("Start to iterate files: %o", patterns);

        // The set of paths to remove duplicate.
        const set = new Set();

        for (const pattern of patterns) ***REMOVED***
            let foundRegardlessOfIgnored = false;
            let found = false;

            // Skip empty string.
            if (!pattern) ***REMOVED***
                continue;
            ***REMOVED***

            // Iterate files of this pttern.
            for (const ***REMOVED*** config, filePath, flag ***REMOVED*** of this._iterateFiles(pattern)) ***REMOVED***
                foundRegardlessOfIgnored = true;
                if (flag === IGNORED_SILENTLY) ***REMOVED***
                    continue;
                ***REMOVED***
                found = true;

                // Remove duplicate paths while yielding paths.
                if (!set.has(filePath)) ***REMOVED***
                    set.add(filePath);
                    yield ***REMOVED***
                        config,
                        filePath,
                        ignored: flag === IGNORED
                    ***REMOVED***;
                ***REMOVED***
            ***REMOVED***

            // Raise an error if any files were not found.
            if (!foundRegardlessOfIgnored) ***REMOVED***
                throw new NoFilesFoundError(
                    pattern,
                    !globInputPaths && isGlob(pattern)
                );
            ***REMOVED***
            if (!found) ***REMOVED***
                throw new AllFilesIgnoredError(pattern);
            ***REMOVED***
        ***REMOVED***

        debug(`Complete iterating files: $***REMOVED***JSON.stringify(patterns)***REMOVED***`);
    ***REMOVED***

    /**
     * Iterate files which are matched by a given glob pattern.
     * @param ***REMOVED***string***REMOVED*** pattern The glob pattern to iterate files.
     * @returns ***REMOVED***IterableIterator<FileEntry>***REMOVED*** The found files.
     */
    _iterateFiles(pattern) ***REMOVED***
        const ***REMOVED*** cwd, globInputPaths ***REMOVED*** = internalSlotsMap.get(this);
        const absolutePath = path.resolve(cwd, pattern);
        const isDot = dotfilesPattern.test(pattern);
        const stat = statSafeSync(absolutePath);

        if (stat && stat.isDirectory()) ***REMOVED***
            return this._iterateFilesWithDirectory(absolutePath, isDot);
        ***REMOVED***
        if (stat && stat.isFile()) ***REMOVED***
            return this._iterateFilesWithFile(absolutePath);
        ***REMOVED***
        if (globInputPaths && isGlobPattern(pattern)) ***REMOVED***
            return this._iterateFilesWithGlob(absolutePath, isDot);
        ***REMOVED***

        return [];
    ***REMOVED***

    /**
     * Iterate a file which is matched by a given path.
     * @param ***REMOVED***string***REMOVED*** filePath The path to the target file.
     * @returns ***REMOVED***IterableIterator<FileEntry>***REMOVED*** The found files.
     * @private
     */
    _iterateFilesWithFile(filePath) ***REMOVED***
        debug(`File: $***REMOVED***filePath***REMOVED***`);

        const ***REMOVED*** configArrayFactory ***REMOVED*** = internalSlotsMap.get(this);
        const config = configArrayFactory.getConfigArrayForFile(filePath);
        const ignored = this._isIgnoredFile(filePath, ***REMOVED*** direct: true ***REMOVED***);
        const flag = ignored ? IGNORED : NONE;

        return [***REMOVED*** config, filePath, flag ***REMOVED***];
    ***REMOVED***

    /**
     * Iterate files in a given path.
     * @param ***REMOVED***string***REMOVED*** directoryPath The path to the target directory.
     * @param ***REMOVED***boolean***REMOVED*** dotfiles If `true` then it doesn't skip dot files by default.
     * @returns ***REMOVED***IterableIterator<FileEntry>***REMOVED*** The found files.
     * @private
     */
    _iterateFilesWithDirectory(directoryPath, dotfiles) ***REMOVED***
        debug(`Directory: $***REMOVED***directoryPath***REMOVED***`);

        return this._iterateFilesRecursive(
            directoryPath,
            ***REMOVED*** dotfiles, recursive: true, selector: null ***REMOVED***
        );
    ***REMOVED***

    /**
     * Iterate files which are matched by a given glob pattern.
     * @param ***REMOVED***string***REMOVED*** pattern The glob pattern to iterate files.
     * @param ***REMOVED***boolean***REMOVED*** dotfiles If `true` then it doesn't skip dot files by default.
     * @returns ***REMOVED***IterableIterator<FileEntry>***REMOVED*** The found files.
     * @private
     */
    _iterateFilesWithGlob(pattern, dotfiles) ***REMOVED***
        debug(`Glob: $***REMOVED***pattern***REMOVED***`);

        const directoryPath = getGlobParent(pattern);
        const globPart = pattern.slice(directoryPath.length + 1);

        /*
         * recursive if there are `**` or path separators in the glob part.
         * Otherwise, patterns such as `src/*.js`, it doesn't need recursive.
         */
        const recursive = /\*\*|\/|\\/u.test(globPart);
        const selector = new Minimatch(pattern, minimatchOpts);

        debug(`recursive? $***REMOVED***recursive***REMOVED***`);

        return this._iterateFilesRecursive(
            directoryPath,
            ***REMOVED*** dotfiles, recursive, selector ***REMOVED***
        );
    ***REMOVED***

    /**
     * Iterate files in a given path.
     * @param ***REMOVED***string***REMOVED*** directoryPath The path to the target directory.
     * @param ***REMOVED***Object***REMOVED*** options The options to iterate files.
     * @param ***REMOVED***boolean***REMOVED*** [options.dotfiles] If `true` then it doesn't skip dot files by default.
     * @param ***REMOVED***boolean***REMOVED*** [options.recursive] If `true` then it dives into sub directories.
     * @param ***REMOVED***InstanceType<Minimatch>***REMOVED*** [options.selector] The matcher to choose files.
     * @returns ***REMOVED***IterableIterator<FileEntry>***REMOVED*** The found files.
     * @private
     */
    *_iterateFilesRecursive(directoryPath, options) ***REMOVED***
        if (this._isIgnoredFile(directoryPath + path.sep, options)) ***REMOVED***
            return;
        ***REMOVED***
        debug(`Enter the directory: $***REMOVED***directoryPath***REMOVED***`);
        const ***REMOVED*** configArrayFactory, extensionRegExp ***REMOVED*** = internalSlotsMap.get(this);

        /** @type ***REMOVED***ConfigArray|null***REMOVED*** */
        let config = null;

        // Enumerate the files of this directory.
        for (const filename of readdirSafeSync(directoryPath)) ***REMOVED***
            const filePath = path.join(directoryPath, filename);
            const stat = statSafeSync(filePath); // TODO: Use `withFileTypes` in the future.

            // Check if the file is matched.
            if (stat && stat.isFile()) ***REMOVED***
                if (!config) ***REMOVED***
                    config = configArrayFactory.getConfigArrayForFile(filePath);
                ***REMOVED***
                const ignored = this._isIgnoredFile(filePath, options);
                const flag = ignored ? IGNORED_SILENTLY : NONE;
                const matched = options.selector

                    // Started with a glob pattern; choose by the pattern.
                    ? options.selector.match(filePath)

                    // Started with a directory path; choose by file extensions.
                    : extensionRegExp.test(filePath);

                if (matched) ***REMOVED***
                    debug(`Yield: $***REMOVED***filename***REMOVED***$***REMOVED***ignored ? " but ignored" : ""***REMOVED***`);
                    yield ***REMOVED*** config, filePath, flag ***REMOVED***;
                ***REMOVED*** else ***REMOVED***
                    debug(`Didn't match: $***REMOVED***filename***REMOVED***`);
                ***REMOVED***

            // Dive into the sub directory.
            ***REMOVED*** else if (options.recursive && stat && stat.isDirectory()) ***REMOVED***
                yield* this._iterateFilesRecursive(filePath, options);
            ***REMOVED***
        ***REMOVED***

        debug(`Leave the directory: $***REMOVED***directoryPath***REMOVED***`);
    ***REMOVED***

    /**
     * Check if a given file should be ignored.
     * @param ***REMOVED***string***REMOVED*** filePath The path to a file to check.
     * @param ***REMOVED***Object***REMOVED*** options Options
     * @param ***REMOVED***boolean***REMOVED*** [options.dotfiles] If `true` then this is not ignore dot files by default.
     * @param ***REMOVED***boolean***REMOVED*** [options.direct] If `true` then this is a direct specified file.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the file should be ignored.
     * @private
     */
    _isIgnoredFile(filePath, ***REMOVED*** dotfiles = false, direct = false ***REMOVED***) ***REMOVED***
        const ***REMOVED***
            ignoreFlag,
            ignoredPaths,
            ignoredPathsWithDotfiles
        ***REMOVED*** = internalSlotsMap.get(this);
        const adoptedIgnoredPaths = dotfiles
            ? ignoredPathsWithDotfiles
            : ignoredPaths;

        return ignoreFlag
            ? adoptedIgnoredPaths.contains(filePath)
            : (!direct && adoptedIgnoredPaths.contains(filePath, "default"));
    ***REMOVED***
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = ***REMOVED*** FileEnumerator ***REMOVED***;
