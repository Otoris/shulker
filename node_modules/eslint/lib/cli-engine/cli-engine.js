/**
 * @fileoverview Main CLI object.
 * @author Nicholas C. Zakas
 */

"use strict";

/*
 * The CLI object should *not* call process.exit() directly. It should only return
 * exit codes. This allows other programs to use the CLI object and still control
 * when the program exits.
 */

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const fs = require("fs");
const path = require("path");
const defaultOptions = require("../../conf/default-cli-options");
const pkg = require("../../package.json");
const ConfigOps = require("../shared/config-ops");
const naming = require("../shared/naming");
const ModuleResolver = require("../shared/relative-module-resolver");
const ***REMOVED*** Linter ***REMOVED*** = require("../linter");
const builtInRules = require("../rules");
const ***REMOVED*** CascadingConfigArrayFactory ***REMOVED*** = require("./cascading-config-array-factory");
const ***REMOVED*** getUsedExtractedConfigs ***REMOVED*** = require("./config-array");
const ***REMOVED*** FileEnumerator ***REMOVED*** = require("./file-enumerator");
const hash = require("./hash");
const ***REMOVED*** IgnoredPaths ***REMOVED*** = require("./ignored-paths");
const LintResultCache = require("./lint-result-cache");

const debug = require("debug")("eslint:cli-engine");
const validFixTypes = new Set(["problem", "suggestion", "layout"]);

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

// For VSCode IntelliSense
/** @typedef ***REMOVED***import("../shared/types").ConfigData***REMOVED*** ConfigData */
/** @typedef ***REMOVED***import("../shared/types").LintMessage***REMOVED*** LintMessage */
/** @typedef ***REMOVED***import("../shared/types").ParserOptions***REMOVED*** ParserOptions */
/** @typedef ***REMOVED***import("../shared/types").Plugin***REMOVED*** Plugin */
/** @typedef ***REMOVED***import("../shared/types").RuleConf***REMOVED*** RuleConf */
/** @typedef ***REMOVED***import("../shared/types").Rule***REMOVED*** Rule */
/** @typedef ***REMOVED***ReturnType<CascadingConfigArrayFactory["getConfigArrayForFile"]>***REMOVED*** ConfigArray */
/** @typedef ***REMOVED***ReturnType<ConfigArray["extractConfig"]>***REMOVED*** ExtractedConfig */

/**
 * The options to configure a CLI engine with.
 * @typedef ***REMOVED***Object***REMOVED*** CLIEngineOptions
 * @property ***REMOVED***boolean***REMOVED*** allowInlineConfig Enable or disable inline configuration comments.
 * @property ***REMOVED***ConfigData***REMOVED*** baseConfig Base config object, extended by all configs used with this CLIEngine instance
 * @property ***REMOVED***boolean***REMOVED*** cache Enable result caching.
 * @property ***REMOVED***string***REMOVED*** cacheLocation The cache file to use instead of .eslintcache.
 * @property ***REMOVED***string***REMOVED*** configFile The configuration file to use.
 * @property ***REMOVED***string***REMOVED*** cwd The value to use for the current working directory.
 * @property ***REMOVED***string[]***REMOVED*** envs An array of environments to load.
 * @property ***REMOVED***string[]***REMOVED*** extensions An array of file extensions to check.
 * @property ***REMOVED***boolean|Function***REMOVED*** fix Execute in autofix mode. If a function, should return a boolean.
 * @property ***REMOVED***string[]***REMOVED*** fixTypes Array of rule types to apply fixes for.
 * @property ***REMOVED***string[]***REMOVED*** globals An array of global variables to declare.
 * @property ***REMOVED***boolean***REMOVED*** ignore False disables use of .eslintignore.
 * @property ***REMOVED***string***REMOVED*** ignorePath The ignore file to use instead of .eslintignore.
 * @property ***REMOVED***string***REMOVED*** ignorePattern A glob pattern of files to ignore.
 * @property ***REMOVED***boolean***REMOVED*** useEslintrc False disables looking for .eslintrc
 * @property ***REMOVED***string***REMOVED*** parser The name of the parser to use.
 * @property ***REMOVED***ParserOptions***REMOVED*** parserOptions An object of parserOption settings to use.
 * @property ***REMOVED***string[]***REMOVED*** plugins An array of plugins to load.
 * @property ***REMOVED***Record<string,RuleConf>***REMOVED*** rules An object of rules to use.
 * @property ***REMOVED***string[]***REMOVED*** rulePaths An array of directories to load custom rules from.
 * @property ***REMOVED***boolean***REMOVED*** reportUnusedDisableDirectives `true` adds reports for unused eslint-disable directives
 * @property ***REMOVED***boolean***REMOVED*** globInputPaths Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.
 * @property ***REMOVED***string***REMOVED*** resolvePluginsRelativeTo The folder where plugins should be resolved from, defaulting to the CWD
 */

/**
 * A linting result.
 * @typedef ***REMOVED***Object***REMOVED*** LintResult
 * @property ***REMOVED***string***REMOVED*** filePath The path to the file that was linted.
 * @property ***REMOVED***LintMessage[]***REMOVED*** messages All of the messages for the result.
 * @property ***REMOVED***number***REMOVED*** errorCount Number of errors for the result.
 * @property ***REMOVED***number***REMOVED*** warningCount Number of warnings for the result.
 * @property ***REMOVED***number***REMOVED*** fixableErrorCount Number of fixable errors for the result.
 * @property ***REMOVED***number***REMOVED*** fixableWarningCount Number of fixable warnings for the result.
 * @property ***REMOVED***string=***REMOVED*** [source] The source code of the file that was linted.
 * @property ***REMOVED***string=***REMOVED*** [output] The source code of the file that was linted, with as many fixes applied as possible.
 */

/**
 * Information of deprecated rules.
 * @typedef ***REMOVED***Object***REMOVED*** DeprecatedRuleInfo
 * @property ***REMOVED***string***REMOVED*** ruleId The rule ID.
 * @property ***REMOVED***string[]***REMOVED*** replacedBy The rule IDs that replace this deprecated rule.
 */

/**
 * Linting results.
 * @typedef ***REMOVED***Object***REMOVED*** LintReport
 * @property ***REMOVED***LintResult[]***REMOVED*** results All of the result.
 * @property ***REMOVED***number***REMOVED*** errorCount Number of errors for the result.
 * @property ***REMOVED***number***REMOVED*** warningCount Number of warnings for the result.
 * @property ***REMOVED***number***REMOVED*** fixableErrorCount Number of fixable errors for the result.
 * @property ***REMOVED***number***REMOVED*** fixableWarningCount Number of fixable warnings for the result.
 * @property ***REMOVED***DeprecatedRuleInfo[]***REMOVED*** usedDeprecatedRules The list of used deprecated rules.
 */

/**
 * Private data for CLIEngine.
 * @typedef ***REMOVED***Object***REMOVED*** CLIEngineInternalSlots
 * @property ***REMOVED***Map<string, Plugin>***REMOVED*** additionalPluginPool The map for additional plugins.
 * @property ***REMOVED***string***REMOVED*** cacheFilePath The path to the cache of lint results.
 * @property ***REMOVED***CascadingConfigArrayFactory***REMOVED*** configArrayFactory The factory of configs.
 * @property ***REMOVED***FileEnumerator***REMOVED*** fileEnumerator The file enumerator.
 * @property ***REMOVED***IgnoredPaths***REMOVED*** ignoredPaths The ignored paths.
 * @property ***REMOVED***ConfigArray[]***REMOVED*** lastConfigArrays The list of config arrays that the last `executeOnFiles` or `executeOnText` used.
 * @property ***REMOVED***LintResultCache|null***REMOVED*** lintResultCache The cache of lint results.
 * @property ***REMOVED***Linter***REMOVED*** linter The linter instance which has loaded rules.
 * @property ***REMOVED***CLIEngineOptions***REMOVED*** options The normalized options of this instance.
 */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/** @type ***REMOVED***WeakMap<CLIEngine, CLIEngineInternalSlots>***REMOVED*** */
const internalSlotsMap = new WeakMap();

/**
 * Determines if each fix type in an array is supported by ESLint and throws
 * an error if not.
 * @param ***REMOVED***string[]***REMOVED*** fixTypes An array of fix types to check.
 * @returns ***REMOVED***void***REMOVED***
 * @throws ***REMOVED***Error***REMOVED*** If an invalid fix type is found.
 */
function validateFixTypes(fixTypes) ***REMOVED***
    for (const fixType of fixTypes) ***REMOVED***
        if (!validFixTypes.has(fixType)) ***REMOVED***
            throw new Error(`Invalid fix type "$***REMOVED***fixType***REMOVED***" found.`);
        ***REMOVED***
    ***REMOVED***
***REMOVED***

/**
 * It will calculate the error and warning count for collection of messages per file
 * @param ***REMOVED***LintMessage[]***REMOVED*** messages - Collection of messages
 * @returns ***REMOVED***Object***REMOVED*** Contains the stats
 * @private
 */
function calculateStatsPerFile(messages) ***REMOVED***
    return messages.reduce((stat, message) => ***REMOVED***
        if (message.fatal || message.severity === 2) ***REMOVED***
            stat.errorCount++;
            if (message.fix) ***REMOVED***
                stat.fixableErrorCount++;
            ***REMOVED***
        ***REMOVED*** else ***REMOVED***
            stat.warningCount++;
            if (message.fix) ***REMOVED***
                stat.fixableWarningCount++;
            ***REMOVED***
        ***REMOVED***
        return stat;
    ***REMOVED***, ***REMOVED***
        errorCount: 0,
        warningCount: 0,
        fixableErrorCount: 0,
        fixableWarningCount: 0
    ***REMOVED***);
***REMOVED***

/**
 * It will calculate the error and warning count for collection of results from all files
 * @param ***REMOVED***LintResult[]***REMOVED*** results - Collection of messages from all the files
 * @returns ***REMOVED***Object***REMOVED*** Contains the stats
 * @private
 */
function calculateStatsPerRun(results) ***REMOVED***
    return results.reduce((stat, result) => ***REMOVED***
        stat.errorCount += result.errorCount;
        stat.warningCount += result.warningCount;
        stat.fixableErrorCount += result.fixableErrorCount;
        stat.fixableWarningCount += result.fixableWarningCount;
        return stat;
    ***REMOVED***, ***REMOVED***
        errorCount: 0,
        warningCount: 0,
        fixableErrorCount: 0,
        fixableWarningCount: 0
    ***REMOVED***);
***REMOVED***

/**
 * Processes an source code using ESLint.
 * @param ***REMOVED***Object***REMOVED*** config The config object.
 * @param ***REMOVED***string***REMOVED*** config.text The source code to verify.
 * @param ***REMOVED***string***REMOVED*** config.cwd The path to the current working directory.
 * @param ***REMOVED***string|undefined***REMOVED*** config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.
 * @param ***REMOVED***ConfigArray***REMOVED*** config.config The config.
 * @param ***REMOVED***boolean***REMOVED*** config.fix If `true` then it does fix.
 * @param ***REMOVED***boolean***REMOVED*** config.allowInlineConfig If `true` then it uses directive comments.
 * @param ***REMOVED***boolean***REMOVED*** config.reportUnusedDisableDirectives If `true` then it reports unused `eslint-disable` comments.
 * @param ***REMOVED***RegExp***REMOVED*** config.extensionRegExp The `RegExp` object that tests if a file path has the allowed file extensions.
 * @param ***REMOVED***Linter***REMOVED*** config.linter The linter instance to verify.
 * @returns ***REMOVED***LintResult***REMOVED*** The result of linting.
 * @private
 */
function verifyText(***REMOVED***
    text,
    cwd,
    filePath: providedFilePath,
    config,
    fix,
    allowInlineConfig,
    reportUnusedDisableDirectives,
    extensionRegExp,
    linter
***REMOVED***) ***REMOVED***
    const filePath = providedFilePath || "<text>";

    debug(`Lint $***REMOVED***filePath***REMOVED***`);

    /*
     * Verify.
     * `config.extractConfig(filePath)` requires an absolute path, but `linter`
     * doesn't know CWD, so it gives `linter` an absolute path always.
     */
    const filePathToVerify = filePath === "<text>" ? path.join(cwd, filePath) : filePath;
    const ***REMOVED*** fixed, messages, output ***REMOVED*** = linter.verifyAndFix(
        text,
        config,
        ***REMOVED***
            allowInlineConfig,
            filename: filePathToVerify,
            fix,
            reportUnusedDisableDirectives,

            /**
             * Check if the linter should adopt a given code block or not.
             * Currently, the linter adopts code blocks if the name matches `--ext` option.
             * In the future, `overrides` in the configuration would affect the adoption (https://github.com/eslint/rfcs/pull/20).
             * @param ***REMOVED***string***REMOVED*** blockFilename The virtual filename of a code block.
             * @returns ***REMOVED***boolean***REMOVED*** `true` if the linter should adopt the code block.
             */
            filterCodeBlock(blockFilename) ***REMOVED***
                return extensionRegExp.test(blockFilename);
            ***REMOVED***
        ***REMOVED***
    );

    // Tweak and return.
    const result = ***REMOVED***
        filePath,
        messages,
        ...calculateStatsPerFile(messages)
    ***REMOVED***;

    if (fixed) ***REMOVED***
        result.output = output;
    ***REMOVED***
    if (
        result.errorCount + result.warningCount > 0 &&
        typeof result.output === "undefined"
    ) ***REMOVED***
        result.source = text;
    ***REMOVED***

    return result;
***REMOVED***

/**
 * Returns result with warning by ignore settings
 * @param ***REMOVED***string***REMOVED*** filePath - File path of checked code
 * @param ***REMOVED***string***REMOVED*** baseDir  - Absolute path of base directory
 * @returns ***REMOVED***LintResult***REMOVED*** Result with single warning
 * @private
 */
function createIgnoreResult(filePath, baseDir) ***REMOVED***
    let message;
    const isHidden = /^\./u.test(path.basename(filePath));
    const isInNodeModules = baseDir && path.relative(baseDir, filePath).startsWith("node_modules");
    const isInBowerComponents = baseDir && path.relative(baseDir, filePath).startsWith("bower_components");

    if (isHidden) ***REMOVED***
        message = "File ignored by default.  Use a negated ignore pattern (like \"--ignore-pattern '!<relative/path/to/filename>'\") to override.";
    ***REMOVED*** else if (isInNodeModules) ***REMOVED***
        message = "File ignored by default. Use \"--ignore-pattern '!node_modules/*'\" to override.";
    ***REMOVED*** else if (isInBowerComponents) ***REMOVED***
        message = "File ignored by default. Use \"--ignore-pattern '!bower_components/*'\" to override.";
    ***REMOVED*** else ***REMOVED***
        message = "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to override.";
    ***REMOVED***

    return ***REMOVED***
        filePath: path.resolve(filePath),
        messages: [
            ***REMOVED***
                fatal: false,
                severity: 1,
                message
            ***REMOVED***
        ],
        errorCount: 0,
        warningCount: 1,
        fixableErrorCount: 0,
        fixableWarningCount: 0
    ***REMOVED***;
***REMOVED***

/**
 * Get a rule.
 * @param ***REMOVED***string***REMOVED*** ruleId The rule ID to get.
 * @param ***REMOVED***ConfigArray[]***REMOVED*** configArrays The config arrays that have plugin rules.
 * @returns ***REMOVED***Rule|null***REMOVED*** The rule or null.
 */
function getRule(ruleId, configArrays) ***REMOVED***
    for (const configArray of configArrays) ***REMOVED***
        const rule = configArray.pluginRules.get(ruleId);

        if (rule) ***REMOVED***
            return rule;
        ***REMOVED***
    ***REMOVED***
    return builtInRules.get(ruleId) || null;
***REMOVED***

/**
 * Collect used deprecated rules.
 * @param ***REMOVED***ConfigArray[]***REMOVED*** usedConfigArrays The config arrays which were used.
 * @param ***REMOVED***Map<string, Object>***REMOVED*** ruleMap The rule definitions which were used (built-ins).
 * @returns ***REMOVED***IterableIterator<DeprecatedRuleInfo>***REMOVED*** Used deprecated rules.
 */
function *iterateRuleDeprecationWarnings(usedConfigArrays) ***REMOVED***
    const processedRuleIds = new Set();

    // Flatten used configs.
    /** @type ***REMOVED***ExtractedConfig[]***REMOVED*** */
    const configs = [].concat(
        ...usedConfigArrays.map(getUsedExtractedConfigs)
    );

    // Traverse rule configs.
    for (const config of configs) ***REMOVED***
        for (const [ruleId, ruleConfig] of Object.entries(config.rules)) ***REMOVED***

            // Skip if it was processed.
            if (processedRuleIds.has(ruleId)) ***REMOVED***
                continue;
            ***REMOVED***
            processedRuleIds.add(ruleId);

            // Skip if it's not used.
            if (!ConfigOps.getRuleSeverity(ruleConfig)) ***REMOVED***
                continue;
            ***REMOVED***
            const rule = getRule(ruleId, usedConfigArrays);

            // Skip if it's not deprecated.
            if (!(rule && rule.meta && rule.meta.deprecated)) ***REMOVED***
                continue;
            ***REMOVED***

            // This rule was used and deprecated.
            yield ***REMOVED***
                ruleId,
                replacedBy: rule.meta.replacedBy || []
            ***REMOVED***;
        ***REMOVED***
    ***REMOVED***
***REMOVED***

/**
 * Checks if the given message is an error message.
 * @param ***REMOVED***LintMessage***REMOVED*** message The message to check.
 * @returns ***REMOVED***boolean***REMOVED*** Whether or not the message is an error message.
 * @private
 */
function isErrorMessage(message) ***REMOVED***
    return message.severity === 2;
***REMOVED***


/**
 * return the cacheFile to be used by eslint, based on whether the provided parameter is
 * a directory or looks like a directory (ends in `path.sep`), in which case the file
 * name will be the `cacheFile/.cache_hashOfCWD`
 *
 * if cacheFile points to a file or looks like a file then in will just use that file
 *
 * @param ***REMOVED***string***REMOVED*** cacheFile The name of file to be used to store the cache
 * @param ***REMOVED***string***REMOVED*** cwd Current working directory
 * @returns ***REMOVED***string***REMOVED*** the resolved path to the cache file
 */
function getCacheFile(cacheFile, cwd) ***REMOVED***

    /*
     * make sure the path separators are normalized for the environment/os
     * keeping the trailing path separator if present
     */
    const normalizedCacheFile = path.normalize(cacheFile);

    const resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);
    const looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;

    /**
     * return the name for the cache file in case the provided parameter is a directory
     * @returns ***REMOVED***string***REMOVED*** the resolved path to the cacheFile
     */
    function getCacheFileForDirectory() ***REMOVED***
        return path.join(resolvedCacheFile, `.cache_$***REMOVED***hash(cwd)***REMOVED***`);
    ***REMOVED***

    let fileStats;

    try ***REMOVED***
        fileStats = fs.lstatSync(resolvedCacheFile);
    ***REMOVED*** catch (ex) ***REMOVED***
        fileStats = null;
    ***REMOVED***


    /*
     * in case the file exists we need to verify if the provided path
     * is a directory or a file. If it is a directory we want to create a file
     * inside that directory
     */
    if (fileStats) ***REMOVED***

        /*
         * is a directory or is a file, but the original file the user provided
         * looks like a directory but `path.resolve` removed the `last path.sep`
         * so we need to still treat this like a directory
         */
        if (fileStats.isDirectory() || looksLikeADirectory) ***REMOVED***
            return getCacheFileForDirectory();
        ***REMOVED***

        // is file so just use that file
        return resolvedCacheFile;
    ***REMOVED***

    /*
     * here we known the file or directory doesn't exist,
     * so we will try to infer if its a directory if it looks like a directory
     * for the current operating system.
     */

    // if the last character passed is a path separator we assume is a directory
    if (looksLikeADirectory) ***REMOVED***
        return getCacheFileForDirectory();
    ***REMOVED***

    return resolvedCacheFile;
***REMOVED***

/**
 * Convert a string array to a boolean map.
 * @param ***REMOVED***string[]|null***REMOVED*** keys The keys to assign true.
 * @param ***REMOVED***boolean***REMOVED*** defaultValue The default value for each property.
 * @param ***REMOVED***string***REMOVED*** displayName The property name which is used in error message.
 * @returns ***REMOVED***Record<string,boolean>***REMOVED*** The boolean map.
 */
function toBooleanMap(keys, defaultValue, displayName) ***REMOVED***
    if (keys && !Array.isArray(keys)) ***REMOVED***
        throw new Error(`$***REMOVED***displayName***REMOVED*** must be an array.`);
    ***REMOVED***
    if (keys && keys.length > 0) ***REMOVED***
        return keys.reduce((map, def) => ***REMOVED***
            const [key, value] = def.split(":");

            if (key !== "__proto__") ***REMOVED***
                map[key] = value === void 0
                    ? defaultValue
                    : value === "true";
            ***REMOVED***

            return map;
        ***REMOVED***, ***REMOVED******REMOVED***);
    ***REMOVED***
    return void 0;
***REMOVED***

/**
 * Create a config data from CLI options.
 * @param ***REMOVED***CLIEngineOptions***REMOVED*** options The options
 * @returns ***REMOVED***ConfigData|null***REMOVED*** The created config data.
 */
function createConfigDataFromOptions(options) ***REMOVED***
    const ***REMOVED*** parser, parserOptions, plugins, rules ***REMOVED*** = options;
    const env = toBooleanMap(options.envs, true, "envs");
    const globals = toBooleanMap(options.globals, false, "globals");

    if (
        env === void 0 &&
        globals === void 0 &&
        parser === void 0 &&
        parserOptions === void 0 &&
        plugins === void 0 &&
        rules === void 0
    ) ***REMOVED***
        return null;
    ***REMOVED***
    return ***REMOVED*** env, globals, parser, parserOptions, plugins, rules ***REMOVED***;
***REMOVED***

/**
 * Checks whether a directory exists at the given location
 * @param ***REMOVED***string***REMOVED*** resolvedPath A path from the CWD
 * @returns ***REMOVED***boolean***REMOVED*** `true` if a directory exists
 */
function directoryExists(resolvedPath) ***REMOVED***
    try ***REMOVED***
        return fs.statSync(resolvedPath).isDirectory();
    ***REMOVED*** catch (error) ***REMOVED***
        if (error && error.code === "ENOENT") ***REMOVED***
            return false;
        ***REMOVED***
        throw error;
    ***REMOVED***
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

class CLIEngine ***REMOVED***

    /**
     * Creates a new instance of the core CLI engine.
     * @param ***REMOVED***CLIEngineOptions***REMOVED*** providedOptions The options for this instance.
     * @constructor
     */
    constructor(providedOptions) ***REMOVED***
        const options = Object.assign(
            Object.create(null),
            defaultOptions,
            ***REMOVED*** cwd: process.cwd() ***REMOVED***,
            providedOptions
        );

        if (options.fix === void 0) ***REMOVED***
            options.fix = false;
        ***REMOVED***

        const additionalPluginPool = new Map();
        const cacheFilePath = getCacheFile(
            options.cacheLocation || options.cacheFile,
            options.cwd
        );
        const configArrayFactory = new CascadingConfigArrayFactory(***REMOVED***
            additionalPluginPool,
            baseConfig: options.baseConfig || null,
            cliConfig: createConfigDataFromOptions(options),
            cwd: options.cwd,
            resolvePluginsRelativeTo: options.resolvePluginsRelativeTo,
            rulePaths: options.rulePaths,
            specificConfigPath: options.configFile,
            useEslintrc: options.useEslintrc
        ***REMOVED***);
        const ignoredPaths = new IgnoredPaths(options);
        const fileEnumerator = new FileEnumerator(***REMOVED***
            configArrayFactory,
            cwd: options.cwd,
            extensions: options.extensions,
            globInputPaths: options.globInputPaths,
            ignore: options.ignore,
            ignoredPaths
        ***REMOVED***);
        const lintResultCache =
            options.cache ? new LintResultCache(cacheFilePath) : null;
        const linter = new Linter();

        /** @type ***REMOVED***ConfigArray[]***REMOVED*** */
        const lastConfigArrays = [configArrayFactory.getConfigArrayForFile()];

        // Store private data.
        internalSlotsMap.set(this, ***REMOVED***
            additionalPluginPool,
            cacheFilePath,
            configArrayFactory,
            fileEnumerator,
            ignoredPaths,
            lastConfigArrays,
            lintResultCache,
            linter,
            options
        ***REMOVED***);

        // setup special filter for fixes
        if (options.fix && options.fixTypes && options.fixTypes.length > 0) ***REMOVED***
            debug(`Using fix types $***REMOVED***options.fixTypes***REMOVED***`);

            // throw an error if any invalid fix types are found
            validateFixTypes(options.fixTypes);

            // convert to Set for faster lookup
            const fixTypes = new Set(options.fixTypes);

            // save original value of options.fix in case it's a function
            const originalFix = (typeof options.fix === "function")
                ? options.fix : () => true;

            options.fix = message => ***REMOVED***
                const rule = message.ruleId && getRule(message.ruleId, lastConfigArrays);
                const matches = rule && rule.meta && fixTypes.has(rule.meta.type);

                return matches && originalFix(message);
            ***REMOVED***;
        ***REMOVED***
    ***REMOVED***

    getRules() ***REMOVED***
        const ***REMOVED*** lastConfigArrays ***REMOVED*** = internalSlotsMap.get(this);

        return new Map(function *() ***REMOVED***
            yield* builtInRules;

            for (const configArray of lastConfigArrays) ***REMOVED***
                yield* configArray.pluginRules;
            ***REMOVED***
        ***REMOVED***());
    ***REMOVED***

    /**
     * Returns results that only contains errors.
     * @param ***REMOVED***LintResult[]***REMOVED*** results The results to filter.
     * @returns ***REMOVED***LintResult[]***REMOVED*** The filtered results.
     */
    static getErrorResults(results) ***REMOVED***
        const filtered = [];

        results.forEach(result => ***REMOVED***
            const filteredMessages = result.messages.filter(isErrorMessage);

            if (filteredMessages.length > 0) ***REMOVED***
                filtered.push(***REMOVED***
                    ...result,
                    messages: filteredMessages,
                    errorCount: filteredMessages.length,
                    warningCount: 0,
                    fixableErrorCount: result.fixableErrorCount,
                    fixableWarningCount: 0
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***);

        return filtered;
    ***REMOVED***

    /**
     * Outputs fixes from the given results to files.
     * @param ***REMOVED***LintReport***REMOVED*** report The report object created by CLIEngine.
     * @returns ***REMOVED***void***REMOVED***
     */
    static outputFixes(report) ***REMOVED***
        report.results.filter(result => Object.prototype.hasOwnProperty.call(result, "output")).forEach(result => ***REMOVED***
            fs.writeFileSync(result.filePath, result.output);
        ***REMOVED***);
    ***REMOVED***


    /**
     * Add a plugin by passing its configuration
     * @param ***REMOVED***string***REMOVED*** name Name of the plugin.
     * @param ***REMOVED***Plugin***REMOVED*** pluginObject Plugin configuration object.
     * @returns ***REMOVED***void***REMOVED***
     */
    addPlugin(name, pluginObject) ***REMOVED***
        const ***REMOVED***
            additionalPluginPool,
            configArrayFactory
        ***REMOVED*** = internalSlotsMap.get(this);

        additionalPluginPool.set(name, pluginObject);
        configArrayFactory.clearCache();
    ***REMOVED***

    /**
     * Resolves the patterns passed into executeOnFiles() into glob-based patterns
     * for easier handling.
     * @param ***REMOVED***string[]***REMOVED*** patterns The file patterns passed on the command line.
     * @returns ***REMOVED***string[]***REMOVED*** The equivalent glob patterns.
     */
    resolveFileGlobPatterns(patterns) ***REMOVED***
        const ***REMOVED*** options ***REMOVED*** = internalSlotsMap.get(this);

        if (options.globInputPaths === false) ***REMOVED***
            return patterns.filter(Boolean);
        ***REMOVED***

        const extensions = options.extensions.map(ext => ext.replace(/^\./u, ""));
        const dirSuffix = `/**/*.***REMOVED***$***REMOVED***extensions.join(",")***REMOVED******REMOVED***`;

        return patterns.filter(Boolean).map(pathname => ***REMOVED***
            const resolvedPath = path.resolve(options.cwd, pathname);
            const newPath = directoryExists(resolvedPath)
                ? pathname.replace(/[/\\]$/u, "") + dirSuffix
                : pathname;

            return path.normalize(newPath).replace(/\\/gu, "/");
        ***REMOVED***);
    ***REMOVED***

    /**
     * Executes the current configuration on an array of file and directory names.
     * @param ***REMOVED***string[]***REMOVED*** patterns An array of file and directory names.
     * @returns ***REMOVED***LintReport***REMOVED*** The results for all files that were linted.
     */
    executeOnFiles(patterns) ***REMOVED***
        const ***REMOVED***
            cacheFilePath,
            fileEnumerator,
            lastConfigArrays,
            lintResultCache,
            linter,
            options: ***REMOVED***
                allowInlineConfig,
                cache,
                cwd,
                fix,
                reportUnusedDisableDirectives
            ***REMOVED***
        ***REMOVED*** = internalSlotsMap.get(this);
        const results = [];
        const startTime = Date.now();

        // Clear the last used config arrays.
        lastConfigArrays.length = 0;

        // Delete cache file; should this do here?
        if (!cache) ***REMOVED***
            try ***REMOVED***
                fs.unlinkSync(cacheFilePath);
            ***REMOVED*** catch (error) ***REMOVED***
                const errorCode = error && error.code;

                // Ignore errors when no such file exists or file system is read only (and cache file does not exist)
                if (errorCode !== "ENOENT" && !(errorCode === "EROFS" && !fs.existsSync(cacheFilePath))) ***REMOVED***
                    throw error;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        // Iterate source code files.
        for (const ***REMOVED*** config, filePath, ignored ***REMOVED*** of fileEnumerator.iterateFiles(patterns)) ***REMOVED***
            if (ignored) ***REMOVED***
                results.push(createIgnoreResult(filePath, cwd));
                continue;
            ***REMOVED***

            /*
             * Store used configs for:
             * - this method uses to collect used deprecated rules.
             * - `getRules()` method uses to collect all loaded rules.
             * - `--fix-type` option uses to get the loaded rule's meta data.
             */
            if (!lastConfigArrays.includes(config)) ***REMOVED***
                lastConfigArrays.push(config);
            ***REMOVED***

            // Skip if there is cached result.
            if (lintResultCache) ***REMOVED***
                const cachedResult =
                    lintResultCache.getCachedLintResults(filePath, config);

                if (cachedResult) ***REMOVED***
                    const hadMessages =
                        cachedResult.messages &&
                        cachedResult.messages.length > 0;

                    if (hadMessages && fix) ***REMOVED***
                        debug(`Reprocessing cached file to allow autofix: $***REMOVED***filePath***REMOVED***`);
                    ***REMOVED*** else ***REMOVED***
                        debug(`Skipping file since it hasn't changed: $***REMOVED***filePath***REMOVED***`);
                        results.push(cachedResult);
                        continue;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***

            // Do lint.
            const result = verifyText(***REMOVED***
                text: fs.readFileSync(filePath, "utf8"),
                filePath,
                config,
                cwd,
                fix,
                allowInlineConfig,
                reportUnusedDisableDirectives,
                extensionRegExp: fileEnumerator.extensionRegExp,
                linter
            ***REMOVED***);

            results.push(result);

            /*
             * Store the lint result in the LintResultCache.
             * NOTE: The LintResultCache will remove the file source and any
             * other properties that are difficult to serialize, and will
             * hydrate those properties back in on future lint runs.
             */
            if (lintResultCache) ***REMOVED***
                lintResultCache.setCachedLintResults(filePath, config, result);
            ***REMOVED***
        ***REMOVED***

        // Persist the cache to disk.
        if (lintResultCache) ***REMOVED***
            lintResultCache.reconcile();
        ***REMOVED***

        // Collect used deprecated rules.
        const usedDeprecatedRules = Array.from(
            iterateRuleDeprecationWarnings(lastConfigArrays)
        );

        debug(`Linting complete in: $***REMOVED***Date.now() - startTime***REMOVED***ms`);
        return ***REMOVED***
            results,
            ...calculateStatsPerRun(results),
            usedDeprecatedRules
        ***REMOVED***;
    ***REMOVED***

    /**
     * Executes the current configuration on text.
     * @param ***REMOVED***string***REMOVED*** text A string of JavaScript code to lint.
     * @param ***REMOVED***string***REMOVED*** [filename] An optional string representing the texts filename.
     * @param ***REMOVED***boolean***REMOVED*** [warnIgnored] Always warn when a file is ignored
     * @returns ***REMOVED***LintReport***REMOVED*** The results for the linting.
     */
    executeOnText(text, filename, warnIgnored) ***REMOVED***
        const ***REMOVED***
            configArrayFactory,
            fileEnumerator,
            ignoredPaths,
            lastConfigArrays,
            linter,
            options: ***REMOVED***
                allowInlineConfig,
                cwd,
                fix,
                reportUnusedDisableDirectives
            ***REMOVED***
        ***REMOVED*** = internalSlotsMap.get(this);
        const results = [];
        const startTime = Date.now();
        const resolvedFilename = filename && path.resolve(cwd, filename);

        // Clear the last used config arrays.
        lastConfigArrays.length = 0;

        if (resolvedFilename && ignoredPaths.contains(resolvedFilename)) ***REMOVED***
            if (warnIgnored) ***REMOVED***
                results.push(createIgnoreResult(resolvedFilename, cwd));
            ***REMOVED***
        ***REMOVED*** else ***REMOVED***
            const config = configArrayFactory.getConfigArrayForFile(
                resolvedFilename || "__placeholder__.js"
            );

            /*
             * Store used configs for:
             * - this method uses to collect used deprecated rules.
             * - `getRules()` method uses to collect all loaded rules.
             * - `--fix-type` option uses to get the loaded rule's meta data.
             */
            lastConfigArrays.push(config);

            // Do lint.
            results.push(verifyText(***REMOVED***
                text,
                filePath: resolvedFilename,
                config,
                cwd,
                fix,
                allowInlineConfig,
                reportUnusedDisableDirectives,
                extensionRegExp: fileEnumerator.extensionRegExp,
                linter
            ***REMOVED***));
        ***REMOVED***

        // Collect used deprecated rules.
        const usedDeprecatedRules = Array.from(
            iterateRuleDeprecationWarnings(lastConfigArrays)
        );

        debug(`Linting complete in: $***REMOVED***Date.now() - startTime***REMOVED***ms`);
        return ***REMOVED***
            results,
            ...calculateStatsPerRun(results),
            usedDeprecatedRules
        ***REMOVED***;
    ***REMOVED***

    /**
     * Returns a configuration object for the given file based on the CLI options.
     * This is the same logic used by the ESLint CLI executable to determine
     * configuration for each file it processes.
     * @param ***REMOVED***string***REMOVED*** filePath The path of the file to retrieve a config object for.
     * @returns ***REMOVED***ConfigData***REMOVED*** A configuration object for the file.
     */
    getConfigForFile(filePath) ***REMOVED***
        const ***REMOVED*** configArrayFactory, options ***REMOVED*** = internalSlotsMap.get(this);
        const absolutePath = path.resolve(options.cwd, filePath);

        if (directoryExists(absolutePath)) ***REMOVED***
            throw Object.assign(
                new Error("'filePath' should not be a directory path."),
                ***REMOVED*** messageTemplate: "print-config-with-directory-path" ***REMOVED***
            );
        ***REMOVED***

        return configArrayFactory
            .getConfigArrayForFile(absolutePath)
            .extractConfig(absolutePath)
            .toCompatibleObjectAsConfigFileContent();
    ***REMOVED***

    /**
     * Checks if a given path is ignored by ESLint.
     * @param ***REMOVED***string***REMOVED*** filePath The path of the file to check.
     * @returns ***REMOVED***boolean***REMOVED*** Whether or not the given path is ignored.
     */
    isPathIgnored(filePath) ***REMOVED***
        const ***REMOVED*** ignoredPaths ***REMOVED*** = internalSlotsMap.get(this);

        return ignoredPaths.contains(filePath);
    ***REMOVED***

    /**
     * Returns the formatter representing the given format or null if no formatter
     * with the given name can be found.
     * @param ***REMOVED***string***REMOVED*** [format] The name of the format to load or the path to a
     *      custom formatter.
     * @returns ***REMOVED***Function***REMOVED*** The formatter function or null if not found.
     */
    getFormatter(format) ***REMOVED***

        // default is stylish
        const resolvedFormatName = format || "stylish";

        // only strings are valid formatters
        if (typeof resolvedFormatName === "string") ***REMOVED***

            // replace \ with / for Windows compatibility
            const normalizedFormatName = resolvedFormatName.replace(/\\/gu, "/");

            const slots = internalSlotsMap.get(this);
            const cwd = slots ? slots.options.cwd : process.cwd();
            const namespace = naming.getNamespaceFromTerm(normalizedFormatName);

            let formatterPath;

            // if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)
            if (!namespace && normalizedFormatName.indexOf("/") > -1) ***REMOVED***
                formatterPath = path.resolve(cwd, normalizedFormatName);
            ***REMOVED*** else ***REMOVED***
                try ***REMOVED***
                    const npmFormat = naming.normalizePackageName(normalizedFormatName, "eslint-formatter");

                    formatterPath = ModuleResolver.resolve(npmFormat, path.join(cwd, "__placeholder__.js"));
                ***REMOVED*** catch (e) ***REMOVED***
                    formatterPath = path.resolve(__dirname, "formatters", normalizedFormatName);
                ***REMOVED***
            ***REMOVED***

            try ***REMOVED***
                return require(formatterPath);
            ***REMOVED*** catch (ex) ***REMOVED***
                ex.message = `There was a problem loading formatter: $***REMOVED***formatterPath***REMOVED***\nError: $***REMOVED***ex.message***REMOVED***`;
                throw ex;
            ***REMOVED***

        ***REMOVED*** else ***REMOVED***
            return null;
        ***REMOVED***
    ***REMOVED***
***REMOVED***

CLIEngine.version = pkg.version;
CLIEngine.getFormatter = CLIEngine.prototype.getFormatter;

module.exports = ***REMOVED***
    CLIEngine,

    /**
     * Get the internal slots of a given CLIEngine instance for tests.
     * @param ***REMOVED***CLIEngine***REMOVED*** instance The CLIEngine instance to get.
     * @returns ***REMOVED***CLIEngineInternalSlots***REMOVED*** The internal slots.
     */
    getCLIEngineInternalSlots(instance) ***REMOVED***
        return internalSlotsMap.get(instance);
    ***REMOVED***
***REMOVED***;
