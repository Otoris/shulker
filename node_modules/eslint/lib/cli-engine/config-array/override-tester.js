/**
 * @fileoverview `OverrideTester` class.
 *
 * `OverrideTester` class handles `files` property and `excludedFiles` property
 * of `overrides` config.
 *
 * It provides one method.
 *
 * - `test(filePath)`
 *      Test if a file path matches the pair of `files` property and
 *      `excludedFiles` property. The `filePath` argument must be an absolute
 *      path.
 *
 * `ConfigArrayFactory` creates `OverrideTester` objects when it processes
 * `overrides` properties.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict";

const assert = require("assert");
const path = require("path");
const util = require("util");
const ***REMOVED*** Minimatch ***REMOVED*** = require("minimatch");
const minimatchOpts = ***REMOVED*** dot: true, matchBase: true ***REMOVED***;

/**
 * @typedef ***REMOVED***Object***REMOVED*** Pattern
 * @property ***REMOVED***InstanceType<Minimatch>[] | null***REMOVED*** includes The positive matchers.
 * @property ***REMOVED***InstanceType<Minimatch>[] | null***REMOVED*** excludes The negative matchers.
 */

/**
 * Normalize a given pattern to an array.
 * @param ***REMOVED***string|string[]|undefined***REMOVED*** patterns A glob pattern or an array of glob patterns.
 * @returns ***REMOVED***string[]|null***REMOVED*** Normalized patterns.
 * @private
 */
function normalizePatterns(patterns) ***REMOVED***
    if (Array.isArray(patterns)) ***REMOVED***
        return patterns.filter(Boolean);
    ***REMOVED***
    if (typeof patterns === "string" && patterns) ***REMOVED***
        return [patterns];
    ***REMOVED***
    return [];
***REMOVED***

/**
 * Create the matchers of given patterns.
 * @param ***REMOVED***string[]***REMOVED*** patterns The patterns.
 * @returns ***REMOVED***InstanceType<Minimatch>[] | null***REMOVED*** The matchers.
 */
function toMatcher(patterns) ***REMOVED***
    if (patterns.length === 0) ***REMOVED***
        return null;
    ***REMOVED***
    return patterns.map(pattern => ***REMOVED***
        if (/^\.[/\\]/u.test(pattern)) ***REMOVED***
            return new Minimatch(
                pattern.slice(2),

                // `./*.js` should not match with `subdir/foo.js`
                ***REMOVED*** ...minimatchOpts, matchBase: false ***REMOVED***
            );
        ***REMOVED***
        return new Minimatch(pattern, minimatchOpts);
    ***REMOVED***);
***REMOVED***

/**
 * Convert a given matcher to string.
 * @param ***REMOVED***Pattern***REMOVED*** matchers The matchers.
 * @returns ***REMOVED***string***REMOVED*** The string expression of the matcher.
 */
function patternToJson(***REMOVED*** includes, excludes ***REMOVED***) ***REMOVED***
    return ***REMOVED***
        includes: includes && includes.map(m => m.pattern),
        excludes: excludes && excludes.map(m => m.pattern)
    ***REMOVED***;
***REMOVED***

/**
 * The class to test given paths are matched by the patterns.
 */
class OverrideTester ***REMOVED***

    /**
     * Create a tester with given criteria.
     * If there are no criteria, returns `null`.
     * @param ***REMOVED***string|string[]***REMOVED*** files The glob patterns for included files.
     * @param ***REMOVED***string|string[]***REMOVED*** excludedFiles The glob patterns for excluded files.
     * @param ***REMOVED***string***REMOVED*** basePath The path to the base directory to test paths.
     * @returns ***REMOVED***OverrideTester|null***REMOVED*** The created instance or `null`.
     */
    static create(files, excludedFiles, basePath) ***REMOVED***
        const includePatterns = normalizePatterns(files);
        const excludePatterns = normalizePatterns(excludedFiles);
        const allPatterns = includePatterns.concat(excludePatterns);

        if (allPatterns.length === 0) ***REMOVED***
            return null;
        ***REMOVED***

        // Rejects absolute paths or relative paths to parents.
        for (const pattern of allPatterns) ***REMOVED***
            if (path.isAbsolute(pattern) || pattern.includes("..")) ***REMOVED***
                throw new Error(`Invalid override pattern (expected relative path not containing '..'): $***REMOVED***pattern***REMOVED***`);
            ***REMOVED***
        ***REMOVED***

        const includes = toMatcher(includePatterns);
        const excludes = toMatcher(excludePatterns);

        return new OverrideTester([***REMOVED*** includes, excludes ***REMOVED***], basePath);
    ***REMOVED***

    /**
     * Combine two testers by logical and.
     * If either of the testers was `null`, returns the other tester.
     * The `basePath` property of the two must be the same value.
     * @param ***REMOVED***OverrideTester|null***REMOVED*** a A tester.
     * @param ***REMOVED***OverrideTester|null***REMOVED*** b Another tester.
     * @returns ***REMOVED***OverrideTester|null***REMOVED*** Combined tester.
     */
    static and(a, b) ***REMOVED***
        if (!b) ***REMOVED***
            return a && new OverrideTester(a.patterns, a.basePath);
        ***REMOVED***
        if (!a) ***REMOVED***
            return new OverrideTester(b.patterns, b.basePath);
        ***REMOVED***

        assert.strictEqual(a.basePath, b.basePath);
        return new OverrideTester(a.patterns.concat(b.patterns), a.basePath);
    ***REMOVED***

    /**
     * Initialize this instance.
     * @param ***REMOVED***Pattern[]***REMOVED*** patterns The matchers.
     * @param ***REMOVED***string***REMOVED*** basePath The base path.
     */
    constructor(patterns, basePath) ***REMOVED***

        /** @type ***REMOVED***Pattern[]***REMOVED*** */
        this.patterns = patterns;

        /** @type ***REMOVED***string***REMOVED*** */
        this.basePath = basePath;
    ***REMOVED***

    /**
     * Test if a given path is matched or not.
     * @param ***REMOVED***string***REMOVED*** filePath The absolute path to the target file.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the path was matched.
     */
    test(filePath) ***REMOVED***
        if (typeof filePath !== "string" || !path.isAbsolute(filePath)) ***REMOVED***
            throw new Error(`'filePath' should be an absolute path, but got $***REMOVED***filePath***REMOVED***.`);
        ***REMOVED***
        const relativePath = path.relative(this.basePath, filePath);

        return this.patterns.every((***REMOVED*** includes, excludes ***REMOVED***) => (
            (!includes || includes.some(m => m.match(relativePath))) &&
            (!excludes || !excludes.some(m => m.match(relativePath)))
        ));
    ***REMOVED***

    /**
     * @returns ***REMOVED***Object***REMOVED*** a JSON compatible object.
     */
    toJSON() ***REMOVED***
        if (this.patterns.length === 1) ***REMOVED***
            return ***REMOVED***
                ...patternToJson(this.patterns[0]),
                basePath: this.basePath
            ***REMOVED***;
        ***REMOVED***
        return ***REMOVED***
            AND: this.patterns.map(patternToJson),
            basePath: this.basePath
        ***REMOVED***;
    ***REMOVED***

    /**
     * @returns ***REMOVED***Object***REMOVED*** an object to display by `console.log()`.
     */
    [util.inspect.custom]() ***REMOVED***
        return this.toJSON();
    ***REMOVED***
***REMOVED***

module.exports = ***REMOVED*** OverrideTester ***REMOVED***;
