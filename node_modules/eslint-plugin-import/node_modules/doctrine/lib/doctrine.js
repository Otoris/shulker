/*
 * @fileoverview Main Doctrine object
 * @author Yusuke Suzuki <utatane.tea@gmail.com>
 * @author Dan Tao <daniel.tao@gmail.com>
 * @author Andrew Eisenberg <andrew@eisenberg.as>
 */

(function () ***REMOVED***
    'use strict';

    var typed,
        utility,
        isArray,
        jsdoc,
        esutils,
        hasOwnProperty;

    esutils = require('esutils');
    isArray = require('isarray');
    typed = require('./typed');
    utility = require('./utility');

    function sliceSource(source, index, last) ***REMOVED***
        return source.slice(index, last);
    ***REMOVED***

    hasOwnProperty = (function () ***REMOVED***
        var func = Object.prototype.hasOwnProperty;
        return function hasOwnProperty(obj, name) ***REMOVED***
            return func.call(obj, name);
        ***REMOVED***;
    ***REMOVED***());

    function shallowCopy(obj) ***REMOVED***
        var ret = ***REMOVED******REMOVED***, key;
        for (key in obj) ***REMOVED***
            if (obj.hasOwnProperty(key)) ***REMOVED***
                ret[key] = obj[key];
            ***REMOVED***
        ***REMOVED***
        return ret;
    ***REMOVED***

    function isASCIIAlphanumeric(ch) ***REMOVED***
        return (ch >= 0x61  /* 'a' */ && ch <= 0x7A  /* 'z' */) ||
            (ch >= 0x41  /* 'A' */ && ch <= 0x5A  /* 'Z' */) ||
            (ch >= 0x30  /* '0' */ && ch <= 0x39  /* '9' */);
    ***REMOVED***

    function isParamTitle(title) ***REMOVED***
        return title === 'param' || title === 'argument' || title === 'arg';
    ***REMOVED***

    function isReturnTitle(title) ***REMOVED***
        return title === 'return' || title === 'returns';
    ***REMOVED***

    function isProperty(title) ***REMOVED***
        return title === 'property' || title === 'prop';
    ***REMOVED***

    function isNameParameterRequired(title) ***REMOVED***
        return isParamTitle(title) || isProperty(title) ||
            title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';
    ***REMOVED***

    function isAllowedName(title) ***REMOVED***
        return isNameParameterRequired(title) || title === 'const' || title === 'constant';
    ***REMOVED***

    function isAllowedNested(title) ***REMOVED***
        return isProperty(title) || isParamTitle(title);
    ***REMOVED***

    function isAllowedOptional(title) ***REMOVED***
        return isProperty(title) || isParamTitle(title);
    ***REMOVED***

    function isTypeParameterRequired(title) ***REMOVED***
        return isParamTitle(title) || isReturnTitle(title) ||
            title === 'define' || title === 'enum' ||
            title === 'implements' || title === 'this' ||
            title === 'type' || title === 'typedef' || isProperty(title);
    ***REMOVED***

    // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required
    // This would require changes to 'parseType'
    function isAllowedType(title) ***REMOVED***
        return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' ||
            title === 'namespace' || title === 'member' || title === 'var' || title === 'module' ||
            title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' ||
            title === 'public' || title === 'private' || title === 'protected';
    ***REMOVED***

    function trim(str) ***REMOVED***
        return str.replace(/^\s+/, '').replace(/\s+$/, '');
    ***REMOVED***

    function unwrapComment(doc) ***REMOVED***
        // JSDoc comment is following form
        //   /**
        //    * .......
        //    */
        // remove /**, */ and *
        var BEFORE_STAR = 0,
            STAR = 1,
            AFTER_STAR = 2,
            index,
            len,
            mode,
            result,
            ch;

        doc = doc.replace(/^\/\*\*?/, '').replace(/\*\/$/, '');
        index = 0;
        len = doc.length;
        mode = BEFORE_STAR;
        result = '';

        while (index < len) ***REMOVED***
            ch = doc.charCodeAt(index);
            switch (mode) ***REMOVED***
            case BEFORE_STAR:
                if (esutils.code.isLineTerminator(ch)) ***REMOVED***
                    result += String.fromCharCode(ch);
                ***REMOVED*** else if (ch === 0x2A  /* '*' */) ***REMOVED***
                    mode = STAR;
                ***REMOVED*** else if (!esutils.code.isWhiteSpace(ch)) ***REMOVED***
                    result += String.fromCharCode(ch);
                    mode = AFTER_STAR;
                ***REMOVED***
                break;

            case STAR:
                if (!esutils.code.isWhiteSpace(ch)) ***REMOVED***
                    result += String.fromCharCode(ch);
                ***REMOVED***
                mode = esutils.code.isLineTerminator(ch) ? BEFORE_STAR : AFTER_STAR;
                break;

            case AFTER_STAR:
                result += String.fromCharCode(ch);
                if (esutils.code.isLineTerminator(ch)) ***REMOVED***
                    mode = BEFORE_STAR;
                ***REMOVED***
                break;
            ***REMOVED***
            index += 1;
        ***REMOVED***

        return result.replace(/\s+$/, '');
    ***REMOVED***

    // JSDoc Tag Parser

    (function (exports) ***REMOVED***
        var Rules,
            index,
            lineNumber,
            length,
            source,
            recoverable,
            sloppy,
            strict;

        function advance() ***REMOVED***
            var ch = source.charCodeAt(index);
            index += 1;
            if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\r' */ && source.charCodeAt(index) === 0x0A  /* '\n' */)) ***REMOVED***
                lineNumber += 1;
            ***REMOVED***
            return String.fromCharCode(ch);
        ***REMOVED***

        function scanTitle() ***REMOVED***
            var title = '';
            // waste '@'
            advance();

            while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) ***REMOVED***
                title += advance();
            ***REMOVED***

            return title;
        ***REMOVED***

        function seekContent() ***REMOVED***
            var ch, waiting, last = index;

            waiting = false;
            while (last < length) ***REMOVED***
                ch = source.charCodeAt(last);
                if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\r' */ && source.charCodeAt(last + 1) === 0x0A  /* '\n' */)) ***REMOVED***
                    waiting = true;
                ***REMOVED*** else if (waiting) ***REMOVED***
                    if (ch === 0x40  /* '@' */) ***REMOVED***
                        break;
                    ***REMOVED***
                    if (!esutils.code.isWhiteSpace(ch)) ***REMOVED***
                        waiting = false;
                    ***REMOVED***
                ***REMOVED***
                last += 1;
            ***REMOVED***
            return last;
        ***REMOVED***

        // type expression may have nest brace, such as,
        // ***REMOVED*** ***REMOVED*** ok: string ***REMOVED*** ***REMOVED***
        //
        // therefore, scanning type expression with balancing braces.
        function parseType(title, last) ***REMOVED***
            var ch, brace, type, direct = false;


            // search '***REMOVED***'
            while (index < last) ***REMOVED***
                ch = source.charCodeAt(index);
                if (esutils.code.isWhiteSpace(ch)) ***REMOVED***
                    advance();
                ***REMOVED*** else if (ch === 0x7B  /* '***REMOVED***' */) ***REMOVED***
                    advance();
                    break;
                ***REMOVED*** else ***REMOVED***
                    // this is direct pattern
                    direct = true;
                    break;
                ***REMOVED***
            ***REMOVED***


            if (direct) ***REMOVED***
                return null;
            ***REMOVED***

            // type expression ***REMOVED*** is found
            brace = 1;
            type = '';
            while (index < last) ***REMOVED***
                ch = source.charCodeAt(index);
                if (esutils.code.isLineTerminator(ch)) ***REMOVED***
                    advance();
                ***REMOVED*** else ***REMOVED***
                    if (ch === 0x7D  /* '***REMOVED***' */) ***REMOVED***
                        brace -= 1;
                        if (brace === 0) ***REMOVED***
                            advance();
                            break;
                        ***REMOVED***
                    ***REMOVED*** else if (ch === 0x7B  /* '***REMOVED***' */) ***REMOVED***
                        brace += 1;
                    ***REMOVED***
                    type += advance();
                ***REMOVED***
            ***REMOVED***

            if (brace !== 0) ***REMOVED***
                // braces is not balanced
                return utility.throwError('Braces are not balanced');
            ***REMOVED***

            if (isAllowedOptional(title)) ***REMOVED***
                return typed.parseParamType(type);
            ***REMOVED***

            return typed.parseType(type);
        ***REMOVED***

        function scanIdentifier(last) ***REMOVED***
            var identifier;
            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index))) ***REMOVED***
                return null;
            ***REMOVED***
            identifier = advance();
            while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) ***REMOVED***
                identifier += advance();
            ***REMOVED***
            return identifier;
        ***REMOVED***

        function skipWhiteSpace(last) ***REMOVED***
            while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) ***REMOVED***
                advance();
            ***REMOVED***
        ***REMOVED***

        function parseName(last, allowBrackets, allowNestedParams) ***REMOVED***
            var name = '',
                useBrackets,
                insideString;


            skipWhiteSpace(last);

            if (index >= last) ***REMOVED***
                return null;
            ***REMOVED***

            if (allowBrackets && source.charCodeAt(index) === 0x5B  /* '[' */) ***REMOVED***
                useBrackets = true;
                name = advance();
            ***REMOVED***

            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index))) ***REMOVED***
                return null;
            ***REMOVED***

            name += scanIdentifier(last);

            if (allowNestedParams) ***REMOVED***
                if (source.charCodeAt(index) === 0x3A /* ':' */ && (
                        name === 'module' ||
                        name === 'external' ||
                        name === 'event')) ***REMOVED***
                    name += advance();
                    name += scanIdentifier(last);

                ***REMOVED***
                if(source.charCodeAt(index) === 0x5B  /* '[' */ && source.charCodeAt(index + 1) === 0x5D  /* ']' */)***REMOVED***
                    name += advance();
                    name += advance();
                ***REMOVED***
                while (source.charCodeAt(index) === 0x2E  /* '.' */ ||
                        source.charCodeAt(index) === 0x2F  /* '/' */ ||
                        source.charCodeAt(index) === 0x23  /* '#' */ ||
                        source.charCodeAt(index) === 0x2D  /* '-' */ ||
                        source.charCodeAt(index) === 0x7E  /* '~' */) ***REMOVED***
                    name += advance();
                    name += scanIdentifier(last);
                ***REMOVED***
            ***REMOVED***

            if (useBrackets) ***REMOVED***
                skipWhiteSpace(last);
                // do we have a default value for this?
                if (source.charCodeAt(index) === 0x3D  /* '=' */) ***REMOVED***
                    // consume the '='' symbol
                    name += advance();
                    skipWhiteSpace(last);

                    var ch;
                    var bracketDepth = 1;

                    // scan in the default value
                    while (index < last) ***REMOVED***
                        ch = source.charCodeAt(index);

                        if (esutils.code.isWhiteSpace(ch)) ***REMOVED***
                            if (!insideString) ***REMOVED***
                                skipWhiteSpace(last);
                                ch = source.charCodeAt(index);
                            ***REMOVED***
                        ***REMOVED***

                        if (ch === 0x27 /* ''' */) ***REMOVED***
                            if (!insideString) ***REMOVED***
                                insideString = '\'';
                            ***REMOVED*** else ***REMOVED***
                                if (insideString === '\'') ***REMOVED***
                                    insideString = '';
                                ***REMOVED***
                            ***REMOVED***
                        ***REMOVED***

                        if (ch === 0x22 /* '"' */) ***REMOVED***
                            if (!insideString) ***REMOVED***
                                insideString = '"';
                            ***REMOVED*** else ***REMOVED***
                                if (insideString === '"') ***REMOVED***
                                    insideString = '';
                                ***REMOVED***
                            ***REMOVED***
                        ***REMOVED***

                        if (ch === 0x5B /* '[' */) ***REMOVED***
                            bracketDepth++;
                        ***REMOVED*** else if (ch === 0x5D  /* ']' */ &&
                            --bracketDepth === 0) ***REMOVED***
                            break;
                        ***REMOVED***

                        name += advance();
                    ***REMOVED***
                ***REMOVED***

                skipWhiteSpace(last);

                if (index >= last || source.charCodeAt(index) !== 0x5D  /* ']' */) ***REMOVED***
                    // we never found a closing ']'
                    return null;
                ***REMOVED***

                // collect the last ']'
                name += advance();
            ***REMOVED***

            return name;
        ***REMOVED***

        function skipToTag() ***REMOVED***
            while (index < length && source.charCodeAt(index) !== 0x40  /* '@' */) ***REMOVED***
                advance();
            ***REMOVED***
            if (index >= length) ***REMOVED***
                return false;
            ***REMOVED***
            utility.assert(source.charCodeAt(index) === 0x40  /* '@' */);
            return true;
        ***REMOVED***

        function TagParser(options, title) ***REMOVED***
            this._options = options;
            this._title = title.toLowerCase();
            this._tag = ***REMOVED***
                title: title,
                description: null
            ***REMOVED***;
            if (this._options.lineNumbers) ***REMOVED***
                this._tag.lineNumber = lineNumber;
            ***REMOVED***
            this._last = 0;
            // space to save special information for title parsers.
            this._extra = ***REMOVED*** ***REMOVED***;
        ***REMOVED***

        // addError(err, ...)
        TagParser.prototype.addError = function addError(errorText) ***REMOVED***
            var args = Array.prototype.slice.call(arguments, 1),
                msg = errorText.replace(
                    /%(\d)/g,
                    function (whole, index) ***REMOVED***
                        utility.assert(index < args.length, 'Message reference must be in range');
                        return args[index];
                    ***REMOVED***
                );

            if (!this._tag.errors) ***REMOVED***
                this._tag.errors = [];
            ***REMOVED***
            if (strict) ***REMOVED***
                utility.throwError(msg);
            ***REMOVED***
            this._tag.errors.push(msg);
            return recoverable;
        ***REMOVED***;

        TagParser.prototype.parseType = function () ***REMOVED***
            // type required titles
            if (isTypeParameterRequired(this._title)) ***REMOVED***
                try ***REMOVED***
                    this._tag.type = parseType(this._title, this._last);
                    if (!this._tag.type) ***REMOVED***
                        if (!isParamTitle(this._title) && !isReturnTitle(this._title)) ***REMOVED***
                            if (!this.addError('Missing or invalid tag type')) ***REMOVED***
                                return false;
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED*** catch (error) ***REMOVED***
                    this._tag.type = null;
                    if (!this.addError(error.message)) ***REMOVED***
                        return false;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED*** else if (isAllowedType(this._title)) ***REMOVED***
                // optional types
                try ***REMOVED***
                    this._tag.type = parseType(this._title, this._last);
                ***REMOVED*** catch (e) ***REMOVED***
                    //For optional types, lets drop the thrown error when we hit the end of the file
                ***REMOVED***
            ***REMOVED***
            return true;
        ***REMOVED***;

        TagParser.prototype._parseNamePath = function (optional) ***REMOVED***
            var name;
            name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);
            if (!name) ***REMOVED***
                if (!optional) ***REMOVED***
                    if (!this.addError('Missing or invalid tag name')) ***REMOVED***
                        return false;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            this._tag.name = name;
            return true;
        ***REMOVED***;

        TagParser.prototype.parseNamePath = function () ***REMOVED***
            return this._parseNamePath(false);
        ***REMOVED***;

        TagParser.prototype.parseNamePathOptional = function () ***REMOVED***
            return this._parseNamePath(true);
        ***REMOVED***;


        TagParser.prototype.parseName = function () ***REMOVED***
            var assign, name;

            // param, property requires name
            if (isAllowedName(this._title)) ***REMOVED***
                this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));
                if (!this._tag.name) ***REMOVED***
                    if (!isNameParameterRequired(this._title)) ***REMOVED***
                        return true;
                    ***REMOVED***

                    // it's possible the name has already been parsed but interpreted as a type
                    // it's also possible this is a sloppy declaration, in which case it will be
                    // fixed at the end
                    if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) ***REMOVED***
                        this._extra.name = this._tag.type;
                        this._tag.name = this._tag.type.name;
                        this._tag.type = null;
                    ***REMOVED*** else ***REMOVED***
                        if (!this.addError('Missing or invalid tag name')) ***REMOVED***
                            return false;
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED*** else ***REMOVED***
                    name = this._tag.name;
                    if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') ***REMOVED***
                        // extract the default value if there is one
                        // example: @param ***REMOVED***string***REMOVED*** [somebody=John Doe] description
                        assign = name.substring(1, name.length - 1).split('=');
                        if (assign[1]) ***REMOVED***
                            this._tag['default'] = assign[1];
                        ***REMOVED***
                        this._tag.name = assign[0];

                        // convert to an optional type
                        if (this._tag.type && this._tag.type.type !== 'OptionalType') ***REMOVED***
                            this._tag.type = ***REMOVED***
                                type: 'OptionalType',
                                expression: this._tag.type
                            ***REMOVED***;
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***


            return true;
        ***REMOVED***;

        TagParser.prototype.parseDescription = function parseDescription() ***REMOVED***
            var description = trim(sliceSource(source, index, this._last));
            if (description) ***REMOVED***
                if ((/^-\s+/).test(description)) ***REMOVED***
                    description = description.substring(2);
                ***REMOVED***
                this._tag.description = description;
            ***REMOVED***
            return true;
        ***REMOVED***;

        TagParser.prototype.parseCaption = function parseDescription() ***REMOVED***
            var description = trim(sliceSource(source, index, this._last));
            var captionStartTag = '<caption>';
            var captionEndTag = '</caption>';
            var captionStart = description.indexOf(captionStartTag);
            var captionEnd = description.indexOf(captionEndTag);
            if (captionStart >= 0 && captionEnd >= 0) ***REMOVED***
                this._tag.caption = trim(description.substring(
                    captionStart + captionStartTag.length, captionEnd));
                this._tag.description = trim(description.substring(captionEnd + captionEndTag.length));
            ***REMOVED*** else ***REMOVED***
                this._tag.description = description;
            ***REMOVED***
            return true;
        ***REMOVED***;

        TagParser.prototype.parseKind = function parseKind() ***REMOVED***
            var kind, kinds;
            kinds = ***REMOVED***
                'class': true,
                'constant': true,
                'event': true,
                'external': true,
                'file': true,
                'function': true,
                'member': true,
                'mixin': true,
                'module': true,
                'namespace': true,
                'typedef': true
            ***REMOVED***;
            kind = trim(sliceSource(source, index, this._last));
            this._tag.kind = kind;
            if (!hasOwnProperty(kinds, kind)) ***REMOVED***
                if (!this.addError('Invalid kind name \'%0\'', kind)) ***REMOVED***
                    return false;
                ***REMOVED***
            ***REMOVED***
            return true;
        ***REMOVED***;

        TagParser.prototype.parseAccess = function parseAccess() ***REMOVED***
            var access;
            access = trim(sliceSource(source, index, this._last));
            this._tag.access = access;
            if (access !== 'private' && access !== 'protected' && access !== 'public') ***REMOVED***
                if (!this.addError('Invalid access name \'%0\'', access)) ***REMOVED***
                    return false;
                ***REMOVED***
            ***REMOVED***
            return true;
        ***REMOVED***;

        TagParser.prototype.parseThis = function parseAccess() ***REMOVED***
            // this name may be a name expression (e.g. ***REMOVED***foo.bar***REMOVED***)
            // or a name path (e.g. foo.bar)
            var value = trim(sliceSource(source, index, this._last));
            if (value && value.charAt(0) === '***REMOVED***') ***REMOVED***
                var gotType = this.parseType();
                if (gotType && this._tag.type.type === 'NameExpression') ***REMOVED***
                    this._tag.name = this._tag.type.name;
                    return true;
                ***REMOVED*** else ***REMOVED***
                    return this.addError('Invalid name for this');
                ***REMOVED***
            ***REMOVED*** else ***REMOVED***
                return this.parseNamePath();
            ***REMOVED***
        ***REMOVED***;

        TagParser.prototype.parseVariation = function parseVariation() ***REMOVED***
            var variation, text;
            text = trim(sliceSource(source, index, this._last));
            variation = parseFloat(text, 10);
            this._tag.variation = variation;
            if (isNaN(variation)) ***REMOVED***
                if (!this.addError('Invalid variation \'%0\'', text)) ***REMOVED***
                    return false;
                ***REMOVED***
            ***REMOVED***
            return true;
        ***REMOVED***;

        TagParser.prototype.ensureEnd = function () ***REMOVED***
            var shouldBeEmpty = trim(sliceSource(source, index, this._last));
            if (shouldBeEmpty) ***REMOVED***
                if (!this.addError('Unknown content \'%0\'', shouldBeEmpty)) ***REMOVED***
                    return false;
                ***REMOVED***
            ***REMOVED***
            return true;
        ***REMOVED***;

        TagParser.prototype.epilogue = function epilogue() ***REMOVED***
            var description;

            description = this._tag.description;
            // un-fix potentially sloppy declaration
            if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') ***REMOVED***
                this._tag.type = this._extra.name;
                if (!this._tag.name) ***REMOVED***
                    this._tag.name = undefined;
                ***REMOVED***

                if (!sloppy) ***REMOVED***
                    if (!this.addError('Missing or invalid tag name')) ***REMOVED***
                        return false;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***

            return true;
        ***REMOVED***;

        Rules = ***REMOVED***
            // http://usejsdoc.org/tags-access.html
            'access': ['parseAccess'],
            // http://usejsdoc.org/tags-alias.html
            'alias': ['parseNamePath', 'ensureEnd'],
            // http://usejsdoc.org/tags-augments.html
            'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            // http://usejsdoc.org/tags-constructor.html
            'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            // Synonym: http://usejsdoc.org/tags-constructor.html
            'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            // Synonym: http://usejsdoc.org/tags-extends.html
            'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            // http://usejsdoc.org/tags-example.html
            'example': ['parseCaption'],
            // http://usejsdoc.org/tags-deprecated.html
            'deprecated': ['parseDescription'],
            // http://usejsdoc.org/tags-global.html
            'global': ['ensureEnd'],
            // http://usejsdoc.org/tags-inner.html
            'inner': ['ensureEnd'],
            // http://usejsdoc.org/tags-instance.html
            'instance': ['ensureEnd'],
            // http://usejsdoc.org/tags-kind.html
            'kind': ['parseKind'],
            // http://usejsdoc.org/tags-mixes.html
            'mixes': ['parseNamePath', 'ensureEnd'],
            // http://usejsdoc.org/tags-mixin.html
            'mixin': ['parseNamePathOptional', 'ensureEnd'],
            // http://usejsdoc.org/tags-member.html
            'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            // http://usejsdoc.org/tags-method.html
            'method': ['parseNamePathOptional', 'ensureEnd'],
            // http://usejsdoc.org/tags-module.html
            'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            // Synonym: http://usejsdoc.org/tags-method.html
            'func': ['parseNamePathOptional', 'ensureEnd'],
            // Synonym: http://usejsdoc.org/tags-method.html
            'function': ['parseNamePathOptional', 'ensureEnd'],
            // Synonym: http://usejsdoc.org/tags-member.html
            'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            // http://usejsdoc.org/tags-name.html
            'name': ['parseNamePath', 'ensureEnd'],
            // http://usejsdoc.org/tags-namespace.html
            'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
            // http://usejsdoc.org/tags-private.html
            'private': ['parseType', 'parseDescription'],
            // http://usejsdoc.org/tags-protected.html
            'protected': ['parseType', 'parseDescription'],
            // http://usejsdoc.org/tags-public.html
            'public': ['parseType', 'parseDescription'],
            // http://usejsdoc.org/tags-readonly.html
            'readonly': ['ensureEnd'],
            // http://usejsdoc.org/tags-requires.html
            'requires': ['parseNamePath', 'ensureEnd'],
            // http://usejsdoc.org/tags-since.html
            'since': ['parseDescription'],
            // http://usejsdoc.org/tags-static.html
            'static': ['ensureEnd'],
            // http://usejsdoc.org/tags-summary.html
            'summary': ['parseDescription'],
            // http://usejsdoc.org/tags-this.html
            'this': ['parseThis', 'ensureEnd'],
            // http://usejsdoc.org/tags-todo.html
            'todo': ['parseDescription'],
            // http://usejsdoc.org/tags-typedef.html
            'typedef': ['parseType', 'parseNamePathOptional'],
            // http://usejsdoc.org/tags-variation.html
            'variation': ['parseVariation'],
            // http://usejsdoc.org/tags-version.html
            'version': ['parseDescription']
        ***REMOVED***;

        TagParser.prototype.parse = function parse() ***REMOVED***
            var i, iz, sequences, method;


            // empty title
            if (!this._title) ***REMOVED***
                if (!this.addError('Missing or invalid title')) ***REMOVED***
                    return null;
                ***REMOVED***
            ***REMOVED***

            // Seek to content last index.
            this._last = seekContent(this._title);

            if (hasOwnProperty(Rules, this._title)) ***REMOVED***
                sequences = Rules[this._title];
            ***REMOVED*** else ***REMOVED***
                // default sequences
                sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];
            ***REMOVED***

            for (i = 0, iz = sequences.length; i < iz; ++i) ***REMOVED***
                method = sequences[i];
                if (!this[method]()) ***REMOVED***
                    return null;
                ***REMOVED***
            ***REMOVED***

            return this._tag;
        ***REMOVED***;

        function parseTag(options) ***REMOVED***
            var title, parser, tag;

            // skip to tag
            if (!skipToTag()) ***REMOVED***
                return null;
            ***REMOVED***

            // scan title
            title = scanTitle();

            // construct tag parser
            parser = new TagParser(options, title);
            tag = parser.parse();

            // Seek global index to end of this tag.
            while (index < parser._last) ***REMOVED***
                advance();
            ***REMOVED***

            return tag;
        ***REMOVED***

        //
        // Parse JSDoc
        //

        function scanJSDocDescription(preserveWhitespace) ***REMOVED***
            var description = '', ch, atAllowed;

            atAllowed = true;
            while (index < length) ***REMOVED***
                ch = source.charCodeAt(index);

                if (atAllowed && ch === 0x40  /* '@' */) ***REMOVED***
                    break;
                ***REMOVED***

                if (esutils.code.isLineTerminator(ch)) ***REMOVED***
                    atAllowed = true;
                ***REMOVED*** else if (atAllowed && !esutils.code.isWhiteSpace(ch)) ***REMOVED***
                    atAllowed = false;
                ***REMOVED***

                description += advance();
            ***REMOVED***

            return preserveWhitespace ? description : trim(description);
        ***REMOVED***

        function parse(comment, options) ***REMOVED***
            var tags = [], tag, description, interestingTags, i, iz;

            if (options === undefined) ***REMOVED***
                options = ***REMOVED******REMOVED***;
            ***REMOVED***

            if (typeof options.unwrap === 'boolean' && options.unwrap) ***REMOVED***
                source = unwrapComment(comment);
            ***REMOVED*** else ***REMOVED***
                source = comment;
            ***REMOVED***

            // array of relevant tags
            if (options.tags) ***REMOVED***
                if (isArray(options.tags)) ***REMOVED***
                    interestingTags = ***REMOVED*** ***REMOVED***;
                    for (i = 0, iz = options.tags.length; i < iz; i++) ***REMOVED***
                        if (typeof options.tags[i] === 'string') ***REMOVED***
                            interestingTags[options.tags[i]] = true;
                        ***REMOVED*** else ***REMOVED***
                            utility.throwError('Invalid "tags" parameter: ' + options.tags);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED*** else ***REMOVED***
                    utility.throwError('Invalid "tags" parameter: ' + options.tags);
                ***REMOVED***
            ***REMOVED***

            length = source.length;
            index = 0;
            lineNumber = 0;
            recoverable = options.recoverable;
            sloppy = options.sloppy;
            strict = options.strict;

            description = scanJSDocDescription(options.preserveWhitespace);

            while (true) ***REMOVED***
                tag = parseTag(options);
                if (!tag) ***REMOVED***
                    break;
                ***REMOVED***
                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) ***REMOVED***
                    tags.push(tag);
                ***REMOVED***
            ***REMOVED***

            return ***REMOVED***
                description: description,
                tags: tags
            ***REMOVED***;
        ***REMOVED***
        exports.parse = parse;
    ***REMOVED***(jsdoc = ***REMOVED******REMOVED***));

    exports.version = utility.VERSION;
    exports.parse = jsdoc.parse;
    exports.parseType = typed.parseType;
    exports.parseParamType = typed.parseParamType;
    exports.unwrapComment = unwrapComment;
    exports.Syntax = shallowCopy(typed.Syntax);
    exports.Error = utility.DoctrineError;
    exports.type = ***REMOVED***
        Syntax: exports.Syntax,
        parseType: typed.parseType,
        parseParamType: typed.parseParamType,
        stringify: typed.stringify
    ***REMOVED***;
***REMOVED***());
/* vim: set sw=4 ts=4 et tw=80 : */
