"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
const ts = require("typescript");
function isAccessorDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.GetAccessor ||
        node.kind === ts.SyntaxKind.SetAccessor;
***REMOVED***
exports.isAccessorDeclaration = isAccessorDeclaration;
function isArrayBindingPattern(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ArrayBindingPattern;
***REMOVED***
exports.isArrayBindingPattern = isArrayBindingPattern;
function isArrayLiteralExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ArrayLiteralExpression;
***REMOVED***
exports.isArrayLiteralExpression = isArrayLiteralExpression;
function isArrayTypeNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ArrayType;
***REMOVED***
exports.isArrayTypeNode = isArrayTypeNode;
function isArrowFunction(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ArrowFunction;
***REMOVED***
exports.isArrowFunction = isArrowFunction;
function isAsExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.AsExpression;
***REMOVED***
exports.isAsExpression = isAsExpression;
function isAssertionExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.AsExpression ||
        node.kind === ts.SyntaxKind.TypeAssertionExpression;
***REMOVED***
exports.isAssertionExpression = isAssertionExpression;
function isAwaitExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.AwaitExpression;
***REMOVED***
exports.isAwaitExpression = isAwaitExpression;
function isBinaryExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.BinaryExpression;
***REMOVED***
exports.isBinaryExpression = isBinaryExpression;
function isBindingElement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.BindingElement;
***REMOVED***
exports.isBindingElement = isBindingElement;
function isBindingPattern(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ArrayBindingPattern ||
        node.kind === ts.SyntaxKind.ObjectBindingPattern;
***REMOVED***
exports.isBindingPattern = isBindingPattern;
function isBlock(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.Block;
***REMOVED***
exports.isBlock = isBlock;
function isBlockLike(node) ***REMOVED***
    return node.statements !== undefined;
***REMOVED***
exports.isBlockLike = isBlockLike;
function isBooleanLiteral(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TrueKeyword || node.kind === ts.SyntaxKind.FalseKeyword;
***REMOVED***
exports.isBooleanLiteral = isBooleanLiteral;
function isBreakOrContinueStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.BreakStatement ||
        node.kind === ts.SyntaxKind.ContinueStatement;
***REMOVED***
exports.isBreakOrContinueStatement = isBreakOrContinueStatement;
function isBreakStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.BreakStatement;
***REMOVED***
exports.isBreakStatement = isBreakStatement;
function isCallExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.CallExpression;
***REMOVED***
exports.isCallExpression = isCallExpression;
function isCallLikeExpression(node) ***REMOVED***
    switch (node.kind) ***REMOVED***
        case ts.SyntaxKind.CallExpression:
        case ts.SyntaxKind.Decorator:
        case ts.SyntaxKind.JsxOpeningElement:
        case ts.SyntaxKind.JsxSelfClosingElement:
        case ts.SyntaxKind.NewExpression:
        case ts.SyntaxKind.TaggedTemplateExpression:
            return true;
        default:
            return false;
    ***REMOVED***
***REMOVED***
exports.isCallLikeExpression = isCallLikeExpression;
function isCallSignatureDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.CallSignature;
***REMOVED***
exports.isCallSignatureDeclaration = isCallSignatureDeclaration;
function isCaseBlock(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.CaseBlock;
***REMOVED***
exports.isCaseBlock = isCaseBlock;
function isCaseClause(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.CaseClause;
***REMOVED***
exports.isCaseClause = isCaseClause;
function isCaseOrDefaultClause(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.CaseClause ||
        node.kind === ts.SyntaxKind.DefaultClause;
***REMOVED***
exports.isCaseOrDefaultClause = isCaseOrDefaultClause;
function isCatchClause(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.CatchClause;
***REMOVED***
exports.isCatchClause = isCatchClause;
function isClassDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ClassDeclaration;
***REMOVED***
exports.isClassDeclaration = isClassDeclaration;
function isClassExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ClassExpression;
***REMOVED***
exports.isClassExpression = isClassExpression;
function isClassLikeDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ClassDeclaration ||
        node.kind === ts.SyntaxKind.ClassExpression;
***REMOVED***
exports.isClassLikeDeclaration = isClassLikeDeclaration;
function isCommaListExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.CommaListExpression;
***REMOVED***
exports.isCommaListExpression = isCommaListExpression;
function isConditionalExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ConditionalExpression;
***REMOVED***
exports.isConditionalExpression = isConditionalExpression;
function isConditionalTypeNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ConditionalType;
***REMOVED***
exports.isConditionalTypeNode = isConditionalTypeNode;
function isConstructorDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.Constructor;
***REMOVED***
exports.isConstructorDeclaration = isConstructorDeclaration;
function isConstructorTypeNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ConstructorType;
***REMOVED***
exports.isConstructorTypeNode = isConstructorTypeNode;
function isConstructSignatureDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ConstructSignature;
***REMOVED***
exports.isConstructSignatureDeclaration = isConstructSignatureDeclaration;
function isContinueStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ContinueStatement;
***REMOVED***
exports.isContinueStatement = isContinueStatement;
function isComputedPropertyName(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ComputedPropertyName;
***REMOVED***
exports.isComputedPropertyName = isComputedPropertyName;
function isDebuggerStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.DebuggerStatement;
***REMOVED***
exports.isDebuggerStatement = isDebuggerStatement;
function isDecorator(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.Decorator;
***REMOVED***
exports.isDecorator = isDecorator;
function isDefaultClause(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.DefaultClause;
***REMOVED***
exports.isDefaultClause = isDefaultClause;
function isDeleteExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.DeleteExpression;
***REMOVED***
exports.isDeleteExpression = isDeleteExpression;
function isDoStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.DoStatement;
***REMOVED***
exports.isDoStatement = isDoStatement;
function isElementAccessExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ElementAccessExpression;
***REMOVED***
exports.isElementAccessExpression = isElementAccessExpression;
function isEmptyStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.EmptyStatement;
***REMOVED***
exports.isEmptyStatement = isEmptyStatement;
function isEntityName(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.Identifier || isQualifiedName(node);
***REMOVED***
exports.isEntityName = isEntityName;
function isEntityNameExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.Identifier ||
        isPropertyAccessExpression(node) && isEntityNameExpression(node.expression);
***REMOVED***
exports.isEntityNameExpression = isEntityNameExpression;
function isEnumDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.EnumDeclaration;
***REMOVED***
exports.isEnumDeclaration = isEnumDeclaration;
function isEnumMember(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.EnumMember;
***REMOVED***
exports.isEnumMember = isEnumMember;
function isExportAssignment(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ExportAssignment;
***REMOVED***
exports.isExportAssignment = isExportAssignment;
function isExportDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ExportDeclaration;
***REMOVED***
exports.isExportDeclaration = isExportDeclaration;
function isExportSpecifier(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ExportSpecifier;
***REMOVED***
exports.isExportSpecifier = isExportSpecifier;
function isExpression(node) ***REMOVED***
    switch (node.kind) ***REMOVED***
        case ts.SyntaxKind.ArrayLiteralExpression:
        case ts.SyntaxKind.ArrowFunction:
        case ts.SyntaxKind.AsExpression:
        case ts.SyntaxKind.AwaitExpression:
        case ts.SyntaxKind.BinaryExpression:
        case ts.SyntaxKind.CallExpression:
        case ts.SyntaxKind.ClassExpression:
        case ts.SyntaxKind.CommaListExpression:
        case ts.SyntaxKind.ConditionalExpression:
        case ts.SyntaxKind.DeleteExpression:
        case ts.SyntaxKind.ElementAccessExpression:
        case ts.SyntaxKind.FalseKeyword:
        case ts.SyntaxKind.FunctionExpression:
        case ts.SyntaxKind.Identifier:
        case ts.SyntaxKind.JsxElement:
        case ts.SyntaxKind.JsxFragment:
        case ts.SyntaxKind.JsxExpression:
        case ts.SyntaxKind.JsxOpeningElement:
        case ts.SyntaxKind.JsxOpeningFragment:
        case ts.SyntaxKind.JsxSelfClosingElement:
        case ts.SyntaxKind.MetaProperty:
        case ts.SyntaxKind.NewExpression:
        case ts.SyntaxKind.NonNullExpression:
        case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
        case ts.SyntaxKind.NullKeyword:
        case ts.SyntaxKind.NumericLiteral:
        case ts.SyntaxKind.ObjectLiteralExpression:
        case ts.SyntaxKind.OmittedExpression:
        case ts.SyntaxKind.ParenthesizedExpression:
        case ts.SyntaxKind.PostfixUnaryExpression:
        case ts.SyntaxKind.PrefixUnaryExpression:
        case ts.SyntaxKind.PropertyAccessExpression:
        case ts.SyntaxKind.RegularExpressionLiteral:
        case ts.SyntaxKind.SpreadElement:
        case ts.SyntaxKind.StringLiteral:
        case ts.SyntaxKind.SuperKeyword:
        case ts.SyntaxKind.TaggedTemplateExpression:
        case ts.SyntaxKind.TemplateExpression:
        case ts.SyntaxKind.ThisKeyword:
        case ts.SyntaxKind.TrueKeyword:
        case ts.SyntaxKind.TypeAssertionExpression:
        case ts.SyntaxKind.TypeOfExpression:
        case ts.SyntaxKind.VoidExpression:
        case ts.SyntaxKind.YieldExpression:
            return true;
        default:
            return false;
    ***REMOVED***
***REMOVED***
exports.isExpression = isExpression;
function isExpressionStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ExpressionStatement;
***REMOVED***
exports.isExpressionStatement = isExpressionStatement;
function isExpressionWithTypeArguments(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ExpressionWithTypeArguments;
***REMOVED***
exports.isExpressionWithTypeArguments = isExpressionWithTypeArguments;
function isExternalModuleReference(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ExternalModuleReference;
***REMOVED***
exports.isExternalModuleReference = isExternalModuleReference;
function isForInStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ForInStatement;
***REMOVED***
exports.isForInStatement = isForInStatement;
function isForInOrOfStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ForOfStatement || node.kind === ts.SyntaxKind.ForInStatement;
***REMOVED***
exports.isForInOrOfStatement = isForInOrOfStatement;
function isForOfStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ForOfStatement;
***REMOVED***
exports.isForOfStatement = isForOfStatement;
function isForStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ForStatement;
***REMOVED***
exports.isForStatement = isForStatement;
function isFunctionDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.FunctionDeclaration;
***REMOVED***
exports.isFunctionDeclaration = isFunctionDeclaration;
function isFunctionExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.FunctionExpression;
***REMOVED***
exports.isFunctionExpression = isFunctionExpression;
function isFunctionTypeNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.FunctionType;
***REMOVED***
exports.isFunctionTypeNode = isFunctionTypeNode;
function isGetAccessorDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.GetAccessor;
***REMOVED***
exports.isGetAccessorDeclaration = isGetAccessorDeclaration;
function isIdentifier(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.Identifier;
***REMOVED***
exports.isIdentifier = isIdentifier;
function isIfStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.IfStatement;
***REMOVED***
exports.isIfStatement = isIfStatement;
function isImportClause(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ImportClause;
***REMOVED***
exports.isImportClause = isImportClause;
function isImportDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ImportDeclaration;
***REMOVED***
exports.isImportDeclaration = isImportDeclaration;
function isImportEqualsDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ImportEqualsDeclaration;
***REMOVED***
exports.isImportEqualsDeclaration = isImportEqualsDeclaration;
function isImportSpecifier(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ImportSpecifier;
***REMOVED***
exports.isImportSpecifier = isImportSpecifier;
function isIndexedAccessTypeNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.IndexedAccessType;
***REMOVED***
exports.isIndexedAccessTypeNode = isIndexedAccessTypeNode;
function isIndexSignatureDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.IndexSignature;
***REMOVED***
exports.isIndexSignatureDeclaration = isIndexSignatureDeclaration;
function isInferTypeNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.InferType;
***REMOVED***
exports.isInferTypeNode = isInferTypeNode;
function isInterfaceDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.InterfaceDeclaration;
***REMOVED***
exports.isInterfaceDeclaration = isInterfaceDeclaration;
function isIntersectionTypeNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.IntersectionType;
***REMOVED***
exports.isIntersectionTypeNode = isIntersectionTypeNode;
function isIterationStatement(node) ***REMOVED***
    switch (node.kind) ***REMOVED***
        case ts.SyntaxKind.ForStatement:
        case ts.SyntaxKind.ForOfStatement:
        case ts.SyntaxKind.ForInStatement:
        case ts.SyntaxKind.WhileStatement:
        case ts.SyntaxKind.DoStatement:
            return true;
        default:
            return false;
    ***REMOVED***
***REMOVED***
exports.isIterationStatement = isIterationStatement;
function isJsDoc(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JSDocComment;
***REMOVED***
exports.isJsDoc = isJsDoc;
function isJsxAttribute(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JsxAttribute;
***REMOVED***
exports.isJsxAttribute = isJsxAttribute;
function isJsxAttributeLike(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JsxAttribute ||
        node.kind === ts.SyntaxKind.JsxSpreadAttribute;
***REMOVED***
exports.isJsxAttributeLike = isJsxAttributeLike;
function isJsxAttributes(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JsxAttributes;
***REMOVED***
exports.isJsxAttributes = isJsxAttributes;
function isJsxClosingElement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JsxClosingElement;
***REMOVED***
exports.isJsxClosingElement = isJsxClosingElement;
function isJsxClosingFragment(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JsxClosingFragment;
***REMOVED***
exports.isJsxClosingFragment = isJsxClosingFragment;
function isJsxElement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JsxElement;
***REMOVED***
exports.isJsxElement = isJsxElement;
function isJsxExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JsxExpression;
***REMOVED***
exports.isJsxExpression = isJsxExpression;
function isJsxFragment(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JsxFragment;
***REMOVED***
exports.isJsxFragment = isJsxFragment;
function isJsxOpeningElement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JsxOpeningElement;
***REMOVED***
exports.isJsxOpeningElement = isJsxOpeningElement;
function isJsxOpeningFragment(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JsxOpeningFragment;
***REMOVED***
exports.isJsxOpeningFragment = isJsxOpeningFragment;
function isJsxOpeningLikeElement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JsxOpeningElement ||
        node.kind === ts.SyntaxKind.JsxSelfClosingElement;
***REMOVED***
exports.isJsxOpeningLikeElement = isJsxOpeningLikeElement;
function isJsxSelfClosingElement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JsxSelfClosingElement;
***REMOVED***
exports.isJsxSelfClosingElement = isJsxSelfClosingElement;
function isJsxSpreadAttribute(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JsxSpreadAttribute;
***REMOVED***
exports.isJsxSpreadAttribute = isJsxSpreadAttribute;
function isJsxText(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.JsxText;
***REMOVED***
exports.isJsxText = isJsxText;
function isLabeledStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.LabeledStatement;
***REMOVED***
exports.isLabeledStatement = isLabeledStatement;
function isLiteralExpression(node) ***REMOVED***
    return node.kind >= ts.SyntaxKind.FirstLiteralToken &&
        node.kind <= ts.SyntaxKind.LastLiteralToken;
***REMOVED***
exports.isLiteralExpression = isLiteralExpression;
function isLiteralTypeNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.LiteralType;
***REMOVED***
exports.isLiteralTypeNode = isLiteralTypeNode;
function isMappedTypeNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.MappedType;
***REMOVED***
exports.isMappedTypeNode = isMappedTypeNode;
function isMetaProperty(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.MetaProperty;
***REMOVED***
exports.isMetaProperty = isMetaProperty;
function isMethodDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.MethodDeclaration;
***REMOVED***
exports.isMethodDeclaration = isMethodDeclaration;
function isMethodSignature(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.MethodSignature;
***REMOVED***
exports.isMethodSignature = isMethodSignature;
function isModuleBlock(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ModuleBlock;
***REMOVED***
exports.isModuleBlock = isModuleBlock;
function isModuleDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ModuleDeclaration;
***REMOVED***
exports.isModuleDeclaration = isModuleDeclaration;
function isNamedExports(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.NamedExports;
***REMOVED***
exports.isNamedExports = isNamedExports;
function isNamedImports(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.NamedImports;
***REMOVED***
exports.isNamedImports = isNamedImports;
function isNamespaceDeclaration(node) ***REMOVED***
    return isModuleDeclaration(node) &&
        node.name.kind === ts.SyntaxKind.Identifier &&
        node.body !== undefined &&
        (node.body.kind === ts.SyntaxKind.ModuleBlock ||
            isNamespaceDeclaration(node.body));
***REMOVED***
exports.isNamespaceDeclaration = isNamespaceDeclaration;
function isNamespaceImport(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.NamespaceImport;
***REMOVED***
exports.isNamespaceImport = isNamespaceImport;
function isNamespaceExportDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.NamespaceExportDeclaration;
***REMOVED***
exports.isNamespaceExportDeclaration = isNamespaceExportDeclaration;
function isNewExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.NewExpression;
***REMOVED***
exports.isNewExpression = isNewExpression;
function isNonNullExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.NonNullExpression;
***REMOVED***
exports.isNonNullExpression = isNonNullExpression;
function isNoSubstitutionTemplateLiteral(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral;
***REMOVED***
exports.isNoSubstitutionTemplateLiteral = isNoSubstitutionTemplateLiteral;
function isNullLiteral(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.NullKeyword;
***REMOVED***
exports.isNullLiteral = isNullLiteral;
function isNumericLiteral(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.NumericLiteral;
***REMOVED***
exports.isNumericLiteral = isNumericLiteral;
function isNumericOrStringLikeLiteral(node) ***REMOVED***
    switch (node.kind) ***REMOVED***
        case ts.SyntaxKind.StringLiteral:
        case ts.SyntaxKind.NumericLiteral:
        case ts.SyntaxKind.NoSubstitutionTemplateLiteral:
            return true;
        default:
            return false;
    ***REMOVED***
***REMOVED***
exports.isNumericOrStringLikeLiteral = isNumericOrStringLikeLiteral;
function isObjectBindingPattern(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ObjectBindingPattern;
***REMOVED***
exports.isObjectBindingPattern = isObjectBindingPattern;
function isObjectLiteralExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ObjectLiteralExpression;
***REMOVED***
exports.isObjectLiteralExpression = isObjectLiteralExpression;
function isOmittedExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.OmittedExpression;
***REMOVED***
exports.isOmittedExpression = isOmittedExpression;
function isParameterDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.Parameter;
***REMOVED***
exports.isParameterDeclaration = isParameterDeclaration;
function isParenthesizedExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ParenthesizedExpression;
***REMOVED***
exports.isParenthesizedExpression = isParenthesizedExpression;
function isParenthesizedTypeNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ParenthesizedType;
***REMOVED***
exports.isParenthesizedTypeNode = isParenthesizedTypeNode;
function isPostfixUnaryExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.PostfixUnaryExpression;
***REMOVED***
exports.isPostfixUnaryExpression = isPostfixUnaryExpression;
function isPrefixUnaryExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.PrefixUnaryExpression;
***REMOVED***
exports.isPrefixUnaryExpression = isPrefixUnaryExpression;
function isPropertyAccessExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.PropertyAccessExpression;
***REMOVED***
exports.isPropertyAccessExpression = isPropertyAccessExpression;
function isPropertyAssignment(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.PropertyAssignment;
***REMOVED***
exports.isPropertyAssignment = isPropertyAssignment;
function isPropertyDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.PropertyDeclaration;
***REMOVED***
exports.isPropertyDeclaration = isPropertyDeclaration;
function isPropertySignature(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.PropertySignature;
***REMOVED***
exports.isPropertySignature = isPropertySignature;
function isQualifiedName(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.QualifiedName;
***REMOVED***
exports.isQualifiedName = isQualifiedName;
function isRegularExpressionLiteral(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.RegularExpressionLiteral;
***REMOVED***
exports.isRegularExpressionLiteral = isRegularExpressionLiteral;
function isReturnStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ReturnStatement;
***REMOVED***
exports.isReturnStatement = isReturnStatement;
function isSetAccessorDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.SetAccessor;
***REMOVED***
exports.isSetAccessorDeclaration = isSetAccessorDeclaration;
function isShorthandPropertyAssignment(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ShorthandPropertyAssignment;
***REMOVED***
exports.isShorthandPropertyAssignment = isShorthandPropertyAssignment;
function isSignatureDeclaration(node) ***REMOVED***
    return node.parameters !== undefined;
***REMOVED***
exports.isSignatureDeclaration = isSignatureDeclaration;
function isSourceFile(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.SourceFile;
***REMOVED***
exports.isSourceFile = isSourceFile;
function isSpreadAssignment(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.SpreadAssignment;
***REMOVED***
exports.isSpreadAssignment = isSpreadAssignment;
function isSpreadElement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.SpreadElement;
***REMOVED***
exports.isSpreadElement = isSpreadElement;
function isStringLiteral(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.StringLiteral;
***REMOVED***
exports.isStringLiteral = isStringLiteral;
function isSwitchStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.SwitchStatement;
***REMOVED***
exports.isSwitchStatement = isSwitchStatement;
function isSyntaxList(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.SyntaxList;
***REMOVED***
exports.isSyntaxList = isSyntaxList;
function isTaggedTemplateExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TaggedTemplateExpression;
***REMOVED***
exports.isTaggedTemplateExpression = isTaggedTemplateExpression;
function isTemplateExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TemplateExpression;
***REMOVED***
exports.isTemplateExpression = isTemplateExpression;
function isTemplateLiteral(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TemplateExpression ||
        node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral;
***REMOVED***
exports.isTemplateLiteral = isTemplateLiteral;
function isTextualLiteral(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.StringLiteral ||
        node.kind === ts.SyntaxKind.NoSubstitutionTemplateLiteral;
***REMOVED***
exports.isTextualLiteral = isTextualLiteral;
function isThrowStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.ThrowStatement;
***REMOVED***
exports.isThrowStatement = isThrowStatement;
function isTryStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TryStatement;
***REMOVED***
exports.isTryStatement = isTryStatement;
function isTupleTypeNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TupleType;
***REMOVED***
exports.isTupleTypeNode = isTupleTypeNode;
function isTypeAliasDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TypeAliasDeclaration;
***REMOVED***
exports.isTypeAliasDeclaration = isTypeAliasDeclaration;
function isTypeAssertion(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TypeAssertionExpression;
***REMOVED***
exports.isTypeAssertion = isTypeAssertion;
function isTypeLiteralNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TypeLiteral;
***REMOVED***
exports.isTypeLiteralNode = isTypeLiteralNode;
function isTypeOfExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TypeOfExpression;
***REMOVED***
exports.isTypeOfExpression = isTypeOfExpression;
function isTypeOperatorNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TypeOperator;
***REMOVED***
exports.isTypeOperatorNode = isTypeOperatorNode;
function isTypeParameterDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TypeParameter;
***REMOVED***
exports.isTypeParameterDeclaration = isTypeParameterDeclaration;
function isTypePredicateNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TypePredicate;
***REMOVED***
exports.isTypePredicateNode = isTypePredicateNode;
function isTypeReferenceNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TypeReference;
***REMOVED***
exports.isTypeReferenceNode = isTypeReferenceNode;
function isTypeQueryNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.TypeQuery;
***REMOVED***
exports.isTypeQueryNode = isTypeQueryNode;
function isUnionTypeNode(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.UnionType;
***REMOVED***
exports.isUnionTypeNode = isUnionTypeNode;
function isVariableDeclaration(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.VariableDeclaration;
***REMOVED***
exports.isVariableDeclaration = isVariableDeclaration;
function isVariableStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.VariableStatement;
***REMOVED***
exports.isVariableStatement = isVariableStatement;
function isVariableDeclarationList(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.VariableDeclarationList;
***REMOVED***
exports.isVariableDeclarationList = isVariableDeclarationList;
function isVoidExpression(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.VoidExpression;
***REMOVED***
exports.isVoidExpression = isVoidExpression;
function isWhileStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.WhileStatement;
***REMOVED***
exports.isWhileStatement = isWhileStatement;
function isWithStatement(node) ***REMOVED***
    return node.kind === ts.SyntaxKind.WithStatement;
***REMOVED***
exports.isWithStatement = isWithStatement;
