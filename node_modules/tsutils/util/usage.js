"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
const util_1 = require("./util");
const ts = require("typescript");
var DeclarationDomain;
(function (DeclarationDomain) ***REMOVED***
    DeclarationDomain[DeclarationDomain["Namespace"] = 1] = "Namespace";
    DeclarationDomain[DeclarationDomain["Type"] = 2] = "Type";
    DeclarationDomain[DeclarationDomain["Value"] = 4] = "Value";
    DeclarationDomain[DeclarationDomain["Import"] = 8] = "Import";
    DeclarationDomain[DeclarationDomain["Any"] = 7] = "Any";
***REMOVED***)(DeclarationDomain = exports.DeclarationDomain || (exports.DeclarationDomain = ***REMOVED******REMOVED***));
var UsageDomain;
(function (UsageDomain) ***REMOVED***
    UsageDomain[UsageDomain["Namespace"] = 1] = "Namespace";
    UsageDomain[UsageDomain["Type"] = 2] = "Type";
    UsageDomain[UsageDomain["Value"] = 4] = "Value";
    UsageDomain[UsageDomain["ValueOrNamespace"] = 5] = "ValueOrNamespace";
    UsageDomain[UsageDomain["Any"] = 7] = "Any";
    UsageDomain[UsageDomain["TypeQuery"] = 8] = "TypeQuery";
***REMOVED***)(UsageDomain = exports.UsageDomain || (exports.UsageDomain = ***REMOVED******REMOVED***));
function getUsageDomain(node) ***REMOVED***
    const parent = node.parent;
    switch (parent.kind) ***REMOVED***
        case ts.SyntaxKind.TypeReference:
            return node.originalKeywordKind !== ts.SyntaxKind.ConstKeyword ? 2 : undefined;
        case ts.SyntaxKind.ExpressionWithTypeArguments:
            return parent.parent.token === ts.SyntaxKind.ImplementsKeyword ||
                parent.parent.parent.kind === ts.SyntaxKind.InterfaceDeclaration
                ? 2
                : 4;
        case ts.SyntaxKind.TypeQuery:
            return 5 | 8;
        case ts.SyntaxKind.QualifiedName:
            if (parent.left === node) ***REMOVED***
                if (getEntityNameParent(parent).kind === ts.SyntaxKind.TypeQuery)
                    return 1 | 8;
                return 1;
            ***REMOVED***
            break;
        case ts.SyntaxKind.ExportSpecifier:
            if (parent.propertyName === undefined ||
                parent.propertyName === node)
                return 7;
            break;
        case ts.SyntaxKind.ExportAssignment:
            return 7;
        case ts.SyntaxKind.BindingElement:
            if (parent.initializer === node)
                return 5;
            break;
        case ts.SyntaxKind.Parameter:
        case ts.SyntaxKind.EnumMember:
        case ts.SyntaxKind.PropertyDeclaration:
        case ts.SyntaxKind.VariableDeclaration:
        case ts.SyntaxKind.PropertyAssignment:
        case ts.SyntaxKind.PropertyAccessExpression:
        case ts.SyntaxKind.ImportEqualsDeclaration:
            if (parent.name !== node)
                return 5;
            break;
        case ts.SyntaxKind.JsxAttribute:
        case ts.SyntaxKind.FunctionDeclaration:
        case ts.SyntaxKind.FunctionExpression:
        case ts.SyntaxKind.NamespaceImport:
        case ts.SyntaxKind.ClassDeclaration:
        case ts.SyntaxKind.ClassExpression:
        case ts.SyntaxKind.ModuleDeclaration:
        case ts.SyntaxKind.MethodDeclaration:
        case ts.SyntaxKind.EnumDeclaration:
        case ts.SyntaxKind.GetAccessor:
        case ts.SyntaxKind.SetAccessor:
        case ts.SyntaxKind.LabeledStatement:
        case ts.SyntaxKind.BreakStatement:
        case ts.SyntaxKind.ContinueStatement:
        case ts.SyntaxKind.ImportClause:
        case ts.SyntaxKind.ImportSpecifier:
        case ts.SyntaxKind.TypePredicate:
        case ts.SyntaxKind.MethodSignature:
        case ts.SyntaxKind.PropertySignature:
        case ts.SyntaxKind.NamespaceExportDeclaration:
        case ts.SyntaxKind.InterfaceDeclaration:
        case ts.SyntaxKind.TypeAliasDeclaration:
        case ts.SyntaxKind.TypeParameter:
            break;
        default:
            return 5;
    ***REMOVED***
***REMOVED***
exports.getUsageDomain = getUsageDomain;
function getDeclarationDomain(node) ***REMOVED***
    switch (node.parent.kind) ***REMOVED***
        case ts.SyntaxKind.TypeParameter:
        case ts.SyntaxKind.InterfaceDeclaration:
        case ts.SyntaxKind.TypeAliasDeclaration:
            return 2;
        case ts.SyntaxKind.ClassDeclaration:
        case ts.SyntaxKind.ClassExpression:
            return 2 | 4;
        case ts.SyntaxKind.EnumDeclaration:
            return 7;
        case ts.SyntaxKind.NamespaceImport:
        case ts.SyntaxKind.ImportClause:
            return 7 | 8;
        case ts.SyntaxKind.ImportEqualsDeclaration:
        case ts.SyntaxKind.ImportSpecifier:
            return node.parent.name === node
                ? 7 | 8
                : undefined;
        case ts.SyntaxKind.ModuleDeclaration:
            return 1;
        case ts.SyntaxKind.Parameter:
            if (node.parent.parent.kind === ts.SyntaxKind.IndexSignature || node.originalKeywordKind === ts.SyntaxKind.ThisKeyword)
                return;
        case ts.SyntaxKind.BindingElement:
        case ts.SyntaxKind.VariableDeclaration:
            return node.parent.name === node ? 4 : undefined;
        case ts.SyntaxKind.FunctionDeclaration:
        case ts.SyntaxKind.FunctionExpression:
            return 4;
    ***REMOVED***
***REMOVED***
exports.getDeclarationDomain = getDeclarationDomain;
function collectVariableUsage(sourceFile) ***REMOVED***
    return new UsageWalker().getUsage(sourceFile);
***REMOVED***
exports.collectVariableUsage = collectVariableUsage;
class AbstractScope ***REMOVED***
    constructor(_global) ***REMOVED***
        this._global = _global;
        this._variables = new Map();
        this._uses = [];
        this._namespaceScopes = undefined;
        this._enumScopes = undefined;
    ***REMOVED***
    addVariable(identifier, name, selector, exported, domain) ***REMOVED***
        const variables = this.getDestinationScope(selector).getVariables();
        const declaration = ***REMOVED***
            domain,
            exported,
            declaration: name,
        ***REMOVED***;
        const variable = variables.get(identifier);
        if (variable === undefined) ***REMOVED***
            variables.set(identifier, ***REMOVED***
                domain,
                declarations: [declaration],
                uses: [],
            ***REMOVED***);
        ***REMOVED***
        else ***REMOVED***
            variable.domain |= domain;
            variable.declarations.push(declaration);
        ***REMOVED***
    ***REMOVED***
    addUse(use) ***REMOVED***
        this._uses.push(use);
    ***REMOVED***
    getVariables() ***REMOVED***
        return this._variables;
    ***REMOVED***
    getFunctionScope() ***REMOVED***
        return this;
    ***REMOVED***
    end(cb) ***REMOVED***
        if (this._namespaceScopes !== undefined)
            this._namespaceScopes.forEach((value) => value.finish(cb));
        this._namespaceScopes = this._enumScopes = undefined;
        this._applyUses();
        this._variables.forEach((variable) => ***REMOVED***
            for (const declaration of variable.declarations) ***REMOVED***
                const result = ***REMOVED***
                    declarations: [],
                    domain: declaration.domain,
                    exported: declaration.exported,
                    inGlobalScope: this._global,
                    uses: [],
                ***REMOVED***;
                for (const other of variable.declarations)
                    if (other.domain & declaration.domain)
                        result.declarations.push(other.declaration);
                for (const use of variable.uses)
                    if (use.domain & declaration.domain)
                        result.uses.push(use);
                cb(result, declaration.declaration, this);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
    markExported(_name) ***REMOVED*** ***REMOVED***
    createOrReuseNamespaceScope(name, _exported, ambient, hasExportStatement) ***REMOVED***
        let scope;
        if (this._namespaceScopes === undefined) ***REMOVED***
            this._namespaceScopes = new Map();
        ***REMOVED***
        else ***REMOVED***
            scope = this._namespaceScopes.get(name);
        ***REMOVED***
        if (scope === undefined) ***REMOVED***
            scope = new NamespaceScope(ambient, hasExportStatement, this);
            this._namespaceScopes.set(name, scope);
        ***REMOVED***
        else ***REMOVED***
            scope.refresh(ambient, hasExportStatement);
        ***REMOVED***
        return scope;
    ***REMOVED***
    createOrReuseEnumScope(name, _exported) ***REMOVED***
        let scope;
        if (this._enumScopes === undefined) ***REMOVED***
            this._enumScopes = new Map();
        ***REMOVED***
        else ***REMOVED***
            scope = this._enumScopes.get(name);
        ***REMOVED***
        if (scope === undefined) ***REMOVED***
            scope = new EnumScope(this);
            this._enumScopes.set(name, scope);
        ***REMOVED***
        return scope;
    ***REMOVED***
    _applyUses() ***REMOVED***
        for (const use of this._uses)
            if (!this._applyUse(use))
                this._addUseToParent(use);
        this._uses = [];
    ***REMOVED***
    _applyUse(use, variables = this._variables) ***REMOVED***
        const variable = variables.get(use.location.text);
        if (variable === undefined || (variable.domain & use.domain) === 0)
            return false;
        variable.uses.push(use);
        return true;
    ***REMOVED***
    _addUseToParent(_use) ***REMOVED*** ***REMOVED***
***REMOVED***
class RootScope extends AbstractScope ***REMOVED***
    constructor(_exportAll, global) ***REMOVED***
        super(global);
        this._exportAll = _exportAll;
        this._exports = undefined;
        this._innerScope = new NonRootScope(this, 1);
    ***REMOVED***
    addVariable(identifier, name, selector, exported, domain) ***REMOVED***
        if (domain & 8)
            return super.addVariable(identifier, name, selector, exported, domain);
        return this._innerScope.addVariable(identifier, name, selector, exported, domain);
    ***REMOVED***
    addUse(use, origin) ***REMOVED***
        if (origin === this._innerScope)
            return super.addUse(use);
        return this._innerScope.addUse(use);
    ***REMOVED***
    markExported(id) ***REMOVED***
        if (this._exports === undefined) ***REMOVED***
            this._exports = [id.text];
        ***REMOVED***
        else ***REMOVED***
            this._exports.push(id.text);
        ***REMOVED***
    ***REMOVED***
    end(cb) ***REMOVED***
        this._innerScope.end((value, key) => ***REMOVED***
            value.exported = value.exported || this._exportAll
                || this._exports !== undefined && this._exports.includes(key.text);
            value.inGlobalScope = this._global;
            return cb(value, key, this);
        ***REMOVED***);
        return super.end((value, key, scope) => ***REMOVED***
            value.exported = value.exported || scope === this
                && this._exports !== undefined && this._exports.includes(key.text);
            return cb(value, key, scope);
        ***REMOVED***);
    ***REMOVED***
    getDestinationScope() ***REMOVED***
        return this;
    ***REMOVED***
***REMOVED***
class NonRootScope extends AbstractScope ***REMOVED***
    constructor(_parent, _boundary) ***REMOVED***
        super(false);
        this._parent = _parent;
        this._boundary = _boundary;
    ***REMOVED***
    _addUseToParent(use) ***REMOVED***
        return this._parent.addUse(use, this);
    ***REMOVED***
    getDestinationScope(selector) ***REMOVED***
        return this._boundary & selector
            ? this
            : this._parent.getDestinationScope(selector);
    ***REMOVED***
***REMOVED***
class EnumScope extends NonRootScope ***REMOVED***
    constructor(parent) ***REMOVED***
        super(parent, 1);
    ***REMOVED***
    end() ***REMOVED***
        this._applyUses();
    ***REMOVED***
***REMOVED***
class ConditionalTypeScope extends NonRootScope ***REMOVED***
    constructor(parent) ***REMOVED***
        super(parent, 8);
        this._state = 0;
    ***REMOVED***
    updateState(newState) ***REMOVED***
        this._state = newState;
    ***REMOVED***
    addUse(use) ***REMOVED***
        if (this._state === 2)
            return void this._uses.push(use);
        return this._parent.addUse(use, this);
    ***REMOVED***
***REMOVED***
class FunctionScope extends NonRootScope ***REMOVED***
    constructor(parent) ***REMOVED***
        super(parent, 1);
    ***REMOVED***
    beginBody() ***REMOVED***
        this._applyUses();
    ***REMOVED***
***REMOVED***
class AbstractNamedExpressionScope extends NonRootScope ***REMOVED***
    constructor(_name, _domain, parent) ***REMOVED***
        super(parent, 1);
        this._name = _name;
        this._domain = _domain;
    ***REMOVED***
    end(cb) ***REMOVED***
        this._innerScope.end(cb);
        return cb(***REMOVED***
            declarations: [this._name],
            domain: this._domain,
            exported: false,
            uses: this._uses,
            inGlobalScope: false,
        ***REMOVED***, this._name, this);
    ***REMOVED***
    addUse(use, source) ***REMOVED***
        if (source !== this._innerScope)
            return this._innerScope.addUse(use);
        if (use.domain & this._domain && use.location.text === this._name.text) ***REMOVED***
            this._uses.push(use);
        ***REMOVED***
        else ***REMOVED***
            return this._parent.addUse(use, this);
        ***REMOVED***
    ***REMOVED***
    getFunctionScope() ***REMOVED***
        return this._innerScope;
    ***REMOVED***
    getDestinationScope() ***REMOVED***
        return this._innerScope;
    ***REMOVED***
***REMOVED***
class FunctionExpressionScope extends AbstractNamedExpressionScope ***REMOVED***
    constructor(name, parent) ***REMOVED***
        super(name, 4, parent);
        this._innerScope = new FunctionScope(this);
    ***REMOVED***
    beginBody() ***REMOVED***
        return this._innerScope.beginBody();
    ***REMOVED***
***REMOVED***
class ClassExpressionScope extends AbstractNamedExpressionScope ***REMOVED***
    constructor(name, parent) ***REMOVED***
        super(name, 4 | 2, parent);
        this._innerScope = new NonRootScope(this, 1);
    ***REMOVED***
***REMOVED***
class BlockScope extends NonRootScope ***REMOVED***
    constructor(_functionScope, parent) ***REMOVED***
        super(parent, 2);
        this._functionScope = _functionScope;
    ***REMOVED***
    getFunctionScope() ***REMOVED***
        return this._functionScope;
    ***REMOVED***
***REMOVED***
function mapDeclaration(declaration) ***REMOVED***
    return ***REMOVED***
        declaration,
        exported: true,
        domain: getDeclarationDomain(declaration),
    ***REMOVED***;
***REMOVED***
class NamespaceScope extends NonRootScope ***REMOVED***
    constructor(_ambient, _hasExport, parent) ***REMOVED***
        super(parent, 1);
        this._ambient = _ambient;
        this._hasExport = _hasExport;
        this._innerScope = new NonRootScope(this, 1);
        this._exports = undefined;
    ***REMOVED***
    finish(cb) ***REMOVED***
        return super.end(cb);
    ***REMOVED***
    end(cb) ***REMOVED***
        this._innerScope.end((variable, key, scope) => ***REMOVED***
            if (scope !== this._innerScope ||
                !variable.exported && (!this._ambient || this._exports !== undefined && !this._exports.has(key.text)))
                return cb(variable, key, scope);
            const namespaceVar = this._variables.get(key.text);
            if (namespaceVar === undefined) ***REMOVED***
                this._variables.set(key.text, ***REMOVED***
                    declarations: variable.declarations.map(mapDeclaration),
                    domain: variable.domain,
                    uses: [...variable.uses],
                ***REMOVED***);
            ***REMOVED***
            else ***REMOVED***
                outer: for (const declaration of variable.declarations) ***REMOVED***
                    for (const existing of namespaceVar.declarations)
                        if (existing.declaration === declaration)
                            continue outer;
                    namespaceVar.declarations.push(mapDeclaration(declaration));
                ***REMOVED***
                namespaceVar.domain |= variable.domain;
                for (const use of variable.uses) ***REMOVED***
                    if (namespaceVar.uses.includes(use))
                        continue;
                    namespaceVar.uses.push(use);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***);
        this._applyUses();
        this._innerScope = new NonRootScope(this, 1);
    ***REMOVED***
    createOrReuseNamespaceScope(name, exported, ambient, hasExportStatement) ***REMOVED***
        if (!exported && (!this._ambient || this._hasExport))
            return this._innerScope.createOrReuseNamespaceScope(name, exported, ambient || this._ambient, hasExportStatement);
        return super.createOrReuseNamespaceScope(name, exported, ambient || this._ambient, hasExportStatement);
    ***REMOVED***
    createOrReuseEnumScope(name, exported) ***REMOVED***
        if (!exported && (!this._ambient || this._hasExport))
            return this._innerScope.createOrReuseEnumScope(name, exported);
        return super.createOrReuseEnumScope(name, exported);
    ***REMOVED***
    addUse(use, source) ***REMOVED***
        if (source !== this._innerScope)
            return this._innerScope.addUse(use);
        this._uses.push(use);
    ***REMOVED***
    refresh(ambient, hasExport) ***REMOVED***
        this._ambient = ambient;
        this._hasExport = hasExport;
    ***REMOVED***
    markExported(name, _as) ***REMOVED***
        if (this._exports === undefined)
            this._exports = new Set();
        this._exports.add(name.text);
    ***REMOVED***
    getDestinationScope() ***REMOVED***
        return this._innerScope;
    ***REMOVED***
***REMOVED***
function getEntityNameParent(name) ***REMOVED***
    let parent = name.parent;
    while (parent.kind === ts.SyntaxKind.QualifiedName)
        parent = parent.parent;
    return parent;
***REMOVED***
class UsageWalker ***REMOVED***
    constructor() ***REMOVED***
        this._result = new Map();
    ***REMOVED***
    getUsage(sourceFile) ***REMOVED***
        const variableCallback = (variable, key) => ***REMOVED***
            this._result.set(key, variable);
        ***REMOVED***;
        const isModule = ts.isExternalModule(sourceFile);
        this._scope = new RootScope(sourceFile.isDeclarationFile && isModule && !containsExportStatement(sourceFile), !isModule);
        const cb = (node) => ***REMOVED***
            if (util_1.isBlockScopeBoundary(node))
                return continueWithScope(node, new BlockScope(this._scope.getFunctionScope(), this._scope), handleBlockScope);
            switch (node.kind) ***REMOVED***
                case ts.SyntaxKind.ClassExpression:
                    return continueWithScope(node, node.name !== undefined
                        ? new ClassExpressionScope(node.name, this._scope)
                        : new NonRootScope(this._scope, 1));
                case ts.SyntaxKind.ClassDeclaration:
                    this._handleDeclaration(node, true, 4 | 2);
                    return continueWithScope(node, new NonRootScope(this._scope, 1));
                case ts.SyntaxKind.InterfaceDeclaration:
                case ts.SyntaxKind.TypeAliasDeclaration:
                    this._handleDeclaration(node, true, 2);
                    return continueWithScope(node, new NonRootScope(this._scope, 4));
                case ts.SyntaxKind.EnumDeclaration:
                    this._handleDeclaration(node, true, 7);
                    return continueWithScope(node, this._scope.createOrReuseEnumScope(node.name.text, util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword)));
                case ts.SyntaxKind.ModuleDeclaration:
                    return this._handleModule(node, continueWithScope);
                case ts.SyntaxKind.MappedType:
                    return continueWithScope(node, new NonRootScope(this._scope, 4));
                case ts.SyntaxKind.FunctionExpression:
                case ts.SyntaxKind.ArrowFunction:
                case ts.SyntaxKind.Constructor:
                case ts.SyntaxKind.MethodDeclaration:
                case ts.SyntaxKind.FunctionDeclaration:
                case ts.SyntaxKind.GetAccessor:
                case ts.SyntaxKind.SetAccessor:
                case ts.SyntaxKind.MethodSignature:
                case ts.SyntaxKind.CallSignature:
                case ts.SyntaxKind.ConstructSignature:
                case ts.SyntaxKind.ConstructorType:
                case ts.SyntaxKind.FunctionType:
                    return this._handleFunctionLikeDeclaration(node, cb, variableCallback);
                case ts.SyntaxKind.ConditionalType:
                    return this._handleConditionalType(node, cb, variableCallback);
                case ts.SyntaxKind.VariableDeclarationList:
                    this._handleVariableDeclaration(node);
                    break;
                case ts.SyntaxKind.Parameter:
                    if (node.parent.kind !== ts.SyntaxKind.IndexSignature &&
                        (node.name.kind !== ts.SyntaxKind.Identifier ||
                            node.name.originalKeywordKind !== ts.SyntaxKind.ThisKeyword))
                        this._handleBindingName(node.name, false, false);
                    break;
                case ts.SyntaxKind.EnumMember:
                    this._scope.addVariable(util_1.getPropertyName(node.name), node.name, 1, true, 4);
                    break;
                case ts.SyntaxKind.ImportClause:
                case ts.SyntaxKind.ImportSpecifier:
                case ts.SyntaxKind.NamespaceImport:
                case ts.SyntaxKind.ImportEqualsDeclaration:
                    this._handleDeclaration(node, false, 7 | 8);
                    break;
                case ts.SyntaxKind.TypeParameter:
                    this._scope.addVariable(node.name.text, node.name, node.parent.kind === ts.SyntaxKind.InferType ? 8 : 7, false, 2);
                    break;
                case ts.SyntaxKind.ExportSpecifier:
                    if (node.propertyName !== undefined)
                        return this._scope.markExported(node.propertyName, node.name);
                    return this._scope.markExported(node.name);
                case ts.SyntaxKind.ExportAssignment:
                    if (node.expression.kind === ts.SyntaxKind.Identifier)
                        return this._scope.markExported(node.expression);
                    break;
                case ts.SyntaxKind.Identifier:
                    const domain = getUsageDomain(node);
                    if (domain !== undefined)
                        this._scope.addUse(***REMOVED*** domain, location: node ***REMOVED***);
                    return;
            ***REMOVED***
            return ts.forEachChild(node, cb);
        ***REMOVED***;
        const continueWithScope = (node, scope, next = forEachChild) => ***REMOVED***
            const savedScope = this._scope;
            this._scope = scope;
            next(node);
            this._scope.end(variableCallback);
            this._scope = savedScope;
        ***REMOVED***;
        const handleBlockScope = (node) => ***REMOVED***
            if (node.kind === ts.SyntaxKind.CatchClause && node.variableDeclaration !== undefined)
                this._handleBindingName(node.variableDeclaration.name, true, false);
            return ts.forEachChild(node, cb);
        ***REMOVED***;
        ts.forEachChild(sourceFile, cb);
        this._scope.end(variableCallback);
        return this._result;
        function forEachChild(node) ***REMOVED***
            return ts.forEachChild(node, cb);
        ***REMOVED***
    ***REMOVED***
    _handleConditionalType(node, cb, varCb) ***REMOVED***
        const savedScope = this._scope;
        const scope = this._scope = new ConditionalTypeScope(savedScope);
        cb(node.checkType);
        scope.updateState(1);
        cb(node.extendsType);
        scope.updateState(2);
        cb(node.trueType);
        scope.updateState(3);
        cb(node.falseType);
        scope.end(varCb);
        this._scope = savedScope;
    ***REMOVED***
    _handleFunctionLikeDeclaration(node, cb, varCb) ***REMOVED***
        if (node.decorators !== undefined)
            node.decorators.forEach(cb);
        const savedScope = this._scope;
        if (node.kind === ts.SyntaxKind.FunctionDeclaration)
            this._handleDeclaration(node, false, 4);
        const scope = this._scope = node.kind === ts.SyntaxKind.FunctionExpression && node.name !== undefined
            ? new FunctionExpressionScope(node.name, savedScope)
            : new FunctionScope(savedScope);
        if (node.name !== undefined)
            cb(node.name);
        if (node.typeParameters !== undefined)
            node.typeParameters.forEach(cb);
        node.parameters.forEach(cb);
        if (node.type !== undefined)
            cb(node.type);
        if (node.body !== undefined) ***REMOVED***
            scope.beginBody();
            cb(node.body);
        ***REMOVED***
        scope.end(varCb);
        this._scope = savedScope;
    ***REMOVED***
    _handleModule(node, next) ***REMOVED***
        if (node.flags & ts.NodeFlags.GlobalAugmentation)
            return next(node, this._scope.createOrReuseNamespaceScope('-global', false, true, false));
        if (node.name.kind === ts.SyntaxKind.Identifier) ***REMOVED***
            const exported = isNamespaceExported(node);
            this._scope.addVariable(node.name.text, node.name, 1, exported, 1 | 4);
            const ambient = util_1.hasModifier(node.modifiers, ts.SyntaxKind.DeclareKeyword);
            return next(node, this._scope.createOrReuseNamespaceScope(node.name.text, exported, ambient, ambient && namespaceHasExportStatement(node)));
        ***REMOVED***
        return next(node, this._scope.createOrReuseNamespaceScope(`"$***REMOVED***node.name.text***REMOVED***"`, false, true, namespaceHasExportStatement(node)));
    ***REMOVED***
    _handleDeclaration(node, blockScoped, domain) ***REMOVED***
        if (node.name !== undefined)
            this._scope.addVariable(node.name.text, node.name, blockScoped ? 3 : 1, util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword), domain);
    ***REMOVED***
    _handleBindingName(name, blockScoped, exported) ***REMOVED***
        if (name.kind === ts.SyntaxKind.Identifier)
            return this._scope.addVariable(name.text, name, blockScoped ? 3 : 1, exported, 4);
        util_1.forEachDestructuringIdentifier(name, (declaration) => ***REMOVED***
            this._scope.addVariable(declaration.name.text, declaration.name, blockScoped ? 3 : 1, exported, 4);
        ***REMOVED***);
    ***REMOVED***
    _handleVariableDeclaration(declarationList) ***REMOVED***
        const blockScoped = util_1.isBlockScopedVariableDeclarationList(declarationList);
        const exported = declarationList.parent.kind === ts.SyntaxKind.VariableStatement &&
            util_1.hasModifier(declarationList.parent.modifiers, ts.SyntaxKind.ExportKeyword);
        for (const declaration of declarationList.declarations)
            this._handleBindingName(declaration.name, blockScoped, exported);
    ***REMOVED***
***REMOVED***
function isNamespaceExported(node) ***REMOVED***
    return node.parent.kind === ts.SyntaxKind.ModuleDeclaration || util_1.hasModifier(node.modifiers, ts.SyntaxKind.ExportKeyword);
***REMOVED***
function namespaceHasExportStatement(ns) ***REMOVED***
    if (ns.body === undefined || ns.body.kind !== ts.SyntaxKind.ModuleBlock)
        return false;
    return containsExportStatement(ns.body);
***REMOVED***
function containsExportStatement(block) ***REMOVED***
    for (const statement of block.statements)
        if (statement.kind === ts.SyntaxKind.ExportDeclaration || statement.kind === ts.SyntaxKind.ExportAssignment)
            return true;
    return false;
***REMOVED***
