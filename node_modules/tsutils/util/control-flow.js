"use strict";
Object.defineProperty(exports, "__esModule", ***REMOVED*** value: true ***REMOVED***);
const ts = require("typescript");
const node_1 = require("../typeguard/node");
function endsControlFlow(statement) ***REMOVED***
    return getControlFlowEnd(statement).end;
***REMOVED***
exports.endsControlFlow = endsControlFlow;
const defaultControlFlowEnd = ***REMOVED*** statements: [], end: false ***REMOVED***;
function getControlFlowEnd(statement) ***REMOVED***
    return node_1.isBlockLike(statement) ? handleBlock(statement) : getControlFlowEndWorker(statement);
***REMOVED***
exports.getControlFlowEnd = getControlFlowEnd;
function getControlFlowEndWorker(statement) ***REMOVED***
    switch (statement.kind) ***REMOVED***
        case ts.SyntaxKind.ReturnStatement:
        case ts.SyntaxKind.ThrowStatement:
        case ts.SyntaxKind.ContinueStatement:
        case ts.SyntaxKind.BreakStatement:
            return ***REMOVED*** statements: [statement], end: true ***REMOVED***;
        case ts.SyntaxKind.Block:
            return handleBlock(statement);
        case ts.SyntaxKind.ForStatement:
        case ts.SyntaxKind.WhileStatement:
            return handleForAndWhileStatement(statement);
        case ts.SyntaxKind.ForOfStatement:
        case ts.SyntaxKind.ForInStatement:
            return handleForInOrOfStatement(statement);
        case ts.SyntaxKind.DoStatement:
            return matchBreakOrContinue(getControlFlowEndWorker(statement.statement), node_1.isBreakOrContinueStatement);
        case ts.SyntaxKind.IfStatement:
            return handleIfStatement(statement);
        case ts.SyntaxKind.SwitchStatement:
            return matchBreakOrContinue(handleSwitchStatement(statement), node_1.isBreakStatement);
        case ts.SyntaxKind.TryStatement:
            return handleTryStatement(statement);
        case ts.SyntaxKind.LabeledStatement:
            return matchLabel(getControlFlowEndWorker(statement.statement), statement.label);
        case ts.SyntaxKind.WithStatement:
            return getControlFlowEndWorker(statement.statement);
        default:
            return defaultControlFlowEnd;
    ***REMOVED***
***REMOVED***
function handleBlock(statement) ***REMOVED***
    const result = ***REMOVED*** statements: [], end: false ***REMOVED***;
    for (const s of statement.statements) ***REMOVED***
        const current = getControlFlowEndWorker(s);
        result.statements.push(...current.statements);
        if (current.end) ***REMOVED***
            result.end = true;
            break;
        ***REMOVED***
    ***REMOVED***
    return result;
***REMOVED***
function handleForInOrOfStatement(statement) ***REMOVED***
    const end = matchBreakOrContinue(getControlFlowEndWorker(statement.statement), node_1.isBreakOrContinueStatement);
    end.end = false;
    return end;
***REMOVED***
function handleForAndWhileStatement(statement) ***REMOVED***
    const constantCondition = statement.kind === ts.SyntaxKind.WhileStatement
        ? getConstantCondition(statement.expression)
        : statement.condition === undefined || getConstantCondition(statement.condition);
    if (constantCondition === false)
        return defaultControlFlowEnd;
    const end = matchBreakOrContinue(getControlFlowEndWorker(statement.statement), node_1.isBreakOrContinueStatement);
    if (constantCondition === undefined)
        end.end = false;
    return end;
***REMOVED***
function getConstantCondition(node) ***REMOVED***
    switch (node.kind) ***REMOVED***
        case ts.SyntaxKind.TrueKeyword:
            return true;
        case ts.SyntaxKind.FalseKeyword:
            return false;
        default:
            return;
    ***REMOVED***
***REMOVED***
function handleIfStatement(node) ***REMOVED***
    switch (getConstantCondition(node.expression)) ***REMOVED***
        case true:
            return getControlFlowEndWorker(node.thenStatement);
        case false:
            return node.elseStatement === undefined
                ? defaultControlFlowEnd
                : getControlFlowEndWorker(node.elseStatement);
    ***REMOVED***
    const then = getControlFlowEndWorker(node.thenStatement);
    if (node.elseStatement === undefined)
        return ***REMOVED***
            statements: then.statements,
            end: false,
        ***REMOVED***;
    const elze = getControlFlowEndWorker(node.elseStatement);
    return ***REMOVED***
        statements: [...then.statements, ...elze.statements],
        end: then.end && elze.end,
    ***REMOVED***;
***REMOVED***
function handleSwitchStatement(node) ***REMOVED***
    let hasDefault = false;
    const result = ***REMOVED***
        statements: [],
        end: false,
    ***REMOVED***;
    for (const clause of node.caseBlock.clauses) ***REMOVED***
        if (clause.kind === ts.SyntaxKind.DefaultClause)
            hasDefault = true;
        const current = handleBlock(clause);
        result.end = current.end;
        result.statements.push(...current.statements);
    ***REMOVED***
    if (!hasDefault)
        result.end = false;
    return result;
***REMOVED***
function handleTryStatement(node) ***REMOVED***
    let finallyResult;
    if (node.finallyBlock !== undefined) ***REMOVED***
        finallyResult = handleBlock(node.finallyBlock);
        if (finallyResult.end)
            return finallyResult;
    ***REMOVED***
    const tryResult = handleBlock(node.tryBlock);
    if (node.catchClause === undefined)
        return ***REMOVED*** statements: finallyResult.statements.concat(tryResult.statements), end: tryResult.end ***REMOVED***;
    const catchResult = handleBlock(node.catchClause.block);
    return ***REMOVED***
        statements: tryResult.statements
            .filter((s) => s.kind !== ts.SyntaxKind.ThrowStatement)
            .concat(catchResult.statements, finallyResult === undefined ? [] : finallyResult.statements),
        end: tryResult.end && catchResult.end,
    ***REMOVED***;
***REMOVED***
function matchBreakOrContinue(current, pred) ***REMOVED***
    const result = ***REMOVED***
        statements: [],
        end: current.end,
    ***REMOVED***;
    for (const statement of current.statements) ***REMOVED***
        if (pred(statement) && statement.label === undefined) ***REMOVED***
            result.end = false;
            continue;
        ***REMOVED***
        result.statements.push(statement);
    ***REMOVED***
    return result;
***REMOVED***
function matchLabel(current, label) ***REMOVED***
    const result = ***REMOVED***
        statements: [],
        end: current.end,
    ***REMOVED***;
    const labelText = label.text;
    for (const statement of current.statements) ***REMOVED***
        switch (statement.kind) ***REMOVED***
            case ts.SyntaxKind.BreakStatement:
            case ts.SyntaxKind.ContinueStatement:
                if (statement.label !== undefined && statement.label.text === labelText) ***REMOVED***
                    result.end = false;
                    continue;
                ***REMOVED***
        ***REMOVED***
        result.statements.push(statement);
    ***REMOVED***
    return result;
***REMOVED***
