/**
 * @author Toru Nagashima
 * See LICENSE file in root directory for full license.
 */
"use strict"

const CodePathAnalyzer = safeRequire(
    "eslint/lib/linter/code-path-analysis/code-path-analyzer",
    "eslint/lib/code-path-analysis/code-path-analyzer"
)
const CodePathSegment = safeRequire(
    "eslint/lib/linter/code-path-analysis/code-path-segment",
    "eslint/lib/code-path-analysis/code-path-segment"
)
const CodePath = safeRequire(
    "eslint/lib/linter/code-path-analysis/code-path",
    "eslint/lib/code-path-analysis/code-path"
)

const originalLeaveNode =
    CodePathAnalyzer && CodePathAnalyzer.prototype.leaveNode

/**
 * Imports a specific module.
 * @param ***REMOVED***...string***REMOVED*** moduleNames - module names to import.
 * @returns ***REMOVED***object|null***REMOVED*** The imported object, or null.
 */
function safeRequire(...moduleNames) ***REMOVED***
    for (const moduleName of moduleNames) ***REMOVED***
        try ***REMOVED***
            return require(moduleName)
        ***REMOVED*** catch (_err) ***REMOVED***
            // Ignore.
        ***REMOVED***
    ***REMOVED***
    return null
***REMOVED***

/* istanbul ignore next */
/**
 * Copied from https://github.com/eslint/eslint/blob/16fad5880bb70e9dddbeab8ed0f425ae51f5841f/lib/code-path-analysis/code-path-analyzer.js#L137
 *
 * @param ***REMOVED***CodePathAnalyzer***REMOVED*** analyzer - The instance.
 * @param ***REMOVED***ASTNode***REMOVED*** node - The current AST node.
 * @returns ***REMOVED***void***REMOVED***
 */
function forwardCurrentToHead(analyzer, node) ***REMOVED***
    const codePath = analyzer.codePath
    const state = CodePath.getState(codePath)
    const currentSegments = state.currentSegments
    const headSegments = state.headSegments
    const end = Math.max(currentSegments.length, headSegments.length)
    let i = 0
    let currentSegment = null
    let headSegment = null

    // Fires leaving events.
    for (i = 0; i < end; ++i) ***REMOVED***
        currentSegment = currentSegments[i]
        headSegment = headSegments[i]

        if (currentSegment !== headSegment && currentSegment) ***REMOVED***
            if (currentSegment.reachable) ***REMOVED***
                analyzer.emitter.emit(
                    "onCodePathSegmentEnd",
                    currentSegment,
                    node
                )
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    // Update state.
    state.currentSegments = headSegments

    // Fires entering events.
    for (i = 0; i < end; ++i) ***REMOVED***
        currentSegment = currentSegments[i]
        headSegment = headSegments[i]

        if (currentSegment !== headSegment && headSegment) ***REMOVED***
            CodePathSegment.markUsed(headSegment)
            if (headSegment.reachable) ***REMOVED***
                analyzer.emitter.emit(
                    "onCodePathSegmentStart",
                    headSegment,
                    node
                )
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
***REMOVED***

/**
 * Checks whether a given node is `process.exit()` or not.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is `process.exit()`.
 */
function isProcessExit(node) ***REMOVED***
    return (
        node.type === "CallExpression" &&
        node.callee.type === "MemberExpression" &&
        node.callee.computed === false &&
        node.callee.object.type === "Identifier" &&
        node.callee.object.name === "process" &&
        node.callee.property.type === "Identifier" &&
        node.callee.property.name === "exit"
    )
***REMOVED***

/**
 * The function to override `CodePathAnalyzer.prototype.leaveNode` in order to
 * address `process.exit()` as throw.
 *
 * @this CodePathAnalyzer
 * @param ***REMOVED***ASTNode***REMOVED*** node - A node to be left.
 * @returns ***REMOVED***void***REMOVED***
 */
function overrideLeaveNode(node) ***REMOVED***
    if (isProcessExit(node)) ***REMOVED***
        this.currentNode = node

        forwardCurrentToHead(this, node)
        CodePath.getState(this.codePath).makeThrow()

        this.original.leaveNode(node)
        this.currentNode = null
    ***REMOVED*** else ***REMOVED***
        originalLeaveNode.call(this, node)
    ***REMOVED***
***REMOVED***

const visitor =
    CodePathAnalyzer == null
        ? ***REMOVED******REMOVED***
        : ***REMOVED***
              Program: function installProcessExitAsThrow() ***REMOVED***
                  CodePathAnalyzer.prototype.leaveNode = overrideLeaveNode
              ***REMOVED***,
              "Program:exit": function restoreProcessExitAsThrow() ***REMOVED***
                  CodePathAnalyzer.prototype.leaveNode = originalLeaveNode
              ***REMOVED***,
          ***REMOVED***

module.exports = ***REMOVED***
    meta: ***REMOVED***
        docs: ***REMOVED***
            description:
                "make `process.exit()` expressions the same code path as `throw`",
            category: "Possible Errors",
            recommended: true,
            url:
                "https://github.com/mysticatea/eslint-plugin-node/blob/v10.0.0/docs/rules/process-exit-as-throw.md",
        ***REMOVED***,
        type: "problem",
        fixable: null,
        schema: [],
        supported: CodePathAnalyzer != null,
    ***REMOVED***,
    create() ***REMOVED***
        return visitor
    ***REMOVED***,
***REMOVED***
