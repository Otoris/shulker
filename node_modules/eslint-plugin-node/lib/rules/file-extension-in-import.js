/**
 * @author Toru Nagashima
 * See LICENSE file in root directory for full license.
 */
"use strict"

const path = require("path")
const fs = require("fs")
const getTryExtensions = require("../util/get-try-extensions")
const visitImport = require("../util/visit-import")
const packageNamePattern = /^(?:@[^/\\]+[/\\])?[^/\\]+$/u
const corePackageOverridePattern = /^(?:assert|async_hooks|buffer|child_process|cluster|console|constants|crypto|dgram|dns|domain|events|fs|http|http2|https|inspector|module|net|os|path|perf_hooks|process|punycode|querystring|readline|repl|stream|string_decoder|sys|timers|tls|trace_events|tty|url|util|v8|vm|worker_threads|zlib)[/\\]$/u

/**
 * Get all file extensions of the files which have the same basename.
 * @param ***REMOVED***string***REMOVED*** filePath The path to the original file to check.
 * @returns ***REMOVED***string[]***REMOVED*** File extensions.
 */
function getExistingExtensions(filePath) ***REMOVED***
    const basename = path.basename(filePath, path.extname(filePath))
    try ***REMOVED***
        return fs
            .readdirSync(path.dirname(filePath))
            .filter(
                filename =>
                    path.basename(filename, path.extname(filename)) === basename
            )
            .map(filename => path.extname(filename))
    ***REMOVED*** catch (_error) ***REMOVED***
        return []
    ***REMOVED***
***REMOVED***

module.exports = ***REMOVED***
    meta: ***REMOVED***
        docs: ***REMOVED***
            description:
                "enforce the style of file extensions in `import` declarations",
            category: "Stylistic Issues",
            recommended: false,
            url:
                "https://github.com/mysticatea/eslint-plugin-node/blob/v10.0.0/docs/rules/file-extension-in-import.md",
        ***REMOVED***,
        fixable: "code",
        messages: ***REMOVED***
            requireExt: "require file extension '***REMOVED******REMOVED***ext***REMOVED******REMOVED***'.",
            forbidExt: "forbid file extension '***REMOVED******REMOVED***ext***REMOVED******REMOVED***'.",
        ***REMOVED***,
        schema: [
            ***REMOVED***
                enum: ["always", "never"],
            ***REMOVED***,
            ***REMOVED***
                type: "object",
                properties: ***REMOVED***
                    tryExtensions: getTryExtensions.schema,
                ***REMOVED***,
                additionalProperties: ***REMOVED***
                    enum: ["always", "never"],
                ***REMOVED***,
            ***REMOVED***,
        ],
        type: "suggestion",
    ***REMOVED***,
    create(context) ***REMOVED***
        if (context.getFilename().startsWith("<")) ***REMOVED***
            return ***REMOVED******REMOVED***
        ***REMOVED***
        const defaultStyle = context.options[0] || "always"
        const overrideStyle = context.options[1] || ***REMOVED******REMOVED***

        function verify(***REMOVED*** filePath, name, node ***REMOVED***) ***REMOVED***
            // Ignore if it's not resolved to a file or it's a bare module.
            if (
                !filePath ||
                packageNamePattern.test(name) ||
                corePackageOverridePattern.test(name)
            ) ***REMOVED***
                return
            ***REMOVED***

            // Get extension.
            const originalExt = path.extname(name)
            const resolvedExt = path.extname(filePath)
            const existingExts = getExistingExtensions(filePath)
            if (!resolvedExt && existingExts.length !== 1) ***REMOVED***
                // Ignore if the file extension could not be determined one.
                return
            ***REMOVED***
            const ext = resolvedExt || existingExts[0]
            const style = overrideStyle[ext] || defaultStyle

            // Verify.
            if (style === "always" && ext !== originalExt) ***REMOVED***
                context.report(***REMOVED***
                    node,
                    messageId: "requireExt",
                    data: ***REMOVED*** ext ***REMOVED***,
                    fix(fixer) ***REMOVED***
                        if (existingExts.length !== 1) ***REMOVED***
                            return null
                        ***REMOVED***
                        const index = node.range[1] - 1
                        return fixer.insertTextBeforeRange([index, index], ext)
                    ***REMOVED***,
                ***REMOVED***)
            ***REMOVED*** else if (style === "never" && ext === originalExt) ***REMOVED***
                context.report(***REMOVED***
                    node,
                    messageId: "forbidExt",
                    data: ***REMOVED*** ext ***REMOVED***,
                    fix(fixer) ***REMOVED***
                        if (existingExts.length !== 1) ***REMOVED***
                            return null
                        ***REMOVED***
                        const index = name.lastIndexOf(ext)
                        const start = node.range[0] + 1 + index
                        const end = start + ext.length
                        return fixer.removeRange([start, end])
                    ***REMOVED***,
                ***REMOVED***)
            ***REMOVED***
        ***REMOVED***

        return visitImport(context, ***REMOVED*** optionIndex: 1 ***REMOVED***, targets => ***REMOVED***
            targets.forEach(verify)
        ***REMOVED***)
    ***REMOVED***,
***REMOVED***
