/**
 * @author Jamund Ferguson
 * See LICENSE file in root directory for full license.
 */
"use strict"

module.exports = ***REMOVED***
    meta: ***REMOVED***
        docs: ***REMOVED***
            description:
                "ensure Node.js-style error-first callback pattern is followed",
            category: "Possible Errors",
            recommended: false,
            url:
                "https://github.com/mysticatea/eslint-plugin-node/blob/v10.0.0/docs/rules/no-callback-literal.md",
        ***REMOVED***,
        type: "problem",
        fixable: null,
        schema: [],
    ***REMOVED***,

    create(context) ***REMOVED***
        const callbackNames = ["callback", "cb"]

        function isCallback(name) ***REMOVED***
            return callbackNames.indexOf(name) > -1
        ***REMOVED***

        return ***REMOVED***
            CallExpression(node) ***REMOVED***
                const errorArg = node.arguments[0]
                const calleeName = node.callee.name

                if (
                    errorArg &&
                    !couldBeError(errorArg) &&
                    isCallback(calleeName)
                ) ***REMOVED***
                    context.report(***REMOVED***
                        node,
                        message:
                            "Unexpected literal in error position of callback.",
                    ***REMOVED***)
                ***REMOVED***
            ***REMOVED***,
        ***REMOVED***
    ***REMOVED***,
***REMOVED***

/**
 * Determine if a node has a possiblity to be an Error object
 * @param  ***REMOVED***ASTNode***REMOVED***  node  ASTNode to check
 * @returns ***REMOVED***boolean***REMOVED***       True if there is a chance it contains an Error obj
 */
function couldBeError(node) ***REMOVED***
    switch (node.type) ***REMOVED***
        case "Identifier":
        case "CallExpression":
        case "NewExpression":
        case "MemberExpression":
        case "TaggedTemplateExpression":
        case "YieldExpression":
            return true // possibly an error object.

        case "AssignmentExpression":
            return couldBeError(node.right)

        case "SequenceExpression": ***REMOVED***
            const exprs = node.expressions
            return exprs.length !== 0 && couldBeError(exprs[exprs.length - 1])
        ***REMOVED***

        case "LogicalExpression":
            return couldBeError(node.left) || couldBeError(node.right)

        case "ConditionalExpression":
            return couldBeError(node.consequent) || couldBeError(node.alternate)

        default:
            return node.value === null
    ***REMOVED***
***REMOVED***
