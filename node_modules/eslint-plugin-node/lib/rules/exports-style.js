/**
 * @author Toru Nagashima
 * See LICENSE file in root directory for full license.
 */
"use strict"

/*istanbul ignore next */
/**
 * This function is copied from https://github.com/eslint/eslint/blob/2355f8d0de1d6732605420d15ddd4f1eee3c37b6/lib/ast-utils.js#L648-L684
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - The node to get.
 * @returns ***REMOVED***string|null***REMOVED*** The property name if static. Otherwise, null.
 * @private
 */
function getStaticPropertyName(node) ***REMOVED***
    let prop = null

    switch (node && node.type) ***REMOVED***
        case "Property":
        case "MethodDefinition":
            prop = node.key
            break

        case "MemberExpression":
            prop = node.property
            break

        // no default
    ***REMOVED***

    switch (prop && prop.type) ***REMOVED***
        case "Literal":
            return String(prop.value)

        case "TemplateLiteral":
            if (prop.expressions.length === 0 && prop.quasis.length === 1) ***REMOVED***
                return prop.quasis[0].value.cooked
            ***REMOVED***
            break

        case "Identifier":
            if (!node.computed) ***REMOVED***
                return prop.name
            ***REMOVED***
            break

        // no default
    ***REMOVED***

    return null
***REMOVED***

/**
 * Checks whether the given node is assignee or not.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node - The node to check.
 * @returns ***REMOVED***boolean***REMOVED*** `true` if the node is assignee.
 */
function isAssignee(node) ***REMOVED***
    return (
        node.parent.type === "AssignmentExpression" && node.parent.left === node
    )
***REMOVED***

/**
 * Gets the top assignment expression node if the given node is an assignee.
 *
 * This is used to distinguish 2 assignees belong to the same assignment.
 * If the node is not an assignee, this returns null.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** leafNode - The node to get.
 * @returns ***REMOVED***ASTNode|null***REMOVED*** The top assignment expression node, or null.
 */
function getTopAssignment(leafNode) ***REMOVED***
    let node = leafNode

    // Skip MemberExpressions.
    while (
        node.parent.type === "MemberExpression" &&
        node.parent.object === node
    ) ***REMOVED***
        node = node.parent
    ***REMOVED***

    // Check assignments.
    if (!isAssignee(node)) ***REMOVED***
        return null
    ***REMOVED***

    // Find the top.
    while (node.parent.type === "AssignmentExpression") ***REMOVED***
        node = node.parent
    ***REMOVED***

    return node
***REMOVED***

/**
 * Gets top assignment nodes of the given node list.
 *
 * @param ***REMOVED***ASTNode[]***REMOVED*** nodes - The node list to get.
 * @returns ***REMOVED***ASTNode[]***REMOVED*** Gotten top assignment nodes.
 */
function createAssignmentList(nodes) ***REMOVED***
    return nodes.map(getTopAssignment).filter(Boolean)
***REMOVED***

/**
 * Gets the reference of `module.exports` from the given scope.
 *
 * @param ***REMOVED***escope.Scope***REMOVED*** scope - The scope to get.
 * @returns ***REMOVED***ASTNode[]***REMOVED*** Gotten MemberExpression node list.
 */
function getModuleExportsNodes(scope) ***REMOVED***
    const variable = scope.set.get("module")
    if (variable == null) ***REMOVED***
        return []
    ***REMOVED***
    return variable.references
        .map(reference => reference.identifier.parent)
        .filter(
            node =>
                node.type === "MemberExpression" &&
                getStaticPropertyName(node) === "exports"
        )
***REMOVED***

/**
 * Gets the reference of `exports` from the given scope.
 *
 * @param ***REMOVED***escope.Scope***REMOVED*** scope - The scope to get.
 * @returns ***REMOVED***ASTNode[]***REMOVED*** Gotten Identifier node list.
 */
function getExportsNodes(scope) ***REMOVED***
    const variable = scope.set.get("exports")
    if (variable == null) ***REMOVED***
        return []
    ***REMOVED***
    return variable.references.map(reference => reference.identifier)
***REMOVED***

module.exports = ***REMOVED***
    meta: ***REMOVED***
        docs: ***REMOVED***
            description: "enforce either `module.exports` or `exports`",
            category: "Stylistic Issues",
            recommended: false,
            url:
                "https://github.com/mysticatea/eslint-plugin-node/blob/v10.0.0/docs/rules/exports-style.md",
        ***REMOVED***,
        type: "suggestion",
        fixable: null,
        schema: [
            ***REMOVED***
                //
                enum: ["module.exports", "exports"],
            ***REMOVED***,
            ***REMOVED***
                type: "object",
                properties: ***REMOVED*** allowBatchAssign: ***REMOVED*** type: "boolean" ***REMOVED*** ***REMOVED***,
                additionalProperties: false,
            ***REMOVED***,
        ],
    ***REMOVED***,

    create(context) ***REMOVED***
        const mode = context.options[0] || "module.exports"
        const batchAssignAllowed = Boolean(
            context.options[1] != null && context.options[1].allowBatchAssign
        )
        const sourceCode = context.getSourceCode()

        /**
         * Gets the location info of reports.
         *
         * exports = foo
         * ^^^^^^^^^
         *
         * module.exports = foo
         * ^^^^^^^^^^^^^^^^
         *
         * @param ***REMOVED***ASTNode***REMOVED*** node - The node of `exports`/`module.exports`.
         * @returns ***REMOVED***Location***REMOVED*** The location info of reports.
         */
        function getLocation(node) ***REMOVED***
            const token = sourceCode.getTokenAfter(node)
            return ***REMOVED***
                start: node.loc.start,
                end: token.loc.end,
            ***REMOVED***
        ***REMOVED***

        /**
         * Enforces `module.exports`.
         * This warns references of `exports`.
         *
         * @returns ***REMOVED***void***REMOVED***
         */
        function enforceModuleExports() ***REMOVED***
            const globalScope = context.getScope()
            const exportsNodes = getExportsNodes(globalScope)
            const assignList = batchAssignAllowed
                ? createAssignmentList(getModuleExportsNodes(globalScope))
                : []

            for (const node of exportsNodes) ***REMOVED***
                // Skip if it's a batch assignment.
                if (
                    assignList.length > 0 &&
                    assignList.indexOf(getTopAssignment(node)) !== -1
                ) ***REMOVED***
                    continue
                ***REMOVED***

                // Report.
                context.report(***REMOVED***
                    node,
                    loc: getLocation(node),
                    message:
                        "Unexpected access to 'exports'. Use 'module.exports' instead.",
                ***REMOVED***)
            ***REMOVED***
        ***REMOVED***

        /**
         * Enforces `exports`.
         * This warns references of `module.exports`.
         *
         * @returns ***REMOVED***void***REMOVED***
         */
        function enforceExports() ***REMOVED***
            const globalScope = context.getScope()
            const exportsNodes = getExportsNodes(globalScope)
            const moduleExportsNodes = getModuleExportsNodes(globalScope)
            const assignList = batchAssignAllowed
                ? createAssignmentList(exportsNodes)
                : []
            const batchAssignList = []

            for (const node of moduleExportsNodes) ***REMOVED***
                // Skip if it's a batch assignment.
                if (assignList.length > 0) ***REMOVED***
                    const found = assignList.indexOf(getTopAssignment(node))
                    if (found !== -1) ***REMOVED***
                        batchAssignList.push(assignList[found])
                        assignList.splice(found, 1)
                        continue
                    ***REMOVED***
                ***REMOVED***

                // Report.
                context.report(***REMOVED***
                    node,
                    loc: getLocation(node),
                    message:
                        "Unexpected access to 'module.exports'. Use 'exports' instead.",
                ***REMOVED***)
            ***REMOVED***

            // Disallow direct assignment to `exports`.
            for (const node of exportsNodes) ***REMOVED***
                // Skip if it's not assignee.
                if (!isAssignee(node)) ***REMOVED***
                    continue
                ***REMOVED***

                // Check if it's a batch assignment.
                if (batchAssignList.indexOf(getTopAssignment(node)) !== -1) ***REMOVED***
                    continue
                ***REMOVED***

                // Report.
                context.report(***REMOVED***
                    node,
                    loc: getLocation(node),
                    message:
                        "Unexpected assignment to 'exports'. Don't modify 'exports' itself.",
                ***REMOVED***)
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            "Program:exit"() ***REMOVED***
                switch (mode) ***REMOVED***
                    case "module.exports":
                        enforceModuleExports()
                        break
                    case "exports":
                        enforceExports()
                        break

                    // no default
                ***REMOVED***
            ***REMOVED***,
        ***REMOVED***
    ***REMOVED***,
***REMOVED***
