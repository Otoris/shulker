'use strict';
var _ = require('lodash');
var ***REMOVED*** defer, empty, from, of ***REMOVED*** = require('rxjs');
var ***REMOVED*** concatMap, filter, publish, reduce ***REMOVED*** = require('rxjs/operators');
var runAsync = require('run-async');
var utils = require('../utils/utils');
var Base = require('./baseUI');

/**
 * Base interface class other can inherits from
 */

class PromptUI extends Base ***REMOVED***
  constructor(prompts, opt) ***REMOVED***
    super(opt);
    this.prompts = prompts;
  ***REMOVED***

  run(questions) ***REMOVED***
    // Keep global reference to the answers
    this.answers = ***REMOVED******REMOVED***;

    // Make sure questions is an array.
    if (_.isPlainObject(questions)) ***REMOVED***
      questions = [questions];
    ***REMOVED***

    // Create an observable, unless we received one as parameter.
    // Note: As this is a public interface, we cannot do an instanceof check as we won't
    // be using the exact same object in memory.
    var obs = _.isArray(questions) ? from(questions) : questions;

    this.process = obs.pipe(
      concatMap(this.processQuestion.bind(this)),
      publish() // Creates a hot Observable. It prevents duplicating prompts.
    );

    this.process.connect();

    return this.process
      .pipe(
        reduce((answers, answer) => ***REMOVED***
          _.set(this.answers, answer.name, answer.answer);
          return this.answers;
        ***REMOVED***, ***REMOVED******REMOVED***)
      )
      .toPromise(Promise)
      .then(this.onCompletion.bind(this));
  ***REMOVED***

  /**
   * Once all prompt are over
   */

  onCompletion() ***REMOVED***
    this.close();

    return this.answers;
  ***REMOVED***

  processQuestion(question) ***REMOVED***
    question = _.clone(question);
    return defer(() => ***REMOVED***
      var obs = of(question);

      return obs.pipe(
        concatMap(this.setDefaultType.bind(this)),
        concatMap(this.filterIfRunnable.bind(this)),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'message', this.answers)
        ),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'default', this.answers)
        ),
        concatMap(() =>
          utils.fetchAsyncQuestionProperty(question, 'choices', this.answers)
        ),
        concatMap(this.fetchAnswer.bind(this))
      );
    ***REMOVED***);
  ***REMOVED***

  fetchAnswer(question) ***REMOVED***
    var Prompt = this.prompts[question.type];
    this.activePrompt = new Prompt(question, this.rl, this.answers);
    return defer(() =>
      from(
        this.activePrompt.run().then(answer => (***REMOVED*** name: question.name, answer: answer ***REMOVED***))
      )
    );
  ***REMOVED***

  setDefaultType(question) ***REMOVED***
    // Default type to input
    if (!this.prompts[question.type]) ***REMOVED***
      question.type = 'input';
    ***REMOVED***

    return defer(() => of(question));
  ***REMOVED***

  filterIfRunnable(question) ***REMOVED***
    if (question.when === false) ***REMOVED***
      return empty();
    ***REMOVED***

    if (!_.isFunction(question.when)) ***REMOVED***
      return of(question);
    ***REMOVED***

    var answers = this.answers;
    return defer(() =>
      from(
        runAsync(question.when)(answers).then(shouldRun => ***REMOVED***
          if (shouldRun) ***REMOVED***
            return question;
          ***REMOVED***
        ***REMOVED***)
      ).pipe(filter(val => val != null))
    );
  ***REMOVED***
***REMOVED***

module.exports = PromptUI;
