/**
 * @fileoverview Common propTypes detection functionality.
 */

'use strict';

const annotations = require('./annotations');
const propsUtil = require('./props');
const variableUtil = require('./variable');
const versionUtil = require('./version');
const propWrapperUtil = require('./propWrapper');
const getKeyValue = require('./ast').getKeyValue;

/**
 * Checks if we are declaring a props as a generic type in a flow-annotated class.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node  the AST node being checked.
 * @returns ***REMOVED***Boolean***REMOVED*** True if the node is a class with generic prop types, false if not.
 */
function isSuperTypeParameterPropsDeclaration(node) ***REMOVED***
  if (node && (node.type === 'ClassDeclaration' || node.type === 'ClassExpression')) ***REMOVED***
    if (node.superTypeParameters && node.superTypeParameters.params.length > 0) ***REMOVED***
      return true;
    ***REMOVED***
  ***REMOVED***
  return false;
***REMOVED***

/**
 * Iterates through a properties node, like a customized forEach.
 * @param ***REMOVED***Object***REMOVED*** context Array of properties to iterate.
 * @param ***REMOVED***Object[]***REMOVED*** properties Array of properties to iterate.
 * @param ***REMOVED***Function***REMOVED*** fn Function to call on each property, receives property key
    and property value. (key, value) => void
 */
function iterateProperties(context, properties, fn) ***REMOVED***
  if (properties && properties.length && typeof fn === 'function') ***REMOVED***
    for (let i = 0, j = properties.length; i < j; i++) ***REMOVED***
      const node = properties[i];
      const key = getKeyValue(context, node);

      const value = node.value;
      fn(key, value, node);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * Checks if a node is inside a class body.
 *
 * @param ***REMOVED***ASTNode***REMOVED*** node  the AST node being checked.
 * @returns ***REMOVED***Boolean***REMOVED*** True if the node has a ClassBody ancestor, false if not.
 */
function isInsideClassBody(node) ***REMOVED***
  let parent = node.parent;
  while (parent) ***REMOVED***
    if (parent.type === 'ClassBody') ***REMOVED***
      return true;
    ***REMOVED***
    parent = parent.parent;
  ***REMOVED***

  return false;
***REMOVED***

module.exports = function propTypesInstructions(context, components, utils) ***REMOVED***
  // Used to track the type annotations in scope.
  // Necessary because babel's scopes do not track type annotations.
  let stack = null;

  const classExpressions = [];
  const defaults = ***REMOVED***customValidators: []***REMOVED***;
  const configuration = Object.assign(***REMOVED******REMOVED***, defaults, context.options[0] || ***REMOVED******REMOVED***);
  const customValidators = configuration.customValidators;

  /**
   * Returns the full scope.
   * @returns ***REMOVED***Object***REMOVED*** The whole scope.
   */
  function typeScope() ***REMOVED***
    return stack[stack.length - 1];
  ***REMOVED***

  /**
   * Gets a node from the scope.
   * @param ***REMOVED***string***REMOVED*** key The name of the identifier to access.
   * @returns ***REMOVED***ASTNode***REMOVED*** The ASTNode associated with the given identifier.
   */
  function getInTypeScope(key) ***REMOVED***
    return stack[stack.length - 1][key];
  ***REMOVED***

  /**
   * Sets the new value in the scope.
   * @param ***REMOVED***string***REMOVED*** key The name of the identifier to access
   * @param ***REMOVED***ASTNode***REMOVED*** value The new value for the identifier.
   * @returns ***REMOVED***ASTNode***REMOVED*** The ASTNode associated with the given identifier.
   */
  function setInTypeScope(key, value) ***REMOVED***
    stack[stack.length - 1][key] = value;
    return value;
  ***REMOVED***

  /**
   * Checks if prop should be validated by plugin-react-proptypes
   * @param ***REMOVED***String***REMOVED*** validator Name of validator to check.
   * @returns ***REMOVED***Boolean***REMOVED*** True if validator should be checked by custom validator.
   */
  function hasCustomValidator(validator) ***REMOVED***
    return customValidators.indexOf(validator) !== -1;
  ***REMOVED***

  /* eslint-disable no-use-before-define */
  /** @type ***REMOVED***TypeDeclarationBuilders***REMOVED*** */
  const typeDeclarationBuilders = ***REMOVED***
    GenericTypeAnnotation(annotation, parentName, seen) ***REMOVED***
      if (getInTypeScope(annotation.id.name)) ***REMOVED***
        return buildTypeAnnotationDeclarationTypes(getInTypeScope(annotation.id.name), parentName, seen);
      ***REMOVED***
      return ***REMOVED******REMOVED***;
    ***REMOVED***,

    ObjectTypeAnnotation(annotation, parentName, seen) ***REMOVED***
      let containsObjectTypeSpread = false;
      const containsIndexers = Boolean(annotation.indexers && annotation.indexers.length);
      const shapeTypeDefinition = ***REMOVED***
        type: 'shape',
        children: ***REMOVED******REMOVED***
      ***REMOVED***;
      iterateProperties(context, annotation.properties, (childKey, childValue, propNode) => ***REMOVED***
        const fullName = [parentName, childKey].join('.');
        if (!childKey && !childValue) ***REMOVED***
          containsObjectTypeSpread = true;
        ***REMOVED*** else ***REMOVED***
          const types = buildTypeAnnotationDeclarationTypes(childValue, fullName, seen);
          types.fullName = fullName;
          types.name = childKey;
          types.node = propNode;
          types.isRequired = !childValue.optional;
          shapeTypeDefinition.children[childKey] = types;
        ***REMOVED***
      ***REMOVED***);

      // Mark if this shape has spread or an indexer. We will know to consider all props from this shape as having propTypes,
      // but still have the ability to detect unused children of this shape.
      shapeTypeDefinition.containsSpread = containsObjectTypeSpread;
      shapeTypeDefinition.containsIndexers = containsIndexers;

      return shapeTypeDefinition;
    ***REMOVED***,

    UnionTypeAnnotation(annotation, parentName, seen) ***REMOVED***
      /** @type ***REMOVED***UnionTypeDefinition***REMOVED*** */
      const unionTypeDefinition = ***REMOVED***
        type: 'union',
        children: []
      ***REMOVED***;
      for (let i = 0, j = annotation.types.length; i < j; i++) ***REMOVED***
        const type = buildTypeAnnotationDeclarationTypes(annotation.types[i], parentName, seen);
        // keep only complex type
        if (type.type) ***REMOVED***
          if (type.children === true) ***REMOVED***
            // every child is accepted for one type, abort type analysis
            unionTypeDefinition.children = true;
            return unionTypeDefinition;
          ***REMOVED***
        ***REMOVED***

        /** @type ***REMOVED***UnionTypeDefinitionChildren***REMOVED*** */(unionTypeDefinition.children).push(type);
      ***REMOVED***
      if (/** @type ***REMOVED***UnionTypeDefinitionChildren***REMOVED*** */(unionTypeDefinition.children).length === 0) ***REMOVED***
        // no complex type found, simply accept everything
        return ***REMOVED******REMOVED***;
      ***REMOVED***
      return unionTypeDefinition;
    ***REMOVED***,

    ArrayTypeAnnotation(annotation, parentName, seen) ***REMOVED***
      const fullName = [parentName, '*'].join('.');
      const child = buildTypeAnnotationDeclarationTypes(annotation.elementType, fullName, seen);
      child.fullName = fullName;
      child.name = '__ANY_KEY__';
      child.node = annotation;
      return ***REMOVED***
        type: 'object',
        children: ***REMOVED***
          __ANY_KEY__: child
        ***REMOVED***
      ***REMOVED***;
    ***REMOVED***
  ***REMOVED***;
  /* eslint-enable no-use-before-define */

  /**
   * Resolve the type annotation for a given node.
   * Flow annotations are sometimes wrapped in outer `TypeAnnotation`
   * and `NullableTypeAnnotation` nodes which obscure the annotation we're
   * interested in.
   * This method also resolves type aliases where possible.
   *
   * @param ***REMOVED***ASTNode***REMOVED*** node The annotation or a node containing the type annotation.
   * @returns ***REMOVED***ASTNode***REMOVED*** The resolved type annotation for the node.
   */
  function resolveTypeAnnotation(node) ***REMOVED***
    let annotation = (node.left && node.left.typeAnnotation) || node.typeAnnotation || node;
    while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) ***REMOVED***
      annotation = annotation.typeAnnotation;
    ***REMOVED***
    if (annotation.type === 'GenericTypeAnnotation' && getInTypeScope(annotation.id.name)) ***REMOVED***
      return getInTypeScope(annotation.id.name);
    ***REMOVED***

    return annotation;
  ***REMOVED***

  /**
   * Creates the representation of the React props type annotation for the component.
   * The representation is used to verify nested used properties.
   * @param ***REMOVED***ASTNode***REMOVED*** annotation Type annotation for the props class property.
   * @param ***REMOVED***String***REMOVED*** parentName
   * @param ***REMOVED***Set<ASTNode>***REMOVED*** [seen]
   * @return ***REMOVED***Object***REMOVED*** The representation of the declaration, empty object means
   *    the property is declared without the need for further analysis.
   */
  function buildTypeAnnotationDeclarationTypes(annotation, parentName, seen) ***REMOVED***
    if (typeof seen === 'undefined') ***REMOVED***
      // Keeps track of annotations we've already seen to
      // prevent problems with recursive types.
      seen = new Set();
    ***REMOVED***
    if (seen.has(annotation)) ***REMOVED***
      // This must be a recursive type annotation, so just accept anything.
      return ***REMOVED******REMOVED***;
    ***REMOVED***
    seen.add(annotation);

    if (annotation.type in typeDeclarationBuilders) ***REMOVED***
      return typeDeclarationBuilders[annotation.type](annotation, parentName, seen);
    ***REMOVED***
    return ***REMOVED******REMOVED***;
  ***REMOVED***

  /**
   * Marks all props found inside ObjectTypeAnnotaiton as declared.
   *
   * Modifies the declaredProperties object
   * @param ***REMOVED***ASTNode***REMOVED*** propTypes
   * @param ***REMOVED***Object***REMOVED*** declaredPropTypes
   * @returns ***REMOVED***Boolean***REMOVED*** True if propTypes should be ignored (e.g. when a type can't be resolved, when it is imported)
   */
  function declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes) ***REMOVED***
    let ignorePropsValidation = false;

    iterateProperties(context, propTypes.properties, (key, value, propNode) => ***REMOVED***
      if (!value) ***REMOVED***
        ignorePropsValidation = true;
        return;
      ***REMOVED***

      const types = buildTypeAnnotationDeclarationTypes(value, key);
      types.fullName = key;
      types.name = key;
      types.node = propNode;
      types.isRequired = !propNode.optional;
      declaredPropTypes[key] = types;
    ***REMOVED***);

    return ignorePropsValidation;
  ***REMOVED***

  /**
   * Marks all props found inside IntersectionTypeAnnotation as declared.
   * Since InterSectionTypeAnnotations can be nested, this handles recursively.
   *
   * Modifies the declaredPropTypes object
   * @param ***REMOVED***ASTNode***REMOVED*** propTypes
   * @param ***REMOVED***Object***REMOVED*** declaredPropTypes
   * @returns ***REMOVED***Boolean***REMOVED*** True if propTypes should be ignored (e.g. when a type can't be resolved, when it is imported)
   */
  function declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes) ***REMOVED***
    return propTypes.types.some((annotation) => ***REMOVED***
      if (annotation.type === 'ObjectTypeAnnotation') ***REMOVED***
        return declarePropTypesForObjectTypeAnnotation(annotation, declaredPropTypes);
      ***REMOVED***

      if (annotation.type === 'UnionTypeAnnotation') ***REMOVED***
        return true;
      ***REMOVED***

      // Type can't be resolved
      if (!annotation.id) ***REMOVED***
        return true;
      ***REMOVED***

      const typeNode = getInTypeScope(annotation.id.name);

      if (!typeNode) ***REMOVED***
        return true;
      ***REMOVED***
      if (typeNode.type === 'IntersectionTypeAnnotation') ***REMOVED***
        return declarePropTypesForIntersectionTypeAnnotation(typeNode, declaredPropTypes);
      ***REMOVED***

      return declarePropTypesForObjectTypeAnnotation(typeNode, declaredPropTypes);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Creates the representation of the React propTypes for the component.
   * The representation is used to verify nested used properties.
   * @param ***REMOVED***ASTNode***REMOVED*** value Node of the PropTypes for the desired property
   * @param ***REMOVED***string***REMOVED*** parentName
   * @return ***REMOVED***Object***REMOVED*** The representation of the declaration, empty object means
   *    the property is declared without the need for further analysis.
   */
  function buildReactDeclarationTypes(value, parentName) ***REMOVED***
    if (
      value &&
      value.callee &&
      value.callee.object &&
      hasCustomValidator(value.callee.object.name)
    ) ***REMOVED***
      return ***REMOVED******REMOVED***;
    ***REMOVED***

    if (
      value &&
      value.type === 'MemberExpression' &&
      value.property &&
      value.property.name &&
      value.property.name === 'isRequired'
    ) ***REMOVED***
      value = value.object;
    ***REMOVED***

    // Verify PropTypes that are functions
    if (
      value &&
      value.type === 'CallExpression' &&
      value.callee &&
      value.callee.property &&
      value.callee.property.name &&
      value.arguments &&
      value.arguments.length > 0
    ) ***REMOVED***
      const callName = value.callee.property.name;
      const argument = value.arguments[0];
      switch (callName) ***REMOVED***
        case 'shape': ***REMOVED***
          if (argument.type !== 'ObjectExpression') ***REMOVED***
            // Invalid proptype or cannot analyse statically
            return ***REMOVED******REMOVED***;
          ***REMOVED***
          const shapeTypeDefinition = ***REMOVED***
            type: 'shape',
            children: ***REMOVED******REMOVED***
          ***REMOVED***;
          iterateProperties(context, argument.properties, (childKey, childValue, propNode) => ***REMOVED***
            if (childValue) ***REMOVED*** // skip spread propTypes
              const fullName = [parentName, childKey].join('.');
              const types = buildReactDeclarationTypes(childValue, fullName);
              types.fullName = fullName;
              types.name = childKey;
              types.node = propNode;
              shapeTypeDefinition.children[childKey] = types;
            ***REMOVED***
          ***REMOVED***);
          return shapeTypeDefinition;
        ***REMOVED***
        case 'arrayOf':
        case 'objectOf': ***REMOVED***
          const fullName = [parentName, '*'].join('.');
          const child = buildReactDeclarationTypes(argument, fullName);
          child.fullName = fullName;
          child.name = '__ANY_KEY__';
          child.node = argument;
          return ***REMOVED***
            type: 'object',
            children: ***REMOVED***
              __ANY_KEY__: child
            ***REMOVED***
          ***REMOVED***;
        ***REMOVED***
        case 'oneOfType': ***REMOVED***
          if (
            !argument.elements ||
            !argument.elements.length
          ) ***REMOVED***
            // Invalid proptype or cannot analyse statically
            return ***REMOVED******REMOVED***;
          ***REMOVED***

          /** @type ***REMOVED***UnionTypeDefinition***REMOVED*** */
          const unionTypeDefinition = ***REMOVED***
            type: 'union',
            children: []
          ***REMOVED***;
          for (let i = 0, j = argument.elements.length; i < j; i++) ***REMOVED***
            const type = buildReactDeclarationTypes(argument.elements[i], parentName);
            // keep only complex type
            if (type.type) ***REMOVED***
              if (type.children === true) ***REMOVED***
                // every child is accepted for one type, abort type analysis
                unionTypeDefinition.children = true;
                return unionTypeDefinition;
              ***REMOVED***
            ***REMOVED***

            /** @type ***REMOVED***UnionTypeDefinitionChildren***REMOVED*** */(unionTypeDefinition.children).push(type);
          ***REMOVED***
          if (/** @type ***REMOVED***UnionTypeDefinitionChildren***REMOVED*** */(unionTypeDefinition.children).length === 0) ***REMOVED***
            // no complex type found, simply accept everything
            return ***REMOVED******REMOVED***;
          ***REMOVED***
          return unionTypeDefinition;
        ***REMOVED***
        case 'instanceOf':
          return ***REMOVED***
            type: 'instance',
            // Accept all children because we can't know what type they are
            children: true
          ***REMOVED***;
        case 'oneOf':
        default:
          return ***REMOVED******REMOVED***;
      ***REMOVED***
    ***REMOVED***
    // Unknown property or accepts everything (any, object, ...)
    return ***REMOVED******REMOVED***;
  ***REMOVED***


  /**
   * Mark a prop type as declared
   * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
   * @param ***REMOVED***ASTNode***REMOVED*** propTypes The AST node containing the proptypes
   */
  function markPropTypesAsDeclared(node, propTypes) ***REMOVED***
    let componentNode = node;
    while (componentNode && !components.get(componentNode)) ***REMOVED***
      componentNode = componentNode.parent;
    ***REMOVED***
    const component = components.get(componentNode);
    const declaredPropTypes = component && component.declaredPropTypes || ***REMOVED******REMOVED***;
    let ignorePropsValidation = component && component.ignorePropsValidation || false;
    switch (propTypes && propTypes.type) ***REMOVED***
      case 'ObjectTypeAnnotation':
        ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes);
        break;
      case 'ObjectExpression':
        iterateProperties(context, propTypes.properties, (key, value, propNode) => ***REMOVED***
          if (!value) ***REMOVED***
            ignorePropsValidation = true;
            return;
          ***REMOVED***
          const types = buildReactDeclarationTypes(value, key);
          types.fullName = key;
          types.name = key;
          types.node = propNode;
          types.isRequired = propsUtil.isRequiredPropType(value);
          declaredPropTypes[key] = types;
        ***REMOVED***);
        break;
      case 'MemberExpression': ***REMOVED***
        let curDeclaredPropTypes = declaredPropTypes;
        // Walk the list of properties, until we reach the assignment
        // ie: ClassX.propTypes.a.b.c = ...
        while (
          propTypes &&
          propTypes.parent &&
          propTypes.parent.type !== 'AssignmentExpression' &&
          propTypes.property &&
          curDeclaredPropTypes
        ) ***REMOVED***
          const propName = propTypes.property.name;
          if (propName in curDeclaredPropTypes) ***REMOVED***
            curDeclaredPropTypes = curDeclaredPropTypes[propName].children;
            propTypes = propTypes.parent;
          ***REMOVED*** else ***REMOVED***
            // This will crash at runtime because we haven't seen this key before
            // stop this and do not declare it
            propTypes = null;
          ***REMOVED***
        ***REMOVED***
        if (propTypes && propTypes.parent && propTypes.property) ***REMOVED***
          if (!(propTypes === propTypes.parent.left && propTypes.parent.left.object)) ***REMOVED***
            ignorePropsValidation = true;
            break;
          ***REMOVED***
          const parentProp = context.getSource(propTypes.parent.left.object).replace(/^.*\.propTypes\./, '');
          const types = buildReactDeclarationTypes(
            propTypes.parent.right,
            parentProp
          );

          types.name = propTypes.property.name;
          types.fullName = [parentProp, propTypes.property.name].join('.');
          types.node = propTypes.parent;
          types.isRequired = propsUtil.isRequiredPropType(propTypes.parent.right);
          curDeclaredPropTypes[propTypes.property.name] = types;
        ***REMOVED*** else ***REMOVED***
          let isUsedInPropTypes = false;
          let n = propTypes;
          while (n) ***REMOVED***
            if (n.type === 'AssignmentExpression' && propsUtil.isPropTypesDeclaration(n.left) ||
              (n.type === 'ClassProperty' || n.type === 'Property') && propsUtil.isPropTypesDeclaration(n)) ***REMOVED***
              // Found a propType used inside of another propType. This is not considered usage, we'll still validate
              // this component.
              isUsedInPropTypes = true;
              break;
            ***REMOVED***
            n = n.parent;
          ***REMOVED***
          if (!isUsedInPropTypes) ***REMOVED***
            ignorePropsValidation = true;
          ***REMOVED***
        ***REMOVED***
        break;
      ***REMOVED***
      case 'Identifier': ***REMOVED***
        const variablesInScope = variableUtil.variablesInScope(context);
        const firstMatchingVariable = variablesInScope
          .find(variableInScope => variableInScope.name === propTypes.name);
        if (firstMatchingVariable) ***REMOVED***
          const defInScope = firstMatchingVariable.defs[firstMatchingVariable.defs.length - 1];
          markPropTypesAsDeclared(node, defInScope.node && defInScope.node.init);
          return;
        ***REMOVED***
        ignorePropsValidation = true;
        break;
      ***REMOVED***
      case 'CallExpression': ***REMOVED***
        if (
          propWrapperUtil.isPropWrapperFunction(
            context,
            context.getSourceCode().getText(propTypes.callee)
          ) &&
          propTypes.arguments && propTypes.arguments[0]
        ) ***REMOVED***
          markPropTypesAsDeclared(node, propTypes.arguments[0]);
          return;
        ***REMOVED***
        break;
      ***REMOVED***
      case 'IntersectionTypeAnnotation':
        ignorePropsValidation = declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes);
        break;
      case null:
        break;
      default:
        ignorePropsValidation = true;
        break;
    ***REMOVED***

    components.set(node, ***REMOVED***
      declaredPropTypes,
      ignorePropsValidation
    ***REMOVED***);
  ***REMOVED***

  /**
   * @param ***REMOVED***ASTNode***REMOVED*** node We expect either an ArrowFunctionExpression,
   *   FunctionDeclaration, or FunctionExpression
   */
  function markAnnotatedFunctionArgumentsAsDeclared(node) ***REMOVED***
    if (!node.params || !node.params.length || !annotations.isAnnotatedFunctionPropsDeclaration(node, context)) ***REMOVED***
      return;
    ***REMOVED***

    if (isInsideClassBody(node)) ***REMOVED***
      return;
    ***REMOVED***

    const param = node.params[0];
    if (param.typeAnnotation && param.typeAnnotation.typeAnnotation && param.typeAnnotation.typeAnnotation.type === 'UnionTypeAnnotation') ***REMOVED***
      param.typeAnnotation.typeAnnotation.types.forEach((annotation) => ***REMOVED***
        if (annotation.type === 'GenericTypeAnnotation') ***REMOVED***
          markPropTypesAsDeclared(node, resolveTypeAnnotation(annotation));
        ***REMOVED*** else ***REMOVED***
          markPropTypesAsDeclared(node, annotation);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED*** else ***REMOVED***
      markPropTypesAsDeclared(node, resolveTypeAnnotation(param));
    ***REMOVED***
  ***REMOVED***

  /**
   * Resolve the type annotation for a given class declaration node with superTypeParameters.
   *
   * @param ***REMOVED***ASTNode***REMOVED*** node The annotation or a node containing the type annotation.
   * @returns ***REMOVED***ASTNode***REMOVED*** The resolved type annotation for the node.
   */
  function resolveSuperParameterPropsType(node) ***REMOVED***
    let propsParameterPosition;
    try ***REMOVED***
      // Flow <=0.52 had 3 required TypedParameters of which the second one is the Props.
      // Flow >=0.53 has 2 optional TypedParameters of which the first one is the Props.
      propsParameterPosition = versionUtil.testFlowVersion(context, '0.53.0') ? 0 : 1;
    ***REMOVED*** catch (e) ***REMOVED***
      // In case there is no flow version defined, we can safely assume that when there are 3 Props we are dealing with version <= 0.52
      propsParameterPosition = node.superTypeParameters.params.length <= 2 ? 0 : 1;
    ***REMOVED***

    let annotation = node.superTypeParameters.params[propsParameterPosition];
    while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) ***REMOVED***
      annotation = annotation.typeAnnotation;
    ***REMOVED***

    if (annotation && annotation.type === 'GenericTypeAnnotation' && getInTypeScope(annotation.id.name)) ***REMOVED***
      return getInTypeScope(annotation.id.name);
    ***REMOVED***
    return annotation;
  ***REMOVED***

  /**
   * Checks if we are declaring a `props` class property with a flow type annotation.
   * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
   * @returns ***REMOVED***Boolean***REMOVED*** True if the node is a type annotated props declaration, false if not.
   */
  function isAnnotatedClassPropsDeclaration(node) ***REMOVED***
    if (node && node.type === 'ClassProperty') ***REMOVED***
      const tokens = context.getFirstTokens(node, 2);
      if (
        node.typeAnnotation && (
          tokens[0].value === 'props' ||
          (tokens[1] && tokens[1].value === 'props')
        )
      ) ***REMOVED***
        return true;
      ***REMOVED***
    ***REMOVED***
    return false;
  ***REMOVED***

  return ***REMOVED***
    ClassExpression(node) ***REMOVED***
      // TypeParameterDeclaration need to be added to typeScope in order to handle ClassExpressions.
      // This visitor is executed before TypeParameterDeclaration are scoped, therefore we postpone
      // processing class expressions until when the program exists.
      classExpressions.push(node);
    ***REMOVED***,

    ClassDeclaration(node) ***REMOVED***
      if (isSuperTypeParameterPropsDeclaration(node)) ***REMOVED***
        markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node));
      ***REMOVED***
    ***REMOVED***,

    ClassProperty(node) ***REMOVED***
      if (isAnnotatedClassPropsDeclaration(node)) ***REMOVED***
        markPropTypesAsDeclared(node, resolveTypeAnnotation(node));
      ***REMOVED*** else if (propsUtil.isPropTypesDeclaration(node)) ***REMOVED***
        markPropTypesAsDeclared(node, node.value);
      ***REMOVED***
    ***REMOVED***,

    ObjectExpression(node) ***REMOVED***
      // Search for the proptypes declaration
      node.properties.forEach((property) => ***REMOVED***
        if (!propsUtil.isPropTypesDeclaration(property)) ***REMOVED***
          return;
        ***REMOVED***
        markPropTypesAsDeclared(node, property.value);
      ***REMOVED***);
    ***REMOVED***,

    FunctionExpression(node) ***REMOVED***
      if (node.parent.type !== 'MethodDefinition') ***REMOVED***
        markAnnotatedFunctionArgumentsAsDeclared(node);
      ***REMOVED***
    ***REMOVED***,

    FunctionDeclaration: markAnnotatedFunctionArgumentsAsDeclared,

    ArrowFunctionExpression: markAnnotatedFunctionArgumentsAsDeclared,

    MemberExpression(node) ***REMOVED***
      if (propsUtil.isPropTypesDeclaration(node)) ***REMOVED***
        const component = utils.getRelatedComponent(node);
        if (!component) ***REMOVED***
          return;
        ***REMOVED***
        markPropTypesAsDeclared(component.node, node.parent.right || node.parent);
      ***REMOVED***
    ***REMOVED***,

    MethodDefinition(node) ***REMOVED***
      if (!node.static || node.kind !== 'get' || !propsUtil.isPropTypesDeclaration(node)) ***REMOVED***
        return;
      ***REMOVED***

      let i = node.value.body.body.length - 1;
      for (; i >= 0; i--) ***REMOVED***
        if (node.value.body.body[i].type === 'ReturnStatement') ***REMOVED***
          break;
        ***REMOVED***
      ***REMOVED***

      if (i >= 0) ***REMOVED***
        markPropTypesAsDeclared(node, node.value.body.body[i].argument);
      ***REMOVED***
    ***REMOVED***,

    TypeAlias(node) ***REMOVED***
      setInTypeScope(node.id.name, node.right);
    ***REMOVED***,

    TypeParameterDeclaration(node) ***REMOVED***
      const identifier = node.params[0];

      if (identifier.typeAnnotation) ***REMOVED***
        setInTypeScope(identifier.name, identifier.typeAnnotation.typeAnnotation);
      ***REMOVED***
    ***REMOVED***,

    Program() ***REMOVED***
      stack = [***REMOVED******REMOVED***];
    ***REMOVED***,

    BlockStatement() ***REMOVED***
      stack.push(Object.create(typeScope()));
    ***REMOVED***,

    'BlockStatement:exit': function () ***REMOVED***
      stack.pop();
    ***REMOVED***,

    'Program:exit': function () ***REMOVED***
      classExpressions.forEach((node) => ***REMOVED***
        if (isSuperTypeParameterPropsDeclaration(node)) ***REMOVED***
          markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node));
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***;
