/**
 * @fileoverview Common used propTypes detection functionality.
 */

'use strict';

const astUtil = require('./ast');
const versionUtil = require('./version');
const ast = require('./ast');

// ------------------------------------------------------------------------------
// Constants
// ------------------------------------------------------------------------------

const LIFE_CYCLE_METHODS = ['componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate'];
const ASYNC_SAFE_LIFE_CYCLE_METHODS = ['getDerivedStateFromProps', 'getSnapshotBeforeUpdate', 'UNSAFE_componentWillReceiveProps', 'UNSAFE_componentWillUpdate'];

function createPropVariables() ***REMOVED***
  /** @type ***REMOVED***Map<string, string[]>***REMOVED*** Maps the variable to its definition. `props.a.b` is stored as `['a', 'b']` */
  let propVariables = new Map();
  let hasBeenWritten = false;
  const stack = [***REMOVED***propVariables, hasBeenWritten***REMOVED***];
  return ***REMOVED***
    pushScope() ***REMOVED***
      // popVariables is not copied until first write.
      stack.push(***REMOVED***propVariables, hasBeenWritten: false***REMOVED***);
    ***REMOVED***,
    popScope() ***REMOVED***
      stack.pop();
      propVariables = stack[stack.length - 1].propVariables;
      hasBeenWritten = stack[stack.length - 1].hasBeenWritten;
    ***REMOVED***,
    /**
     * Add a variable name to the current scope
     * @param ***REMOVED***string***REMOVED*** name
     * @param ***REMOVED***string[]***REMOVED*** allNames Example: `props.a.b` should be formatted as `['a', 'b']`
     */
    set(name, allNames) ***REMOVED***
      if (!hasBeenWritten) ***REMOVED***
        // copy on write
        propVariables = new Map(propVariables);
        Object.assign(stack[stack.length - 1], ***REMOVED***propVariables, hasBeenWritten: true***REMOVED***);
        stack[stack.length - 1].hasBeenWritten = true;
      ***REMOVED***
      return propVariables.set(name, allNames);
    ***REMOVED***,
    /**
     * Get the definition of a variable.
     * @param ***REMOVED***string***REMOVED*** name
     * @returns ***REMOVED***string[]***REMOVED*** Example: `props.a.b` is represented by `['a', 'b']`
     */
    get(name) ***REMOVED***
      return propVariables.get(name);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***

/**
 * Checks if the string is one of `props`, `nextProps`, or `prevProps`
 * @param ***REMOVED***string***REMOVED*** name The AST node being checked.
 * @returns ***REMOVED***Boolean***REMOVED*** True if the prop name matches
 */
function isCommonVariableNameForProps(name) ***REMOVED***
  return name === 'props' || name === 'nextProps' || name === 'prevProps';
***REMOVED***

/**
 * Checks if the component must be validated
 * @param ***REMOVED***Object***REMOVED*** component The component to process
 * @returns ***REMOVED***Boolean***REMOVED*** True if the component must be validated, false if not.
 */
function mustBeValidated(component) ***REMOVED***
  return !!(component && !component.ignorePropsValidation);
***REMOVED***

/**
 * Check if we are in a lifecycle method
 * @return ***REMOVED***boolean***REMOVED*** true if we are in a class constructor, false if not
 */
function inLifeCycleMethod(context, checkAsyncSafeLifeCycles) ***REMOVED***
  let scope = context.getScope();
  while (scope) ***REMOVED***
    if (scope.block && scope.block.parent && scope.block.parent.key) ***REMOVED***
      const name = scope.block.parent.key.name;

      if (LIFE_CYCLE_METHODS.indexOf(name) >= 0) ***REMOVED***
        return true;
      ***REMOVED***
      if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(name) >= 0) ***REMOVED***
        return true;
      ***REMOVED***
    ***REMOVED***
    scope = scope.upper;
  ***REMOVED***
  return false;
***REMOVED***

/**
 * Returns true if the given node is a React Component lifecycle method
 * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
 * @return ***REMOVED***Boolean***REMOVED*** True if the node is a lifecycle method
 */
function isNodeALifeCycleMethod(node, checkAsyncSafeLifeCycles) ***REMOVED***
  const nodeKeyName = (node.key || /** @type ***REMOVED***ASTNode***REMOVED*** */ (***REMOVED******REMOVED***)).name;

  if (node.kind === 'constructor') ***REMOVED***
    return true;
  ***REMOVED***
  if (LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) ***REMOVED***
    return true;
  ***REMOVED***
  if (checkAsyncSafeLifeCycles && ASYNC_SAFE_LIFE_CYCLE_METHODS.indexOf(nodeKeyName) >= 0) ***REMOVED***
    return true;
  ***REMOVED***

  return false;
***REMOVED***

/**
 * Returns true if the given node is inside a React Component lifecycle
 * method.
 * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
 * @return ***REMOVED***Boolean***REMOVED*** True if the node is inside a lifecycle method
 */
function isInLifeCycleMethod(node, checkAsyncSafeLifeCycles) ***REMOVED***
  if ((node.type === 'MethodDefinition' || node.type === 'Property') && isNodeALifeCycleMethod(node, checkAsyncSafeLifeCycles)) ***REMOVED***
    return true;
  ***REMOVED***

  if (node.parent) ***REMOVED***
    return isInLifeCycleMethod(node.parent, checkAsyncSafeLifeCycles);
  ***REMOVED***

  return false;
***REMOVED***

/**
 * Check if the current node is in a setState updater method
 * @return ***REMOVED***boolean***REMOVED*** true if we are in a setState updater, false if not
 */
function inSetStateUpdater(context) ***REMOVED***
  let scope = context.getScope();
  while (scope) ***REMOVED***
    if (
      scope.block && scope.block.parent &&
      scope.block.parent.type === 'CallExpression' &&
      scope.block.parent.callee.property &&
      scope.block.parent.callee.property.name === 'setState' &&
      // Make sure we are in the updater not the callback
      scope.block.parent.arguments[0].start === scope.block.start
    ) ***REMOVED***
      return true;
    ***REMOVED***
    scope = scope.upper;
  ***REMOVED***
  return false;
***REMOVED***

function isPropArgumentInSetStateUpdater(context, name) ***REMOVED***
  if (typeof name !== 'string') ***REMOVED***
    return;
  ***REMOVED***
  let scope = context.getScope();
  while (scope) ***REMOVED***
    if (
      scope.block && scope.block.parent &&
      scope.block.parent.type === 'CallExpression' &&
      scope.block.parent.callee.property &&
      scope.block.parent.callee.property.name === 'setState' &&
      // Make sure we are in the updater not the callback
      scope.block.parent.arguments[0].start === scope.block.start &&
      scope.block.parent.arguments[0].params &&
      scope.block.parent.arguments[0].params.length > 1
    ) ***REMOVED***
      return scope.block.parent.arguments[0].params[1].name === name;
    ***REMOVED***
    scope = scope.upper;
  ***REMOVED***
  return false;
***REMOVED***

function isInClassComponent(utils) ***REMOVED***
  return utils.getParentES6Component() || utils.getParentES5Component();
***REMOVED***

/**
 * Checks if the node is `this.props`
 * @param ***REMOVED***ASTNode|undefined***REMOVED*** node
 * @returns ***REMOVED***boolean***REMOVED***
 */
function isThisDotProps(node) ***REMOVED***
  return !!node &&
    node.type === 'MemberExpression' &&
    node.object.type === 'ThisExpression' &&
    node.property.name === 'props';
***REMOVED***

/**
 * Checks if the prop has spread operator.
 * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being marked.
 * @returns ***REMOVED***Boolean***REMOVED*** True if the prop has spread operator, false if not.
 */
function hasSpreadOperator(context, node) ***REMOVED***
  const tokens = context.getSourceCode().getTokens(node);
  return tokens.length && tokens[0].value === '...';
***REMOVED***

/**
 * Retrieve the name of a property node
 * @param ***REMOVED***ASTNode***REMOVED*** node The AST node with the property.
 * @return ***REMOVED***string|undefined***REMOVED*** the name of the property or undefined if not found
 */
function getPropertyName(node) ***REMOVED***
  const property = node.property;
  if (property) ***REMOVED***
    switch (property.type) ***REMOVED***
      case 'Identifier':
        if (node.computed) ***REMOVED***
          return '__COMPUTED_PROP__';
        ***REMOVED***
        return property.name;
      case 'MemberExpression':
        return;
      case 'Literal':
        // Accept computed properties that are literal strings
        if (typeof property.value === 'string') ***REMOVED***
          return property.value;
        ***REMOVED***
        // falls through
      default:
        if (node.computed) ***REMOVED***
          return '__COMPUTED_PROP__';
        ***REMOVED***
        break;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * Checks if the node is a propTypes usage of the form `this.props.*`, `props.*`, `prevProps.*`, or `nextProps.*`.
 * @param ***REMOVED***ASTNode***REMOVED*** node
 * @param ***REMOVED***Context***REMOVED*** context
 * @param ***REMOVED***Object***REMOVED*** utils
 * @param ***REMOVED***boolean***REMOVED*** checkAsyncSafeLifeCycles
 * @returns ***REMOVED***boolean***REMOVED***
 */
function isPropTypesUsageByMemberExpression(node, context, utils, checkAsyncSafeLifeCycles) ***REMOVED***
  if (isInClassComponent(utils)) ***REMOVED***
    // this.props.*
    if (isThisDotProps(node.object)) ***REMOVED***
      return true;
    ***REMOVED***
    // props.* or prevProps.* or nextProps.*
    if (
      isCommonVariableNameForProps(node.object.name) &&
      (inLifeCycleMethod(context, checkAsyncSafeLifeCycles) || utils.inConstructor())
    ) ***REMOVED***
      return true;
    ***REMOVED***
    // this.setState((_, props) => props.*))
    if (isPropArgumentInSetStateUpdater(context, node.object.name)) ***REMOVED***
      return true;
    ***REMOVED***
    return false;
  ***REMOVED***
  // props.* in function component
  return node.object.name === 'props' && !ast.isAssignmentLHS(node);
***REMOVED***

module.exports = function usedPropTypesInstructions(context, components, utils) ***REMOVED***
  const checkAsyncSafeLifeCycles = versionUtil.testReactVersion(context, '16.3.0');

  const propVariables = createPropVariables();
  const pushScope = propVariables.pushScope;
  const popScope = propVariables.popScope;

  /**
   * Mark a prop type as used
   * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being marked.
   * @param ***REMOVED***string[]***REMOVED*** [parentNames]
   */
  function markPropTypesAsUsed(node, parentNames) ***REMOVED***
    parentNames = parentNames || [];
    let type;
    let name;
    let allNames;
    let properties;
    switch (node.type) ***REMOVED***
      case 'MemberExpression':
        name = getPropertyName(node);
        if (name) ***REMOVED***
          allNames = parentNames.concat(name);
          if (
            // Match props.foo.bar, don't match bar[props.foo]
            node.parent.type === 'MemberExpression' &&
            node.parent.object === node
          ) ***REMOVED***
            markPropTypesAsUsed(node.parent, allNames);
          ***REMOVED***
          // Handle the destructuring part of `const ***REMOVED***foo***REMOVED*** = props.a.b`
          if (
            node.parent.type === 'VariableDeclarator' &&
            node.parent.id.type === 'ObjectPattern'
          ) ***REMOVED***
            node.parent.id.parent = node.parent; // patch for bug in eslint@4 in which ObjectPattern has no parent
            markPropTypesAsUsed(node.parent.id, allNames);
          ***REMOVED***

          // const a = props.a
          if (
            node.parent.type === 'VariableDeclarator' &&
            node.parent.id.type === 'Identifier'
          ) ***REMOVED***
            propVariables.set(node.parent.id.name, allNames);
          ***REMOVED***
          // Do not mark computed props as used.
          type = name !== '__COMPUTED_PROP__' ? 'direct' : null;
        ***REMOVED***
        break;
      case 'ArrowFunctionExpression':
      case 'FunctionDeclaration':
      case 'FunctionExpression': ***REMOVED***
        if (node.params.length === 0) ***REMOVED***
          break;
        ***REMOVED***
        type = 'destructuring';
        const propParam = inSetStateUpdater(context) ? node.params[1] : node.params[0];
        properties = propParam.type === 'AssignmentPattern' ?
          propParam.left.properties :
          propParam.properties;
        break;
      ***REMOVED***
      case 'ObjectPattern':
        type = 'destructuring';
        properties = node.properties;
        break;
      default:
        throw new Error(`$***REMOVED***node.type***REMOVED*** ASTNodes are not handled by markPropTypesAsUsed`);
    ***REMOVED***

    const component = components.get(utils.getParentComponent());
    const usedPropTypes = component && component.usedPropTypes || [];
    let ignoreUnusedPropTypesValidation = component && component.ignoreUnusedPropTypesValidation || false;

    switch (type) ***REMOVED***
      case 'direct': ***REMOVED***
        // Ignore Object methods
        if (name in Object.prototype) ***REMOVED***
          break;
        ***REMOVED***

        const reportedNode = node.property;
        usedPropTypes.push(***REMOVED***
          name,
          allNames,
          node: reportedNode
        ***REMOVED***);
        break;
      ***REMOVED***
      case 'destructuring': ***REMOVED***
        for (let k = 0, l = (properties || []).length; k < l; k++) ***REMOVED***
          if (hasSpreadOperator(context, properties[k]) || properties[k].computed) ***REMOVED***
            ignoreUnusedPropTypesValidation = true;
            break;
          ***REMOVED***
          const propName = ast.getKeyValue(context, properties[k]);

          if (propName) ***REMOVED***
            propVariables.set(propName, parentNames.concat(propName));
            usedPropTypes.push(***REMOVED***
              allNames: parentNames.concat([propName]),
              name: propName,
              node: properties[k]
            ***REMOVED***);
          ***REMOVED***

          if (
            propName &&
            properties[k].type === 'Property' &&
            properties[k].value.type === 'ObjectPattern'
          ) ***REMOVED***
            markPropTypesAsUsed(properties[k].value, parentNames.concat([propName]));
          ***REMOVED***
        ***REMOVED***
        break;
      ***REMOVED***
      default:
        break;
    ***REMOVED***

    components.set(component ? component.node : node, ***REMOVED***
      usedPropTypes,
      ignoreUnusedPropTypesValidation
    ***REMOVED***);
  ***REMOVED***

  /**
   * @param ***REMOVED***ASTNode***REMOVED*** node We expect either an ArrowFunctionExpression,
   *   FunctionDeclaration, or FunctionExpression
   */
  function markDestructuredFunctionArgumentsAsUsed(node) ***REMOVED***
    const param = node.params && inSetStateUpdater(context) ? node.params[1] : node.params[0];

    const destructuring = param && (
      param.type === 'ObjectPattern' ||
      param.type === 'AssignmentPattern' && param.left.type === 'ObjectPattern'
    );

    if (destructuring && (components.get(node) || components.get(node.parent))) ***REMOVED***
      markPropTypesAsUsed(node);
    ***REMOVED***
  ***REMOVED***

  function handleSetStateUpdater(node) ***REMOVED***
    if (!node.params || node.params.length < 2 || !inSetStateUpdater(context)) ***REMOVED***
      return;
    ***REMOVED***
    markPropTypesAsUsed(node);
  ***REMOVED***

  /**
   * Handle both stateless functions and setState updater functions.
   * @param ***REMOVED***ASTNode***REMOVED*** node We expect either an ArrowFunctionExpression,
   *   FunctionDeclaration, or FunctionExpression
   */
  function handleFunctionLikeExpressions(node) ***REMOVED***
    pushScope();
    handleSetStateUpdater(node);
    markDestructuredFunctionArgumentsAsUsed(node);
  ***REMOVED***

  function handleCustomValidators(component) ***REMOVED***
    const propTypes = component.declaredPropTypes;
    if (!propTypes) ***REMOVED***
      return;
    ***REMOVED***

    Object.keys(propTypes).forEach((key) => ***REMOVED***
      const node = propTypes[key].node;

      if (node.value && astUtil.isFunctionLikeExpression(node.value)) ***REMOVED***
        markPropTypesAsUsed(node.value);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  return ***REMOVED***
    VariableDeclarator(node) ***REMOVED***
      // let props = this.props
      if (isThisDotProps(node.init) && isInClassComponent(utils) && node.id.type === 'Identifier') ***REMOVED***
        propVariables.set(node.id.name, []);
      ***REMOVED***

      // Only handles destructuring
      if (node.id.type !== 'ObjectPattern' || !node.init) ***REMOVED***
        return;
      ***REMOVED***

      // let ***REMOVED***props: ***REMOVED***firstname***REMOVED******REMOVED*** = this
      const propsProperty = node.id.properties.find(property => (
        property.key &&
        (property.key.name === 'props' || property.key.value === 'props')
      ));
      if (node.init.type === 'ThisExpression' && propsProperty && propsProperty.value.type === 'ObjectPattern') ***REMOVED***
        markPropTypesAsUsed(propsProperty.value);
        return;
      ***REMOVED***

      // let ***REMOVED***props***REMOVED*** = this
      if (node.init.type === 'ThisExpression' && propsProperty && propsProperty.value.name === 'props') ***REMOVED***
        propVariables.set('props', []);
        return;
      ***REMOVED***

      // let ***REMOVED***firstname***REMOVED*** = props
      if (
        isCommonVariableNameForProps(node.init.name) &&
        (utils.getParentStatelessComponent() || isInLifeCycleMethod(node, checkAsyncSafeLifeCycles))
      ) ***REMOVED***
        markPropTypesAsUsed(node.id);
        return;
      ***REMOVED***

      // let ***REMOVED***firstname***REMOVED*** = this.props
      if (isThisDotProps(node.init) && isInClassComponent(utils)) ***REMOVED***
        markPropTypesAsUsed(node.id);
        return;
      ***REMOVED***

      // let ***REMOVED***firstname***REMOVED*** = thing, where thing is defined by const thing = this.props.**.*
      if (propVariables.get(node.init.name)) ***REMOVED***
        markPropTypesAsUsed(node.id, propVariables.get(node.init.name));
      ***REMOVED***
    ***REMOVED***,

    FunctionDeclaration: handleFunctionLikeExpressions,

    ArrowFunctionExpression: handleFunctionLikeExpressions,

    FunctionExpression: handleFunctionLikeExpressions,

    'FunctionDeclaration:exit': popScope,

    'ArrowFunctionExpression:exit': popScope,

    'FunctionExpression:exit': popScope,

    JSXSpreadAttribute(node) ***REMOVED***
      const component = components.get(utils.getParentComponent());
      components.set(component ? component.node : node, ***REMOVED***
        ignoreUnusedPropTypesValidation: true
      ***REMOVED***);
    ***REMOVED***,

    MemberExpression(node) ***REMOVED***
      if (isPropTypesUsageByMemberExpression(node, context, utils, checkAsyncSafeLifeCycles)) ***REMOVED***
        markPropTypesAsUsed(node);
        return;
      ***REMOVED***

      if (propVariables.get(node.object.name)) ***REMOVED***
        markPropTypesAsUsed(node, propVariables.get(node.object.name));
      ***REMOVED***
    ***REMOVED***,

    ObjectPattern(node) ***REMOVED***
      // If the object pattern is a destructured props object in a lifecycle
      // method -- mark it for used props.
      if (isNodeALifeCycleMethod(node.parent.parent, checkAsyncSafeLifeCycles) && node.properties.length > 0) ***REMOVED***
        markPropTypesAsUsed(node.parent);
      ***REMOVED***
    ***REMOVED***,

    'Program:exit': function () ***REMOVED***
      const list = components.list();

      Object.keys(list).filter(component => mustBeValidated(list[component])).forEach((component) => ***REMOVED***
        handleCustomValidators(list[component]);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***;
