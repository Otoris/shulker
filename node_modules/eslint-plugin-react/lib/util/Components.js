/**
 * @fileoverview Utility class and functions for React components detection
 * @author Yannick Croissant
 */

'use strict';

const doctrine = require('doctrine');
const arrayIncludes = require('array-includes');

const variableUtil = require('./variable');
const pragmaUtil = require('./pragma');
const astUtil = require('./ast');
const propTypesUtil = require('./propTypes');
const jsxUtil = require('./jsx');
const usedPropTypesUtil = require('./usedPropTypes');
const defaultPropsUtil = require('./defaultProps');

function getId(node) ***REMOVED***
  return node && node.range.join(':');
***REMOVED***

function usedPropTypesAreEquivalent(propA, propB) ***REMOVED***
  if (propA.name === propB.name) ***REMOVED***
    if (!propA.allNames && !propB.allNames) ***REMOVED***
      return true;
    ***REMOVED***
    if (Array.isArray(propA.allNames) && Array.isArray(propB.allNames) && propA.allNames.join('') === propB.allNames.join('')) ***REMOVED***
      return true;
    ***REMOVED***
    return false;
  ***REMOVED***
  return false;
***REMOVED***

function mergeUsedPropTypes(propsList, newPropsList) ***REMOVED***
  const propsToAdd = [];
  newPropsList.forEach((newProp) => ***REMOVED***
    const newPropisAlreadyInTheList = propsList.some(prop => usedPropTypesAreEquivalent(prop, newProp));
    if (!newPropisAlreadyInTheList) ***REMOVED***
      propsToAdd.push(newProp);
    ***REMOVED***
  ***REMOVED***);

  return propsList.concat(propsToAdd);
***REMOVED***

const Lists = new WeakMap();

/**
 * Components
 */
class Components ***REMOVED***
  constructor() ***REMOVED***
    Lists.set(this, ***REMOVED******REMOVED***);
  ***REMOVED***

  /**
   * Add a node to the components list, or update it if it's already in the list
   *
   * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being added.
   * @param ***REMOVED***Number***REMOVED*** confidence Confidence in the component detection (0=banned, 1=maybe, 2=yes)
   * @returns ***REMOVED***Object***REMOVED*** Added component object
   */
  add(node, confidence) ***REMOVED***
    const id = getId(node);
    const list = Lists.get(this);
    if (list[id]) ***REMOVED***
      if (confidence === 0 || list[id].confidence === 0) ***REMOVED***
        list[id].confidence = 0;
      ***REMOVED*** else ***REMOVED***
        list[id].confidence = Math.max(list[id].confidence, confidence);
      ***REMOVED***
      return list[id];
    ***REMOVED***
    list[id] = ***REMOVED***
      node,
      confidence
    ***REMOVED***;
    return list[id];
  ***REMOVED***

  /**
   * Find a component in the list using its node
   *
   * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being searched.
   * @returns ***REMOVED***Object***REMOVED*** Component object, undefined if the component is not found or has confidence value of 0.
   */
  get(node) ***REMOVED***
    const id = getId(node);
    const item = Lists.get(this)[id];
    if (item && item.confidence >= 1) ***REMOVED***
      return item;
    ***REMOVED***
    return null;
  ***REMOVED***

  /**
   * Update a component in the list
   *
   * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being updated.
   * @param ***REMOVED***Object***REMOVED*** props Additional properties to add to the component.
   */
  set(node, props) ***REMOVED***
    const list = Lists.get(this);
    let component = list[getId(node)];
    while (!component) ***REMOVED***
      node = node.parent;
      if (!node) ***REMOVED***
        return;
      ***REMOVED***
      component = list[getId(node)];
    ***REMOVED***

    Object.assign(
      component,
      props,
      ***REMOVED***
        usedPropTypes: mergeUsedPropTypes(
          component.usedPropTypes || [],
          props.usedPropTypes || []
        )
      ***REMOVED***
    );
  ***REMOVED***

  /**
   * Return the components list
   * Components for which we are not confident are not returned
   *
   * @returns ***REMOVED***Object***REMOVED*** Components list
   */
  list() ***REMOVED***
    const thisList = Lists.get(this);
    const list = ***REMOVED******REMOVED***;
    const usedPropTypes = ***REMOVED******REMOVED***;

    // Find props used in components for which we are not confident
    Object.keys(thisList).filter(i => thisList[i].confidence < 2).forEach((i) => ***REMOVED***
      let component = null;
      let node = null;
      node = thisList[i].node;
      while (!component && node.parent) ***REMOVED***
        node = node.parent;
        // Stop moving up if we reach a decorator
        if (node.type === 'Decorator') ***REMOVED***
          break;
        ***REMOVED***
        component = this.get(node);
      ***REMOVED***
      if (component) ***REMOVED***
        const newUsedProps = (thisList[i].usedPropTypes || []).filter(propType => !propType.node || propType.node.kind !== 'init');

        const componentId = getId(component.node);

        usedPropTypes[componentId] = mergeUsedPropTypes(usedPropTypes[componentId] || [], newUsedProps);
      ***REMOVED***
    ***REMOVED***);

    // Assign used props in not confident components to the parent component
    Object.keys(thisList).filter(j => thisList[j].confidence >= 2).forEach((j) => ***REMOVED***
      const id = getId(thisList[j].node);
      list[j] = thisList[j];
      if (usedPropTypes[id]) ***REMOVED***
        list[j].usedPropTypes = mergeUsedPropTypes(list[j].usedPropTypes || [], usedPropTypes[id]);
      ***REMOVED***
    ***REMOVED***);
    return list;
  ***REMOVED***

  /**
   * Return the length of the components list
   * Components for which we are not confident are not counted
   *
   * @returns ***REMOVED***Number***REMOVED*** Components list length
   */
  length() ***REMOVED***
    const list = Lists.get(this);
    return Object.keys(list).filter(i => list[i].confidence >= 2).length;
  ***REMOVED***
***REMOVED***

function componentRule(rule, context) ***REMOVED***
  const createClass = pragmaUtil.getCreateClassFromContext(context);
  const pragma = pragmaUtil.getFromContext(context);
  const sourceCode = context.getSourceCode();
  const components = new Components();

  // Utilities for component detection
  const utils = ***REMOVED***

    /**
     * Check if the node is a React ES5 component
     *
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     * @returns ***REMOVED***Boolean***REMOVED*** True if the node is a React ES5 component, false if not
     */
    isES5Component(node) ***REMOVED***
      if (!node.parent) ***REMOVED***
        return false;
      ***REMOVED***
      return new RegExp(`^($***REMOVED***pragma***REMOVED***\\.)?$***REMOVED***createClass***REMOVED***$`).test(sourceCode.getText(node.parent.callee));
    ***REMOVED***,

    /**
     * Check if the node is a React ES6 component
     *
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     * @returns ***REMOVED***Boolean***REMOVED*** True if the node is a React ES6 component, false if not
     */
    isES6Component(node) ***REMOVED***
      if (utils.isExplicitComponent(node)) ***REMOVED***
        return true;
      ***REMOVED***

      if (!node.superClass) ***REMOVED***
        return false;
      ***REMOVED***
      return new RegExp(`^($***REMOVED***pragma***REMOVED***\\.)?(Pure)?Component$`).test(sourceCode.getText(node.superClass));
    ***REMOVED***,

    /**
     * Check if the node is explicitly declared as a descendant of a React Component
     *
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked (can be a ReturnStatement or an ArrowFunctionExpression).
     * @returns ***REMOVED***Boolean***REMOVED*** True if the node is explicitly declared as a descendant of a React Component, false if not
     */
    isExplicitComponent(node) ***REMOVED***
      let comment;
      // Sometimes the passed node may not have been parsed yet by eslint, and this function call crashes.
      // Can be removed when eslint sets "parent" property for all nodes on initial AST traversal: https://github.com/eslint/eslint-scope/issues/27
      // eslint-disable-next-line no-warning-comments
      // FIXME: Remove try/catch when https://github.com/eslint/eslint-scope/issues/27 is implemented.
      try ***REMOVED***
        comment = sourceCode.getJSDocComment(node);
      ***REMOVED*** catch (e) ***REMOVED***
        comment = null;
      ***REMOVED***

      if (comment === null) ***REMOVED***
        return false;
      ***REMOVED***

      const commentAst = doctrine.parse(comment.value, ***REMOVED***
        unwrap: true,
        tags: ['extends', 'augments']
      ***REMOVED***);

      const relevantTags = commentAst.tags.filter(tag => tag.name === 'React.Component' || tag.name === 'React.PureComponent');

      return relevantTags.length > 0;
    ***REMOVED***,

    /**
     * Checks to see if our component extends React.PureComponent
     *
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     * @returns ***REMOVED***Boolean***REMOVED*** True if node extends React.PureComponent, false if not
     */
    isPureComponent(node) ***REMOVED***
      if (node.superClass) ***REMOVED***
        return new RegExp(`^($***REMOVED***pragma***REMOVED***\\.)?PureComponent$`).test(sourceCode.getText(node.superClass));
      ***REMOVED***
      return false;
    ***REMOVED***,

    /**
     * Check if variable is destructured from pragma import
     *
     * @param ***REMOVED***string***REMOVED*** variable The variable name to check
     * @returns ***REMOVED***Boolean***REMOVED*** True if createElement is destructured from the pragma
     */
    isDestructuredFromPragmaImport(variable) ***REMOVED***
      const variables = variableUtil.variablesInScope(context);
      const variableInScope = variableUtil.getVariable(variables, variable);
      if (variableInScope) ***REMOVED***
        const map = variableInScope.scope.set;
        return map.has(pragma);
      ***REMOVED***
      return false;
    ***REMOVED***,

    /**
     * Checks to see if node is called within createElement from pragma
     *
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     * @returns ***REMOVED***Boolean***REMOVED*** True if createElement called from pragma
     */
    isCreateElement(node) ***REMOVED***
      const calledOnPragma = (
        node &&
        node.callee &&
        node.callee.object &&
        node.callee.object.name === pragma &&
        node.callee.property &&
        node.callee.property.name === 'createElement'
      );

      const calledDirectly = (
        node &&
        node.callee &&
        node.callee.name === 'createElement'
      );

      if (this.isDestructuredFromPragmaImport('createElement')) ***REMOVED***
        return calledDirectly || calledOnPragma;
      ***REMOVED***
      return calledOnPragma;
    ***REMOVED***,

    /**
     * Check if we are in a class constructor
     * @return ***REMOVED***boolean***REMOVED*** true if we are in a class constructor, false if not
     */
    inConstructor() ***REMOVED***
      let scope = context.getScope();
      while (scope) ***REMOVED***
        if (scope.block && scope.block.parent && scope.block.parent.kind === 'constructor') ***REMOVED***
          return true;
        ***REMOVED***
        scope = scope.upper;
      ***REMOVED***
      return false;
    ***REMOVED***,

    /**
     * Determine if the node is MemberExpression of `this.state`
     * @param ***REMOVED***Object***REMOVED*** node The node to process
     * @returns ***REMOVED***Boolean***REMOVED***
     */
    isStateMemberExpression(node) ***REMOVED***
      return node.type === 'MemberExpression' && node.object.type === 'ThisExpression' && node.property.name === 'state';
    ***REMOVED***,

    getReturnPropertyAndNode(ASTnode) ***REMOVED***
      let property;
      let node = ASTnode;
      switch (node.type) ***REMOVED***
        case 'ReturnStatement':
          property = 'argument';
          break;
        case 'ArrowFunctionExpression':
          property = 'body';
          if (node[property] && node[property].type === 'BlockStatement') ***REMOVED***
            node = utils.findReturnStatement(node);
            property = 'argument';
          ***REMOVED***
          break;
        default:
          node = utils.findReturnStatement(node);
          property = 'argument';
      ***REMOVED***
      return ***REMOVED***
        node,
        property
      ***REMOVED***;
    ***REMOVED***,

    /**
     * Check if the node is returning JSX
     *
     * @param ***REMOVED***ASTNode***REMOVED*** ASTnode The AST node being checked
     * @param ***REMOVED***Boolean***REMOVED*** [strict] If true, in a ternary condition the node must return JSX in both cases
     * @returns ***REMOVED***Boolean***REMOVED*** True if the node is returning JSX, false if not
     */
    isReturningJSX(ASTnode, strict) ***REMOVED***
      const nodeAndProperty = utils.getReturnPropertyAndNode(ASTnode);
      const node = nodeAndProperty.node;
      const property = nodeAndProperty.property;

      if (!node) ***REMOVED***
        return false;
      ***REMOVED***

      const returnsConditionalJSXConsequent = node[property] &&
        node[property].type === 'ConditionalExpression' &&
        jsxUtil.isJSX(node[property].consequent);
      const returnsConditionalJSXAlternate = node[property] &&
        node[property].type === 'ConditionalExpression' &&
        jsxUtil.isJSX(node[property].alternate);
      const returnsConditionalJSX = strict ?
        (returnsConditionalJSXConsequent && returnsConditionalJSXAlternate) :
        (returnsConditionalJSXConsequent || returnsConditionalJSXAlternate);

      const returnsJSX = node[property] &&
        jsxUtil.isJSX(node[property]);
      const returnsPragmaCreateElement = this.isCreateElement(node[property]);

      return Boolean(
        returnsConditionalJSX ||
        returnsJSX ||
        returnsPragmaCreateElement
      );
    ***REMOVED***,

    /**
     * Check if the node is returning null
     *
     * @param ***REMOVED***ASTNode***REMOVED*** ASTnode The AST node being checked
     * @returns ***REMOVED***Boolean***REMOVED*** True if the node is returning null, false if not
     */
    isReturningNull(ASTnode) ***REMOVED***
      const nodeAndProperty = utils.getReturnPropertyAndNode(ASTnode);
      const property = nodeAndProperty.property;
      const node = nodeAndProperty.node;

      if (!node) ***REMOVED***
        return false;
      ***REMOVED***

      return node[property] && node[property].value === null;
    ***REMOVED***,

    /**
     * Check if the node is returning JSX or null
     *
     * @param ***REMOVED***ASTNode***REMOVED*** ASTnode The AST node being checked
     * @param ***REMOVED***Boolean***REMOVED*** [strict] If true, in a ternary condition the node must return JSX in both cases
     * @returns ***REMOVED***Boolean***REMOVED*** True if the node is returning JSX or null, false if not
     */
    isReturningJSXOrNull(ASTNode, strict) ***REMOVED***
      return utils.isReturningJSX(ASTNode, strict) || utils.isReturningNull(ASTNode);
    ***REMOVED***,

    getPragmaComponentWrapper(node) ***REMOVED***
      let isPragmaComponentWrapper;
      let currentNode = node;
      let prevNode;
      do ***REMOVED***
        currentNode = currentNode.parent;
        isPragmaComponentWrapper = this.isPragmaComponentWrapper(currentNode);
        if (isPragmaComponentWrapper) ***REMOVED***
          prevNode = currentNode;
        ***REMOVED***
      ***REMOVED*** while (isPragmaComponentWrapper);

      return prevNode;
    ***REMOVED***,

    isPragmaComponentWrapper(node) ***REMOVED***
      if (!node || node.type !== 'CallExpression') ***REMOVED***
        return false;
      ***REMOVED***
      const propertyNames = ['forwardRef', 'memo'];
      const calleeObject = node.callee.object;
      if (calleeObject && node.callee.property) ***REMOVED***
        return arrayIncludes(propertyNames, node.callee.property.name) && calleeObject.name === pragma;
      ***REMOVED***
      return arrayIncludes(propertyNames, node.callee.name) && this.isDestructuredFromPragmaImport(node.callee.name);
    ***REMOVED***,

    /**
     * Find a return statment in the current node
     *
     * @param ***REMOVED***ASTNode***REMOVED*** ASTnode The AST node being checked
     */
    findReturnStatement: astUtil.findReturnStatement,

    /**
     * Get the parent component node from the current scope
     *
     * @returns ***REMOVED***ASTNode***REMOVED*** component node, null if we are not in a component
     */
    getParentComponent() ***REMOVED***
      return (
        utils.getParentES6Component() ||
        utils.getParentES5Component() ||
        utils.getParentStatelessComponent()
      );
    ***REMOVED***,

    /**
     * Get the parent ES5 component node from the current scope
     *
     * @returns ***REMOVED***ASTNode***REMOVED*** component node, null if we are not in a component
     */
    getParentES5Component() ***REMOVED***
      let scope = context.getScope();
      while (scope) ***REMOVED***
        const node = scope.block && scope.block.parent && scope.block.parent.parent;
        if (node && utils.isES5Component(node)) ***REMOVED***
          return node;
        ***REMOVED***
        scope = scope.upper;
      ***REMOVED***
      return null;
    ***REMOVED***,

    /**
     * Get the parent ES6 component node from the current scope
     *
     * @returns ***REMOVED***ASTNode***REMOVED*** component node, null if we are not in a component
     */
    getParentES6Component() ***REMOVED***
      let scope = context.getScope();
      while (scope && scope.type !== 'class') ***REMOVED***
        scope = scope.upper;
      ***REMOVED***
      const node = scope && scope.block;
      if (!node || !utils.isES6Component(node)) ***REMOVED***
        return null;
      ***REMOVED***
      return node;
    ***REMOVED***,

    /**
     * Get the parent stateless component node from the current scope
     *
     * @returns ***REMOVED***ASTNode***REMOVED*** component node, null if we are not in a component
     */
    getParentStatelessComponent() ***REMOVED***
      let scope = context.getScope();
      while (scope) ***REMOVED***
        const node = scope.block;
        const isFunction = /Function/.test(node.type); // Functions
        const isArrowFunction = astUtil.isArrowFunction(node);
        const enclosingScope = isArrowFunction ? utils.getArrowFunctionScope(scope) : scope;
        const enclosingScopeParent = enclosingScope && enclosingScope.block.parent;
        const isClass = enclosingScope && astUtil.isClass(enclosingScope.block);
        const isMethod = enclosingScopeParent && enclosingScopeParent.type === 'MethodDefinition'; // Classes methods
        const isArgument = node.parent && node.parent.type === 'CallExpression'; // Arguments (callback, etc.)
        // Attribute Expressions inside JSX Elements (<button onClick=***REMOVED***() => props.handleClick()***REMOVED***></button>)
        const isJSXExpressionContainer = node.parent && node.parent.type === 'JSXExpressionContainer';
        const pragmaComponentWrapper = this.getPragmaComponentWrapper(node);
        if (isFunction && pragmaComponentWrapper) ***REMOVED***
          return pragmaComponentWrapper;
        ***REMOVED***
        // Stop moving up if we reach a class or an argument (like a callback)
        if (isClass || isArgument) ***REMOVED***
          return null;
        ***REMOVED***
        // Return the node if it is a function that is not a class method and is not inside a JSX Element
        if (isFunction && !isMethod && !isJSXExpressionContainer && utils.isReturningJSXOrNull(node)) ***REMOVED***
          return node;
        ***REMOVED***
        scope = scope.upper;
      ***REMOVED***
      return null;
    ***REMOVED***,

    /**
     * Get an enclosing scope used to find `this` value by an arrow function
     * @param ***REMOVED***Scope***REMOVED*** scope Current scope
     * @returns ***REMOVED***Scope***REMOVED*** An enclosing scope used by an arrow function
     */
    getArrowFunctionScope(scope) ***REMOVED***
      scope = scope.upper;
      while (scope) ***REMOVED***
        if (astUtil.isFunction(scope.block) || astUtil.isClass(scope.block)) ***REMOVED***
          return scope;
        ***REMOVED***
        scope = scope.upper;
      ***REMOVED***
      return null;
    ***REMOVED***,

    /**
     * Get the related component from a node
     *
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked (must be a MemberExpression).
     * @returns ***REMOVED***ASTNode***REMOVED*** component node, null if we cannot find the component
     */
    getRelatedComponent(node) ***REMOVED***
      let i;
      let j;
      let k;
      let l;
      let componentNode;
      // Get the component path
      const componentPath = [];
      while (node) ***REMOVED***
        if (node.property && node.property.type === 'Identifier') ***REMOVED***
          componentPath.push(node.property.name);
        ***REMOVED***
        if (node.object && node.object.type === 'Identifier') ***REMOVED***
          componentPath.push(node.object.name);
        ***REMOVED***
        node = node.object;
      ***REMOVED***
      componentPath.reverse();
      const componentName = componentPath.slice(0, componentPath.length - 1).join('.');

      // Find the variable in the current scope
      const variableName = componentPath.shift();
      if (!variableName) ***REMOVED***
        return null;
      ***REMOVED***
      let variableInScope;
      const variables = variableUtil.variablesInScope(context);
      for (i = 0, j = variables.length; i < j; i++) ***REMOVED***
        if (variables[i].name === variableName) ***REMOVED***
          variableInScope = variables[i];
          break;
        ***REMOVED***
      ***REMOVED***
      if (!variableInScope) ***REMOVED***
        return null;
      ***REMOVED***

      // Try to find the component using variable references
      const refs = variableInScope.references;
      refs.some((ref) => ***REMOVED***
        let refId = ref.identifier;
        if (refId.parent && refId.parent.type === 'MemberExpression') ***REMOVED***
          refId = refId.parent;
        ***REMOVED***
        if (sourceCode.getText(refId) !== componentName) ***REMOVED***
          return false;
        ***REMOVED***
        if (refId.type === 'MemberExpression') ***REMOVED***
          componentNode = refId.parent.right;
        ***REMOVED*** else if (
          refId.parent &&
          refId.parent.type === 'VariableDeclarator' &&
          refId.parent.init &&
          refId.parent.init.type !== 'Identifier'
        ) ***REMOVED***
          componentNode = refId.parent.init;
        ***REMOVED***
        return true;
      ***REMOVED***);

      if (componentNode) ***REMOVED***
        // Return the component
        return components.add(componentNode, 1);
      ***REMOVED***

      // Try to find the component using variable declarations
      const defs = variableInScope.defs;
      const defInScope = defs.find(def => (
        def.type === 'ClassName' ||
        def.type === 'FunctionName' ||
        def.type === 'Variable'
      ));
      if (!defInScope || !defInScope.node) ***REMOVED***
        return null;
      ***REMOVED***
      componentNode = defInScope.node.init || defInScope.node;

      // Traverse the node properties to the component declaration
      for (i = 0, j = componentPath.length; i < j; i++) ***REMOVED***
        if (!componentNode.properties) ***REMOVED***
          continue; // eslint-disable-line no-continue
        ***REMOVED***
        for (k = 0, l = componentNode.properties.length; k < l; k++) ***REMOVED***
          if (componentNode.properties[k].key && componentNode.properties[k].key.name === componentPath[i]) ***REMOVED***
            componentNode = componentNode.properties[k];
            break;
          ***REMOVED***
        ***REMOVED***
        if (!componentNode || !componentNode.value) ***REMOVED***
          return null;
        ***REMOVED***
        componentNode = componentNode.value;
      ***REMOVED***

      // Return the component
      return components.add(componentNode, 1);
    ***REMOVED***
  ***REMOVED***;

  // Component detection instructions
  const detectionInstructions = ***REMOVED***
    CallExpression(node) ***REMOVED***
      if (!utils.isPragmaComponentWrapper(node)) ***REMOVED***
        return;
      ***REMOVED***
      if (node.arguments.length > 0 && astUtil.isFunctionLikeExpression(node.arguments[0])) ***REMOVED***
        components.add(node, 2);
      ***REMOVED***
    ***REMOVED***,

    ClassExpression(node) ***REMOVED***
      if (!utils.isES6Component(node)) ***REMOVED***
        return;
      ***REMOVED***
      components.add(node, 2);
    ***REMOVED***,

    ClassDeclaration(node) ***REMOVED***
      if (!utils.isES6Component(node)) ***REMOVED***
        return;
      ***REMOVED***
      components.add(node, 2);
    ***REMOVED***,

    ClassProperty(node) ***REMOVED***
      node = utils.getParentComponent();
      if (!node) ***REMOVED***
        return;
      ***REMOVED***
      components.add(node, 2);
    ***REMOVED***,

    ObjectExpression(node) ***REMOVED***
      if (!utils.isES5Component(node)) ***REMOVED***
        return;
      ***REMOVED***
      components.add(node, 2);
    ***REMOVED***,

    FunctionExpression(node) ***REMOVED***
      if (node.async) ***REMOVED***
        components.add(node, 0);
        return;
      ***REMOVED***
      const component = utils.getParentComponent();
      if (
        !component ||
        (component.parent && component.parent.type === 'JSXExpressionContainer')
      ) ***REMOVED***
        // Ban the node if we cannot find a parent component
        components.add(node, 0);
        return;
      ***REMOVED***
      components.add(component, 1);
    ***REMOVED***,

    FunctionDeclaration(node) ***REMOVED***
      if (node.async) ***REMOVED***
        components.add(node, 0);
        return;
      ***REMOVED***
      node = utils.getParentComponent();
      if (!node) ***REMOVED***
        return;
      ***REMOVED***
      components.add(node, 1);
    ***REMOVED***,

    ArrowFunctionExpression(node) ***REMOVED***
      if (node.async) ***REMOVED***
        components.add(node, 0);
        return;
      ***REMOVED***
      const component = utils.getParentComponent();
      if (
        !component ||
        (component.parent && component.parent.type === 'JSXExpressionContainer')
      ) ***REMOVED***
        // Ban the node if we cannot find a parent component
        components.add(node, 0);
        return;
      ***REMOVED***
      if (component.expression && utils.isReturningJSX(component)) ***REMOVED***
        components.add(component, 2);
      ***REMOVED*** else ***REMOVED***
        components.add(component, 1);
      ***REMOVED***
    ***REMOVED***,

    ThisExpression(node) ***REMOVED***
      const component = utils.getParentComponent();
      if (!component || !/Function/.test(component.type) || !node.parent.property) ***REMOVED***
        return;
      ***REMOVED***
      // Ban functions accessing a property on a ThisExpression
      components.add(node, 0);
    ***REMOVED***,

    ReturnStatement(node) ***REMOVED***
      if (!utils.isReturningJSX(node)) ***REMOVED***
        return;
      ***REMOVED***
      node = utils.getParentComponent();
      if (!node) ***REMOVED***
        const scope = context.getScope();
        components.add(scope.block, 1);
        return;
      ***REMOVED***
      components.add(node, 2);
    ***REMOVED***
  ***REMOVED***;

  // Update the provided rule instructions to add the component detection
  const ruleInstructions = rule(context, components, utils);
  const updatedRuleInstructions = Object.assign(***REMOVED******REMOVED***, ruleInstructions);
  const propTypesInstructions = propTypesUtil(context, components, utils);
  const usedPropTypesInstructions = usedPropTypesUtil(context, components, utils);
  const defaultPropsInstructions = defaultPropsUtil(context, components, utils);
  const allKeys = new Set(Object.keys(detectionInstructions).concat(
    Object.keys(propTypesInstructions),
    Object.keys(usedPropTypesInstructions),
    Object.keys(defaultPropsInstructions)
  ));

  allKeys.forEach((instruction) => ***REMOVED***
    updatedRuleInstructions[instruction] = function (node) ***REMOVED***
      if (instruction in detectionInstructions) ***REMOVED***
        detectionInstructions[instruction](node);
      ***REMOVED***
      if (instruction in propTypesInstructions) ***REMOVED***
        propTypesInstructions[instruction](node);
      ***REMOVED***
      if (instruction in usedPropTypesInstructions) ***REMOVED***
        usedPropTypesInstructions[instruction](node);
      ***REMOVED***
      if (instruction in defaultPropsInstructions) ***REMOVED***
        defaultPropsInstructions[instruction](node);
      ***REMOVED***
      if (ruleInstructions[instruction]) ***REMOVED***
        return ruleInstructions[instruction](node);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***);

  // Return the updated rule instructions
  return updatedRuleInstructions;
***REMOVED***

module.exports = Object.assign(Components, ***REMOVED***
  detect(rule) ***REMOVED***
    return componentRule.bind(this, rule);
  ***REMOVED***
***REMOVED***);
