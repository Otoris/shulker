/**
 * @fileoverview Enforce consistent usage of destructuring assignment of props, state, and context.
 */

'use strict';

const Components = require('../util/Components');
const docsUrl = require('../util/docsUrl');
const isAssignmentLHS = require('../util/ast').isAssignmentLHS;

const DEFAULT_OPTION = 'always';

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Enforce consistent usage of destructuring assignment of props, state, and context',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('destructuring-assignment')
    ***REMOVED***,
    schema: [***REMOVED***
      type: 'string',
      enum: [
        'always',
        'never'
      ]
    ***REMOVED***, ***REMOVED***
      type: 'object',
      properties: ***REMOVED***
        ignoreClassFields: ***REMOVED***
          type: 'boolean'
        ***REMOVED***
      ***REMOVED***,
      additionalProperties: false
    ***REMOVED***]
  ***REMOVED***,

  create: Components.detect((context, components, utils) => ***REMOVED***
    const configuration = context.options[0] || DEFAULT_OPTION;
    const ignoreClassFields = context.options[1] && context.options[1].ignoreClassFields === true || false;

    /**
     * @param ***REMOVED***ASTNode***REMOVED*** node We expect either an ArrowFunctionExpression,
     *   FunctionDeclaration, or FunctionExpression
     */
    function handleStatelessComponent(node) ***REMOVED***
      const destructuringProps = node.params && node.params[0] && node.params[0].type === 'ObjectPattern';
      const destructuringContext = node.params && node.params[1] && node.params[1].type === 'ObjectPattern';

      if (destructuringProps && components.get(node) && configuration === 'never') ***REMOVED***
        context.report(***REMOVED***
          node,
          message: 'Must never use destructuring props assignment in SFC argument'
        ***REMOVED***);
      ***REMOVED*** else if (destructuringContext && components.get(node) && configuration === 'never') ***REMOVED***
        context.report(***REMOVED***
          node,
          message: 'Must never use destructuring context assignment in SFC argument'
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    function handleSFCUsage(node) ***REMOVED***
      // props.aProp || context.aProp
      const isPropUsed = (node.object.name === 'props' || node.object.name === 'context') && !isAssignmentLHS(node);
      if (isPropUsed && configuration === 'always') ***REMOVED***
        context.report(***REMOVED***
          node,
          message: `Must use destructuring $***REMOVED***node.object.name***REMOVED*** assignment`
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    function isInClassProperty(node) ***REMOVED***
      let curNode = node.parent;
      while (curNode) ***REMOVED***
        if (curNode.type === 'ClassProperty') ***REMOVED***
          return true;
        ***REMOVED***
        curNode = curNode.parent;
      ***REMOVED***
      return false;
    ***REMOVED***

    function handleClassUsage(node) ***REMOVED***
      // this.props.Aprop || this.context.aProp || this.state.aState
      const isPropUsed = (
        node.object.type === 'MemberExpression' && node.object.object.type === 'ThisExpression' &&
        (node.object.property.name === 'props' || node.object.property.name === 'context' || node.object.property.name === 'state') &&
        !isAssignmentLHS(node)
      );

      if (
        isPropUsed && configuration === 'always' &&
        !(ignoreClassFields && isInClassProperty(node))
      ) ***REMOVED***
        context.report(***REMOVED***
          node,
          message: `Must use destructuring $***REMOVED***node.object.property.name***REMOVED*** assignment`
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    return ***REMOVED***

      FunctionDeclaration: handleStatelessComponent,

      ArrowFunctionExpression: handleStatelessComponent,

      FunctionExpression: handleStatelessComponent,

      MemberExpression(node) ***REMOVED***
        const SFCComponent = components.get(context.getScope(node).block);
        const classComponent = utils.getParentComponent(node);
        if (SFCComponent) ***REMOVED***
          handleSFCUsage(node);
        ***REMOVED***
        if (classComponent) ***REMOVED***
          handleClassUsage(node);
        ***REMOVED***
      ***REMOVED***,

      VariableDeclarator(node) ***REMOVED***
        const classComponent = utils.getParentComponent(node);
        const SFCComponent = components.get(context.getScope(node).block);

        const destructuring = (node.init && node.id && node.id.type === 'ObjectPattern');
        // let ***REMOVED***foo***REMOVED*** = props;
        const destructuringSFC = destructuring && (node.init.name === 'props' || node.init.name === 'context');
        // let ***REMOVED***foo***REMOVED*** = this.props;
        const destructuringClass = destructuring && node.init.object && node.init.object.type === 'ThisExpression' && (
          node.init.property.name === 'props' || node.init.property.name === 'context' || node.init.property.name === 'state'
        );

        if (SFCComponent && destructuringSFC && configuration === 'never') ***REMOVED***
          context.report(***REMOVED***
            node,
            message: `Must never use destructuring $***REMOVED***node.init.name***REMOVED*** assignment`
          ***REMOVED***);
        ***REMOVED***

        if (
          classComponent && destructuringClass && configuration === 'never' &&
          !(ignoreClassFields && node.parent.type === 'ClassProperty')
        ) ***REMOVED***
          context.report(***REMOVED***
            node,
            message: `Must never use destructuring $***REMOVED***node.init.property.name***REMOVED*** assignment`
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***)
***REMOVED***;
