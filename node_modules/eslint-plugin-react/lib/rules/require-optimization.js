/**
 * @fileoverview Enforce React components to have a shouldComponentUpdate method
 * @author Evgueni Naverniouk
 */

'use strict';

const Components = require('../util/Components');
const docsUrl = require('../util/docsUrl');

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Enforce React components to have a shouldComponentUpdate method',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('require-optimization')
    ***REMOVED***,

    schema: [***REMOVED***
      type: 'object',
      properties: ***REMOVED***
        allowDecorators: ***REMOVED***
          type: 'array',
          items: ***REMOVED***
            type: 'string'
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,
      additionalProperties: false
    ***REMOVED***]
  ***REMOVED***,

  create: Components.detect((context, components, utils) => ***REMOVED***
    const MISSING_MESSAGE = 'Component is not optimized. Please add a shouldComponentUpdate method.';
    const configuration = context.options[0] || ***REMOVED******REMOVED***;
    const allowDecorators = configuration.allowDecorators || [];

    /**
     * Checks to see if our component is decorated by PureRenderMixin via reactMixin
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     * @returns ***REMOVED***Boolean***REMOVED*** True if node is decorated with a PureRenderMixin, false if not.
     */
    const hasPureRenderDecorator = function (node) ***REMOVED***
      if (node.decorators && node.decorators.length) ***REMOVED***
        for (let i = 0, l = node.decorators.length; i < l; i++) ***REMOVED***
          if (
            node.decorators[i].expression &&
            node.decorators[i].expression.callee &&
            node.decorators[i].expression.callee.object &&
            node.decorators[i].expression.callee.object.name === 'reactMixin' &&
            node.decorators[i].expression.callee.property &&
            node.decorators[i].expression.callee.property.name === 'decorate' &&
            node.decorators[i].expression.arguments &&
            node.decorators[i].expression.arguments.length &&
            node.decorators[i].expression.arguments[0].name === 'PureRenderMixin'
          ) ***REMOVED***
            return true;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      return false;
    ***REMOVED***;

    /**
     * Checks to see if our component is custom decorated
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     * @returns ***REMOVED***Boolean***REMOVED*** True if node is decorated name with a custom decorated, false if not.
     */
    const hasCustomDecorator = function (node) ***REMOVED***
      const allowLength = allowDecorators.length;

      if (allowLength && node.decorators && node.decorators.length) ***REMOVED***
        for (let i = 0; i < allowLength; i++) ***REMOVED***
          for (let j = 0, l = node.decorators.length; j < l; j++) ***REMOVED***
            if (
              node.decorators[j].expression &&
              node.decorators[j].expression.name === allowDecorators[i]
            ) ***REMOVED***
              return true;
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      return false;
    ***REMOVED***;

    /**
     * Checks if we are declaring a shouldComponentUpdate method
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     * @returns ***REMOVED***Boolean***REMOVED*** True if we are declaring a shouldComponentUpdate method, false if not.
     */
    const isSCUDeclared = function (node) ***REMOVED***
      return Boolean(
        node &&
        node.name === 'shouldComponentUpdate'
      );
    ***REMOVED***;

    /**
     * Checks if we are declaring a PureRenderMixin mixin
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     * @returns ***REMOVED***Boolean***REMOVED*** True if we are declaring a PureRenderMixin method, false if not.
     */
    const isPureRenderDeclared = function (node) ***REMOVED***
      let hasPR = false;
      if (node.value && node.value.elements) ***REMOVED***
        for (let i = 0, l = node.value.elements.length; i < l; i++) ***REMOVED***
          if (node.value.elements[i] && node.value.elements[i].name === 'PureRenderMixin') ***REMOVED***
            hasPR = true;
            break;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      return Boolean(
        node &&
        node.key.name === 'mixins' &&
        hasPR
      );
    ***REMOVED***;

    /**
     * Mark shouldComponentUpdate as declared
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     */
    const markSCUAsDeclared = function (node) ***REMOVED***
      components.set(node, ***REMOVED***
        hasSCU: true
      ***REMOVED***);
    ***REMOVED***;

    /**
     * Reports missing optimization for a given component
     * @param ***REMOVED***Object***REMOVED*** component The component to process
     */
    const reportMissingOptimization = function (component) ***REMOVED***
      context.report(***REMOVED***
        node: component.node,
        message: MISSING_MESSAGE,
        data: ***REMOVED***
          component: component.name
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***;

    /**
     * Checks if we are declaring function in class
     * @returns ***REMOVED***Boolean***REMOVED*** True if we are declaring function in class, false if not.
     */
    const isFunctionInClass = function () ***REMOVED***
      let blockNode;
      let scope = context.getScope();
      while (scope) ***REMOVED***
        blockNode = scope.block;
        if (blockNode && blockNode.type === 'ClassDeclaration') ***REMOVED***
          return true;
        ***REMOVED***
        scope = scope.upper;
      ***REMOVED***

      return false;
    ***REMOVED***;

    return ***REMOVED***
      ArrowFunctionExpression(node) ***REMOVED***
        // Stateless Functional Components cannot be optimized (yet)
        markSCUAsDeclared(node);
      ***REMOVED***,

      ClassDeclaration(node) ***REMOVED***
        if (!(hasPureRenderDecorator(node) || hasCustomDecorator(node) || utils.isPureComponent(node))) ***REMOVED***
          return;
        ***REMOVED***
        markSCUAsDeclared(node);
      ***REMOVED***,

      FunctionDeclaration(node) ***REMOVED***
        // Skip if the function is declared in the class
        if (isFunctionInClass()) ***REMOVED***
          return;
        ***REMOVED***
        // Stateless Functional Components cannot be optimized (yet)
        markSCUAsDeclared(node);
      ***REMOVED***,

      FunctionExpression(node) ***REMOVED***
        // Skip if the function is declared in the class
        if (isFunctionInClass()) ***REMOVED***
          return;
        ***REMOVED***
        // Stateless Functional Components cannot be optimized (yet)
        markSCUAsDeclared(node);
      ***REMOVED***,

      MethodDefinition(node) ***REMOVED***
        if (!isSCUDeclared(node.key)) ***REMOVED***
          return;
        ***REMOVED***
        markSCUAsDeclared(node);
      ***REMOVED***,

      ObjectExpression(node) ***REMOVED***
        // Search for the shouldComponentUpdate declaration
        const found = node.properties.some(property => (
          property.key &&
          (isSCUDeclared(property.key) || isPureRenderDeclared(property))
        ));
        if (found) ***REMOVED***
          markSCUAsDeclared(node);
        ***REMOVED***
      ***REMOVED***,

      'Program:exit': function () ***REMOVED***
        const list = components.list();

        // Report missing shouldComponentUpdate for all components
        Object.keys(list).filter(component => !list[component].hasSCU).forEach((component) => ***REMOVED***
          reportMissingOptimization(list[component]);
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***)
***REMOVED***;
