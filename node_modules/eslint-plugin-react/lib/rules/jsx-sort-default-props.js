/**
 * @fileoverview Enforce default props alphabetical sorting
 * @author Vladimir Kattsov
 */

'use strict';

const variableUtil = require('../util/variable');
const docsUrl = require('../util/docsUrl');
const propWrapperUtil = require('../util/propWrapper');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Enforce default props alphabetical sorting',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-sort-default-props')
    ***REMOVED***,

    schema: [***REMOVED***
      type: 'object',
      properties: ***REMOVED***
        ignoreCase: ***REMOVED***
          type: 'boolean'
        ***REMOVED***
      ***REMOVED***,
      additionalProperties: false
    ***REMOVED***]
  ***REMOVED***,

  create(context) ***REMOVED***
    const configuration = context.options[0] || ***REMOVED******REMOVED***;
    const ignoreCase = configuration.ignoreCase || false;

    /**
     * Get properties name
     * @param ***REMOVED***Object***REMOVED*** node - Property.
     * @returns ***REMOVED***String***REMOVED*** Property name.
     */
    function getPropertyName(node) ***REMOVED***
      if (node.key || ['MethodDefinition', 'Property'].indexOf(node.type) !== -1) ***REMOVED***
        return node.key.name;
      ***REMOVED***
      if (node.type === 'MemberExpression') ***REMOVED***
        return node.property.name;
      // Special case for class properties
      // (babel-eslint@5 does not expose property name so we have to rely on tokens)
      ***REMOVED***
      if (node.type === 'ClassProperty') ***REMOVED***
        const tokens = context.getFirstTokens(node, 2);
        return tokens[1] && tokens[1].type === 'Identifier' ? tokens[1].value : tokens[0].value;
      ***REMOVED***
      return '';
    ***REMOVED***

    /**
     * Checks if the Identifier node passed in looks like a defaultProps declaration.
     * @param   ***REMOVED***ASTNode***REMOVED***  node The node to check. Must be an Identifier node.
     * @returns ***REMOVED***Boolean***REMOVED***       `true` if the node is a defaultProps declaration, `false` if not
     */
    function isDefaultPropsDeclaration(node) ***REMOVED***
      const propName = getPropertyName(node);
      return (propName === 'defaultProps' || propName === 'getDefaultProps');
    ***REMOVED***

    function getKey(node) ***REMOVED***
      return context.getSourceCode().getText(node.key || node.argument);
    ***REMOVED***

    /**
     * Find a variable by name in the current scope.
     * @param  ***REMOVED***string***REMOVED*** name Name of the variable to look for.
     * @returns ***REMOVED***ASTNode|null***REMOVED*** Return null if the variable could not be found, ASTNode otherwise.
     */
    function findVariableByName(name) ***REMOVED***
      const variable = variableUtil.variablesInScope(context).find(item => item.name === name);

      if (!variable || !variable.defs[0] || !variable.defs[0].node) ***REMOVED***
        return null;
      ***REMOVED***

      if (variable.defs[0].node.type === 'TypeAlias') ***REMOVED***
        return variable.defs[0].node.right;
      ***REMOVED***

      return variable.defs[0].node.init;
    ***REMOVED***

    /**
     * Checks if defaultProps declarations are sorted
     * @param ***REMOVED***Array***REMOVED*** declarations The array of AST nodes being checked.
     * @returns ***REMOVED***void***REMOVED***
     */
    function checkSorted(declarations) ***REMOVED***
      declarations.reduce((prev, curr, idx, decls) => ***REMOVED***
        if (/Spread(?:Property|Element)$/.test(curr.type)) ***REMOVED***
          return decls[idx + 1];
        ***REMOVED***

        let prevPropName = getKey(prev);
        let currentPropName = getKey(curr);

        if (ignoreCase) ***REMOVED***
          prevPropName = prevPropName.toLowerCase();
          currentPropName = currentPropName.toLowerCase();
        ***REMOVED***

        if (currentPropName < prevPropName) ***REMOVED***
          context.report(***REMOVED***
            node: curr,
            message: 'Default prop types declarations should be sorted alphabetically'
          ***REMOVED***);

          return prev;
        ***REMOVED***

        return curr;
      ***REMOVED***, declarations[0]);
    ***REMOVED***

    function checkNode(node) ***REMOVED***
      switch (node && node.type) ***REMOVED***
        case 'ObjectExpression':
          checkSorted(node.properties);
          break;
        case 'Identifier': ***REMOVED***
          const propTypesObject = findVariableByName(node.name);
          if (propTypesObject && propTypesObject.properties) ***REMOVED***
            checkSorted(propTypesObject.properties);
          ***REMOVED***
          break;
        ***REMOVED***
        case 'CallExpression': ***REMOVED***
          const innerNode = node.arguments && node.arguments[0];
          if (propWrapperUtil.isPropWrapperFunction(context, node.callee.name) && innerNode) ***REMOVED***
            checkNode(innerNode);
          ***REMOVED***
          break;
        ***REMOVED***
        default:
          break;
      ***REMOVED***
    ***REMOVED***

    // --------------------------------------------------------------------------
    // Public API
    // --------------------------------------------------------------------------

    return ***REMOVED***
      ClassProperty(node) ***REMOVED***
        if (!isDefaultPropsDeclaration(node)) ***REMOVED***
          return;
        ***REMOVED***

        checkNode(node.value);
      ***REMOVED***,

      MemberExpression(node) ***REMOVED***
        if (!isDefaultPropsDeclaration(node)) ***REMOVED***
          return;
        ***REMOVED***

        checkNode(node.parent.right);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
