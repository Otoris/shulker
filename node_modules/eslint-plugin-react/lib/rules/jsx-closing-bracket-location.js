/**
 * @fileoverview Validate closing bracket location in JSX
 * @author Yannick Croissant
 */

'use strict';

const has = require('has');
const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------
module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Validate closing bracket location in JSX',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-closing-bracket-location')
    ***REMOVED***,
    fixable: 'code',

    schema: [***REMOVED***
      oneOf: [
        ***REMOVED***
          enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned']
        ***REMOVED***,
        ***REMOVED***
          type: 'object',
          properties: ***REMOVED***
            location: ***REMOVED***
              enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned']
            ***REMOVED***
          ***REMOVED***,
          additionalProperties: false
        ***REMOVED***, ***REMOVED***
          type: 'object',
          properties: ***REMOVED***
            nonEmpty: ***REMOVED***
              enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false]
            ***REMOVED***,
            selfClosing: ***REMOVED***
              enum: ['after-props', 'props-aligned', 'tag-aligned', 'line-aligned', false]
            ***REMOVED***
          ***REMOVED***,
          additionalProperties: false
        ***REMOVED***
      ]
    ***REMOVED***]
  ***REMOVED***,

  create(context) ***REMOVED***
    const MESSAGE = 'The closing bracket must be ***REMOVED******REMOVED***location***REMOVED******REMOVED******REMOVED******REMOVED***details***REMOVED******REMOVED***';
    const MESSAGE_LOCATION = ***REMOVED***
      'after-props': 'placed after the last prop',
      'after-tag': 'placed after the opening tag',
      'props-aligned': 'aligned with the last prop',
      'tag-aligned': 'aligned with the opening tag',
      'line-aligned': 'aligned with the line containing the opening tag'
    ***REMOVED***;
    const DEFAULT_LOCATION = 'tag-aligned';

    const config = context.options[0];
    const options = ***REMOVED***
      nonEmpty: DEFAULT_LOCATION,
      selfClosing: DEFAULT_LOCATION
    ***REMOVED***;

    if (typeof config === 'string') ***REMOVED***
      // simple shorthand [1, 'something']
      options.nonEmpty = config;
      options.selfClosing = config;
    ***REMOVED*** else if (typeof config === 'object') ***REMOVED***
      // [1, ***REMOVED***location: 'something'***REMOVED***] (back-compat)
      if (has(config, 'location')) ***REMOVED***
        options.nonEmpty = config.location;
        options.selfClosing = config.location;
      ***REMOVED***
      // [1, ***REMOVED***nonEmpty: 'something'***REMOVED***]
      if (has(config, 'nonEmpty')) ***REMOVED***
        options.nonEmpty = config.nonEmpty;
      ***REMOVED***
      // [1, ***REMOVED***selfClosing: 'something'***REMOVED***]
      if (has(config, 'selfClosing')) ***REMOVED***
        options.selfClosing = config.selfClosing;
      ***REMOVED***
    ***REMOVED***

    /**
     * Get expected location for the closing bracket
     * @param ***REMOVED***Object***REMOVED*** tokens Locations of the opening bracket, closing bracket and last prop
     * @return ***REMOVED***String***REMOVED*** Expected location for the closing bracket
     */
    function getExpectedLocation(tokens) ***REMOVED***
      let location;
      // Is always after the opening tag if there is no props
      if (typeof tokens.lastProp === 'undefined') ***REMOVED***
        location = 'after-tag';
      // Is always after the last prop if this one is on the same line as the opening bracket
      ***REMOVED*** else if (tokens.opening.line === tokens.lastProp.lastLine) ***REMOVED***
        location = 'after-props';
      // Else use configuration dependent on selfClosing property
      ***REMOVED*** else ***REMOVED***
        location = tokens.selfClosing ? options.selfClosing : options.nonEmpty;
      ***REMOVED***
      return location;
    ***REMOVED***

    /**
     * Get the correct 0-indexed column for the closing bracket, given the
     * expected location.
     * @param ***REMOVED***Object***REMOVED*** tokens Locations of the opening bracket, closing bracket and last prop
     * @param ***REMOVED***String***REMOVED*** expectedLocation Expected location for the closing bracket
     * @return ***REMOVED***?Number***REMOVED*** The correct column for the closing bracket, or null
     */
    function getCorrectColumn(tokens, expectedLocation) ***REMOVED***
      switch (expectedLocation) ***REMOVED***
        case 'props-aligned':
          return tokens.lastProp.column;
        case 'tag-aligned':
          return tokens.opening.column;
        case 'line-aligned':
          return tokens.openingStartOfLine.column;
        default:
          return null;
      ***REMOVED***
    ***REMOVED***

    /**
     * Check if the closing bracket is correctly located
     * @param ***REMOVED***Object***REMOVED*** tokens Locations of the opening bracket, closing bracket and last prop
     * @param ***REMOVED***String***REMOVED*** expectedLocation Expected location for the closing bracket
     * @return ***REMOVED***Boolean***REMOVED*** True if the closing bracket is correctly located, false if not
     */
    function hasCorrectLocation(tokens, expectedLocation) ***REMOVED***
      switch (expectedLocation) ***REMOVED***
        case 'after-tag':
          return tokens.tag.line === tokens.closing.line;
        case 'after-props':
          return tokens.lastProp.lastLine === tokens.closing.line;
        case 'props-aligned':
        case 'tag-aligned':
        case 'line-aligned': ***REMOVED***
          const correctColumn = getCorrectColumn(tokens, expectedLocation);
          return correctColumn === tokens.closing.column;
        ***REMOVED***
        default:
          return true;
      ***REMOVED***
    ***REMOVED***

    /**
     * Get the characters used for indentation on the line to be matched
     * @param ***REMOVED***Object***REMOVED*** tokens Locations of the opening bracket, closing bracket and last prop
     * @param ***REMOVED***String***REMOVED*** expectedLocation Expected location for the closing bracket
     * @param ***REMOVED***Number***REMOVED*** [correctColumn] Expected column for the closing bracket. Default to 0
     * @return ***REMOVED***String***REMOVED*** The characters used for indentation
     */
    function getIndentation(tokens, expectedLocation, correctColumn) ***REMOVED***
      correctColumn = correctColumn || 0;
      let indentation;
      let spaces = [];
      switch (expectedLocation) ***REMOVED***
        case 'props-aligned':
          indentation = /^\s*/.exec(context.getSourceCode().lines[tokens.lastProp.firstLine - 1])[0];
          break;
        case 'tag-aligned':
        case 'line-aligned':
          indentation = /^\s*/.exec(context.getSourceCode().lines[tokens.opening.line - 1])[0];
          break;
        default:
          indentation = '';
      ***REMOVED***
      if (indentation.length + 1 < correctColumn) ***REMOVED***
        // Non-whitespace characters were included in the column offset
        spaces = new Array(+correctColumn + 1 - indentation.length);
      ***REMOVED***
      return indentation + spaces.join(' ');
    ***REMOVED***

    /**
     * Get the locations of the opening bracket, closing bracket, last prop, and
     * start of opening line.
     * @param ***REMOVED***ASTNode***REMOVED*** node The node to check
     * @return ***REMOVED***Object***REMOVED*** Locations of the opening bracket, closing bracket, last
     * prop and start of opening line.
     */
    function getTokensLocations(node) ***REMOVED***
      const sourceCode = context.getSourceCode();
      const opening = sourceCode.getFirstToken(node).loc.start;
      const closing = sourceCode.getLastTokens(node, node.selfClosing ? 2 : 1)[0].loc.start;
      const tag = sourceCode.getFirstToken(node.name).loc.start;
      let lastProp;
      if (node.attributes.length) ***REMOVED***
        lastProp = node.attributes[node.attributes.length - 1];
        lastProp = ***REMOVED***
          column: sourceCode.getFirstToken(lastProp).loc.start.column,
          firstLine: sourceCode.getFirstToken(lastProp).loc.start.line,
          lastLine: sourceCode.getLastToken(lastProp).loc.end.line
        ***REMOVED***;
      ***REMOVED***
      const openingLine = sourceCode.lines[opening.line - 1];
      const openingStartOfLine = ***REMOVED***
        column: /^\s*/.exec(openingLine)[0].length,
        line: opening.line
      ***REMOVED***;
      return ***REMOVED***
        tag,
        opening,
        closing,
        lastProp,
        selfClosing: node.selfClosing,
        openingStartOfLine
      ***REMOVED***;
    ***REMOVED***

    /**
     * Get an unique ID for a given JSXOpeningElement
     *
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     * @returns ***REMOVED***String***REMOVED*** Unique ID (based on its range)
     */
    function getOpeningElementId(node) ***REMOVED***
      return node.range.join(':');
    ***REMOVED***

    const lastAttributeNode = ***REMOVED******REMOVED***;

    return ***REMOVED***
      JSXAttribute(node) ***REMOVED***
        lastAttributeNode[getOpeningElementId(node.parent)] = node;
      ***REMOVED***,

      JSXSpreadAttribute(node) ***REMOVED***
        lastAttributeNode[getOpeningElementId(node.parent)] = node;
      ***REMOVED***,

      'JSXOpeningElement:exit': function (node) ***REMOVED***
        const attributeNode = lastAttributeNode[getOpeningElementId(node)];
        const cachedLastAttributeEndPos = attributeNode ? attributeNode.range[1] : null;
        let expectedNextLine;
        const tokens = getTokensLocations(node);
        const expectedLocation = getExpectedLocation(tokens);

        if (hasCorrectLocation(tokens, expectedLocation)) ***REMOVED***
          return;
        ***REMOVED***

        const data = ***REMOVED***location: MESSAGE_LOCATION[expectedLocation], details: ''***REMOVED***;
        const correctColumn = getCorrectColumn(tokens, expectedLocation);

        if (correctColumn !== null) ***REMOVED***
          expectedNextLine = tokens.lastProp &&
            (tokens.lastProp.lastLine === tokens.closing.line);
          data.details = ` (expected column $***REMOVED***correctColumn + 1***REMOVED***$***REMOVED***expectedNextLine ? ' on the next line)' : ')'***REMOVED***`;
        ***REMOVED***

        context.report(***REMOVED***
          node,
          loc: tokens.closing,
          message: MESSAGE,
          data,
          fix(fixer) ***REMOVED***
            const closingTag = tokens.selfClosing ? '/>' : '>';
            switch (expectedLocation) ***REMOVED***
              case 'after-tag':
                if (cachedLastAttributeEndPos) ***REMOVED***
                  return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]],
                    (expectedNextLine ? '\n' : '') + closingTag);
                ***REMOVED***
                return fixer.replaceTextRange([node.name.range[1], node.range[1]],
                  (expectedNextLine ? '\n' : ' ') + closingTag);
              case 'after-props':
                return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]],
                  (expectedNextLine ? '\n' : '') + closingTag);
              case 'props-aligned':
              case 'tag-aligned':
              case 'line-aligned':
                return fixer.replaceTextRange([cachedLastAttributeEndPos, node.range[1]],
                  `\n$***REMOVED***getIndentation(tokens, expectedLocation, correctColumn)***REMOVED***$***REMOVED***closingTag***REMOVED***`);
              default:
                return true;
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
