/**
 * @fileoverview Enforce component methods order
 * @author Yannick Croissant
 */

'use strict';

const has = require('has');
const entries = require('object.entries');
const arrayIncludes = require('array-includes');

const Components = require('../util/Components');
const astUtil = require('../util/ast');
const docsUrl = require('../util/docsUrl');

const defaultConfig = ***REMOVED***
  order: [
    'static-methods',
    'lifecycle',
    'everything-else',
    'render'
  ],
  groups: ***REMOVED***
    lifecycle: [
      'displayName',
      'propTypes',
      'contextTypes',
      'childContextTypes',
      'mixins',
      'statics',
      'defaultProps',
      'constructor',
      'getDefaultProps',
      'state',
      'getInitialState',
      'getChildContext',
      'getDerivedStateFromProps',
      'componentWillMount',
      'UNSAFE_componentWillMount',
      'componentDidMount',
      'componentWillReceiveProps',
      'UNSAFE_componentWillReceiveProps',
      'shouldComponentUpdate',
      'componentWillUpdate',
      'UNSAFE_componentWillUpdate',
      'getSnapshotBeforeUpdate',
      'componentDidUpdate',
      'componentDidCatch',
      'componentWillUnmount'
    ]
  ***REMOVED***
***REMOVED***;

/**
 * Get the methods order from the default config and the user config
 * @param ***REMOVED***Object***REMOVED*** userConfig The user configuration.
 * @returns ***REMOVED***Array***REMOVED*** Methods order
 */
function getMethodsOrder(userConfig) ***REMOVED***
  userConfig = userConfig || ***REMOVED******REMOVED***;

  const groups = Object.assign(***REMOVED******REMOVED***, defaultConfig.groups, userConfig.groups);
  const order = userConfig.order || defaultConfig.order;

  let config = [];
  let entry;
  for (let i = 0, j = order.length; i < j; i++) ***REMOVED***
    entry = order[i];
    if (has(groups, entry)) ***REMOVED***
      config = config.concat(groups[entry]);
    ***REMOVED*** else ***REMOVED***
      config.push(entry);
    ***REMOVED***
  ***REMOVED***

  return config;
***REMOVED***

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Enforce component methods order',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('sort-comp')
    ***REMOVED***,

    schema: [***REMOVED***
      type: 'object',
      properties: ***REMOVED***
        order: ***REMOVED***
          type: 'array',
          items: ***REMOVED***
            type: 'string'
          ***REMOVED***
        ***REMOVED***,
        groups: ***REMOVED***
          type: 'object',
          patternProperties: ***REMOVED***
            '^.*$': ***REMOVED***
              type: 'array',
              items: ***REMOVED***
                type: 'string'
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,
      additionalProperties: false
    ***REMOVED***]
  ***REMOVED***,

  create: Components.detect((context, components) => ***REMOVED***
    const errors = ***REMOVED******REMOVED***;

    const MISPOSITION_MESSAGE = '***REMOVED******REMOVED***propA***REMOVED******REMOVED*** should be placed ***REMOVED******REMOVED***position***REMOVED******REMOVED*** ***REMOVED******REMOVED***propB***REMOVED******REMOVED***';

    const methodsOrder = getMethodsOrder(context.options[0]);

    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------

    const regExpRegExp = /\/(.*)\/([g|y|i|m]*)/;

    /**
     * Get indexes of the matching patterns in methods order configuration
     * @param ***REMOVED***Object***REMOVED*** method - Method metadata.
     * @returns ***REMOVED***Array***REMOVED*** The matching patterns indexes. Return [Infinity] if there is no match.
     */
    function getRefPropIndexes(method) ***REMOVED***
      const methodGroupIndexes = [];

      methodsOrder.forEach((currentGroup, groupIndex) => ***REMOVED***
        if (currentGroup === 'getters') ***REMOVED***
          if (method.getter) ***REMOVED***
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else if (currentGroup === 'setters') ***REMOVED***
          if (method.setter) ***REMOVED***
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else if (currentGroup === 'type-annotations') ***REMOVED***
          if (method.typeAnnotation) ***REMOVED***
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else if (currentGroup === 'static-methods') ***REMOVED***
          if (method.static) ***REMOVED***
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else if (currentGroup === 'instance-variables') ***REMOVED***
          if (method.instanceVariable) ***REMOVED***
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else if (currentGroup === 'instance-methods') ***REMOVED***
          if (method.instanceMethod) ***REMOVED***
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else if (arrayIncludes([
          'displayName',
          'propTypes',
          'contextTypes',
          'childContextTypes',
          'mixins',
          'statics',
          'defaultProps',
          'constructor',
          'getDefaultProps',
          'state',
          'getInitialState',
          'getChildContext',
          'getDerivedStateFromProps',
          'componentWillMount',
          'UNSAFE_componentWillMount',
          'componentDidMount',
          'componentWillReceiveProps',
          'UNSAFE_componentWillReceiveProps',
          'shouldComponentUpdate',
          'componentWillUpdate',
          'UNSAFE_componentWillUpdate',
          'getSnapshotBeforeUpdate',
          'componentDidUpdate',
          'componentDidCatch',
          'componentWillUnmount',
          'render'
        ], currentGroup)) ***REMOVED***
          if (currentGroup === method.name) ***REMOVED***
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          // Is the group a regex?
          const isRegExp = currentGroup.match(regExpRegExp);
          if (isRegExp) ***REMOVED***
            const isMatching = new RegExp(isRegExp[1], isRegExp[2]).test(method.name);
            if (isMatching) ***REMOVED***
              methodGroupIndexes.push(groupIndex);
            ***REMOVED***
          ***REMOVED*** else if (currentGroup === method.name) ***REMOVED***
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***);

      // No matching pattern, return 'everything-else' index
      if (methodGroupIndexes.length === 0) ***REMOVED***
        const everythingElseIndex = methodsOrder.indexOf('everything-else');

        if (everythingElseIndex !== -1) ***REMOVED***
          methodGroupIndexes.push(everythingElseIndex);
        ***REMOVED*** else ***REMOVED***
          // No matching pattern and no 'everything-else' group
          methodGroupIndexes.push(Infinity);
        ***REMOVED***
      ***REMOVED***

      return methodGroupIndexes;
    ***REMOVED***

    /**
     * Get properties name
     * @param ***REMOVED***Object***REMOVED*** node - Property.
     * @returns ***REMOVED***String***REMOVED*** Property name.
     */
    function getPropertyName(node) ***REMOVED***
      if (node.kind === 'get') ***REMOVED***
        return 'getter functions';
      ***REMOVED***

      if (node.kind === 'set') ***REMOVED***
        return 'setter functions';
      ***REMOVED***

      return astUtil.getPropertyName(node);
    ***REMOVED***

    /**
     * Store a new error in the error list
     * @param ***REMOVED***Object***REMOVED*** propA - Mispositioned property.
     * @param ***REMOVED***Object***REMOVED*** propB - Reference property.
     */
    function storeError(propA, propB) ***REMOVED***
      // Initialize the error object if needed
      if (!errors[propA.index]) ***REMOVED***
        errors[propA.index] = ***REMOVED***
          node: propA.node,
          score: 0,
          closest: ***REMOVED***
            distance: Infinity,
            ref: ***REMOVED***
              node: null,
              index: 0
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***;
      ***REMOVED***
      // Increment the prop score
      errors[propA.index].score++;
      // Stop here if we already have pushed another node at this position
      if (getPropertyName(errors[propA.index].node) !== getPropertyName(propA.node)) ***REMOVED***
        return;
      ***REMOVED***
      // Stop here if we already have a closer reference
      if (Math.abs(propA.index - propB.index) > errors[propA.index].closest.distance) ***REMOVED***
        return;
      ***REMOVED***
      // Update the closest reference
      errors[propA.index].closest.distance = Math.abs(propA.index - propB.index);
      errors[propA.index].closest.ref.node = propB.node;
      errors[propA.index].closest.ref.index = propB.index;
    ***REMOVED***

    /**
     * Dedupe errors, only keep the ones with the highest score and delete the others
     */
    function dedupeErrors() ***REMOVED***
      for (const i in errors) ***REMOVED***
        if (has(errors, i)) ***REMOVED***
          const index = errors[i].closest.ref.index;
          if (errors[index]) ***REMOVED***
            if (errors[i].score > errors[index].score) ***REMOVED***
              delete errors[index];
            ***REMOVED*** else ***REMOVED***
              delete errors[i];
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    /**
     * Report errors
     */
    function reportErrors() ***REMOVED***
      dedupeErrors();

      entries(errors).forEach((entry) => ***REMOVED***
        const nodeA = entry[1].node;
        const nodeB = entry[1].closest.ref.node;
        const indexA = entry[0];
        const indexB = entry[1].closest.ref.index;

        context.report(***REMOVED***
          node: nodeA,
          message: MISPOSITION_MESSAGE,
          data: ***REMOVED***
            propA: getPropertyName(nodeA),
            propB: getPropertyName(nodeB),
            position: indexA < indexB ? 'before' : 'after'
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***

    /**
     * Compare two properties and find out if they are in the right order
     * @param ***REMOVED***Array***REMOVED*** propertiesInfos Array containing all the properties metadata.
     * @param ***REMOVED***Object***REMOVED*** propA First property name and metadata
     * @param ***REMOVED***Object***REMOVED*** propB Second property name.
     * @returns ***REMOVED***Object***REMOVED*** Object containing a correct true/false flag and the correct indexes for the two properties.
     */
    function comparePropsOrder(propertiesInfos, propA, propB) ***REMOVED***
      let i;
      let j;
      let k;
      let l;
      let refIndexA;
      let refIndexB;

      // Get references indexes (the correct position) for given properties
      const refIndexesA = getRefPropIndexes(propA);
      const refIndexesB = getRefPropIndexes(propB);

      // Get current indexes for given properties
      const classIndexA = propertiesInfos.indexOf(propA);
      const classIndexB = propertiesInfos.indexOf(propB);

      // Loop around the references indexes for the 1st property
      for (i = 0, j = refIndexesA.length; i < j; i++) ***REMOVED***
        refIndexA = refIndexesA[i];

        // Loop around the properties for the 2nd property (for comparison)
        for (k = 0, l = refIndexesB.length; k < l; k++) ***REMOVED***
          refIndexB = refIndexesB[k];

          if (
            // Comparing the same properties
            refIndexA === refIndexB ||
            // 1st property is placed before the 2nd one in reference and in current component
            refIndexA < refIndexB && classIndexA < classIndexB ||
            // 1st property is placed after the 2nd one in reference and in current component
            refIndexA > refIndexB && classIndexA > classIndexB
          ) ***REMOVED***
            return ***REMOVED***
              correct: true,
              indexA: classIndexA,
              indexB: classIndexB
            ***REMOVED***;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      // We did not find any correct match between reference and current component
      return ***REMOVED***
        correct: false,
        indexA: refIndexA,
        indexB: refIndexB
      ***REMOVED***;
    ***REMOVED***

    /**
     * Check properties order from a properties list and store the eventual errors
     * @param ***REMOVED***Array***REMOVED*** properties Array containing all the properties.
     */
    function checkPropsOrder(properties) ***REMOVED***
      const propertiesInfos = properties.map(node => (***REMOVED***
        name: getPropertyName(node),
        getter: node.kind === 'get',
        setter: node.kind === 'set',
        static: node.static,
        instanceVariable: !node.static &&
          node.type === 'ClassProperty' &&
          (!node.value || !astUtil.isFunctionLikeExpression(node.value)),
        instanceMethod: !node.static &&
          node.type === 'ClassProperty' &&
          node.value &&
          (astUtil.isFunctionLikeExpression(node.value)),
        typeAnnotation: !!node.typeAnnotation && node.value === null
      ***REMOVED***));

      // Loop around the properties
      propertiesInfos.forEach((propA, i) => ***REMOVED***
        // Loop around the properties a second time (for comparison)
        propertiesInfos.forEach((propB, k) => ***REMOVED***
          if (i === k) ***REMOVED***
            return;
          ***REMOVED***

          // Compare the properties order
          const order = comparePropsOrder(propertiesInfos, propA, propB);

          if (!order.correct) ***REMOVED***
            // Store an error if the order is incorrect
            storeError(***REMOVED***
              node: properties[i],
              index: order.indexA
            ***REMOVED***, ***REMOVED***
              node: properties[k],
              index: order.indexB
            ***REMOVED***);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***

    return ***REMOVED***
      'Program:exit': function () ***REMOVED***
        const list = components.list();
        Object.keys(list).forEach((component) => ***REMOVED***
          const properties = astUtil.getComponentProperties(list[component].node);
          checkPropsOrder(properties);
        ***REMOVED***);

        reportErrors();
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***),

  defaultConfig
***REMOVED***;
