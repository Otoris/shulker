/**
 * @fileoverview Prevent missing props validation in a React component definition
 * @author Yannick Croissant
 */

'use strict';

// As for exceptions for props.children or props.className (and alike) look at
// https://github.com/yannickcr/eslint-plugin-react/issues/7

const Components = require('../util/Components');
const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Prevent missing props validation in a React component definition',
      category: 'Best Practices',
      recommended: true,
      url: docsUrl('prop-types')
    ***REMOVED***,

    schema: [***REMOVED***
      type: 'object',
      properties: ***REMOVED***
        ignore: ***REMOVED***
          type: 'array',
          items: ***REMOVED***
            type: 'string'
          ***REMOVED***
        ***REMOVED***,
        customValidators: ***REMOVED***
          type: 'array',
          items: ***REMOVED***
            type: 'string'
          ***REMOVED***
        ***REMOVED***,
        skipUndeclared: ***REMOVED***
          type: 'boolean'
        ***REMOVED***
      ***REMOVED***,
      additionalProperties: false
    ***REMOVED***]
  ***REMOVED***,

  create: Components.detect((context, components) => ***REMOVED***
    const configuration = context.options[0] || ***REMOVED******REMOVED***;
    const ignored = configuration.ignore || [];
    const skipUndeclared = configuration.skipUndeclared || false;

    const MISSING_MESSAGE = '\'***REMOVED******REMOVED***name***REMOVED******REMOVED***\' is missing in props validation';

    /**
     * Checks if the prop is ignored
     * @param ***REMOVED***String***REMOVED*** name Name of the prop to check.
     * @returns ***REMOVED***Boolean***REMOVED*** True if the prop is ignored, false if not.
     */
    function isIgnored(name) ***REMOVED***
      return ignored.indexOf(name) !== -1;
    ***REMOVED***

    /**
     * Checks if the component must be validated
     * @param ***REMOVED***Object***REMOVED*** component The component to process
     * @returns ***REMOVED***Boolean***REMOVED*** True if the component must be validated, false if not.
     */
    function mustBeValidated(component) ***REMOVED***
      const isSkippedByConfig = skipUndeclared && typeof component.declaredPropTypes === 'undefined';
      return Boolean(
        component &&
        component.usedPropTypes &&
        !component.ignorePropsValidation &&
        !isSkippedByConfig
      );
    ***REMOVED***

    /**
     * Internal: Checks if the prop is declared
     * @param ***REMOVED***Object***REMOVED*** declaredPropTypes Description of propTypes declared in the current component
     * @param ***REMOVED***String[]***REMOVED*** keyList Dot separated name of the prop to check.
     * @returns ***REMOVED***Boolean***REMOVED*** True if the prop is declared, false if not.
     */
    function internalIsDeclaredInComponent(declaredPropTypes, keyList) ***REMOVED***
      for (let i = 0, j = keyList.length; i < j; i++) ***REMOVED***
        const key = keyList[i];
        const propType = (
          declaredPropTypes && (
            // Check if this key is declared
            (declaredPropTypes[key] || // If not, check if this type accepts any key
            declaredPropTypes.__ANY_KEY__) // eslint-disable-line no-underscore-dangle
          )
        );

        if (!propType) ***REMOVED***
          // If it's a computed property, we can't make any further analysis, but is valid
          return key === '__COMPUTED_PROP__';
        ***REMOVED***
        if (typeof propType === 'object' && !propType.type) ***REMOVED***
          return true;
        ***REMOVED***
        // Consider every children as declared
        if (propType.children === true || propType.containsSpread || propType.containsIndexers) ***REMOVED***
          return true;
        ***REMOVED***
        if (propType.acceptedProperties) ***REMOVED***
          return key in propType.acceptedProperties;
        ***REMOVED***
        if (propType.type === 'union') ***REMOVED***
          // If we fall in this case, we know there is at least one complex type in the union
          if (i + 1 >= j) ***REMOVED***
            // this is the last key, accept everything
            return true;
          ***REMOVED***
          // non trivial, check all of them
          const unionTypes = propType.children;
          const unionPropType = ***REMOVED******REMOVED***;
          for (let k = 0, z = unionTypes.length; k < z; k++) ***REMOVED***
            unionPropType[key] = unionTypes[k];
            const isValid = internalIsDeclaredInComponent(
              unionPropType,
              keyList.slice(i)
            );
            if (isValid) ***REMOVED***
              return true;
            ***REMOVED***
          ***REMOVED***

          // every possible union were invalid
          return false;
        ***REMOVED***
        declaredPropTypes = propType.children;
      ***REMOVED***
      return true;
    ***REMOVED***

    /**
     * Checks if the prop is declared
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     * @param ***REMOVED***String[]***REMOVED*** names List of names of the prop to check.
     * @returns ***REMOVED***Boolean***REMOVED*** True if the prop is declared, false if not.
     */
    function isDeclaredInComponent(node, names) ***REMOVED***
      while (node) ***REMOVED***
        const component = components.get(node);

        const isDeclared = component && component.confidence === 2 &&
          internalIsDeclaredInComponent(component.declaredPropTypes || ***REMOVED******REMOVED***, names);
        if (isDeclared) ***REMOVED***
          return true;
        ***REMOVED***
        node = node.parent;
      ***REMOVED***
      return false;
    ***REMOVED***

    /**
     * Reports undeclared proptypes for a given component
     * @param ***REMOVED***Object***REMOVED*** component The component to process
     */
    function reportUndeclaredPropTypes(component) ***REMOVED***
      const undeclareds = component.usedPropTypes.filter(propType => (
        propType.node &&
        !isIgnored(propType.allNames[0]) &&
        !isDeclaredInComponent(component.node, propType.allNames)
      ));
      undeclareds.forEach((propType) => ***REMOVED***
        context.report(***REMOVED***
          node: propType.node,
          message: MISSING_MESSAGE,
          data: ***REMOVED***
            name: propType.allNames.join('.').replace(/\.__COMPUTED_PROP__/g, '[]')
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***

    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------

    return ***REMOVED***
      'Program:exit': function () ***REMOVED***
        const list = components.list();
        // Report undeclared proptypes for all classes
        Object.keys(list).filter(component => mustBeValidated(list[component])).forEach((component) => ***REMOVED***
          reportUndeclaredPropTypes(list[component]);
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***)
***REMOVED***;
