/**
 * @fileoverview Report when a DOM element is using both children and dangerouslySetInnerHTML
 * @author David Petersen
 */

'use strict';

const variableUtil = require('../util/variable');
const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------
module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Report when a DOM element is using both children and dangerouslySetInnerHTML',
      category: '',
      recommended: true,
      url: docsUrl('no-danger-with-children')
    ***REMOVED***,
    schema: [] // no options
  ***REMOVED***,
  create(context) ***REMOVED***
    function findSpreadVariable(name) ***REMOVED***
      return variableUtil.variablesInScope(context).find(item => item.name === name);
    ***REMOVED***
    /**
     * Takes a ObjectExpression and returns the value of the prop if it has it
     * @param ***REMOVED***object***REMOVED*** node - ObjectExpression node
     * @param ***REMOVED***string***REMOVED*** propName - name of the prop to look for
     * @param ***REMOVED***string[]***REMOVED*** seenProps
     */
    function findObjectProp(node, propName, seenProps) ***REMOVED***
      if (!node.properties) ***REMOVED***
        return false;
      ***REMOVED***
      return node.properties.find((prop) => ***REMOVED***
        if (prop.type === 'Property') ***REMOVED***
          return prop.key.name === propName;
        ***REMOVED***
        if (prop.type === 'ExperimentalSpreadProperty' || prop.type === 'SpreadElement') ***REMOVED***
          const variable = findSpreadVariable(prop.argument.name);
          if (variable && variable.defs.length && variable.defs[0].node.init) ***REMOVED***
            if (seenProps.indexOf(prop.argument.name) > -1) ***REMOVED***
              return false;
            ***REMOVED***
            const newSeenProps = seenProps.concat(prop.argument.name || []);
            return findObjectProp(variable.defs[0].node.init, propName, newSeenProps);
          ***REMOVED***
        ***REMOVED***
        return false;
      ***REMOVED***);
    ***REMOVED***

    /**
     * Takes a JSXElement and returns the value of the prop if it has it
     * @param ***REMOVED***object***REMOVED*** node - JSXElement node
     * @param ***REMOVED***string***REMOVED*** propName - name of the prop to look for
     */
    function findJsxProp(node, propName) ***REMOVED***
      const attributes = node.openingElement.attributes;
      return attributes.find((attribute) => ***REMOVED***
        if (attribute.type === 'JSXSpreadAttribute') ***REMOVED***
          const variable = findSpreadVariable(attribute.argument.name);
          if (variable && variable.defs.length && variable.defs[0].node.init) ***REMOVED***
            return findObjectProp(variable.defs[0].node.init, propName, []);
          ***REMOVED***
        ***REMOVED***
        return attribute.name && attribute.name.name === propName;
      ***REMOVED***);
    ***REMOVED***

    /**
     * Checks to see if a node is a line break
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked
     * @returns ***REMOVED***Boolean***REMOVED*** True if node is a line break, false if not
     */
    function isLineBreak(node) ***REMOVED***
      const isLiteral = node.type === 'Literal' || node.type === 'JSXText';
      const isMultiline = node.loc.start.line !== node.loc.end.line;
      const isWhiteSpaces = /^\s*$/.test(node.value);

      return isLiteral && isMultiline && isWhiteSpaces;
    ***REMOVED***

    return ***REMOVED***
      JSXElement(node) ***REMOVED***
        let hasChildren = false;

        if (node.children.length && !isLineBreak(node.children[0])) ***REMOVED***
          hasChildren = true;
        ***REMOVED*** else if (findJsxProp(node, 'children')) ***REMOVED***
          hasChildren = true;
        ***REMOVED***

        if (
          node.openingElement.attributes &&
          hasChildren &&
          findJsxProp(node, 'dangerouslySetInnerHTML')
        ) ***REMOVED***
          context.report(***REMOVED***
            node,
            message: 'Only set one of `children` or `props.dangerouslySetInnerHTML`'
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***,
      CallExpression(node) ***REMOVED***
        if (
          node.callee &&
          node.callee.type === 'MemberExpression' &&
          node.callee.property.name === 'createElement' &&
          node.arguments.length > 1
        ) ***REMOVED***
          let hasChildren = false;

          let props = node.arguments[1];

          if (props.type === 'Identifier') ***REMOVED***
            const variable = variableUtil.variablesInScope(context).find(item => item.name === props.name);
            if (variable && variable.defs.length && variable.defs[0].node.init) ***REMOVED***
              props = variable.defs[0].node.init;
            ***REMOVED***
          ***REMOVED***

          const dangerously = findObjectProp(props, 'dangerouslySetInnerHTML', []);

          if (node.arguments.length === 2) ***REMOVED***
            if (findObjectProp(props, 'children', [])) ***REMOVED***
              hasChildren = true;
            ***REMOVED***
          ***REMOVED*** else ***REMOVED***
            hasChildren = true;
          ***REMOVED***

          if (dangerously && hasChildren) ***REMOVED***
            context.report(***REMOVED***
              node,
              message: 'Only set one of `children` or `props.dangerouslySetInnerHTML`'
            ***REMOVED***);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
