/**
 * @fileoverview Prevents usage of Function.prototype.bind and arrow functions
 *               in React component props.
 * @author Daniel Lo Nigro <dan.cx>
 * @author Jacky Ho
 */

'use strict';

const propName = require('jsx-ast-utils/propName');
const Components = require('../util/Components');
const docsUrl = require('../util/docsUrl');
const jsxUtil = require('../util/jsx');

// -----------------------------------------------------------------------------
// Rule Definition
// -----------------------------------------------------------------------------

const violationMessageStore = ***REMOVED***
  bindCall: 'JSX props should not use .bind()',
  arrowFunc: 'JSX props should not use arrow functions',
  bindExpression: 'JSX props should not use ::',
  func: 'JSX props should not use functions'
***REMOVED***;

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Prevents usage of Function.prototype.bind and arrow functions in React component props',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('jsx-no-bind')
    ***REMOVED***,

    schema: [***REMOVED***
      type: 'object',
      properties: ***REMOVED***
        allowArrowFunctions: ***REMOVED***
          default: false,
          type: 'boolean'
        ***REMOVED***,
        allowBind: ***REMOVED***
          default: false,
          type: 'boolean'
        ***REMOVED***,
        allowFunctions: ***REMOVED***
          default: false,
          type: 'boolean'
        ***REMOVED***,
        ignoreRefs: ***REMOVED***
          default: false,
          type: 'boolean'
        ***REMOVED***,
        ignoreDOMComponents: ***REMOVED***
          default: false,
          type: 'boolean'
        ***REMOVED***
      ***REMOVED***,
      additionalProperties: false
    ***REMOVED***]
  ***REMOVED***,

  create: Components.detect((context) => ***REMOVED***
    const configuration = context.options[0] || ***REMOVED******REMOVED***;

    // Keep track of all the variable names pointing to a bind call,
    // bind expression or an arrow function in different block statements
    const blockVariableNameSets = ***REMOVED******REMOVED***;

    function setBlockVariableNameSet(blockStart) ***REMOVED***
      blockVariableNameSets[blockStart] = ***REMOVED***
        arrowFunc: new Set(),
        bindCall: new Set(),
        bindExpression: new Set(),
        func: new Set()
      ***REMOVED***;
    ***REMOVED***

    function getNodeViolationType(node) ***REMOVED***
      const nodeType = node.type;

      if (
        !configuration.allowBind &&
        nodeType === 'CallExpression' &&
        node.callee.type === 'MemberExpression' &&
        node.callee.property.type === 'Identifier' &&
        node.callee.property.name === 'bind'
      ) ***REMOVED***
        return 'bindCall';
      ***REMOVED***
      if (nodeType === 'ConditionalExpression') ***REMOVED***
        return getNodeViolationType(node.test) ||
               getNodeViolationType(node.consequent) ||
               getNodeViolationType(node.alternate);
      ***REMOVED***
      if (!configuration.allowArrowFunctions && nodeType === 'ArrowFunctionExpression') ***REMOVED***
        return 'arrowFunc';
      ***REMOVED***
      if (!configuration.allowFunctions && nodeType === 'FunctionExpression') ***REMOVED***
        return 'func';
      ***REMOVED***
      if (!configuration.allowBind && nodeType === 'BindExpression') ***REMOVED***
        return 'bindExpression';
      ***REMOVED***

      return null;
    ***REMOVED***

    function addVariableNameToSet(violationType, variableName, blockStart) ***REMOVED***
      blockVariableNameSets[blockStart][violationType].add(variableName);
    ***REMOVED***

    function getBlockStatementAncestors(node) ***REMOVED***
      return context.getAncestors(node).reverse().filter(
        ancestor => ancestor.type === 'BlockStatement'
      );
    ***REMOVED***

    function reportVariableViolation(node, name, blockStart) ***REMOVED***
      const blockSets = blockVariableNameSets[blockStart];
      const violationTypes = Object.keys(blockSets);

      return violationTypes.find((type) => ***REMOVED***
        if (blockSets[type].has(name)) ***REMOVED***
          context.report(***REMOVED***node, message: violationMessageStore[type]***REMOVED***);
          return true;
        ***REMOVED***

        return false;
      ***REMOVED***);
    ***REMOVED***

    function findVariableViolation(node, name) ***REMOVED***
      getBlockStatementAncestors(node).find(
        block => reportVariableViolation(node, name, block.start)
      );
    ***REMOVED***

    return ***REMOVED***
      BlockStatement(node) ***REMOVED***
        setBlockVariableNameSet(node.start);
      ***REMOVED***,

      VariableDeclarator(node) ***REMOVED***
        if (!node.init) ***REMOVED***
          return;
        ***REMOVED***
        const blockAncestors = getBlockStatementAncestors(node);
        const variableViolationType = getNodeViolationType(node.init);

        if (
          blockAncestors.length > 0 &&
          variableViolationType &&
          node.parent.kind === 'const' // only support const right now
        ) ***REMOVED***
          addVariableNameToSet(
            variableViolationType, node.id.name, blockAncestors[0].start
          );
        ***REMOVED***
      ***REMOVED***,

      JSXAttribute(node) ***REMOVED***
        const isRef = configuration.ignoreRefs && propName(node) === 'ref';
        if (isRef || !node.value || !node.value.expression) ***REMOVED***
          return;
        ***REMOVED***
        const isDOMComponent = jsxUtil.isDOMComponent(node.parent);
        if (configuration.ignoreDOMComponents && isDOMComponent) ***REMOVED***
          return;
        ***REMOVED***
        const valueNode = node.value.expression;
        const valueNodeType = valueNode.type;
        const nodeViolationType = getNodeViolationType(valueNode);

        if (valueNodeType === 'Identifier') ***REMOVED***
          findVariableViolation(node, valueNode.name);
        ***REMOVED*** else if (nodeViolationType) ***REMOVED***
          context.report(***REMOVED***
            node, message: violationMessageStore[nodeViolationType]
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***)
***REMOVED***;
