/**
 * @fileoverview Limit to one expression per line in JSX
 * @author Mark Ivan Allen <Vydia.com>
 */

'use strict';

const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

const optionDefaults = ***REMOVED***
  allow: 'none'
***REMOVED***;

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Limit to one expression per line in JSX',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-one-expression-per-line')
    ***REMOVED***,
    fixable: 'whitespace',
    schema: [
      ***REMOVED***
        type: 'object',
        properties: ***REMOVED***
          allow: ***REMOVED***
            enum: ['none', 'literal', 'single-child']
          ***REMOVED***
        ***REMOVED***,
        default: optionDefaults,
        additionalProperties: false
      ***REMOVED***
    ]
  ***REMOVED***,

  create(context) ***REMOVED***
    const options = Object.assign(***REMOVED******REMOVED***, optionDefaults, context.options[0]);

    function nodeKey(node) ***REMOVED***
      return `$***REMOVED***node.loc.start.line***REMOVED***,$***REMOVED***node.loc.start.column***REMOVED***`;
    ***REMOVED***

    function nodeDescriptor(n) ***REMOVED***
      return n.openingElement ? n.openingElement.name.name : context.getSourceCode().getText(n).replace(/\n/g, '');
    ***REMOVED***

    function handleJSX(node) ***REMOVED***
      const children = node.children;

      if (!children || !children.length) ***REMOVED***
        return;
      ***REMOVED***

      const openingElement = node.openingElement || node.openingFragment;
      const closingElement = node.closingElement || node.closingFragment;
      const openingElementStartLine = openingElement.loc.start.line;
      const openingElementEndLine = openingElement.loc.end.line;
      const closingElementStartLine = closingElement.loc.start.line;
      const closingElementEndLine = closingElement.loc.end.line;

      if (children.length === 1) ***REMOVED***
        const child = children[0];
        if (
          openingElementStartLine === openingElementEndLine &&
          openingElementEndLine === closingElementStartLine &&
          closingElementStartLine === closingElementEndLine &&
          closingElementEndLine === child.loc.start.line &&
          child.loc.start.line === child.loc.end.line
        ) ***REMOVED***
          if (
            options.allow === 'single-child' ||
            options.allow === 'literal' && (child.type === 'Literal' || child.type === 'JSXText')
          ) ***REMOVED***
            return;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      const childrenGroupedByLine = ***REMOVED******REMOVED***;
      const fixDetailsByNode = ***REMOVED******REMOVED***;

      children.forEach((child) => ***REMOVED***
        let countNewLinesBeforeContent = 0;
        let countNewLinesAfterContent = 0;

        if (child.type === 'Literal' || child.type === 'JSXText') ***REMOVED***
          if (/^\s*$/.test(child.raw)) ***REMOVED***
            return;
          ***REMOVED***

          countNewLinesBeforeContent = (child.raw.match(/^\s*\n/g) || []).length;
          countNewLinesAfterContent = (child.raw.match(/\n\s*$/g) || []).length;
        ***REMOVED***

        const startLine = child.loc.start.line + countNewLinesBeforeContent;
        const endLine = child.loc.end.line - countNewLinesAfterContent;

        if (startLine === endLine) ***REMOVED***
          if (!childrenGroupedByLine[startLine]) ***REMOVED***
            childrenGroupedByLine[startLine] = [];
          ***REMOVED***
          childrenGroupedByLine[startLine].push(child);
        ***REMOVED*** else ***REMOVED***
          if (!childrenGroupedByLine[startLine]) ***REMOVED***
            childrenGroupedByLine[startLine] = [];
          ***REMOVED***
          childrenGroupedByLine[startLine].push(child);
          if (!childrenGroupedByLine[endLine]) ***REMOVED***
            childrenGroupedByLine[endLine] = [];
          ***REMOVED***
          childrenGroupedByLine[endLine].push(child);
        ***REMOVED***
      ***REMOVED***);

      Object.keys(childrenGroupedByLine).forEach((_line) => ***REMOVED***
        const line = parseInt(_line, 10);
        const firstIndex = 0;
        const lastIndex = childrenGroupedByLine[line].length - 1;

        childrenGroupedByLine[line].forEach((child, i) => ***REMOVED***
          let prevChild;
          let nextChild;

          if (i === firstIndex) ***REMOVED***
            if (line === openingElementEndLine) ***REMOVED***
              prevChild = openingElement;
            ***REMOVED***
          ***REMOVED*** else ***REMOVED***
            prevChild = childrenGroupedByLine[line][i - 1];
          ***REMOVED***

          if (i === lastIndex) ***REMOVED***
            if (line === closingElementStartLine) ***REMOVED***
              nextChild = closingElement;
            ***REMOVED***
          ***REMOVED*** else ***REMOVED***
            // We don't need to append a trailing because the next child will prepend a leading.
            // nextChild = childrenGroupedByLine[line][i + 1];
          ***REMOVED***

          function spaceBetweenPrev() ***REMOVED***
            return ((prevChild.type === 'Literal' || prevChild.type === 'JSXText') && / $/.test(prevChild.raw)) ||
              ((child.type === 'Literal' || child.type === 'JSXText') && /^ /.test(child.raw)) ||
              context.getSourceCode().isSpaceBetweenTokens(prevChild, child);
          ***REMOVED***

          function spaceBetweenNext() ***REMOVED***
            return ((nextChild.type === 'Literal' || nextChild.type === 'JSXText') && /^ /.test(nextChild.raw)) ||
              ((child.type === 'Literal' || child.type === 'JSXText') && / $/.test(child.raw)) ||
              context.getSourceCode().isSpaceBetweenTokens(child, nextChild);
          ***REMOVED***

          if (!prevChild && !nextChild) ***REMOVED***
            return;
          ***REMOVED***

          const source = context.getSourceCode().getText(child);
          const leadingSpace = !!(prevChild && spaceBetweenPrev());
          const trailingSpace = !!(nextChild && spaceBetweenNext());
          const leadingNewLine = !!prevChild;
          const trailingNewLine = !!nextChild;

          const key = nodeKey(child);

          if (!fixDetailsByNode[key]) ***REMOVED***
            fixDetailsByNode[key] = ***REMOVED***
              node: child,
              source,
              descriptor: nodeDescriptor(child)
            ***REMOVED***;
          ***REMOVED***

          if (leadingSpace) ***REMOVED***
            fixDetailsByNode[key].leadingSpace = true;
          ***REMOVED***
          if (leadingNewLine) ***REMOVED***
            fixDetailsByNode[key].leadingNewLine = true;
          ***REMOVED***
          if (trailingNewLine) ***REMOVED***
            fixDetailsByNode[key].trailingNewLine = true;
          ***REMOVED***
          if (trailingSpace) ***REMOVED***
            fixDetailsByNode[key].trailingSpace = true;
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***);

      Object.keys(fixDetailsByNode).forEach((key) => ***REMOVED***
        const details = fixDetailsByNode[key];

        const nodeToReport = details.node;
        const descriptor = details.descriptor;
        const source = details.source.replace(/(^ +| +(?=\n)*$)/g, '');

        const leadingSpaceString = details.leadingSpace ? '\n***REMOVED***\' \'***REMOVED***' : '';
        const trailingSpaceString = details.trailingSpace ? '***REMOVED***\' \'***REMOVED***\n' : '';
        const leadingNewLineString = details.leadingNewLine ? '\n' : '';
        const trailingNewLineString = details.trailingNewLine ? '\n' : '';

        const replaceText = `$***REMOVED***leadingSpaceString***REMOVED***$***REMOVED***leadingNewLineString***REMOVED***$***REMOVED***source***REMOVED***$***REMOVED***trailingNewLineString***REMOVED***$***REMOVED***trailingSpaceString***REMOVED***`;

        context.report(***REMOVED***
          node: nodeToReport,
          message: `\`$***REMOVED***descriptor***REMOVED***\` must be placed on a new line`,
          fix(fixer) ***REMOVED***
            return fixer.replaceText(nodeToReport, replaceText);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***

    return ***REMOVED***
      JSXElement: handleJSX,
      JSXFragment: handleJSX
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
