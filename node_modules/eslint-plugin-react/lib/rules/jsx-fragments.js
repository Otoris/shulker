/**
 * @fileoverview Enforce shorthand or standard form for React fragments.
 * @author Alex Zherdev
 */

'use strict';

const elementType = require('jsx-ast-utils/elementType');
const pragmaUtil = require('../util/pragma');
const variableUtil = require('../util/variable');
const versionUtil = require('../util/version');
const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

function replaceNode(source, node, text) ***REMOVED***
  return `$***REMOVED***source.slice(0, node.range[0])***REMOVED***$***REMOVED***text***REMOVED***$***REMOVED***source.slice(node.range[1])***REMOVED***`;
***REMOVED***

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Enforce shorthand or standard form for React fragments',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-fragments')
    ***REMOVED***,
    fixable: 'code',

    schema: [***REMOVED***
      enum: ['syntax', 'element']
    ***REMOVED***]
  ***REMOVED***,

  create(context) ***REMOVED***
    const configuration = context.options[0] || 'syntax';
    const reactPragma = pragmaUtil.getFromContext(context);
    const fragmentPragma = pragmaUtil.getFragmentFromContext(context);
    const openFragShort = '<>';
    const closeFragShort = '</>';
    const openFragLong = `<$***REMOVED***reactPragma***REMOVED***.$***REMOVED***fragmentPragma***REMOVED***>`;
    const closeFragLong = `</$***REMOVED***reactPragma***REMOVED***.$***REMOVED***fragmentPragma***REMOVED***>`;

    function reportOnReactVersion(node) ***REMOVED***
      if (!versionUtil.testReactVersion(context, '16.2.0')) ***REMOVED***
        context.report(***REMOVED***
          node,
          message: 'Fragments are only supported starting from React v16.2. ' +
            'Please disable the `react/jsx-fragments` rule in ESLint settings or upgrade your version of React.'
        ***REMOVED***);
        return true;
      ***REMOVED***

      return false;
    ***REMOVED***

    function getFixerToLong(jsxFragment) ***REMOVED***
      const sourceCode = context.getSourceCode();
      return function (fixer) ***REMOVED***
        let source = sourceCode.getText();
        source = replaceNode(source, jsxFragment.closingFragment, closeFragLong);
        source = replaceNode(source, jsxFragment.openingFragment, openFragLong);
        const lengthDiff = openFragLong.length - sourceCode.getText(jsxFragment.openingFragment).length +
          closeFragLong.length - sourceCode.getText(jsxFragment.closingFragment).length;
        const range = jsxFragment.range;
        return fixer.replaceTextRange(range, source.slice(range[0], range[1] + lengthDiff));
      ***REMOVED***;
    ***REMOVED***

    function getFixerToShort(jsxElement) ***REMOVED***
      const sourceCode = context.getSourceCode();
      return function (fixer) ***REMOVED***
        let source = sourceCode.getText();
        let lengthDiff;
        if (jsxElement.closingElement) ***REMOVED***
          source = replaceNode(source, jsxElement.closingElement, closeFragShort);
          source = replaceNode(source, jsxElement.openingElement, openFragShort);
          lengthDiff = sourceCode.getText(jsxElement.openingElement).length - openFragShort.length +
            sourceCode.getText(jsxElement.closingElement).length - closeFragShort.length;
        ***REMOVED*** else ***REMOVED***
          source = replaceNode(source, jsxElement.openingElement, `$***REMOVED***openFragShort***REMOVED***$***REMOVED***closeFragShort***REMOVED***`);
          lengthDiff = sourceCode.getText(jsxElement.openingElement).length - openFragShort.length -
            closeFragShort.length;
        ***REMOVED***

        const range = jsxElement.range;
        return fixer.replaceTextRange(range, source.slice(range[0], range[1] - lengthDiff));
      ***REMOVED***;
    ***REMOVED***

    function refersToReactFragment(name) ***REMOVED***
      const variableInit = variableUtil.findVariableByName(context, name);
      if (!variableInit) ***REMOVED***
        return false;
      ***REMOVED***

      // const ***REMOVED*** Fragment ***REMOVED*** = React;
      if (variableInit.type === 'Identifier' && variableInit.name === reactPragma) ***REMOVED***
        return true;
      ***REMOVED***

      // const Fragment = React.Fragment;
      if (
        variableInit.type === 'MemberExpression' &&
        variableInit.object.type === 'Identifier' &&
        variableInit.object.name === reactPragma &&
        variableInit.property.type === 'Identifier' &&
        variableInit.property.name === fragmentPragma
      ) ***REMOVED***
        return true;
      ***REMOVED***

      // const ***REMOVED*** Fragment ***REMOVED*** = require('react');
      if (
        variableInit.callee &&
        variableInit.callee.name === 'require' &&
        variableInit.arguments &&
        variableInit.arguments[0] &&
        variableInit.arguments[0].value === 'react'
      ) ***REMOVED***
        return true;
      ***REMOVED***

      return false;
    ***REMOVED***

    const jsxElements = [];
    const fragmentNames = new Set([`$***REMOVED***reactPragma***REMOVED***.$***REMOVED***fragmentPragma***REMOVED***`]);

    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------

    return ***REMOVED***
      JSXElement(node) ***REMOVED***
        jsxElements.push(node);
      ***REMOVED***,

      JSXFragment(node) ***REMOVED***
        if (reportOnReactVersion(node)) ***REMOVED***
          return;
        ***REMOVED***

        if (configuration === 'element') ***REMOVED***
          context.report(***REMOVED***
            node,
            message: `Prefer $***REMOVED***reactPragma***REMOVED***.$***REMOVED***fragmentPragma***REMOVED*** over fragment shorthand`,
            fix: getFixerToLong(node)
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***,

      ImportDeclaration(node) ***REMOVED***
        if (node.source && node.source.value === 'react') ***REMOVED***
          node.specifiers.forEach((spec) => ***REMOVED***
            if (spec.imported && spec.imported.name === fragmentPragma) ***REMOVED***
              if (spec.local) ***REMOVED***
                fragmentNames.add(spec.local.name);
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***,

      'Program:exit': function () ***REMOVED***
        jsxElements.forEach((node) => ***REMOVED***
          const openingEl = node.openingElement;
          const elName = elementType(openingEl);

          if (fragmentNames.has(elName) || refersToReactFragment(elName)) ***REMOVED***
            if (reportOnReactVersion(node)) ***REMOVED***
              return;
            ***REMOVED***

            const attrs = openingEl.attributes;
            if (configuration === 'syntax' && !(attrs && attrs.length > 0)) ***REMOVED***
              context.report(***REMOVED***
                node,
                message: `Prefer fragment shorthand over $***REMOVED***reactPragma***REMOVED***.$***REMOVED***fragmentPragma***REMOVED***`,
                fix: getFixerToShort(node)
              ***REMOVED***);
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
