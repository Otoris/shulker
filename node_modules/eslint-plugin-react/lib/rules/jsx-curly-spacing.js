/**
 * @fileoverview Enforce or disallow spaces inside of curly braces in JSX attributes.
 * @author Jamund Ferguson
 * @author Brandyn Bennett
 * @author Michael Ficarra
 * @author Vignesh Anand
 * @author Jamund Ferguson
 * @author Yannick Croissant
 * @author Erik Wendel
 */

'use strict';

const has = require('has');
const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

const SPACING = ***REMOVED***
  always: 'always',
  never: 'never'
***REMOVED***;
const SPACING_VALUES = [SPACING.always, SPACING.never];

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Enforce or disallow spaces inside of curly braces in JSX attributes',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-curly-spacing')
    ***REMOVED***,
    fixable: 'code',

    schema: ***REMOVED***
      definitions: ***REMOVED***
        basicConfig: ***REMOVED***
          type: 'object',
          properties: ***REMOVED***
            when: ***REMOVED***
              enum: SPACING_VALUES
            ***REMOVED***,
            allowMultiline: ***REMOVED***
              type: 'boolean'
            ***REMOVED***,
            spacing: ***REMOVED***
              type: 'object',
              properties: ***REMOVED***
                objectLiterals: ***REMOVED***
                  enum: SPACING_VALUES
                ***REMOVED***
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***,
        basicConfigOrBoolean: ***REMOVED***
          oneOf: [***REMOVED***
            $ref: '#/definitions/basicConfig'
          ***REMOVED***, ***REMOVED***
            type: 'boolean'
          ***REMOVED***]
        ***REMOVED***
      ***REMOVED***,
      type: 'array',
      items: [***REMOVED***
        oneOf: [***REMOVED***
          allOf: [***REMOVED***
            $ref: '#/definitions/basicConfig'
          ***REMOVED***, ***REMOVED***
            type: 'object',
            properties: ***REMOVED***
              attributes: ***REMOVED***
                $ref: '#/definitions/basicConfigOrBoolean'
              ***REMOVED***,
              children: ***REMOVED***
                $ref: '#/definitions/basicConfigOrBoolean'
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***]
        ***REMOVED***, ***REMOVED***
          enum: SPACING_VALUES
        ***REMOVED***]
      ***REMOVED***, ***REMOVED***
        type: 'object',
        properties: ***REMOVED***
          allowMultiline: ***REMOVED***
            type: 'boolean'
          ***REMOVED***,
          spacing: ***REMOVED***
            type: 'object',
            properties: ***REMOVED***
              objectLiterals: ***REMOVED***
                enum: SPACING_VALUES
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***,
        additionalProperties: false
      ***REMOVED***]
    ***REMOVED***
  ***REMOVED***,

  create(context) ***REMOVED***
    function normalizeConfig(configOrTrue, defaults, lastPass) ***REMOVED***
      const config = configOrTrue === true ? ***REMOVED******REMOVED*** : configOrTrue;
      const when = config.when || defaults.when;
      const allowMultiline = has(config, 'allowMultiline') ? config.allowMultiline : defaults.allowMultiline;
      const spacing = config.spacing || ***REMOVED******REMOVED***;
      let objectLiteralSpaces = spacing.objectLiterals || defaults.objectLiteralSpaces;
      if (lastPass) ***REMOVED***
        // On the final pass assign the values that should be derived from others if they are still undefined
        objectLiteralSpaces = objectLiteralSpaces || when;
      ***REMOVED***

      return ***REMOVED***
        when,
        allowMultiline,
        objectLiteralSpaces
      ***REMOVED***;
    ***REMOVED***

    const DEFAULT_WHEN = SPACING.never;
    const DEFAULT_ALLOW_MULTILINE = true;
    const DEFAULT_ATTRIBUTES = true;
    const DEFAULT_CHILDREN = false;

    let originalConfig = context.options[0] || ***REMOVED******REMOVED***;
    if (SPACING_VALUES.indexOf(originalConfig) !== -1) ***REMOVED***
      originalConfig = Object.assign(***REMOVED***when: context.options[0]***REMOVED***, context.options[1]);
    ***REMOVED***
    const defaultConfig = normalizeConfig(originalConfig, ***REMOVED***
      when: DEFAULT_WHEN,
      allowMultiline: DEFAULT_ALLOW_MULTILINE
    ***REMOVED***);
    const attributes = has(originalConfig, 'attributes') ? originalConfig.attributes : DEFAULT_ATTRIBUTES;
    const attributesConfig = attributes ? normalizeConfig(attributes, defaultConfig, true) : null;
    const children = has(originalConfig, 'children') ? originalConfig.children : DEFAULT_CHILDREN;
    const childrenConfig = children ? normalizeConfig(children, defaultConfig, true) : null;

    // --------------------------------------------------------------------------
    // Helpers
    // --------------------------------------------------------------------------

    /**
     * Determines whether two adjacent tokens have a newline between them.
     * @param ***REMOVED***Object***REMOVED*** left - The left token object.
     * @param ***REMOVED***Object***REMOVED*** right - The right token object.
     * @returns ***REMOVED***boolean***REMOVED*** Whether or not there is a newline between the tokens.
     */
    function isMultiline(left, right) ***REMOVED***
      return left.loc.end.line !== right.loc.start.line;
    ***REMOVED***

    /**
     * Trims text of whitespace between two ranges
     * @param ***REMOVED***Fixer***REMOVED*** fixer - the eslint fixer object
     * @param ***REMOVED***number***REMOVED*** fromLoc - the start location
     * @param ***REMOVED***number***REMOVED*** toLoc - the end location
     * @param ***REMOVED***string***REMOVED*** mode - either 'start' or 'end'
     * @param ***REMOVED***string=***REMOVED*** spacing - a spacing value that will optionally add a space to the removed text
     * @returns ***REMOVED***Object|*|***REMOVED***range, text***REMOVED******REMOVED***
     */
    function fixByTrimmingWhitespace(fixer, fromLoc, toLoc, mode, spacing) ***REMOVED***
      let replacementText = context.getSourceCode().text.slice(fromLoc, toLoc);
      if (mode === 'start') ***REMOVED***
        replacementText = replacementText.replace(/^\s+/gm, '');
      ***REMOVED*** else ***REMOVED***
        replacementText = replacementText.replace(/\s+$/gm, '');
      ***REMOVED***
      if (spacing === SPACING.always) ***REMOVED***
        if (mode === 'start') ***REMOVED***
          replacementText += ' ';
        ***REMOVED*** else ***REMOVED***
          replacementText = ` $***REMOVED***replacementText***REMOVED***`;
        ***REMOVED***
      ***REMOVED***
      return fixer.replaceTextRange([fromLoc, toLoc], replacementText);
    ***REMOVED***

    /**
    * Reports that there shouldn't be a newline after the first token
    * @param ***REMOVED***ASTNode***REMOVED*** node - The node to report in the event of an error.
    * @param ***REMOVED***Token***REMOVED*** token - The token to use for the report.
    * @param ***REMOVED***string***REMOVED*** spacing
    * @returns ***REMOVED***void***REMOVED***
    */
    function reportNoBeginningNewline(node, token, spacing) ***REMOVED***
      context.report(***REMOVED***
        node,
        loc: token.loc.start,
        message: `There should be no newline after '$***REMOVED***token.value***REMOVED***'`,
        fix(fixer) ***REMOVED***
          const nextToken = context.getSourceCode().getTokenAfter(token);
          return fixByTrimmingWhitespace(fixer, token.range[1], nextToken.range[0], 'start', spacing);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    /**
    * Reports that there shouldn't be a newline before the last token
    * @param ***REMOVED***ASTNode***REMOVED*** node - The node to report in the event of an error.
    * @param ***REMOVED***Token***REMOVED*** token - The token to use for the report.
    * @param ***REMOVED***string***REMOVED*** spacing
    * @returns ***REMOVED***void***REMOVED***
    */
    function reportNoEndingNewline(node, token, spacing) ***REMOVED***
      context.report(***REMOVED***
        node,
        loc: token.loc.start,
        message: `There should be no newline before '$***REMOVED***token.value***REMOVED***'`,
        fix(fixer) ***REMOVED***
          const previousToken = context.getSourceCode().getTokenBefore(token);
          return fixByTrimmingWhitespace(fixer, previousToken.range[1], token.range[0], 'end', spacing);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    /**
    * Reports that there shouldn't be a space after the first token
    * @param ***REMOVED***ASTNode***REMOVED*** node - The node to report in the event of an error.
    * @param ***REMOVED***Token***REMOVED*** token - The token to use for the report.
    * @returns ***REMOVED***void***REMOVED***
    */
    function reportNoBeginningSpace(node, token) ***REMOVED***
      context.report(***REMOVED***
        node,
        loc: token.loc.start,
        message: `There should be no space after '$***REMOVED***token.value***REMOVED***'`,
        fix(fixer) ***REMOVED***
          const sourceCode = context.getSourceCode();
          const nextToken = sourceCode.getTokenAfter(token);
          let nextComment;

          // ESLint >=4.x
          if (sourceCode.getCommentsAfter) ***REMOVED***
            nextComment = sourceCode.getCommentsAfter(token);
          // ESLint 3.x
          ***REMOVED*** else ***REMOVED***
            const potentialComment = sourceCode.getTokenAfter(token, ***REMOVED***includeComments: true***REMOVED***);
            nextComment = nextToken === potentialComment ? [] : [potentialComment];
          ***REMOVED***

          // Take comments into consideration to narrow the fix range to what is actually affected. (See #1414)
          if (nextComment.length > 0) ***REMOVED***
            return fixByTrimmingWhitespace(fixer, token.range[1], Math.min(nextToken.range[0], nextComment[0].start), 'start');
          ***REMOVED***

          return fixByTrimmingWhitespace(fixer, token.range[1], nextToken.range[0], 'start');
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    /**
    * Reports that there shouldn't be a space before the last token
    * @param ***REMOVED***ASTNode***REMOVED*** node - The node to report in the event of an error.
    * @param ***REMOVED***Token***REMOVED*** token - The token to use for the report.
    * @returns ***REMOVED***void***REMOVED***
    */
    function reportNoEndingSpace(node, token) ***REMOVED***
      context.report(***REMOVED***
        node,
        loc: token.loc.start,
        message: `There should be no space before '$***REMOVED***token.value***REMOVED***'`,
        fix(fixer) ***REMOVED***
          const sourceCode = context.getSourceCode();
          const previousToken = sourceCode.getTokenBefore(token);
          let previousComment;

          // ESLint >=4.x
          if (sourceCode.getCommentsBefore) ***REMOVED***
            previousComment = sourceCode.getCommentsBefore(token);
          // ESLint 3.x
          ***REMOVED*** else ***REMOVED***
            const potentialComment = sourceCode.getTokenBefore(token, ***REMOVED***includeComments: true***REMOVED***);
            previousComment = previousToken === potentialComment ? [] : [potentialComment];
          ***REMOVED***

          // Take comments into consideration to narrow the fix range to what is actually affected. (See #1414)
          if (previousComment.length > 0) ***REMOVED***
            return fixByTrimmingWhitespace(fixer, Math.max(previousToken.range[1], previousComment[0].end), token.range[0], 'end');
          ***REMOVED***

          return fixByTrimmingWhitespace(fixer, previousToken.range[1], token.range[0], 'end');
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    /**
    * Reports that there should be a space after the first token
    * @param ***REMOVED***ASTNode***REMOVED*** node - The node to report in the event of an error.
    * @param ***REMOVED***Token***REMOVED*** token - The token to use for the report.
    * @returns ***REMOVED***void***REMOVED***
    */
    function reportRequiredBeginningSpace(node, token) ***REMOVED***
      context.report(***REMOVED***
        node,
        loc: token.loc.start,
        message: `A space is required after '$***REMOVED***token.value***REMOVED***'`,
        fix(fixer) ***REMOVED***
          return fixer.insertTextAfter(token, ' ');
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    /**
    * Reports that there should be a space before the last token
    * @param ***REMOVED***ASTNode***REMOVED*** node - The node to report in the event of an error.
    * @param ***REMOVED***Token***REMOVED*** token - The token to use for the report.
    * @returns ***REMOVED***void***REMOVED***
    */
    function reportRequiredEndingSpace(node, token) ***REMOVED***
      context.report(***REMOVED***
        node,
        loc: token.loc.start,
        message: `A space is required before '$***REMOVED***token.value***REMOVED***'`,
        fix(fixer) ***REMOVED***
          return fixer.insertTextBefore(token, ' ');
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    /**
     * Determines if spacing in curly braces is valid.
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node to check.
     * @returns ***REMOVED***void***REMOVED***
     */
    function validateBraceSpacing(node) ***REMOVED***
      let config;
      switch (node.parent.type) ***REMOVED***
        case 'JSXAttribute':
        case 'JSXOpeningElement':
          config = attributesConfig;
          break;

        case 'JSXElement':
        case 'JSXFragment':
          config = childrenConfig;
          break;

        default:
          return;
      ***REMOVED***
      if (config === null) ***REMOVED***
        return;
      ***REMOVED***

      const sourceCode = context.getSourceCode();
      const first = context.getFirstToken(node);
      const last = sourceCode.getLastToken(node);
      let second = context.getTokenAfter(first, ***REMOVED***includeComments: true***REMOVED***);
      let penultimate = sourceCode.getTokenBefore(last, ***REMOVED***includeComments: true***REMOVED***);

      if (!second) ***REMOVED***
        second = context.getTokenAfter(first);
        const leadingComments = sourceCode.getNodeByRangeIndex(second.range[0]).leadingComments;
        second = leadingComments ? leadingComments[0] : second;
      ***REMOVED***
      if (!penultimate) ***REMOVED***
        penultimate = sourceCode.getTokenBefore(last);
        const trailingComments = sourceCode.getNodeByRangeIndex(penultimate.range[0]).trailingComments;
        penultimate = trailingComments ? trailingComments[trailingComments.length - 1] : penultimate;
      ***REMOVED***

      const isObjectLiteral = first.value === second.value;
      const spacing = isObjectLiteral ? config.objectLiteralSpaces : config.when;
      if (spacing === SPACING.always) ***REMOVED***
        if (!sourceCode.isSpaceBetweenTokens(first, second)) ***REMOVED***
          reportRequiredBeginningSpace(node, first);
        ***REMOVED*** else if (!config.allowMultiline && isMultiline(first, second)) ***REMOVED***
          reportNoBeginningNewline(node, first, spacing);
        ***REMOVED***
        if (!sourceCode.isSpaceBetweenTokens(penultimate, last)) ***REMOVED***
          reportRequiredEndingSpace(node, last);
        ***REMOVED*** else if (!config.allowMultiline && isMultiline(penultimate, last)) ***REMOVED***
          reportNoEndingNewline(node, last, spacing);
        ***REMOVED***
      ***REMOVED*** else if (spacing === SPACING.never) ***REMOVED***
        if (isMultiline(first, second)) ***REMOVED***
          if (!config.allowMultiline) ***REMOVED***
            reportNoBeginningNewline(node, first, spacing);
          ***REMOVED***
        ***REMOVED*** else if (sourceCode.isSpaceBetweenTokens(first, second)) ***REMOVED***
          reportNoBeginningSpace(node, first);
        ***REMOVED***
        if (isMultiline(penultimate, last)) ***REMOVED***
          if (!config.allowMultiline) ***REMOVED***
            reportNoEndingNewline(node, last, spacing);
          ***REMOVED***
        ***REMOVED*** else if (sourceCode.isSpaceBetweenTokens(penultimate, last)) ***REMOVED***
          reportNoEndingSpace(node, last);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------

    return ***REMOVED***
      JSXExpressionContainer: validateBraceSpacing,
      JSXSpreadAttribute: validateBraceSpacing
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
