/**
 * @fileoverview Forbid certain propTypes
 */

'use strict';

const variableUtil = require('../util/variable');
const propsUtil = require('../util/props');
const astUtil = require('../util/ast');
const docsUrl = require('../util/docsUrl');
const propWrapperUtil = require('../util/propWrapper');

// ------------------------------------------------------------------------------
// Constants
// ------------------------------------------------------------------------------

const DEFAULTS = ['any', 'array', 'object'];

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Forbid certain propTypes',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('forbid-prop-types')
    ***REMOVED***,

    schema: [***REMOVED***
      type: 'object',
      properties: ***REMOVED***
        forbid: ***REMOVED***
          type: 'array',
          items: ***REMOVED***
            type: 'string'
          ***REMOVED***
        ***REMOVED***,
        checkContextTypes: ***REMOVED***
          type: 'boolean'
        ***REMOVED***,
        checkChildContextTypes: ***REMOVED***
          type: 'boolean'
        ***REMOVED***
      ***REMOVED***,
      additionalProperties: true
    ***REMOVED***]
  ***REMOVED***,

  create(context) ***REMOVED***
    const configuration = context.options[0] || ***REMOVED******REMOVED***;
    const checkContextTypes = configuration.checkContextTypes || false;
    const checkChildContextTypes = configuration.checkChildContextTypes || false;

    function isForbidden(type) ***REMOVED***
      const forbid = configuration.forbid || DEFAULTS;
      return forbid.indexOf(type) >= 0;
    ***REMOVED***

    function shouldCheckContextTypes(node) ***REMOVED***
      if (checkContextTypes && propsUtil.isContextTypesDeclaration(node)) ***REMOVED***
        return true;
      ***REMOVED***
      return false;
    ***REMOVED***

    function shouldCheckChildContextTypes(node) ***REMOVED***
      if (checkChildContextTypes && propsUtil.isChildContextTypesDeclaration(node)) ***REMOVED***
        return true;
      ***REMOVED***
      return false;
    ***REMOVED***

    /**
     * Checks if propTypes declarations are forbidden
     * @param ***REMOVED***Array***REMOVED*** declarations The array of AST nodes being checked.
     * @returns ***REMOVED***void***REMOVED***
     */
    function checkProperties(declarations) ***REMOVED***
      declarations.forEach((declaration) => ***REMOVED***
        if (declaration.type !== 'Property') ***REMOVED***
          return;
        ***REMOVED***
        let target;
        let value = declaration.value;
        if (
          value.type === 'MemberExpression' &&
          value.property &&
          value.property.name &&
          value.property.name === 'isRequired'
        ) ***REMOVED***
          value = value.object;
        ***REMOVED***
        if (
          value.type === 'CallExpression' &&
          value.callee.type === 'MemberExpression'
        ) ***REMOVED***
          value = value.callee;
        ***REMOVED***
        if (value.property) ***REMOVED***
          target = value.property.name;
        ***REMOVED*** else if (value.type === 'Identifier') ***REMOVED***
          target = value.name;
        ***REMOVED***
        if (isForbidden(target)) ***REMOVED***
          context.report(***REMOVED***
            node: declaration,
            message: `Prop type \`$***REMOVED***target***REMOVED***\` is forbidden`
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    function checkNode(node) ***REMOVED***
      switch (node && node.type) ***REMOVED***
        case 'ObjectExpression':
          checkProperties(node.properties);
          break;
        case 'Identifier': ***REMOVED***
          const propTypesObject = variableUtil.findVariableByName(context, node.name);
          if (propTypesObject && propTypesObject.properties) ***REMOVED***
            checkProperties(propTypesObject.properties);
          ***REMOVED***
          break;
        ***REMOVED***
        case 'CallExpression': ***REMOVED***
          const innerNode = node.arguments && node.arguments[0];
          if (propWrapperUtil.isPropWrapperFunction(context, context.getSource(node.callee)) && innerNode) ***REMOVED***
            checkNode(innerNode);
          ***REMOVED***
          break;
        ***REMOVED***
        default:
          break;
      ***REMOVED***
    ***REMOVED***

    return ***REMOVED***
      ClassProperty(node) ***REMOVED***
        if (
          !propsUtil.isPropTypesDeclaration(node) &&
          !shouldCheckContextTypes(node) &&
          !shouldCheckChildContextTypes(node)
        ) ***REMOVED***
          return;
        ***REMOVED***
        checkNode(node.value);
      ***REMOVED***,

      MemberExpression(node) ***REMOVED***
        if (
          !propsUtil.isPropTypesDeclaration(node) &&
          !shouldCheckContextTypes(node) &&
          !shouldCheckChildContextTypes(node)
        ) ***REMOVED***
          return;
        ***REMOVED***

        checkNode(node.parent.right);
      ***REMOVED***,

      MethodDefinition(node) ***REMOVED***
        if (
          !propsUtil.isPropTypesDeclaration(node) &&
          !shouldCheckContextTypes(node) &&
          !shouldCheckChildContextTypes(node)
        ) ***REMOVED***
          return;
        ***REMOVED***

        const returnStatement = astUtil.findReturnStatement(node);

        if (returnStatement && returnStatement.argument) ***REMOVED***
          checkNode(returnStatement.argument);
        ***REMOVED***
      ***REMOVED***,

      ObjectExpression(node) ***REMOVED***
        node.properties.forEach((property) => ***REMOVED***
          if (!property.key) ***REMOVED***
            return;
          ***REMOVED***

          if (
            !propsUtil.isPropTypesDeclaration(property) &&
            !shouldCheckContextTypes(property) &&
            !shouldCheckChildContextTypes(property)
          ) ***REMOVED***
            return;
          ***REMOVED***
          if (property.value.type === 'ObjectExpression') ***REMOVED***
            checkProperties(property.value.properties);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***

    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
