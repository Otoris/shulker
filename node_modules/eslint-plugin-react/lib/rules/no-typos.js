/**
 * @fileoverview Prevent common casing typos
 */

'use strict';

const PROP_TYPES = Object.keys(require('prop-types'));
const Components = require('../util/Components');
const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

const STATIC_CLASS_PROPERTIES = ['propTypes', 'contextTypes', 'childContextTypes', 'defaultProps'];
const LIFECYCLE_METHODS = [
  'getDerivedStateFromProps',
  'componentWillMount',
  'UNSAFE_componentWillMount',
  'componentDidMount',
  'componentWillReceiveProps',
  'UNSAFE_componentWillReceiveProps',
  'shouldComponentUpdate',
  'componentWillUpdate',
  'UNSAFE_componentWillUpdate',
  'getSnapshotBeforeUpdate',
  'componentDidUpdate',
  'componentDidCatch',
  'componentWillUnmount',
  'render'
];

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Prevent common typos',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('no-typos')
    ***REMOVED***,
    schema: []
  ***REMOVED***,

  create: Components.detect((context, components, utils) => ***REMOVED***
    let propTypesPackageName = null;
    let reactPackageName = null;

    function checkValidPropTypeQualifier(node) ***REMOVED***
      if (node.name !== 'isRequired') ***REMOVED***
        context.report(***REMOVED***
          node,
          message: `Typo in prop type chain qualifier: $***REMOVED***node.name***REMOVED***`
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    function checkValidPropType(node) ***REMOVED***
      if (node.name && !PROP_TYPES.some(propTypeName => propTypeName === node.name)) ***REMOVED***
        context.report(***REMOVED***
          node,
          message: `Typo in declared prop type: $***REMOVED***node.name***REMOVED***`
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    function isPropTypesPackage(node) ***REMOVED***
      return (
        node.type === 'Identifier' &&
        node.name === propTypesPackageName
      ) || (
        node.type === 'MemberExpression' &&
        node.property.name === 'PropTypes' &&
        node.object.name === reactPackageName
      );
    ***REMOVED***

    /* eslint-disable no-use-before-define */

    function checkValidCallExpression(node) ***REMOVED***
      const callee = node.callee;
      if (callee.type === 'MemberExpression' && callee.property.name === 'shape') ***REMOVED***
        checkValidPropObject(node.arguments[0]);
      ***REMOVED*** else if (callee.type === 'MemberExpression' && callee.property.name === 'oneOfType') ***REMOVED***
        const args = node.arguments[0];
        if (args && args.type === 'ArrayExpression') ***REMOVED***
          args.elements.forEach((el) => ***REMOVED***
            checkValidProp(el);
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    function checkValidProp(node) ***REMOVED***
      if ((!propTypesPackageName && !reactPackageName) || !node) ***REMOVED***
        return;
      ***REMOVED***

      if (node.type === 'MemberExpression') ***REMOVED***
        if (
          node.object.type === 'MemberExpression' &&
          isPropTypesPackage(node.object.object)
        ) ***REMOVED*** // PropTypes.myProp.isRequired
          checkValidPropType(node.object.property);
          checkValidPropTypeQualifier(node.property);
        ***REMOVED*** else if (
          isPropTypesPackage(node.object) &&
          node.property.name !== 'isRequired'
        ) ***REMOVED*** // PropTypes.myProp
          checkValidPropType(node.property);
        ***REMOVED*** else if (node.object.type === 'CallExpression') ***REMOVED***
          checkValidPropTypeQualifier(node.property);
          checkValidCallExpression(node.object);
        ***REMOVED***
      ***REMOVED*** else if (node.type === 'CallExpression') ***REMOVED***
        checkValidCallExpression(node);
      ***REMOVED***
    ***REMOVED***

    /* eslint-enable no-use-before-define */

    function checkValidPropObject(node) ***REMOVED***
      if (node && node.type === 'ObjectExpression') ***REMOVED***
        node.properties.forEach(prop => checkValidProp(prop.value));
      ***REMOVED***
    ***REMOVED***

    function reportErrorIfPropertyCasingTypo(node, propertyName, isClassProperty) ***REMOVED***
      if (propertyName === 'propTypes' || propertyName === 'contextTypes' || propertyName === 'childContextTypes') ***REMOVED***
        checkValidPropObject(node);
      ***REMOVED***
      STATIC_CLASS_PROPERTIES.forEach((CLASS_PROP) => ***REMOVED***
        if (propertyName && CLASS_PROP.toLowerCase() === propertyName.toLowerCase() && CLASS_PROP !== propertyName) ***REMOVED***
          const message = isClassProperty ?
            'Typo in static class property declaration' :
            'Typo in property declaration';
          context.report(***REMOVED***
            node,
            message
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    function reportErrorIfLifecycleMethodCasingTypo(node) ***REMOVED***
      LIFECYCLE_METHODS.forEach((method) => ***REMOVED***
        if (method.toLowerCase() === node.key.name.toLowerCase() && method !== node.key.name) ***REMOVED***
          context.report(***REMOVED***
            node,
            message: 'Typo in component lifecycle method declaration'
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    return ***REMOVED***
      ImportDeclaration(node) ***REMOVED***
        if (node.source && node.source.value === 'prop-types') ***REMOVED*** // import PropType from "prop-types"
          propTypesPackageName = node.specifiers[0].local.name;
        ***REMOVED*** else if (node.source && node.source.value === 'react') ***REMOVED*** // import ***REMOVED*** PropTypes ***REMOVED*** from "react"
          if (node.specifiers.length > 0) ***REMOVED***
            reactPackageName = node.specifiers[0].local.name; // guard against accidental anonymous `import "react"`
          ***REMOVED***
          if (node.specifiers.length >= 1) ***REMOVED***
            const propTypesSpecifier = node.specifiers.find(specifier => (
              specifier.imported && specifier.imported.name === 'PropTypes'
            ));
            if (propTypesSpecifier) ***REMOVED***
              propTypesPackageName = propTypesSpecifier.local.name;
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,

      ClassProperty(node) ***REMOVED***
        if (!node.static || !utils.isES6Component(node.parent.parent)) ***REMOVED***
          return;
        ***REMOVED***

        const tokens = context.getFirstTokens(node, 2);
        const propertyName = tokens[1].value;
        reportErrorIfPropertyCasingTypo(node.value, propertyName, true);
      ***REMOVED***,

      MemberExpression(node) ***REMOVED***
        const propertyName = node.property.name;

        if (
          !propertyName ||
          STATIC_CLASS_PROPERTIES.map(prop => prop.toLocaleLowerCase()).indexOf(propertyName.toLowerCase()) === -1
        ) ***REMOVED***
          return;
        ***REMOVED***

        const relatedComponent = utils.getRelatedComponent(node);

        if (
          relatedComponent &&
          (utils.isES6Component(relatedComponent.node) || utils.isReturningJSX(relatedComponent.node)) &&
          (node.parent && node.parent.type === 'AssignmentExpression' && node.parent.right)
        ) ***REMOVED***
          reportErrorIfPropertyCasingTypo(node.parent.right, propertyName, true);
        ***REMOVED***
      ***REMOVED***,

      MethodDefinition(node) ***REMOVED***
        if (!utils.isES6Component(node.parent.parent)) ***REMOVED***
          return;
        ***REMOVED***

        reportErrorIfLifecycleMethodCasingTypo(node);
      ***REMOVED***,

      ObjectExpression(node) ***REMOVED***
        const component = utils.isES5Component(node) && components.get(node);

        if (!component) ***REMOVED***
          return;
        ***REMOVED***

        node.properties.forEach((property) => ***REMOVED***
          reportErrorIfPropertyCasingTypo(property.value, property.key.name, false);
          reportErrorIfLifecycleMethodCasingTypo(property);
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***)
***REMOVED***;
