/**
 * @fileoverview Prevent usage of Array index in keys
 * @author Joe Lencioni
 */

'use strict';

const has = require('has');
const astUtil = require('../util/ast');
const docsUrl = require('../util/docsUrl');
const pragma = require('../util/pragma');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Prevent usage of Array index in keys',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('no-array-index-key')
    ***REMOVED***,

    schema: []
  ***REMOVED***,

  create(context) ***REMOVED***
    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------
    const indexParamNames = [];
    const iteratorFunctionsToIndexParamPosition = ***REMOVED***
      every: 1,
      filter: 1,
      find: 1,
      findIndex: 1,
      forEach: 1,
      map: 1,
      reduce: 2,
      reduceRight: 2,
      some: 1
    ***REMOVED***;
    const ERROR_MESSAGE = 'Do not use Array index in keys';

    function isArrayIndex(node) ***REMOVED***
      return node.type === 'Identifier' &&
        indexParamNames.indexOf(node.name) !== -1;
    ***REMOVED***

    function isUsingReactChildren(node) ***REMOVED***
      const callee = node.callee;
      if (
        !callee ||
        !callee.property ||
        !callee.object
      ) ***REMOVED***
        return null;
      ***REMOVED***

      const isReactChildMethod = ['map', 'forEach'].indexOf(callee.property.name) > -1;
      if (!isReactChildMethod) ***REMOVED***
        return null;
      ***REMOVED***

      const obj = callee.object;
      if (obj && obj.name === 'Children') ***REMOVED***
        return true;
      ***REMOVED***
      if (obj && obj.object && obj.object.name === pragma.getFromContext(context)) ***REMOVED***
        return true;
      ***REMOVED***

      return false;
    ***REMOVED***

    function getMapIndexParamName(node) ***REMOVED***
      const callee = node.callee;
      if (callee.type !== 'MemberExpression') ***REMOVED***
        return null;
      ***REMOVED***
      if (callee.property.type !== 'Identifier') ***REMOVED***
        return null;
      ***REMOVED***
      if (!has(iteratorFunctionsToIndexParamPosition, callee.property.name)) ***REMOVED***
        return null;
      ***REMOVED***

      const callbackArg = isUsingReactChildren(node) ?
        node.arguments[1] :
        node.arguments[0];

      if (!callbackArg) ***REMOVED***
        return null;
      ***REMOVED***

      if (!astUtil.isFunctionLikeExpression(callbackArg)) ***REMOVED***
        return null;
      ***REMOVED***

      const params = callbackArg.params;

      const indexParamPosition = iteratorFunctionsToIndexParamPosition[callee.property.name];
      if (params.length < indexParamPosition + 1) ***REMOVED***
        return null;
      ***REMOVED***

      return params[indexParamPosition].name;
    ***REMOVED***

    function getIdentifiersFromBinaryExpression(side) ***REMOVED***
      if (side.type === 'Identifier') ***REMOVED***
        return side;
      ***REMOVED***

      if (side.type === 'BinaryExpression') ***REMOVED***
        // recurse
        const left = getIdentifiersFromBinaryExpression(side.left);
        const right = getIdentifiersFromBinaryExpression(side.right);
        return [].concat(left, right).filter(Boolean);
      ***REMOVED***

      return null;
    ***REMOVED***

    function checkPropValue(node) ***REMOVED***
      if (isArrayIndex(node)) ***REMOVED***
        // key=***REMOVED***bar***REMOVED***
        context.report(***REMOVED***
          node,
          message: ERROR_MESSAGE
        ***REMOVED***);
        return;
      ***REMOVED***

      if (node.type === 'TemplateLiteral') ***REMOVED***
        // key=***REMOVED***`foo-$***REMOVED***bar***REMOVED***`***REMOVED***
        node.expressions.filter(isArrayIndex).forEach(() => ***REMOVED***
          context.report(***REMOVED***node, message: ERROR_MESSAGE***REMOVED***);
        ***REMOVED***);

        return;
      ***REMOVED***

      if (node.type === 'BinaryExpression') ***REMOVED***
        // key=***REMOVED***'foo' + bar***REMOVED***
        const identifiers = getIdentifiersFromBinaryExpression(node);

        identifiers.filter(isArrayIndex).forEach(() => ***REMOVED***
          context.report(***REMOVED***node, message: ERROR_MESSAGE***REMOVED***);
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    return ***REMOVED***
      CallExpression(node) ***REMOVED***
        if (
          node.callee &&
          node.callee.type === 'MemberExpression' &&
          ['createElement', 'cloneElement'].indexOf(node.callee.property.name) !== -1 &&
          node.arguments.length > 1
        ) ***REMOVED***
          // React.createElement
          if (!indexParamNames.length) ***REMOVED***
            return;
          ***REMOVED***

          const props = node.arguments[1];

          if (props.type !== 'ObjectExpression') ***REMOVED***
            return;
          ***REMOVED***

          props.properties.forEach((prop) => ***REMOVED***
            if (!prop.key || prop.key.name !== 'key') ***REMOVED***
              // ***REMOVED*** ...foo ***REMOVED***
              // ***REMOVED*** foo: bar ***REMOVED***
              return;
            ***REMOVED***

            checkPropValue(prop.value);
          ***REMOVED***);

          return;
        ***REMOVED***

        const mapIndexParamName = getMapIndexParamName(node);
        if (!mapIndexParamName) ***REMOVED***
          return;
        ***REMOVED***

        indexParamNames.push(mapIndexParamName);
      ***REMOVED***,

      JSXAttribute(node) ***REMOVED***
        if (node.name.name !== 'key') ***REMOVED***
          // foo=***REMOVED***bar***REMOVED***
          return;
        ***REMOVED***

        if (!indexParamNames.length) ***REMOVED***
          // Not inside a call expression that we think has an index param.
          return;
        ***REMOVED***

        const value = node.value;
        if (!value || value.type !== 'JSXExpressionContainer') ***REMOVED***
          // key='foo' or just simply 'key'
          return;
        ***REMOVED***

        checkPropValue(value.expression);
      ***REMOVED***,

      'CallExpression:exit': function (node) ***REMOVED***
        const mapIndexParamName = getMapIndexParamName(node);
        if (!mapIndexParamName) ***REMOVED***
          return;
        ***REMOVED***

        indexParamNames.pop();
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
