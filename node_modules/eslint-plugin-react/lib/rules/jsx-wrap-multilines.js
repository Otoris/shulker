/**
 * @fileoverview Prevent missing parentheses around multilines JSX
 * @author Yannick Croissant
 */

'use strict';

const has = require('has');
const docsUrl = require('../util/docsUrl');
const jsxUtil = require('../util/jsx');

// ------------------------------------------------------------------------------
// Constants
// ------------------------------------------------------------------------------

const DEFAULTS = ***REMOVED***
  declaration: 'parens',
  assignment: 'parens',
  return: 'parens',
  arrow: 'parens',
  condition: 'ignore',
  logical: 'ignore',
  prop: 'ignore'
***REMOVED***;

const MISSING_PARENS = 'Missing parentheses around multilines JSX';
const PARENS_NEW_LINES = 'Parentheses around JSX should be on separate lines';

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Prevent missing parentheses around multilines JSX',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-wrap-multilines')
    ***REMOVED***,
    fixable: 'code',

    schema: [***REMOVED***
      type: 'object',
      // true/false are for backwards compatibility
      properties: ***REMOVED***
        declaration: ***REMOVED***
          enum: [true, false, 'ignore', 'parens', 'parens-new-line']
        ***REMOVED***,
        assignment: ***REMOVED***
          enum: [true, false, 'ignore', 'parens', 'parens-new-line']
        ***REMOVED***,
        return: ***REMOVED***
          enum: [true, false, 'ignore', 'parens', 'parens-new-line']
        ***REMOVED***,
        arrow: ***REMOVED***
          enum: [true, false, 'ignore', 'parens', 'parens-new-line']
        ***REMOVED***,
        condition: ***REMOVED***
          enum: [true, false, 'ignore', 'parens', 'parens-new-line']
        ***REMOVED***,
        logical: ***REMOVED***
          enum: [true, false, 'ignore', 'parens', 'parens-new-line']
        ***REMOVED***,
        prop: ***REMOVED***
          enum: [true, false, 'ignore', 'parens', 'parens-new-line']
        ***REMOVED***
      ***REMOVED***,
      additionalProperties: false
    ***REMOVED***]
  ***REMOVED***,

  create(context) ***REMOVED***
    function getOption(type) ***REMOVED***
      const userOptions = context.options[0] || ***REMOVED******REMOVED***;
      if (has(userOptions, type)) ***REMOVED***
        return userOptions[type];
      ***REMOVED***
      return DEFAULTS[type];
    ***REMOVED***

    function isEnabled(type) ***REMOVED***
      const option = getOption(type);
      return option && option !== 'ignore';
    ***REMOVED***

    function isParenthesised(node) ***REMOVED***
      const sourceCode = context.getSourceCode();
      const previousToken = sourceCode.getTokenBefore(node);
      const nextToken = sourceCode.getTokenAfter(node);

      return previousToken && nextToken &&
        previousToken.value === '(' && previousToken.range[1] <= node.range[0] &&
        nextToken.value === ')' && nextToken.range[0] >= node.range[1];
    ***REMOVED***

    function needsOpeningNewLine(node) ***REMOVED***
      const previousToken = context.getSourceCode().getTokenBefore(node);

      if (!isParenthesised(node)) ***REMOVED***
        return false;
      ***REMOVED***

      if (previousToken.loc.end.line === node.loc.start.line) ***REMOVED***
        return true;
      ***REMOVED***

      return false;
    ***REMOVED***

    function needsClosingNewLine(node) ***REMOVED***
      const nextToken = context.getSourceCode().getTokenAfter(node);

      if (!isParenthesised(node)) ***REMOVED***
        return false;
      ***REMOVED***

      if (node.loc.end.line === nextToken.loc.end.line) ***REMOVED***
        return true;
      ***REMOVED***

      return false;
    ***REMOVED***

    function isMultilines(node) ***REMOVED***
      return node.loc.start.line !== node.loc.end.line;
    ***REMOVED***

    function report(node, message, fix) ***REMOVED***
      context.report(***REMOVED***
        node,
        message,
        fix
      ***REMOVED***);
    ***REMOVED***

    function trimTokenBeforeNewline(node, tokenBefore) ***REMOVED***
      // if the token before the jsx is a bracket or curly brace
      // we don't want a space between the opening parentheses and the multiline jsx
      const isBracket = tokenBefore.value === '***REMOVED***' || tokenBefore.value === '[';
      return `$***REMOVED***tokenBefore.value.trim()***REMOVED***$***REMOVED***isBracket ? '' : ' '***REMOVED***`;
    ***REMOVED***

    function check(node, type) ***REMOVED***
      if (!node || !jsxUtil.isJSX(node)) ***REMOVED***
        return;
      ***REMOVED***

      const sourceCode = context.getSourceCode();
      const option = getOption(type);

      if ((option === true || option === 'parens') && !isParenthesised(node) && isMultilines(node)) ***REMOVED***
        report(node, MISSING_PARENS, fixer => fixer.replaceText(node, `($***REMOVED***sourceCode.getText(node)***REMOVED***)`));
      ***REMOVED***

      if (option === 'parens-new-line' && isMultilines(node)) ***REMOVED***
        if (!isParenthesised(node)) ***REMOVED***
          const tokenBefore = sourceCode.getTokenBefore(node, ***REMOVED***includeComments: true***REMOVED***);
          const tokenAfter = sourceCode.getTokenAfter(node, ***REMOVED***includeComments: true***REMOVED***);
          if (tokenBefore.loc.end.line < node.loc.start.line) ***REMOVED***
            // Strip newline after operator if parens newline is specified
            report(
              node,
              MISSING_PARENS,
              fixer => fixer.replaceTextRange(
                [tokenBefore.range[0], tokenAfter ? tokenAfter.range[0] : node.range[1]],
                `$***REMOVED***trimTokenBeforeNewline(node, tokenBefore)***REMOVED***(\n$***REMOVED***sourceCode.getText(node)***REMOVED***\n)`
              )
            );
          ***REMOVED*** else ***REMOVED***
            report(node, MISSING_PARENS, fixer => fixer.replaceText(node, `(\n$***REMOVED***sourceCode.getText(node)***REMOVED***\n)`));
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          const needsOpening = needsOpeningNewLine(node);
          const needsClosing = needsClosingNewLine(node);
          if (needsOpening || needsClosing) ***REMOVED***
            report(node, PARENS_NEW_LINES, (fixer) => ***REMOVED***
              const text = sourceCode.getText(node);
              let fixed = text;
              if (needsOpening) ***REMOVED***
                fixed = `\n$***REMOVED***fixed***REMOVED***`;
              ***REMOVED***
              if (needsClosing) ***REMOVED***
                fixed = `$***REMOVED***fixed***REMOVED***\n`;
              ***REMOVED***
              return fixer.replaceText(node, fixed);
            ***REMOVED***);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------

    return ***REMOVED***

      VariableDeclarator(node) ***REMOVED***
        const type = 'declaration';
        if (!isEnabled(type)) ***REMOVED***
          return;
        ***REMOVED***
        if (!isEnabled('condition') && node.init && node.init.type === 'ConditionalExpression') ***REMOVED***
          check(node.init.consequent, type);
          check(node.init.alternate, type);
          return;
        ***REMOVED***
        check(node.init, type);
      ***REMOVED***,

      AssignmentExpression(node) ***REMOVED***
        const type = 'assignment';
        if (!isEnabled(type)) ***REMOVED***
          return;
        ***REMOVED***
        if (!isEnabled('condition') && node.right.type === 'ConditionalExpression') ***REMOVED***
          check(node.right.consequent, type);
          check(node.right.alternate, type);
          return;
        ***REMOVED***
        check(node.right, type);
      ***REMOVED***,

      ReturnStatement(node) ***REMOVED***
        const type = 'return';
        if (isEnabled(type)) ***REMOVED***
          check(node.argument, type);
        ***REMOVED***
      ***REMOVED***,

      'ArrowFunctionExpression:exit': function (node) ***REMOVED***
        const arrowBody = node.body;
        const type = 'arrow';

        if (isEnabled(type) && arrowBody.type !== 'BlockStatement') ***REMOVED***
          check(arrowBody, type);
        ***REMOVED***
      ***REMOVED***,

      ConditionalExpression(node) ***REMOVED***
        const type = 'condition';
        if (isEnabled(type)) ***REMOVED***
          check(node.consequent, type);
          check(node.alternate, type);
        ***REMOVED***
      ***REMOVED***,

      LogicalExpression(node) ***REMOVED***
        const type = 'logical';
        if (isEnabled(type)) ***REMOVED***
          check(node.right, type);
        ***REMOVED***
      ***REMOVED***,

      JSXAttribute(node) ***REMOVED***
        const type = 'prop';
        if (isEnabled(type) && node.value && node.value.type === 'JSXExpressionContainer') ***REMOVED***
          check(node.value.expression, type);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
