/**
 * @fileoverview enforce consistent line breaks inside jsx curly
 */

'use strict';

const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

function getNormalizedOption(context) ***REMOVED***
  const rawOption = context.options[0] || 'consistent';

  if (rawOption === 'consistent') ***REMOVED***
    return ***REMOVED***
      multiline: 'consistent',
      singleline: 'consistent'
    ***REMOVED***;
  ***REMOVED***

  if (rawOption === 'never') ***REMOVED***
    return ***REMOVED***
      multiline: 'forbid',
      singleline: 'forbid'
    ***REMOVED***;
  ***REMOVED***

  return ***REMOVED***
    multiline: rawOption.multiline || 'consistent',
    singleline: rawOption.singleline || 'consistent'
  ***REMOVED***;
***REMOVED***

module.exports = ***REMOVED***
  meta: ***REMOVED***
    type: 'layout',

    docs: ***REMOVED***
      description: 'enforce consistent line breaks inside jsx curly',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-curly-newline')
    ***REMOVED***,

    fixable: 'whitespace',

    schema: [
      ***REMOVED***
        oneOf: [
          ***REMOVED***
            enum: ['consistent', 'never']
          ***REMOVED***,
          ***REMOVED***
            type: 'object',
            properties: ***REMOVED***
              singleline: ***REMOVED***enum: ['consistent', 'require', 'forbid']***REMOVED***,
              multiline: ***REMOVED***enum: ['consistent', 'require', 'forbid']***REMOVED***
            ***REMOVED***,
            additionalProperties: false
          ***REMOVED***
        ]
      ***REMOVED***
    ],


    messages: ***REMOVED***
      expectedBefore: 'Expected newline before \'***REMOVED***\'.',
      expectedAfter: 'Expected newline after \'***REMOVED***\'.',
      unexpectedBefore: 'Unexpected newline before \'***REMOVED***\'.',
      unexpectedAfter: 'Unexpected newline after \'***REMOVED***\'.'
    ***REMOVED***
  ***REMOVED***,

  create(context) ***REMOVED***
    const sourceCode = context.getSourceCode();
    const option = getNormalizedOption(context);

    // ----------------------------------------------------------------------
    // Helpers
    // ----------------------------------------------------------------------

    /**
     * Determines whether two adjacent tokens are on the same line.
     * @param ***REMOVED***Object***REMOVED*** left - The left token object.
     * @param ***REMOVED***Object***REMOVED*** right - The right token object.
     * @returns ***REMOVED***boolean***REMOVED*** Whether or not the tokens are on the same line.
     */
    function isTokenOnSameLine(left, right) ***REMOVED***
      return left.loc.end.line === right.loc.start.line;
    ***REMOVED***

    /**
     * Determines whether there should be newlines inside curlys
     * @param ***REMOVED***ASTNode***REMOVED*** expression The expression contained in the curlys
     * @param ***REMOVED***boolean***REMOVED*** hasLeftNewline `true` if the left curly has a newline in the current code.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if there should be newlines inside the function curlys
     */
    function shouldHaveNewlines(expression, hasLeftNewline) ***REMOVED***
      const isMultiline = expression.loc.start.line !== expression.loc.end.line;

      switch (isMultiline ? option.multiline : option.singleline) ***REMOVED***
        case 'forbid': return false;
        case 'require': return true;
        case 'consistent':
        default: return hasLeftNewline;
      ***REMOVED***
    ***REMOVED***

    /**
     * Validates curlys
     * @param ***REMOVED***Object***REMOVED*** curlys An object with keys `leftParen` for the left paren token, and `rightParen` for the right paren token
     * @param ***REMOVED***ASTNode***REMOVED*** expression The expression inside the curly
     * @returns ***REMOVED***void***REMOVED***
     */
    function validateCurlys(curlys, expression) ***REMOVED***
      const leftCurly = curlys.leftCurly;
      const rightCurly = curlys.rightCurly;
      const tokenAfterLeftCurly = sourceCode.getTokenAfter(leftCurly);
      const tokenBeforeRightCurly = sourceCode.getTokenBefore(rightCurly);
      const hasLeftNewline = !isTokenOnSameLine(leftCurly, tokenAfterLeftCurly);
      const hasRightNewline = !isTokenOnSameLine(tokenBeforeRightCurly, rightCurly);
      const needsNewlines = shouldHaveNewlines(expression, hasLeftNewline);

      if (hasLeftNewline && !needsNewlines) ***REMOVED***
        context.report(***REMOVED***
          node: leftCurly,
          messageId: 'unexpectedAfter',
          fix(fixer) ***REMOVED***
            return sourceCode
              .getText()
              .slice(leftCurly.range[1], tokenAfterLeftCurly.range[0])
              .trim() ?
              null : // If there is a comment between the ***REMOVED*** and the first element, don't do a fix.
              fixer.removeRange([leftCurly.range[1], tokenAfterLeftCurly.range[0]]);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED*** else if (!hasLeftNewline && needsNewlines) ***REMOVED***
        context.report(***REMOVED***
          node: leftCurly,
          messageId: 'expectedAfter',
          fix: fixer => fixer.insertTextAfter(leftCurly, '\n')
        ***REMOVED***);
      ***REMOVED***

      if (hasRightNewline && !needsNewlines) ***REMOVED***
        context.report(***REMOVED***
          node: rightCurly,
          messageId: 'unexpectedBefore',
          fix(fixer) ***REMOVED***
            return sourceCode
              .getText()
              .slice(tokenBeforeRightCurly.range[1], rightCurly.range[0])
              .trim() ?
              null : // If there is a comment between the last element and the ***REMOVED***, don't do a fix.
              fixer.removeRange([
                tokenBeforeRightCurly.range[1],
                rightCurly.range[0]
              ]);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED*** else if (!hasRightNewline && needsNewlines) ***REMOVED***
        context.report(***REMOVED***
          node: rightCurly,
          messageId: 'expectedBefore',
          fix: fixer => fixer.insertTextBefore(rightCurly, '\n')
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***


    // ----------------------------------------------------------------------
    // Public
    // ----------------------------------------------------------------------

    return ***REMOVED***
      JSXExpressionContainer(node) ***REMOVED***
        const curlyTokens = ***REMOVED***
          leftCurly: sourceCode.getFirstToken(node),
          rightCurly: sourceCode.getLastToken(node)
        ***REMOVED***;
        validateCurlys(curlyTokens, node.expression);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
