/**
 * @fileoverview Prevent usage of this.state within setState
 * @author Rolf Erik Lekang, JÃ¸rgen Aaberg
 */

'use strict';

const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Reports when this.state is accessed within setState',
      category: 'Possible Errors',
      recommended: false,
      url: docsUrl('no-access-state-in-setstate')
    ***REMOVED***
  ***REMOVED***,

  create(context) ***REMOVED***
    function isSetStateCall(node) ***REMOVED***
      return node.type === 'CallExpression' &&
        node.callee.property &&
        node.callee.property.name === 'setState' &&
        node.callee.object.type === 'ThisExpression';
    ***REMOVED***

    function isFirstArgumentInSetStateCall(current, node) ***REMOVED***
      if (!isSetStateCall(current)) ***REMOVED***
        return false;
      ***REMOVED***
      while (node && node.parent !== current) ***REMOVED***
        node = node.parent;
      ***REMOVED***
      return current.arguments[0] === node;
    ***REMOVED***

    // The methods array contains all methods or functions that are using this.state
    // or that are calling another method or function using this.state
    const methods = [];
    // The vars array contains all variables that contains this.state
    const vars = [];
    return ***REMOVED***
      CallExpression(node) ***REMOVED***
        // Appends all the methods that are calling another
        // method containing this.state to the methods array
        methods.forEach((method) => ***REMOVED***
          if (node.callee.name === method.methodName) ***REMOVED***
            let current = node.parent;
            while (current.type !== 'Program') ***REMOVED***
              if (current.type === 'MethodDefinition') ***REMOVED***
                methods.push(***REMOVED***
                  methodName: current.key.name,
                  node: method.node
                ***REMOVED***);
                break;
              ***REMOVED***
              current = current.parent;
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***);

        // Finding all CallExpressions that is inside a setState
        // to further check if they contains this.state
        let current = node.parent;
        while (current.type !== 'Program') ***REMOVED***
          if (isFirstArgumentInSetStateCall(current, node)) ***REMOVED***
            const methodName = node.callee.name;
            methods.forEach((method) => ***REMOVED***
              if (method.methodName === methodName) ***REMOVED***
                context.report(***REMOVED***
                  node: method.node,
                  message: 'Use callback in setState when referencing the previous state.'
                ***REMOVED***);
              ***REMOVED***
            ***REMOVED***);

            break;
          ***REMOVED***
          current = current.parent;
        ***REMOVED***
      ***REMOVED***,

      MemberExpression(node) ***REMOVED***
        if (
          node.property.name === 'state' &&
          node.object.type === 'ThisExpression'
        ) ***REMOVED***
          let current = node;
          while (current.type !== 'Program') ***REMOVED***
            // Reporting if this.state is directly within this.setState
            if (isFirstArgumentInSetStateCall(current, node)) ***REMOVED***
              context.report(***REMOVED***
                node,
                message: 'Use callback in setState when referencing the previous state.'
              ***REMOVED***);
              break;
            ***REMOVED***

            // Storing all functions and methods that contains this.state
            if (current.type === 'MethodDefinition') ***REMOVED***
              methods.push(***REMOVED***
                methodName: current.key.name,
                node
              ***REMOVED***);
              break;
            ***REMOVED*** else if (current.type === 'FunctionExpression' && current.parent.key) ***REMOVED***
              methods.push(***REMOVED***
                methodName: current.parent.key.name,
                node
              ***REMOVED***);
              break;
            ***REMOVED***

            // Storing all variables containg this.state
            if (current.type === 'VariableDeclarator') ***REMOVED***
              vars.push(***REMOVED***
                node,
                scope: context.getScope(),
                variableName: current.id.name
              ***REMOVED***);
              break;
            ***REMOVED***

            current = current.parent;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,

      Identifier(node) ***REMOVED***
        // Checks if the identifier is a variable within an object
        let current = node;
        while (current.parent.type === 'BinaryExpression') ***REMOVED***
          current = current.parent;
        ***REMOVED***
        if (
          current.parent.value === current ||
          current.parent.object === current
        ) ***REMOVED***
          while (current.type !== 'Program') ***REMOVED***
            if (isFirstArgumentInSetStateCall(current, node)) ***REMOVED***
              vars
                .filter(v => v.scope === context.getScope() && v.variableName === node.name)
                .forEach((v) => ***REMOVED***
                  context.report(***REMOVED***
                    node: v.node,
                    message: 'Use callback in setState when referencing the previous state.'
                  ***REMOVED***);
                ***REMOVED***);
            ***REMOVED***
            current = current.parent;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,

      ObjectPattern(node) ***REMOVED***
        const isDerivedFromThis = node.parent.init && node.parent.init.type === 'ThisExpression';
        node.properties.forEach((property) => ***REMOVED***
          if (property && property.key && property.key.name === 'state' && isDerivedFromThis) ***REMOVED***
            vars.push(***REMOVED***
              node: property.key,
              scope: context.getScope(),
              variableName: property.key.name
            ***REMOVED***);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
