/**
 * @fileoverview Enforce stateless components to be written as a pure function
 * @author Yannick Croissant
 * @author Alberto Rodríguez
 * @copyright 2015 Alberto Rodríguez. All rights reserved.
 */

'use strict';

const Components = require('../util/Components');
const versionUtil = require('../util/version');
const astUtil = require('../util/ast');
const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Enforce stateless components to be written as a pure function',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('prefer-stateless-function')
    ***REMOVED***,
    schema: [***REMOVED***
      type: 'object',
      properties: ***REMOVED***
        ignorePureComponents: ***REMOVED***
          default: false,
          type: 'boolean'
        ***REMOVED***
      ***REMOVED***,
      additionalProperties: false
    ***REMOVED***]
  ***REMOVED***,

  create: Components.detect((context, components, utils) => ***REMOVED***
    const configuration = context.options[0] || ***REMOVED******REMOVED***;
    const ignorePureComponents = configuration.ignorePureComponents || false;

    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------

    /**
     * Checks whether a given array of statements is a single call of `super`.
     * @see ESLint no-useless-constructor rule
     * @param ***REMOVED***ASTNode[]***REMOVED*** body - An array of statements to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the body is a single call of `super`.
     */
    function isSingleSuperCall(body) ***REMOVED***
      return (
        body.length === 1 &&
        body[0].type === 'ExpressionStatement' &&
        body[0].expression.type === 'CallExpression' &&
        body[0].expression.callee.type === 'Super'
      );
    ***REMOVED***

    /**
     * Checks whether a given node is a pattern which doesn't have any side effects.
     * Default parameters and Destructuring parameters can have side effects.
     * @see ESLint no-useless-constructor rule
     * @param ***REMOVED***ASTNode***REMOVED*** node - A pattern node.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the node doesn't have any side effects.
     */
    function isSimple(node) ***REMOVED***
      return node.type === 'Identifier' || node.type === 'RestElement';
    ***REMOVED***

    /**
     * Checks whether a given array of expressions is `...arguments` or not.
     * `super(...arguments)` passes all arguments through.
     * @see ESLint no-useless-constructor rule
     * @param ***REMOVED***ASTNode[]***REMOVED*** superArgs - An array of expressions to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the superArgs is `...arguments`.
     */
    function isSpreadArguments(superArgs) ***REMOVED***
      return (
        superArgs.length === 1 &&
        superArgs[0].type === 'SpreadElement' &&
        superArgs[0].argument.type === 'Identifier' &&
        superArgs[0].argument.name === 'arguments'
      );
    ***REMOVED***

    /**
     * Checks whether given 2 nodes are identifiers which have the same name or not.
     * @see ESLint no-useless-constructor rule
     * @param ***REMOVED***ASTNode***REMOVED*** ctorParam - A node to check.
     * @param ***REMOVED***ASTNode***REMOVED*** superArg - A node to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the nodes are identifiers which have the same
     *      name.
     */
    function isValidIdentifierPair(ctorParam, superArg) ***REMOVED***
      return (
        ctorParam.type === 'Identifier' &&
        superArg.type === 'Identifier' &&
        ctorParam.name === superArg.name
      );
    ***REMOVED***

    /**
     * Checks whether given 2 nodes are a rest/spread pair which has the same values.
     * @see ESLint no-useless-constructor rule
     * @param ***REMOVED***ASTNode***REMOVED*** ctorParam - A node to check.
     * @param ***REMOVED***ASTNode***REMOVED*** superArg - A node to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the nodes are a rest/spread pair which has the
     *      same values.
     */
    function isValidRestSpreadPair(ctorParam, superArg) ***REMOVED***
      return (
        ctorParam.type === 'RestElement' &&
        superArg.type === 'SpreadElement' &&
        isValidIdentifierPair(ctorParam.argument, superArg.argument)
      );
    ***REMOVED***

    /**
     * Checks whether given 2 nodes have the same value or not.
     * @see ESLint no-useless-constructor rule
     * @param ***REMOVED***ASTNode***REMOVED*** ctorParam - A node to check.
     * @param ***REMOVED***ASTNode***REMOVED*** superArg - A node to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if the nodes have the same value or not.
     */
    function isValidPair(ctorParam, superArg) ***REMOVED***
      return (
        isValidIdentifierPair(ctorParam, superArg) ||
        isValidRestSpreadPair(ctorParam, superArg)
      );
    ***REMOVED***

    /**
     * Checks whether the parameters of a constructor and the arguments of `super()`
     * have the same values or not.
     * @see ESLint no-useless-constructor rule
     * @param ***REMOVED***ASTNode[]***REMOVED*** ctorParams - The parameters of a constructor to check.
     * @param ***REMOVED***ASTNode***REMOVED*** superArgs - The arguments of `super()` to check.
     * @returns ***REMOVED***boolean***REMOVED*** `true` if those have the same values.
     */
    function isPassingThrough(ctorParams, superArgs) ***REMOVED***
      if (ctorParams.length !== superArgs.length) ***REMOVED***
        return false;
      ***REMOVED***

      for (let i = 0; i < ctorParams.length; ++i) ***REMOVED***
        if (!isValidPair(ctorParams[i], superArgs[i])) ***REMOVED***
          return false;
        ***REMOVED***
      ***REMOVED***

      return true;
    ***REMOVED***

    /**
     * Checks whether the constructor body is a redundant super call.
     * @see ESLint no-useless-constructor rule
     * @param ***REMOVED***Array***REMOVED*** body - constructor body content.
     * @param ***REMOVED***Array***REMOVED*** ctorParams - The params to check against super call.
     * @returns ***REMOVED***boolean***REMOVED*** true if the construtor body is redundant
     */
    function isRedundantSuperCall(body, ctorParams) ***REMOVED***
      return (
        isSingleSuperCall(body) &&
        ctorParams.every(isSimple) &&
        (
          isSpreadArguments(body[0].expression.arguments) ||
          isPassingThrough(ctorParams, body[0].expression.arguments)
        )
      );
    ***REMOVED***

    /**
     * Check if a given AST node have any other properties the ones available in stateless components
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     * @returns ***REMOVED***Boolean***REMOVED*** True if the node has at least one other property, false if not.
     */
    function hasOtherProperties(node) ***REMOVED***
      const properties = astUtil.getComponentProperties(node);
      return properties.some((property) => ***REMOVED***
        const name = astUtil.getPropertyName(property);
        const isDisplayName = name === 'displayName';
        const isPropTypes = name === 'propTypes' || name === 'props' && property.typeAnnotation;
        const contextTypes = name === 'contextTypes';
        const defaultProps = name === 'defaultProps';
        const isUselessConstructor = property.kind === 'constructor' &&
          isRedundantSuperCall(property.value.body.body, property.value.params);
        const isRender = name === 'render';
        return !isDisplayName && !isPropTypes && !contextTypes && !defaultProps && !isUselessConstructor && !isRender;
      ***REMOVED***);
    ***REMOVED***

    /**
     * Mark component as pure as declared
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     */
    const markSCUAsDeclared = function (node) ***REMOVED***
      components.set(node, ***REMOVED***
        hasSCU: true
      ***REMOVED***);
    ***REMOVED***;

    /**
     * Mark childContextTypes as declared
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     */
    const markChildContextTypesAsDeclared = function (node) ***REMOVED***
      components.set(node, ***REMOVED***
        hasChildContextTypes: true
      ***REMOVED***);
    ***REMOVED***;

    /**
     * Mark a setState as used
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     */
    function markThisAsUsed(node) ***REMOVED***
      components.set(node, ***REMOVED***
        useThis: true
      ***REMOVED***);
    ***REMOVED***

    /**
     * Mark a props or context as used
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     */
    function markPropsOrContextAsUsed(node) ***REMOVED***
      components.set(node, ***REMOVED***
        usePropsOrContext: true
      ***REMOVED***);
    ***REMOVED***

    /**
     * Mark a ref as used
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     */
    function markRefAsUsed(node) ***REMOVED***
      components.set(node, ***REMOVED***
        useRef: true
      ***REMOVED***);
    ***REMOVED***

    /**
     * Mark return as invalid
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     */
    function markReturnAsInvalid(node) ***REMOVED***
      components.set(node, ***REMOVED***
        invalidReturn: true
      ***REMOVED***);
    ***REMOVED***

    /**
     * Mark a ClassDeclaration as having used decorators
     * @param ***REMOVED***ASTNode***REMOVED*** node The AST node being checked.
     */
    function markDecoratorsAsUsed(node) ***REMOVED***
      components.set(node, ***REMOVED***
        useDecorators: true
      ***REMOVED***);
    ***REMOVED***

    function visitClass(node) ***REMOVED***
      if (ignorePureComponents && utils.isPureComponent(node)) ***REMOVED***
        markSCUAsDeclared(node);
      ***REMOVED***

      if (node.decorators && node.decorators.length) ***REMOVED***
        markDecoratorsAsUsed(node);
      ***REMOVED***
    ***REMOVED***

    return ***REMOVED***
      ClassDeclaration: visitClass,
      ClassExpression: visitClass,

      // Mark `this` destructuring as a usage of `this`
      VariableDeclarator(node) ***REMOVED***
        // Ignore destructuring on other than `this`
        if (!node.id || node.id.type !== 'ObjectPattern' || !node.init || node.init.type !== 'ThisExpression') ***REMOVED***
          return;
        ***REMOVED***
        // Ignore `props` and `context`
        const useThis = node.id.properties.some((property) => ***REMOVED***
          const name = astUtil.getPropertyName(property);
          return name !== 'props' && name !== 'context';
        ***REMOVED***);
        if (!useThis) ***REMOVED***
          markPropsOrContextAsUsed(node);
          return;
        ***REMOVED***
        markThisAsUsed(node);
      ***REMOVED***,

      // Mark `this` usage
      MemberExpression(node) ***REMOVED***
        if (node.object.type !== 'ThisExpression') ***REMOVED***
          if (node.property && node.property.name === 'childContextTypes') ***REMOVED***
            const component = utils.getRelatedComponent(node);
            if (!component) ***REMOVED***
              return;
            ***REMOVED***
            markChildContextTypesAsDeclared(component.node);
          ***REMOVED***
          return;
        // Ignore calls to `this.props` and `this.context`
        ***REMOVED***
        if (
          (node.property.name || node.property.value) === 'props' ||
          (node.property.name || node.property.value) === 'context'
        ) ***REMOVED***
          markPropsOrContextAsUsed(node);
          return;
        ***REMOVED***
        markThisAsUsed(node);
      ***REMOVED***,

      // Mark `ref` usage
      JSXAttribute(node) ***REMOVED***
        const name = context.getSourceCode().getText(node.name);
        if (name !== 'ref') ***REMOVED***
          return;
        ***REMOVED***
        markRefAsUsed(node);
      ***REMOVED***,

      // Mark `render` that do not return some JSX
      ReturnStatement(node) ***REMOVED***
        let blockNode;
        let scope = context.getScope();
        while (scope) ***REMOVED***
          blockNode = scope.block && scope.block.parent;
          if (blockNode && (blockNode.type === 'MethodDefinition' || blockNode.type === 'Property')) ***REMOVED***
            break;
          ***REMOVED***
          scope = scope.upper;
        ***REMOVED***
        const isRender = blockNode && blockNode.key && blockNode.key.name === 'render';
        const allowNull = versionUtil.testReactVersion(context, '15.0.0'); // Stateless components can return null since React 15
        const isReturningJSX = utils.isReturningJSX(node, !allowNull);
        const isReturningNull = node.argument && (node.argument.value === null || node.argument.value === false);
        if (
          !isRender ||
          (allowNull && (isReturningJSX || isReturningNull)) ||
          (!allowNull && isReturningJSX)
        ) ***REMOVED***
          return;
        ***REMOVED***
        markReturnAsInvalid(node);
      ***REMOVED***,

      'Program:exit': function () ***REMOVED***
        const list = components.list();
        Object.keys(list).forEach((component) => ***REMOVED***
          if (
            hasOtherProperties(list[component].node) ||
            list[component].useThis ||
            list[component].useRef ||
            list[component].invalidReturn ||
            list[component].hasChildContextTypes ||
            list[component].useDecorators ||
            (!utils.isES5Component(list[component].node) && !utils.isES6Component(list[component].node))
          ) ***REMOVED***
            return;
          ***REMOVED***

          if (list[component].hasSCU) ***REMOVED***
            return;
          ***REMOVED***
          context.report(***REMOVED***
            node: list[component].node,
            message: 'Component should be written as a pure function'
          ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***)
***REMOVED***;
