/**
 * @fileoverview Limit maximum of props on a single line in JSX
 * @author Yannick Croissant
 */

'use strict';

const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Limit maximum of props on a single line in JSX',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-max-props-per-line')
    ***REMOVED***,
    fixable: 'code',
    schema: [***REMOVED***
      type: 'object',
      properties: ***REMOVED***
        maximum: ***REMOVED***
          type: 'integer',
          minimum: 1
        ***REMOVED***,
        when: ***REMOVED***
          type: 'string',
          enum: ['always', 'multiline']
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***]
  ***REMOVED***,

  create(context) ***REMOVED***
    const configuration = context.options[0] || ***REMOVED******REMOVED***;
    const maximum = configuration.maximum || 1;
    const when = configuration.when || 'always';

    function getPropName(propNode) ***REMOVED***
      if (propNode.type === 'JSXSpreadAttribute') ***REMOVED***
        return context.getSourceCode().getText(propNode.argument);
      ***REMOVED***
      return propNode.name.name;
    ***REMOVED***

    function generateFixFunction(line, max) ***REMOVED***
      const sourceCode = context.getSourceCode();
      const output = [];
      const front = line[0].range[0];
      const back = line[line.length - 1].range[1];
      for (let i = 0; i < line.length; i += max) ***REMOVED***
        const nodes = line.slice(i, i + max);
        output.push(nodes.reduce((prev, curr) => ***REMOVED***
          if (prev === '') ***REMOVED***
            return sourceCode.getText(curr);
          ***REMOVED***
          return `$***REMOVED***prev***REMOVED*** $***REMOVED***sourceCode.getText(curr)***REMOVED***`;
        ***REMOVED***, ''));
      ***REMOVED***
      const code = output.join('\n');
      return function (fixer) ***REMOVED***
        return fixer.replaceTextRange([front, back], code);
      ***REMOVED***;
    ***REMOVED***

    return ***REMOVED***
      JSXOpeningElement(node) ***REMOVED***
        if (!node.attributes.length) ***REMOVED***
          return;
        ***REMOVED***

        if (when === 'multiline' && node.loc.start.line === node.loc.end.line) ***REMOVED***
          return;
        ***REMOVED***

        const firstProp = node.attributes[0];
        const linePartitionedProps = [[firstProp]];

        node.attributes.reduce((last, decl) => ***REMOVED***
          if (last.loc.end.line === decl.loc.start.line) ***REMOVED***
            linePartitionedProps[linePartitionedProps.length - 1].push(decl);
          ***REMOVED*** else ***REMOVED***
            linePartitionedProps.push([decl]);
          ***REMOVED***
          return decl;
        ***REMOVED***);

        linePartitionedProps.forEach((propsInLine) => ***REMOVED***
          if (propsInLine.length > maximum) ***REMOVED***
            const name = getPropName(propsInLine[maximum]);
            context.report(***REMOVED***
              node: propsInLine[maximum],
              message: `Prop \`$***REMOVED***name***REMOVED***\` must be placed on a new line`,
              fix: generateFixFunction(propsInLine, maximum)
            ***REMOVED***);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
