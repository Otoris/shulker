/**
 * @fileoverview Enforces consistent naming for boolean props
 * @author Ev Haus
 */

'use strict';

const Components = require('../util/Components');
const propsUtil = require('../util/props');
const docsUrl = require('../util/docsUrl');
const propWrapperUtil = require('../util/propWrapper');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      category: 'Stylistic Issues',
      description: 'Enforces consistent naming for boolean props',
      recommended: false,
      url: docsUrl('boolean-prop-naming')
    ***REMOVED***,

    schema: [***REMOVED***
      additionalProperties: false,
      properties: ***REMOVED***
        propTypeNames: ***REMOVED***
          items: ***REMOVED***
            type: 'string'
          ***REMOVED***,
          minItems: 1,
          type: 'array',
          uniqueItems: true
        ***REMOVED***,
        rule: ***REMOVED***
          default: '^(is|has)[A-Z]([A-Za-z0-9]?)+',
          minLength: 1,
          type: 'string'
        ***REMOVED***,
        message: ***REMOVED***
          minLength: 1,
          type: 'string'
        ***REMOVED***,
        validateNested: ***REMOVED***
          default: false,
          type: 'boolean'
        ***REMOVED***
      ***REMOVED***,
      type: 'object'
    ***REMOVED***]
  ***REMOVED***,

  create: Components.detect((context, components, utils) => ***REMOVED***
    const config = context.options[0] || ***REMOVED******REMOVED***;
    const rule = config.rule ? new RegExp(config.rule) : null;
    const propTypeNames = config.propTypeNames || ['bool'];

    // Remembers all Flowtype object definitions
    const objectTypeAnnotations = new Map();

    /**
     * Returns the prop key to ensure we handle the following cases:
     * propTypes: ***REMOVED***
     *   full: React.PropTypes.bool,
     *   short: PropTypes.bool,
     *   direct: bool,
     *   required: PropTypes.bool.isRequired
     * ***REMOVED***
     * @param ***REMOVED***Object***REMOVED*** node The node we're getting the name of
     */
    function getPropKey(node) ***REMOVED***
      // Check for `ExperimentalSpreadProperty` (ESLint 3/4) and `SpreadElement` (ESLint 5)
      // so we can skip validation of those fields.
      // Otherwise it will look for `node.value.property` which doesn't exist and breaks ESLint.
      if (node.type === 'ExperimentalSpreadProperty' || node.type === 'SpreadElement') ***REMOVED***
        return null;
      ***REMOVED***
      if (node.value.property) ***REMOVED***
        const name = node.value.property.name;
        if (name === 'isRequired') ***REMOVED***
          if (node.value.object && node.value.object.property) ***REMOVED***
            return node.value.object.property.name;
          ***REMOVED***
          return null;
        ***REMOVED***
        return name;
      ***REMOVED***
      if (node.value.type === 'Identifier') ***REMOVED***
        return node.value.name;
      ***REMOVED***
      return null;
    ***REMOVED***

    /**
     * Returns the name of the given node (prop)
     * @param ***REMOVED***Object***REMOVED*** node The node we're getting the name of
     */
    function getPropName(node) ***REMOVED***
      // Due to this bug https://github.com/babel/babel-eslint/issues/307
      // we can't get the name of the Flow object key name. So we have
      // to hack around it for now.
      if (node.type === 'ObjectTypeProperty') ***REMOVED***
        return context.getSourceCode().getFirstToken(node).value;
      ***REMOVED***

      return node.key.name;
    ***REMOVED***

    /**
     * Checks if prop is declared in flow way
     * @param ***REMOVED***Object***REMOVED*** prop Property object, single prop type declaration
     * @returns ***REMOVED***Boolean***REMOVED***
     */
    function flowCheck(prop) ***REMOVED***
      return (
        prop.type === 'ObjectTypeProperty' &&
        prop.value.type === 'BooleanTypeAnnotation' &&
        rule.test(getPropName(prop)) === false
      );
    ***REMOVED***

    /**
     * Checks if prop is declared in regular way
     * @param ***REMOVED***Object***REMOVED*** prop Property object, single prop type declaration
     * @returns ***REMOVED***Boolean***REMOVED***
     */
    function regularCheck(prop) ***REMOVED***
      const propKey = getPropKey(prop);
      return (
        propKey &&
        propTypeNames.indexOf(propKey) >= 0 &&
        rule.test(getPropName(prop)) === false
      );
    ***REMOVED***

    /**
     * Checks if prop is nested
     * @param ***REMOVED***Object***REMOVED*** prop Property object, single prop type declaration
     * @returns ***REMOVED***Boolean***REMOVED***
     */
    function nestedPropTypes(prop) ***REMOVED***
      return (
        prop.type === 'Property' &&
        prop.value.type === 'CallExpression'
      );
    ***REMOVED***

    /**
     * Runs recursive check on all proptypes
     * @param ***REMOVED***Array***REMOVED*** proptypes A list of Property object (for each proptype defined)
     * @param ***REMOVED***Function***REMOVED*** addInvalidProp callback to run for each error
     */
    function runCheck(proptypes, addInvalidProp) ***REMOVED***
      proptypes = proptypes || [];

      proptypes.forEach((prop) => ***REMOVED***
        if (config.validateNested && nestedPropTypes(prop)) ***REMOVED***
          runCheck(prop.value.arguments[0].properties, addInvalidProp);
          return;
        ***REMOVED***
        if (flowCheck(prop) || regularCheck(prop)) ***REMOVED***
          addInvalidProp(prop);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    /**
     * Checks and mark props with invalid naming
     * @param ***REMOVED***Object***REMOVED*** node The component node we're testing
     * @param ***REMOVED***Array***REMOVED*** proptypes A list of Property object (for each proptype defined)
     */
    function validatePropNaming(node, proptypes) ***REMOVED***
      const component = components.get(node) || node;
      const invalidProps = component.invalidProps || [];

      runCheck(proptypes, (prop) => ***REMOVED***
        invalidProps.push(prop);
      ***REMOVED***);

      components.set(node, ***REMOVED***
        invalidProps
      ***REMOVED***);
    ***REMOVED***

    /**
     * Reports invalid prop naming
     * @param ***REMOVED***Object***REMOVED*** component The component to process
     */
    function reportInvalidNaming(component) ***REMOVED***
      component.invalidProps.forEach((propNode) => ***REMOVED***
        const propName = getPropName(propNode);
        context.report(***REMOVED***
          node: propNode,
          message: config.message || 'Prop name (***REMOVED******REMOVED*** propName ***REMOVED******REMOVED***) doesn\'t match rule (***REMOVED******REMOVED*** pattern ***REMOVED******REMOVED***)',
          data: ***REMOVED***
            component: propName,
            propName,
            pattern: config.rule
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***

    function checkPropWrapperArguments(node, args) ***REMOVED***
      if (!node || !Array.isArray(args)) ***REMOVED***
        return;
      ***REMOVED***
      args.filter(arg => arg.type === 'ObjectExpression').forEach(object => validatePropNaming(node, object.properties));
    ***REMOVED***

    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------

    return ***REMOVED***
      ClassProperty(node) ***REMOVED***
        if (!rule || !propsUtil.isPropTypesDeclaration(node)) ***REMOVED***
          return;
        ***REMOVED***
        if (
          node.value &&
          node.value.type === 'CallExpression' &&
          propWrapperUtil.isPropWrapperFunction(
            context,
            context.getSourceCode().getText(node.value.callee)
          )
        ) ***REMOVED***
          checkPropWrapperArguments(node, node.value.arguments);
        ***REMOVED***
        if (node.value && node.value.properties) ***REMOVED***
          validatePropNaming(node, node.value.properties);
        ***REMOVED***
        if (node.typeAnnotation && node.typeAnnotation.typeAnnotation) ***REMOVED***
          validatePropNaming(node, node.typeAnnotation.typeAnnotation.properties);
        ***REMOVED***
      ***REMOVED***,

      MemberExpression(node) ***REMOVED***
        if (!rule || !propsUtil.isPropTypesDeclaration(node)) ***REMOVED***
          return;
        ***REMOVED***
        const component = utils.getRelatedComponent(node);
        if (!component || !node.parent.right) ***REMOVED***
          return;
        ***REMOVED***
        const right = node.parent.right;
        if (
          right.type === 'CallExpression' &&
          propWrapperUtil.isPropWrapperFunction(
            context,
            context.getSourceCode().getText(right.callee)
          )
        ) ***REMOVED***
          checkPropWrapperArguments(component.node, right.arguments);
          return;
        ***REMOVED***
        validatePropNaming(component.node, node.parent.right.properties);
      ***REMOVED***,

      ObjectExpression(node) ***REMOVED***
        if (!rule) ***REMOVED***
          return;
        ***REMOVED***

        // Search for the proptypes declaration
        node.properties.forEach((property) => ***REMOVED***
          if (!propsUtil.isPropTypesDeclaration(property)) ***REMOVED***
            return;
          ***REMOVED***
          validatePropNaming(node, property.value.properties);
        ***REMOVED***);
      ***REMOVED***,

      TypeAlias(node) ***REMOVED***
        // Cache all ObjectType annotations, we will check them at the end
        if (node.right.type === 'ObjectTypeAnnotation') ***REMOVED***
          objectTypeAnnotations.set(node.id.name, node.right);
        ***REMOVED***
      ***REMOVED***,

      'Program:exit': function () ***REMOVED***
        if (!rule) ***REMOVED***
          return;
        ***REMOVED***

        const list = components.list();
        Object.keys(list).forEach((component) => ***REMOVED***
          // If this is a functional component that uses a global type, check it
          if (
            list[component].node.type === 'FunctionDeclaration' &&
            list[component].node.params &&
            list[component].node.params.length &&
            list[component].node.params[0].typeAnnotation
          ) ***REMOVED***
            const typeNode = list[component].node.params[0].typeAnnotation;
            const annotation = typeNode.typeAnnotation;

            let propType;
            if (annotation.type === 'GenericTypeAnnotation') ***REMOVED***
              propType = objectTypeAnnotations.get(annotation.id.name);
            ***REMOVED*** else if (annotation.type === 'ObjectTypeAnnotation') ***REMOVED***
              propType = annotation;
            ***REMOVED***
            if (propType) ***REMOVED***
              validatePropNaming(list[component].node, propType.properties);
            ***REMOVED***
          ***REMOVED***

          if (list[component].invalidProps && list[component].invalidProps.length > 0) ***REMOVED***
            reportInvalidNaming(list[component]);
          ***REMOVED***
        ***REMOVED***);

        // Reset cache
        objectTypeAnnotations.clear();
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***)
***REMOVED***;
