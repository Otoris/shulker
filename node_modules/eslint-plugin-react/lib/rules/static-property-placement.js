/**
 * @fileoverview Defines where React component static properties should be positioned.
 * @author Daniel Mason
 */

'use strict';

const fromEntries = require('object.fromentries');
const Components = require('../util/Components');
const docsUrl = require('../util/docsUrl');
const astUtil = require('../util/ast');
const propsUtil = require('../util/props');

// ------------------------------------------------------------------------------
// Positioning Options
// ------------------------------------------------------------------------------
const STATIC_PUBLIC_FIELD = 'static public field';
const STATIC_GETTER = 'static getter';
const PROPERTY_ASSIGNMENT = 'property assignment';
const POSITION_SETTINGS = [STATIC_PUBLIC_FIELD, STATIC_GETTER, PROPERTY_ASSIGNMENT];

// ------------------------------------------------------------------------------
// Rule messages
// ------------------------------------------------------------------------------
const ERROR_MESSAGES = ***REMOVED***
  [STATIC_PUBLIC_FIELD]: '\'***REMOVED******REMOVED***name***REMOVED******REMOVED***\' should be declared as a static class property.',
  [STATIC_GETTER]: '\'***REMOVED******REMOVED***name***REMOVED******REMOVED***\' should be declared as a static getter class function.',
  [PROPERTY_ASSIGNMENT]: '\'***REMOVED******REMOVED***name***REMOVED******REMOVED***\' should be declared outside the class body.'
***REMOVED***;

// ------------------------------------------------------------------------------
// Properties to check
// ------------------------------------------------------------------------------
const propertiesToCheck = ***REMOVED***
  propTypes: propsUtil.isPropTypesDeclaration,
  defaultProps: propsUtil.isDefaultPropsDeclaration,
  childContextTypes: propsUtil.isChildContextTypesDeclaration,
  contextTypes: propsUtil.isContextTypesDeclaration,
  contextType: propsUtil.isContextTypeDeclaration,
  displayName: node => propsUtil.isDisplayNameDeclaration(astUtil.getPropertyNameNode(node))
***REMOVED***;

const classProperties = Object.keys(propertiesToCheck);
const schemaProperties = fromEntries(classProperties.map(property => [property, ***REMOVED***enum: POSITION_SETTINGS***REMOVED***]));

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Defines where React component static properties should be positioned.',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('static-property-placement')
    ***REMOVED***,
    fixable: null, // or 'code' or 'whitespace'
    schema: [
      ***REMOVED***enum: POSITION_SETTINGS***REMOVED***,
      ***REMOVED***
        type: 'object',
        properties: schemaProperties,
        additionalProperties: false
      ***REMOVED***
    ]
  ***REMOVED***,

  create: Components.detect((context, components, utils) => ***REMOVED***
    // variables should be defined here
    const options = context.options;
    const defaultCheckType = options[0] || STATIC_PUBLIC_FIELD;
    const hasAdditionalConfig = options.length > 1;
    const additionalConfig = hasAdditionalConfig ? options[1] : ***REMOVED******REMOVED***;

    // Set config
    const config = fromEntries(classProperties.map(property => [
      property,
      additionalConfig[property] || defaultCheckType
    ]));

    // ----------------------------------------------------------------------
    // Helpers
    // ----------------------------------------------------------------------

    /**
      * Checks if we are declaring context in class
      * @returns ***REMOVED***Boolean***REMOVED*** True if we are declaring context in class, false if not.
     */
    function isContextInClass() ***REMOVED***
      let blockNode;
      let scope = context.getScope();
      while (scope) ***REMOVED***
        blockNode = scope.block;
        if (blockNode && blockNode.type === 'ClassDeclaration') ***REMOVED***
          return true;
        ***REMOVED***
        scope = scope.upper;
      ***REMOVED***

      return false;
    ***REMOVED***

    /**
     * Check if we should report this property node
     * @param ***REMOVED***ASTNode***REMOVED*** node
     * @param ***REMOVED***string***REMOVED*** expectedRule
     */
    function reportNodeIncorrectlyPositioned(node, expectedRule) ***REMOVED***
      // Detect if this node is an expected property declaration adn return the property name
      const name = classProperties.find((propertyName) => ***REMOVED***
        if (propertiesToCheck[propertyName](node)) ***REMOVED***
          return !!propertyName;
        ***REMOVED***

        return false;
      ***REMOVED***);

      // If name is set but the configured rule does not match expected then report error
      if (name && config[name] !== expectedRule) ***REMOVED***
        // Report the error
        context.report(***REMOVED***
          node,
          message: ERROR_MESSAGES[config[name]],
          data: ***REMOVED***name***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    // ----------------------------------------------------------------------
    // Public
    // ----------------------------------------------------------------------
    return ***REMOVED***
      ClassProperty: node => reportNodeIncorrectlyPositioned(node, STATIC_PUBLIC_FIELD),

      MemberExpression: (node) => ***REMOVED***
        // If definition type is undefined then it must not be a defining expression or if the definition is inside a
        // class body then skip this node.
        const right = node.parent.right;
        if (!right || right.type === 'undefined' || isContextInClass()) ***REMOVED***
          return;
        ***REMOVED***

        // Get the related component
        const relatedComponent = utils.getRelatedComponent(node);

        // If the related component is not an ES6 component then skip this node
        if (!relatedComponent || !utils.isES6Component(relatedComponent.node)) ***REMOVED***
          return;
        ***REMOVED***

        // Report if needed
        reportNodeIncorrectlyPositioned(node, PROPERTY_ASSIGNMENT);
      ***REMOVED***,

      MethodDefinition: (node) => ***REMOVED***
        // If the function is inside a class and is static getter then check if correctly positioned
        if (isContextInClass() && node.static && node.kind === 'get') ***REMOVED***
          // Report error if needed
          reportNodeIncorrectlyPositioned(node, STATIC_GETTER);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***)
***REMOVED***;
