/**
 * @fileoverview Forbid certain elements
 * @author Kenneth Chung
 */

'use strict';

const has = require('has');
const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Forbid certain elements',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('forbid-elements')
    ***REMOVED***,

    schema: [***REMOVED***
      type: 'object',
      properties: ***REMOVED***
        forbid: ***REMOVED***
          type: 'array',
          items: ***REMOVED***
            anyOf: [
              ***REMOVED***type: 'string'***REMOVED***,
              ***REMOVED***
                type: 'object',
                properties: ***REMOVED***
                  element: ***REMOVED***type: 'string'***REMOVED***,
                  message: ***REMOVED***type: 'string'***REMOVED***
                ***REMOVED***,
                required: ['element'],
                additionalProperties: false
              ***REMOVED***
            ]
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,
      additionalProperties: false
    ***REMOVED***]
  ***REMOVED***,

  create(context) ***REMOVED***
    const configuration = context.options[0] || ***REMOVED******REMOVED***;
    const forbidConfiguration = configuration.forbid || [];

    const indexedForbidConfigs = ***REMOVED******REMOVED***;

    forbidConfiguration.forEach((item) => ***REMOVED***
      if (typeof item === 'string') ***REMOVED***
        indexedForbidConfigs[item] = ***REMOVED***element: item***REMOVED***;
      ***REMOVED*** else ***REMOVED***
        indexedForbidConfigs[item.element] = item;
      ***REMOVED***
    ***REMOVED***);

    function errorMessageForElement(name) ***REMOVED***
      const message = `<$***REMOVED***name***REMOVED***> is forbidden`;
      const additionalMessage = indexedForbidConfigs[name].message;

      if (additionalMessage) ***REMOVED***
        return `$***REMOVED***message***REMOVED***, $***REMOVED***additionalMessage***REMOVED***`;
      ***REMOVED***

      return message;
    ***REMOVED***

    function isValidCreateElement(node) ***REMOVED***
      return node.callee &&
        node.callee.type === 'MemberExpression' &&
        node.callee.object.name === 'React' &&
        node.callee.property.name === 'createElement' &&
        node.arguments.length > 0;
    ***REMOVED***

    function reportIfForbidden(element, node) ***REMOVED***
      if (has(indexedForbidConfigs, element)) ***REMOVED***
        context.report(***REMOVED***
          node,
          message: errorMessageForElement(element)
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    return ***REMOVED***
      JSXOpeningElement(node) ***REMOVED***
        reportIfForbidden(context.getSourceCode().getText(node.name), node.name);
      ***REMOVED***,

      CallExpression(node) ***REMOVED***
        if (!isValidCreateElement(node)) ***REMOVED***
          return;
        ***REMOVED***

        const argument = node.arguments[0];
        const argType = argument.type;

        if (argType === 'Identifier' && /^[A-Z_]/.test(argument.name)) ***REMOVED***
          reportIfForbidden(argument.name, argument);
        ***REMOVED*** else if (argType === 'Literal' && /^[a-z][^.]*$/.test(argument.value)) ***REMOVED***
          reportIfForbidden(argument.value, argument);
        ***REMOVED*** else if (argType === 'MemberExpression') ***REMOVED***
          reportIfForbidden(context.getSourceCode().getText(argument), argument);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
