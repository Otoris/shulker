/**
 * @fileoverview Validates whitespace in and around the JSX opening and closing brackets
 * @author Diogo Franco (Kovensky)
 */

'use strict';

const getTokenBeforeClosingBracket = require('../util/getTokenBeforeClosingBracket');
const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Validators
// ------------------------------------------------------------------------------

function validateClosingSlash(context, node, option) ***REMOVED***
  const sourceCode = context.getSourceCode();

  const SELF_CLOSING_NEVER_MESSAGE = 'Whitespace is forbidden between `/` and `>`; write `/>`';
  const SELF_CLOSING_ALWAYS_MESSAGE = 'Whitespace is required between `/` and `>`; write `/ >`';
  const NEVER_MESSAGE = 'Whitespace is forbidden between `<` and `/`; write `</`';
  const ALWAYS_MESSAGE = 'Whitespace is required between `<` and `/`; write `< /`';

  let adjacent;

  if (node.selfClosing) ***REMOVED***
    const lastTokens = sourceCode.getLastTokens(node, 2);

    adjacent = !sourceCode.isSpaceBetweenTokens(lastTokens[0], lastTokens[1]);

    if (option === 'never') ***REMOVED***
      if (!adjacent) ***REMOVED***
        context.report(***REMOVED***
          node,
          loc: ***REMOVED***
            start: lastTokens[0].loc.start,
            end: lastTokens[1].loc.end
          ***REMOVED***,
          message: SELF_CLOSING_NEVER_MESSAGE,
          fix(fixer) ***REMOVED***
            return fixer.removeRange([lastTokens[0].range[1], lastTokens[1].range[0]]);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED*** else if (option === 'always' && adjacent) ***REMOVED***
      context.report(***REMOVED***
        node,
        loc: ***REMOVED***
          start: lastTokens[0].loc.start,
          end: lastTokens[1].loc.end
        ***REMOVED***,
        message: SELF_CLOSING_ALWAYS_MESSAGE,
        fix(fixer) ***REMOVED***
          return fixer.insertTextBefore(lastTokens[1], ' ');
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED*** else ***REMOVED***
    const firstTokens = sourceCode.getFirstTokens(node, 2);

    adjacent = !sourceCode.isSpaceBetweenTokens(firstTokens[0], firstTokens[1]);

    if (option === 'never') ***REMOVED***
      if (!adjacent) ***REMOVED***
        context.report(***REMOVED***
          node,
          loc: ***REMOVED***
            start: firstTokens[0].loc.start,
            end: firstTokens[1].loc.end
          ***REMOVED***,
          message: NEVER_MESSAGE,
          fix(fixer) ***REMOVED***
            return fixer.removeRange([firstTokens[0].range[1], firstTokens[1].range[0]]);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED*** else if (option === 'always' && adjacent) ***REMOVED***
      context.report(***REMOVED***
        node,
        loc: ***REMOVED***
          start: firstTokens[0].loc.start,
          end: firstTokens[1].loc.end
        ***REMOVED***,
        message: ALWAYS_MESSAGE,
        fix(fixer) ***REMOVED***
          return fixer.insertTextBefore(firstTokens[1], ' ');
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function validateBeforeSelfClosing(context, node, option) ***REMOVED***
  const sourceCode = context.getSourceCode();

  const NEVER_MESSAGE = 'A space is forbidden before closing bracket';
  const ALWAYS_MESSAGE = 'A space is required before closing bracket';

  const leftToken = getTokenBeforeClosingBracket(node);
  const closingSlash = sourceCode.getTokenAfter(leftToken);

  if (leftToken.loc.end.line !== closingSlash.loc.start.line) ***REMOVED***
    return;
  ***REMOVED***

  if (option === 'always' && !sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) ***REMOVED***
    context.report(***REMOVED***
      node,
      loc: closingSlash.loc.start,
      message: ALWAYS_MESSAGE,
      fix(fixer) ***REMOVED***
        return fixer.insertTextBefore(closingSlash, ' ');
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED*** else if (option === 'never' && sourceCode.isSpaceBetweenTokens(leftToken, closingSlash)) ***REMOVED***
    context.report(***REMOVED***
      node,
      loc: closingSlash.loc.start,
      message: NEVER_MESSAGE,
      fix(fixer) ***REMOVED***
        const previousToken = sourceCode.getTokenBefore(closingSlash);
        return fixer.removeRange([previousToken.range[1], closingSlash.range[0]]);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

function validateAfterOpening(context, node, option) ***REMOVED***
  const sourceCode = context.getSourceCode();

  const NEVER_MESSAGE = 'A space is forbidden after opening bracket';
  const ALWAYS_MESSAGE = 'A space is required after opening bracket';

  const openingToken = sourceCode.getTokenBefore(node.name);

  if (option === 'allow-multiline') ***REMOVED***
    if (openingToken.loc.start.line !== node.name.loc.start.line) ***REMOVED***
      return;
    ***REMOVED***
  ***REMOVED***

  const adjacent = !sourceCode.isSpaceBetweenTokens(openingToken, node.name);

  if (option === 'never' || option === 'allow-multiline') ***REMOVED***
    if (!adjacent) ***REMOVED***
      context.report(***REMOVED***
        node,
        loc: ***REMOVED***
          start: openingToken.loc.start,
          end: node.name.loc.start
        ***REMOVED***,
        message: NEVER_MESSAGE,
        fix(fixer) ***REMOVED***
          return fixer.removeRange([openingToken.range[1], node.name.range[0]]);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED*** else if (option === 'always' && adjacent) ***REMOVED***
    context.report(***REMOVED***
      node,
      loc: ***REMOVED***
        start: openingToken.loc.start,
        end: node.name.loc.start
      ***REMOVED***,
      message: ALWAYS_MESSAGE,
      fix(fixer) ***REMOVED***
        return fixer.insertTextBefore(node.name, ' ');
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

function validateBeforeClosing(context, node, option) ***REMOVED***
  // Don't enforce this rule for self closing tags
  if (!node.selfClosing) ***REMOVED***
    const sourceCode = context.getSourceCode();

    const NEVER_MESSAGE = 'A space is forbidden before closing bracket';
    const ALWAYS_MESSAGE = 'Whitespace is required before closing bracket';

    const lastTokens = sourceCode.getLastTokens(node, 2);
    const closingToken = lastTokens[1];
    const leftToken = lastTokens[0];

    if (leftToken.loc.start.line !== closingToken.loc.start.line) ***REMOVED***
      return;
    ***REMOVED***

    const adjacent = !sourceCode.isSpaceBetweenTokens(leftToken, closingToken);

    if (option === 'never' && !adjacent) ***REMOVED***
      context.report(***REMOVED***
        node,
        loc: ***REMOVED***
          start: leftToken.loc.end,
          end: closingToken.loc.start
        ***REMOVED***,
        message: NEVER_MESSAGE,
        fix(fixer) ***REMOVED***
          return fixer.removeRange([leftToken.range[1], closingToken.range[0]]);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED*** else if (option === 'always' && adjacent) ***REMOVED***
      context.report(***REMOVED***
        node,
        loc: ***REMOVED***
          start: leftToken.loc.end,
          end: closingToken.loc.start
        ***REMOVED***,
        message: ALWAYS_MESSAGE,
        fix(fixer) ***REMOVED***
          return fixer.insertTextBefore(closingToken, ' ');
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

const optionDefaults = ***REMOVED***
  closingSlash: 'never',
  beforeSelfClosing: 'always',
  afterOpening: 'never',
  beforeClosing: 'allow'
***REMOVED***;

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Validate whitespace in and around the JSX opening and closing brackets',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-tag-spacing')
    ***REMOVED***,
    fixable: 'whitespace',
    schema: [
      ***REMOVED***
        type: 'object',
        properties: ***REMOVED***
          closingSlash: ***REMOVED***
            enum: ['always', 'never', 'allow']
          ***REMOVED***,
          beforeSelfClosing: ***REMOVED***
            enum: ['always', 'never', 'allow']
          ***REMOVED***,
          afterOpening: ***REMOVED***
            enum: ['always', 'allow-multiline', 'never', 'allow']
          ***REMOVED***,
          beforeClosing: ***REMOVED***
            enum: ['always', 'never', 'allow']
          ***REMOVED***
        ***REMOVED***,
        default: optionDefaults,
        additionalProperties: false
      ***REMOVED***
    ]
  ***REMOVED***,
  create(context) ***REMOVED***
    const options = Object.assign(***REMOVED******REMOVED***, optionDefaults, context.options[0]);

    return ***REMOVED***
      JSXOpeningElement(node) ***REMOVED***
        if (options.closingSlash !== 'allow' && node.selfClosing) ***REMOVED***
          validateClosingSlash(context, node, options.closingSlash);
        ***REMOVED***
        if (options.afterOpening !== 'allow') ***REMOVED***
          validateAfterOpening(context, node, options.afterOpening);
        ***REMOVED***
        if (options.beforeSelfClosing !== 'allow' && node.selfClosing) ***REMOVED***
          validateBeforeSelfClosing(context, node, options.beforeSelfClosing);
        ***REMOVED***
        if (options.beforeClosing !== 'allow') ***REMOVED***
          validateBeforeClosing(context, node, options.beforeClosing);
        ***REMOVED***
      ***REMOVED***,
      JSXClosingElement(node) ***REMOVED***
        if (options.afterOpening !== 'allow') ***REMOVED***
          validateAfterOpening(context, node, options.afterOpening);
        ***REMOVED***
        if (options.closingSlash !== 'allow') ***REMOVED***
          validateClosingSlash(context, node, options.closingSlash);
        ***REMOVED***
        if (options.beforeClosing !== 'allow') ***REMOVED***
          validateBeforeClosing(context, node, options.beforeClosing);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
