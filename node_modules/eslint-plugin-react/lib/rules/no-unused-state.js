/**
 * @fileoverview  Attempts to discover all state fields in a React component and
 * warn if any of them are never read.
 *
 * State field definitions are collected from `this.state = ***REMOVED******REMOVED***` assignments in
 * the constructor, objects passed to `this.setState()`, and `state = ***REMOVED******REMOVED***` class
 * property assignments.
 */

'use strict';

const Components = require('../util/Components');
const docsUrl = require('../util/docsUrl');

// Descend through all wrapping TypeCastExpressions and return the expression
// that was cast.
function uncast(node) ***REMOVED***
  while (node.type === 'TypeCastExpression') ***REMOVED***
    node = node.expression;
  ***REMOVED***
  return node;
***REMOVED***

// Return the name of an identifier or the string value of a literal. Useful
// anywhere that a literal may be used as a key (e.g., member expressions,
// method definitions, ObjectExpression property keys).
function getName(node) ***REMOVED***
  node = uncast(node);
  const type = node.type;

  if (type === 'Identifier') ***REMOVED***
    return node.name;
  ***REMOVED***
  if (type === 'Literal') ***REMOVED***
    return String(node.value);
  ***REMOVED***
  if (type === 'TemplateLiteral' && node.expressions.length === 0) ***REMOVED***
    return node.quasis[0].value.raw;
  ***REMOVED***
  return null;
***REMOVED***

function isThisExpression(node) ***REMOVED***
  return uncast(node).type === 'ThisExpression';
***REMOVED***

function getInitialClassInfo() ***REMOVED***
  return ***REMOVED***
    // Set of nodes where state fields were defined.
    stateFields: new Set(),

    // Set of names of state fields that we've seen used.
    usedStateFields: new Set(),

    // Names of local variables that may be pointing to this.state. To
    // track this properly, we would need to keep track of all locals,
    // shadowing, assignments, etc. To keep things simple, we only
    // maintain one set of aliases per method and accept that it will
    // produce some false negatives.
    aliases: null
  ***REMOVED***;
***REMOVED***

function isSetStateCall(node) ***REMOVED***
  return (
    node.callee.type === 'MemberExpression' &&
    isThisExpression(node.callee.object) &&
    getName(node.callee.property) === 'setState'
  );
***REMOVED***

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Prevent definition of unused state fields',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('no-unused-state')
    ***REMOVED***,
    schema: []
  ***REMOVED***,

  create: Components.detect((context, components, utils) => ***REMOVED***
    // Non-null when we are inside a React component ClassDeclaration and we have
    // not yet encountered any use of this.state which we have chosen not to
    // analyze. If we encounter any such usage (like this.state being spread as
    // JSX attributes), then this is again set to null.
    let classInfo = null;

    function isStateParameterReference(node) ***REMOVED***
      const classMethods = [
        'shouldComponentUpdate',
        'componentWillUpdate',
        'UNSAFE_componentWillUpdate',
        'getSnapshotBeforeUpdate',
        'componentDidUpdate'
      ];

      let scope = context.getScope();
      while (scope) ***REMOVED***
        const parent = scope.block && scope.block.parent;
        if (
          parent &&
          parent.type === 'MethodDefinition' && (
            parent.static && parent.key.name === 'getDerivedStateFromProps' ||
            classMethods.indexOf(parent.key.name) !== -1
          ) &&
          parent.value.type === 'FunctionExpression' &&
          parent.value.params[1] &&
          parent.value.params[1].name === node.name
        ) ***REMOVED***
          return true;
        ***REMOVED***
        scope = scope.upper;
      ***REMOVED***

      return false;
    ***REMOVED***

    // Returns true if the given node is possibly a reference to `this.state` or the state parameter of
    // a lifecycle method.
    function isStateReference(node) ***REMOVED***
      node = uncast(node);

      const isDirectStateReference = node.type === 'MemberExpression' &&
        isThisExpression(node.object) &&
        node.property.name === 'state';

      const isAliasedStateReference = node.type === 'Identifier' &&
        classInfo.aliases &&
        classInfo.aliases.has(node.name);

      return isDirectStateReference || isAliasedStateReference || isStateParameterReference(node);
    ***REMOVED***

    // Takes an ObjectExpression node and adds all named Property nodes to the
    // current set of state fields.
    function addStateFields(node) ***REMOVED***
      for (const prop of node.properties) ***REMOVED***
        const key = prop.key;

        if (
          prop.type === 'Property' &&
          (key.type === 'Literal' ||
          (key.type === 'TemplateLiteral' && key.expressions.length === 0) ||
          (prop.computed === false && key.type === 'Identifier')) &&
          getName(prop.key) !== null
        ) ***REMOVED***
          classInfo.stateFields.add(prop);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    // Adds the name of the given node as a used state field if the node is an
    // Identifier or a Literal. Other node types are ignored.
    function addUsedStateField(node) ***REMOVED***
      const name = getName(node);
      if (name) ***REMOVED***
        classInfo.usedStateFields.add(name);
      ***REMOVED***
    ***REMOVED***

    // Records used state fields and new aliases for an ObjectPattern which
    // destructures `this.state`.
    function handleStateDestructuring(node) ***REMOVED***
      for (const prop of node.properties) ***REMOVED***
        if (prop.type === 'Property') ***REMOVED***
          addUsedStateField(prop.key);
        ***REMOVED*** else if (
          (prop.type === 'ExperimentalRestProperty' || prop.type === 'RestElement') &&
          classInfo.aliases
        ) ***REMOVED***
          classInfo.aliases.add(getName(prop.argument));
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    // Used to record used state fields and new aliases for both
    // AssignmentExpressions and VariableDeclarators.
    function handleAssignment(left, right) ***REMOVED***
      switch (left.type) ***REMOVED***
        case 'Identifier':
          if (isStateReference(right) && classInfo.aliases) ***REMOVED***
            classInfo.aliases.add(left.name);
          ***REMOVED***
          break;
        case 'ObjectPattern':
          if (isStateReference(right)) ***REMOVED***
            handleStateDestructuring(left);
          ***REMOVED*** else if (isThisExpression(right) && classInfo.aliases) ***REMOVED***
            for (const prop of left.properties) ***REMOVED***
              if (prop.type === 'Property' && getName(prop.key) === 'state') ***REMOVED***
                const name = getName(prop.value);
                if (name) ***REMOVED***
                  classInfo.aliases.add(name);
                ***REMOVED*** else if (prop.value.type === 'ObjectPattern') ***REMOVED***
                  handleStateDestructuring(prop.value);
                ***REMOVED***
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
          break;
        default:
        // pass
      ***REMOVED***
    ***REMOVED***

    function reportUnusedFields() ***REMOVED***
      // Report all unused state fields.
      for (const node of classInfo.stateFields) ***REMOVED***
        const name = getName(node.key);
        if (!classInfo.usedStateFields.has(name)) ***REMOVED***
          context.report(***REMOVED***
            node,
            message: `Unused state field: '$***REMOVED***name***REMOVED***'`
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    return ***REMOVED***
      ClassDeclaration(node) ***REMOVED***
        if (utils.isES6Component(node)) ***REMOVED***
          classInfo = getInitialClassInfo();
        ***REMOVED***
      ***REMOVED***,

      ObjectExpression(node) ***REMOVED***
        if (utils.isES5Component(node)) ***REMOVED***
          classInfo = getInitialClassInfo();
        ***REMOVED***
      ***REMOVED***,

      'ObjectExpression:exit': function (node) ***REMOVED***
        if (!classInfo) ***REMOVED***
          return;
        ***REMOVED***

        if (utils.isES5Component(node)) ***REMOVED***
          reportUnusedFields();
          classInfo = null;
        ***REMOVED***
      ***REMOVED***,

      'ClassDeclaration:exit': function () ***REMOVED***
        if (!classInfo) ***REMOVED***
          return;
        ***REMOVED***
        reportUnusedFields();
        classInfo = null;
      ***REMOVED***,

      CallExpression(node) ***REMOVED***
        if (!classInfo) ***REMOVED***
          return;
        ***REMOVED***
        // If we're looking at a `this.setState(***REMOVED******REMOVED***)` invocation, record all the
        // properties as state fields.
        if (
          isSetStateCall(node) &&
          node.arguments.length > 0 &&
          node.arguments[0].type === 'ObjectExpression'
        ) ***REMOVED***
          addStateFields(node.arguments[0]);
        ***REMOVED*** else if (
          isSetStateCall(node) &&
          node.arguments.length > 0 &&
          node.arguments[0].type === 'ArrowFunctionExpression'
        ) ***REMOVED***
          if (node.arguments[0].body.type === 'ObjectExpression') ***REMOVED***
            addStateFields(node.arguments[0].body);
          ***REMOVED***
          if (node.arguments[0].params.length > 0 && classInfo.aliases) ***REMOVED***
            const firstParam = node.arguments[0].params[0];
            if (firstParam.type === 'ObjectPattern') ***REMOVED***
              handleStateDestructuring(firstParam);
            ***REMOVED*** else ***REMOVED***
              classInfo.aliases.add(getName(firstParam));
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,

      ClassProperty(node) ***REMOVED***
        if (!classInfo) ***REMOVED***
          return;
        ***REMOVED***
        // If we see state being assigned as a class property using an object
        // expression, record all the fields of that object as state fields.
        if (
          getName(node.key) === 'state' &&
          !node.static &&
          node.value &&
          node.value.type === 'ObjectExpression'
        ) ***REMOVED***
          addStateFields(node.value);
        ***REMOVED***

        if (
          !node.static &&
          node.value &&
          node.value.type === 'ArrowFunctionExpression'
        ) ***REMOVED***
          // Create a new set for this.state aliases local to this method.
          classInfo.aliases = new Set();
        ***REMOVED***
      ***REMOVED***,

      'ClassProperty:exit': function (node) ***REMOVED***
        if (
          classInfo &&
          !node.static &&
          node.value &&
          node.value.type === 'ArrowFunctionExpression'
        ) ***REMOVED***
          // Forget our set of local aliases.
          classInfo.aliases = null;
        ***REMOVED***
      ***REMOVED***,

      MethodDefinition() ***REMOVED***
        if (!classInfo) ***REMOVED***
          return;
        ***REMOVED***
        // Create a new set for this.state aliases local to this method.
        classInfo.aliases = new Set();
      ***REMOVED***,

      'MethodDefinition:exit': function () ***REMOVED***
        if (!classInfo) ***REMOVED***
          return;
        ***REMOVED***
        // Forget our set of local aliases.
        classInfo.aliases = null;
      ***REMOVED***,

      FunctionExpression(node) ***REMOVED***
        if (!classInfo) ***REMOVED***
          return;
        ***REMOVED***

        const parent = node.parent;
        if (!utils.isES5Component(parent.parent)) ***REMOVED***
          return;
        ***REMOVED***

        if (parent.key.name === 'getInitialState') ***REMOVED***
          const body = node.body.body;
          const lastBodyNode = body[body.length - 1];

          if (
            lastBodyNode.type === 'ReturnStatement' &&
            lastBodyNode.argument.type === 'ObjectExpression'
          ) ***REMOVED***
            addStateFields(lastBodyNode.argument);
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          // Create a new set for this.state aliases local to this method.
          classInfo.aliases = new Set();
        ***REMOVED***
      ***REMOVED***,

      AssignmentExpression(node) ***REMOVED***
        if (!classInfo) ***REMOVED***
          return;
        ***REMOVED***
        // Check for assignments like `this.state = ***REMOVED******REMOVED***`
        if (
          node.left.type === 'MemberExpression' &&
          isThisExpression(node.left.object) &&
          getName(node.left.property) === 'state' &&
          node.right.type === 'ObjectExpression'
        ) ***REMOVED***
          // Find the nearest function expression containing this assignment.
          let fn = node;
          while (fn.type !== 'FunctionExpression' && fn.parent) ***REMOVED***
            fn = fn.parent;
          ***REMOVED***
          // If the nearest containing function is the constructor, then we want
          // to record all the assigned properties as state fields.
          if (
            fn.parent &&
            fn.parent.type === 'MethodDefinition' &&
            fn.parent.kind === 'constructor'
          ) ***REMOVED***
            addStateFields(node.right);
          ***REMOVED***
        ***REMOVED*** else ***REMOVED***
          // Check for assignments like `alias = this.state` and record the alias.
          handleAssignment(node.left, node.right);
        ***REMOVED***
      ***REMOVED***,

      VariableDeclarator(node) ***REMOVED***
        if (!classInfo || !node.init) ***REMOVED***
          return;
        ***REMOVED***
        handleAssignment(node.id, node.init);
      ***REMOVED***,

      MemberExpression(node) ***REMOVED***
        if (!classInfo) ***REMOVED***
          return;
        ***REMOVED***
        if (isStateReference(node.object)) ***REMOVED***
          // If we see this.state[foo] access, give up.
          if (node.computed && node.property.type !== 'Literal') ***REMOVED***
            classInfo = null;
            return;
          ***REMOVED***
          // Otherwise, record that we saw this property being accessed.
          addUsedStateField(node.property);
        // If we see a `this.state` access in a CallExpression, give up.
        ***REMOVED*** else if (isStateReference(node) && node.parent.type === 'CallExpression') ***REMOVED***
          classInfo = null;
        ***REMOVED***
      ***REMOVED***,

      JSXSpreadAttribute(node) ***REMOVED***
        if (classInfo && isStateReference(node.argument)) ***REMOVED***
          classInfo = null;
        ***REMOVED***
      ***REMOVED***,

      'ExperimentalSpreadProperty, SpreadElement': function (node) ***REMOVED***
        if (classInfo && isStateReference(node.argument)) ***REMOVED***
          classInfo = null;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***)
***REMOVED***;
