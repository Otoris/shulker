/**
 * @fileoverview Enforce propTypes declarations alphabetical sorting
 */

'use strict';

const variableUtil = require('../util/variable');
const propsUtil = require('../util/props');
const docsUrl = require('../util/docsUrl');
const propWrapperUtil = require('../util/propWrapper');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Enforce propTypes declarations alphabetical sorting',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('sort-prop-types')
    ***REMOVED***,

    fixable: 'code',

    schema: [***REMOVED***
      type: 'object',
      properties: ***REMOVED***
        requiredFirst: ***REMOVED***
          type: 'boolean'
        ***REMOVED***,
        callbacksLast: ***REMOVED***
          type: 'boolean'
        ***REMOVED***,
        ignoreCase: ***REMOVED***
          type: 'boolean'
        ***REMOVED***,
        // Whether alphabetical sorting should be enforced
        noSortAlphabetically: ***REMOVED***
          type: 'boolean'
        ***REMOVED***,
        sortShapeProp: ***REMOVED***
          type: 'boolean'
        ***REMOVED***
      ***REMOVED***,
      additionalProperties: false
    ***REMOVED***]
  ***REMOVED***,

  create(context) ***REMOVED***
    const configuration = context.options[0] || ***REMOVED******REMOVED***;
    const requiredFirst = configuration.requiredFirst || false;
    const callbacksLast = configuration.callbacksLast || false;
    const ignoreCase = configuration.ignoreCase || false;
    const noSortAlphabetically = configuration.noSortAlphabetically || false;
    const sortShapeProp = configuration.sortShapeProp || false;

    function getKey(node) ***REMOVED***
      if (node.key && node.key.value) ***REMOVED***
        return node.key.value;
      ***REMOVED***
      return context.getSourceCode().getText(node.key || node.argument);
    ***REMOVED***

    function getValueName(node) ***REMOVED***
      return node.type === 'Property' && node.value.property && node.value.property.name;
    ***REMOVED***

    function isCallbackPropName(propName) ***REMOVED***
      return /^on[A-Z]/.test(propName);
    ***REMOVED***

    function isRequiredProp(node) ***REMOVED***
      return getValueName(node) === 'isRequired';
    ***REMOVED***

    function isShapeProp(node) ***REMOVED***
      return Boolean(
        node && node.callee && node.callee.property && node.callee.property.name === 'shape'
      );
    ***REMOVED***

    function getShapeProperties(node) ***REMOVED***
      return node.arguments && node.arguments[0] && node.arguments[0].properties;
    ***REMOVED***

    function toLowerCase(item) ***REMOVED***
      return String(item).toLowerCase();
    ***REMOVED***

    function sorter(a, b) ***REMOVED***
      let aKey = getKey(a);
      let bKey = getKey(b);
      if (requiredFirst) ***REMOVED***
        if (isRequiredProp(a) && !isRequiredProp(b)) ***REMOVED***
          return -1;
        ***REMOVED***
        if (!isRequiredProp(a) && isRequiredProp(b)) ***REMOVED***
          return 1;
        ***REMOVED***
      ***REMOVED***

      if (callbacksLast) ***REMOVED***
        if (isCallbackPropName(aKey) && !isCallbackPropName(bKey)) ***REMOVED***
          return 1;
        ***REMOVED***
        if (!isCallbackPropName(aKey) && isCallbackPropName(bKey)) ***REMOVED***
          return -1;
        ***REMOVED***
      ***REMOVED***

      if (ignoreCase) ***REMOVED***
        aKey = toLowerCase(aKey);
        bKey = toLowerCase(bKey);
      ***REMOVED***

      if (aKey < bKey) ***REMOVED***
        return -1;
      ***REMOVED***
      if (aKey > bKey) ***REMOVED***
        return 1;
      ***REMOVED***
      return 0;
    ***REMOVED***


    /**
     * Checks if propTypes declarations are sorted
     * @param ***REMOVED***Array***REMOVED*** declarations The array of AST nodes being checked.
     * @returns ***REMOVED***void***REMOVED***
     */
    function checkSorted(declarations) ***REMOVED***
      // Declarations will be `undefined` if the `shape` is not a literal. For
      // example, if it is a propType imported from another file.
      if (!declarations) ***REMOVED***
        return;
      ***REMOVED***

      function fix(fixer) ***REMOVED***
        function sortInSource(allNodes, source) ***REMOVED***
          const originalSource = source;
          const nodeGroups = allNodes.reduce((acc, curr) => ***REMOVED***
            if (curr.type === 'ExperimentalSpreadProperty' || curr.type === 'SpreadElement') ***REMOVED***
              acc.push([]);
            ***REMOVED*** else ***REMOVED***
              acc[acc.length - 1].push(curr);
            ***REMOVED***
            return acc;
          ***REMOVED***, [[]]);

          nodeGroups.forEach((nodes) => ***REMOVED***
            const sortedAttributes = nodes.slice().sort(sorter);

            for (let i = nodes.length - 1; i >= 0; i--) ***REMOVED***
              const sortedAttr = sortedAttributes[i];
              const attr = nodes[i];
              let sortedAttrText = context.getSourceCode().getText(sortedAttr);
              if (sortShapeProp && isShapeProp(sortedAttr.value)) ***REMOVED***
                const shape = getShapeProperties(sortedAttr.value);
                if (shape) ***REMOVED***
                  const attrSource = sortInSource(
                    shape,
                    originalSource
                  );
                  sortedAttrText = attrSource.slice(sortedAttr.range[0], sortedAttr.range[1]);
                ***REMOVED***
              ***REMOVED***
              source = `$***REMOVED***source.slice(0, attr.range[0])***REMOVED***$***REMOVED***sortedAttrText***REMOVED***$***REMOVED***source.slice(attr.range[1])***REMOVED***`;
            ***REMOVED***
          ***REMOVED***);
          return source;
        ***REMOVED***

        const source = sortInSource(declarations, context.getSourceCode().getText());

        const rangeStart = declarations[0].range[0];
        const rangeEnd = declarations[declarations.length - 1].range[1];
        return fixer.replaceTextRange([rangeStart, rangeEnd], source.slice(rangeStart, rangeEnd));
      ***REMOVED***

      declarations.reduce((prev, curr, idx, decls) => ***REMOVED***
        if (curr.type === 'ExperimentalSpreadProperty' || curr.type === 'SpreadElement') ***REMOVED***
          return decls[idx + 1];
        ***REMOVED***

        let prevPropName = getKey(prev);
        let currentPropName = getKey(curr);
        const previousIsRequired = isRequiredProp(prev);
        const currentIsRequired = isRequiredProp(curr);
        const previousIsCallback = isCallbackPropName(prevPropName);
        const currentIsCallback = isCallbackPropName(currentPropName);

        if (ignoreCase) ***REMOVED***
          prevPropName = toLowerCase(prevPropName);
          currentPropName = toLowerCase(currentPropName);
        ***REMOVED***

        if (requiredFirst) ***REMOVED***
          if (previousIsRequired && !currentIsRequired) ***REMOVED***
            // Transition between required and non-required. Don't compare for alphabetical.
            return curr;
          ***REMOVED***
          if (!previousIsRequired && currentIsRequired) ***REMOVED***
            // Encountered a non-required prop after a required prop
            context.report(***REMOVED***
              node: curr,
              message: 'Required prop types must be listed before all other prop types',
              fix
            ***REMOVED***);
            return curr;
          ***REMOVED***
        ***REMOVED***

        if (callbacksLast) ***REMOVED***
          if (!previousIsCallback && currentIsCallback) ***REMOVED***
            // Entering the callback prop section
            return curr;
          ***REMOVED***
          if (previousIsCallback && !currentIsCallback) ***REMOVED***
            // Encountered a non-callback prop after a callback prop
            context.report(***REMOVED***
              node: prev,
              message: 'Callback prop types must be listed after all other prop types',
              fix
            ***REMOVED***);
            return prev;
          ***REMOVED***
        ***REMOVED***

        if (!noSortAlphabetically && currentPropName < prevPropName) ***REMOVED***
          context.report(***REMOVED***
            node: curr,
            message: 'Prop types declarations should be sorted alphabetically',
            fix
          ***REMOVED***);
          return prev;
        ***REMOVED***

        return curr;
      ***REMOVED***, declarations[0]);
    ***REMOVED***

    function checkNode(node) ***REMOVED***
      switch (node && node.type) ***REMOVED***
        case 'ObjectExpression':
          checkSorted(node.properties);
          break;
        case 'Identifier': ***REMOVED***
          const propTypesObject = variableUtil.findVariableByName(context, node.name);
          if (propTypesObject && propTypesObject.properties) ***REMOVED***
            checkSorted(propTypesObject.properties);
          ***REMOVED***
          break;
        ***REMOVED***
        case 'CallExpression': ***REMOVED***
          const innerNode = node.arguments && node.arguments[0];
          if (propWrapperUtil.isPropWrapperFunction(context, node.callee.name) && innerNode) ***REMOVED***
            checkNode(innerNode);
          ***REMOVED***
          break;
        ***REMOVED***
        default:
          break;
      ***REMOVED***
    ***REMOVED***

    return ***REMOVED***
      CallExpression(node) ***REMOVED***
        if (!sortShapeProp || !isShapeProp(node) || !(node.arguments && node.arguments[0])) ***REMOVED***
          return;
        ***REMOVED***

        const firstArg = node.arguments[0];
        if (firstArg.properties) ***REMOVED***
          checkSorted(firstArg.properties);
        ***REMOVED*** else if (firstArg.type === 'Identifier') ***REMOVED***
          const variable = variableUtil.findVariableByName(context, firstArg.name);
          if (variable && variable.properties) ***REMOVED***
            checkSorted(variable.properties);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,

      ClassProperty(node) ***REMOVED***
        if (!propsUtil.isPropTypesDeclaration(node)) ***REMOVED***
          return;
        ***REMOVED***
        checkNode(node.value);
      ***REMOVED***,

      MemberExpression(node) ***REMOVED***
        if (!propsUtil.isPropTypesDeclaration(node)) ***REMOVED***
          return;
        ***REMOVED***

        checkNode(node.parent.right);
      ***REMOVED***,

      ObjectExpression(node) ***REMOVED***
        node.properties.forEach((property) => ***REMOVED***
          if (!property.key) ***REMOVED***
            return;
          ***REMOVED***

          if (!propsUtil.isPropTypesDeclaration(property)) ***REMOVED***
            return;
          ***REMOVED***
          if (property.value.type === 'ObjectExpression') ***REMOVED***
            checkSorted(property.value.properties);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***

    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
