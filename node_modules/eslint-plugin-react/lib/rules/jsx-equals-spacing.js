/**
 * @fileoverview Disallow or enforce spaces around equal signs in JSX attributes.
 * @author ryym
 */

'use strict';

const docsUrl = require('../util/docsUrl');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description: 'Disallow or enforce spaces around equal signs in JSX attributes',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-equals-spacing')
    ***REMOVED***,
    fixable: 'code',

    schema: [***REMOVED***
      enum: ['always', 'never']
    ***REMOVED***]
  ***REMOVED***,

  create(context) ***REMOVED***
    const config = context.options[0];

    /**
     * Determines a given attribute node has an equal sign.
     * @param ***REMOVED***ASTNode***REMOVED*** attrNode - The attribute node.
     * @returns ***REMOVED***boolean***REMOVED*** Whether or not the attriute node has an equal sign.
     */
    function hasEqual(attrNode) ***REMOVED***
      return attrNode.type !== 'JSXSpreadAttribute' && attrNode.value !== null;
    ***REMOVED***

    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------

    return ***REMOVED***
      JSXOpeningElement(node) ***REMOVED***
        node.attributes.forEach((attrNode) => ***REMOVED***
          if (!hasEqual(attrNode)) ***REMOVED***
            return;
          ***REMOVED***

          const sourceCode = context.getSourceCode();
          const equalToken = sourceCode.getTokenAfter(attrNode.name);
          const spacedBefore = sourceCode.isSpaceBetweenTokens(attrNode.name, equalToken);
          const spacedAfter = sourceCode.isSpaceBetweenTokens(equalToken, attrNode.value);

          switch (config) ***REMOVED***
            default:
            case 'never':
              if (spacedBefore) ***REMOVED***
                context.report(***REMOVED***
                  node: attrNode,
                  loc: equalToken.loc.start,
                  message: 'There should be no space before \'=\'',
                  fix(fixer) ***REMOVED***
                    return fixer.removeRange([attrNode.name.range[1], equalToken.range[0]]);
                  ***REMOVED***
                ***REMOVED***);
              ***REMOVED***
              if (spacedAfter) ***REMOVED***
                context.report(***REMOVED***
                  node: attrNode,
                  loc: equalToken.loc.start,
                  message: 'There should be no space after \'=\'',
                  fix(fixer) ***REMOVED***
                    return fixer.removeRange([equalToken.range[1], attrNode.value.range[0]]);
                  ***REMOVED***
                ***REMOVED***);
              ***REMOVED***
              break;
            case 'always':
              if (!spacedBefore) ***REMOVED***
                context.report(***REMOVED***
                  node: attrNode,
                  loc: equalToken.loc.start,
                  message: 'A space is required before \'=\'',
                  fix(fixer) ***REMOVED***
                    return fixer.insertTextBefore(equalToken, ' ');
                  ***REMOVED***
                ***REMOVED***);
              ***REMOVED***
              if (!spacedAfter) ***REMOVED***
                context.report(***REMOVED***
                  node: attrNode,
                  loc: equalToken.loc.start,
                  message: 'A space is required after \'=\'',
                  fix(fixer) ***REMOVED***
                    return fixer.insertTextAfter(equalToken, ' ');
                  ***REMOVED***
                ***REMOVED***);
              ***REMOVED***
              break;
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
