/**
 * @fileoverview Enforce curly braces or disallow unnecessary curly brace in JSX
 * @author Jacky Ho
 * @author Simon Lydell
 */

'use strict';

const docsUrl = require('../util/docsUrl');
const jsxUtil = require('../util/jsx');

// ------------------------------------------------------------------------------
// Constants
// ------------------------------------------------------------------------------

const OPTION_ALWAYS = 'always';
const OPTION_NEVER = 'never';
const OPTION_IGNORE = 'ignore';

const OPTION_VALUES = [
  OPTION_ALWAYS,
  OPTION_NEVER,
  OPTION_IGNORE
];
const DEFAULT_CONFIG = ***REMOVED***props: OPTION_NEVER, children: OPTION_NEVER***REMOVED***;

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

module.exports = ***REMOVED***
  meta: ***REMOVED***
    docs: ***REMOVED***
      description:
        'Disallow unnecessary JSX expressions when literals alone are sufficient ' +
          'or enfore JSX expressions on literals in JSX children or attributes',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-curly-brace-presence')
    ***REMOVED***,
    fixable: 'code',

    schema: [
      ***REMOVED***
        oneOf: [
          ***REMOVED***
            type: 'object',
            properties: ***REMOVED***
              props: ***REMOVED***enum: OPTION_VALUES***REMOVED***,
              children: ***REMOVED***enum: OPTION_VALUES***REMOVED***
            ***REMOVED***,
            additionalProperties: false
          ***REMOVED***,
          ***REMOVED***
            enum: OPTION_VALUES
          ***REMOVED***
        ]
      ***REMOVED***
    ]
  ***REMOVED***,

  create(context) ***REMOVED***
    const ruleOptions = context.options[0];
    const userConfig = typeof ruleOptions === 'string' ?
      ***REMOVED***props: ruleOptions, children: ruleOptions***REMOVED*** :
      Object.assign(***REMOVED******REMOVED***, DEFAULT_CONFIG, ruleOptions);

    function containsLineTerminators(rawStringValue) ***REMOVED***
      return /[\n\r\u2028\u2029]/.test(rawStringValue);
    ***REMOVED***

    function containsBackslash(rawStringValue) ***REMOVED***
      return rawStringValue.includes('\\');
    ***REMOVED***

    function containsHTMLEntity(rawStringValue) ***REMOVED***
      return /&[A-Za-z\d#]+;/.test(rawStringValue);
    ***REMOVED***

    function containsDisallowedJSXTextChars(rawStringValue) ***REMOVED***
      return /[***REMOVED***<>***REMOVED***]/.test(rawStringValue);
    ***REMOVED***

    function containsQuoteCharacters(value) ***REMOVED***
      return /['"]/.test(value);
    ***REMOVED***

    function escapeDoubleQuotes(rawStringValue) ***REMOVED***
      return rawStringValue.replace(/\\"/g, '"').replace(/"/g, '\\"');
    ***REMOVED***

    function escapeBackslashes(rawStringValue) ***REMOVED***
      return rawStringValue.replace(/\\/g, '\\\\');
    ***REMOVED***

    function needToEscapeCharacterForJSX(raw) ***REMOVED***
      return (
        containsBackslash(raw) ||
        containsHTMLEntity(raw) ||
        containsDisallowedJSXTextChars(raw)
      );
    ***REMOVED***

    function containsWhitespaceExpression(child) ***REMOVED***
      if (child.type === 'JSXExpressionContainer') ***REMOVED***
        const value = child.expression.value;
        return value ? !(/\S/.test(value)) : false;
      ***REMOVED***
      return false;
    ***REMOVED***

    /**
     * Report and fix an unnecessary curly brace violation on a node
     * @param ***REMOVED***ASTNode***REMOVED*** JSXExpressionNode - The AST node with an unnecessary JSX expression
     */
    function reportUnnecessaryCurly(JSXExpressionNode) ***REMOVED***
      context.report(***REMOVED***
        node: JSXExpressionNode,
        message: 'Curly braces are unnecessary here.',
        fix(fixer) ***REMOVED***
          const expression = JSXExpressionNode.expression;
          const expressionType = expression.type;
          const parentType = JSXExpressionNode.parent.type;

          let textToReplace;
          if (parentType === 'JSXAttribute') ***REMOVED***
            textToReplace = `"$***REMOVED***expressionType === 'TemplateLiteral' ?
              expression.quasis[0].value.raw :
              expression.raw.substring(1, expression.raw.length - 1)
            ***REMOVED***"`;
          ***REMOVED*** else ***REMOVED***
            textToReplace = expressionType === 'TemplateLiteral' ?
              expression.quasis[0].value.cooked : expression.value;
          ***REMOVED***

          return fixer.replaceText(JSXExpressionNode, textToReplace);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    function reportMissingCurly(literalNode) ***REMOVED***
      context.report(***REMOVED***
        node: literalNode,
        message: 'Need to wrap this literal in a JSX expression.',
        fix(fixer) ***REMOVED***
          // If a HTML entity name is found, bail out because it can be fixed
          // by either using the real character or the unicode equivalent.
          // If it contains any line terminator character, bail out as well.
          if (
            containsHTMLEntity(literalNode.raw) ||
            containsLineTerminators(literalNode.raw)
          ) ***REMOVED***
            return null;
          ***REMOVED***

          const expression = literalNode.parent.type === 'JSXAttribute' ?
            `***REMOVED***"$***REMOVED***escapeDoubleQuotes(escapeBackslashes(
              literalNode.raw.substring(1, literalNode.raw.length - 1)
            ))***REMOVED***"***REMOVED***` :
            `***REMOVED***$***REMOVED***JSON.stringify(literalNode.value)***REMOVED******REMOVED***`;

          return fixer.replaceText(literalNode, expression);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    // Bail out if there is any character that needs to be escaped in JSX
    // because escaping decreases readiblity and the original code may be more
    // readible anyway or intentional for other specific reasons
    function lintUnnecessaryCurly(JSXExpressionNode) ***REMOVED***
      const expression = JSXExpressionNode.expression;
      const expressionType = expression.type;

      if (
        (expressionType === 'Literal' || expressionType === 'JSXText') &&
          typeof expression.value === 'string' &&
          !needToEscapeCharacterForJSX(expression.raw) && (
          jsxUtil.isJSX(JSXExpressionNode.parent) ||
          !containsQuoteCharacters(expression.value)
        )
      ) ***REMOVED***
        reportUnnecessaryCurly(JSXExpressionNode);
      ***REMOVED*** else if (
        expressionType === 'TemplateLiteral' &&
          expression.expressions.length === 0 &&
          expression.quasis[0].value.raw.indexOf('\n') === -1 &&
          !needToEscapeCharacterForJSX(expression.quasis[0].value.raw) && (
          jsxUtil.isJSX(JSXExpressionNode.parent) ||
          !containsQuoteCharacters(expression.quasis[0].value.cooked)
        )
      ) ***REMOVED***
        reportUnnecessaryCurly(JSXExpressionNode);
      ***REMOVED***
    ***REMOVED***

    function areRuleConditionsSatisfied(parent, config, ruleCondition) ***REMOVED***
      return (
        parent.type === 'JSXAttribute' &&
          typeof config.props === 'string' &&
          config.props === ruleCondition
      ) || (
        jsxUtil.isJSX(parent) &&
          typeof config.children === 'string' &&
          config.children === ruleCondition
      );
    ***REMOVED***

    function shouldCheckForUnnecessaryCurly(parent, config) ***REMOVED***
      // If there are more than one JSX child, there is no need to check for
      // unnecessary curly braces.
      if (jsxUtil.isJSX(parent) && parent.children.length !== 1) ***REMOVED***
        return false;
      ***REMOVED***

      if (
        parent.children &&
        parent.children.length === 1 &&
        containsWhitespaceExpression(parent.children[0])
      ) ***REMOVED***
        return false;
      ***REMOVED***

      return areRuleConditionsSatisfied(parent, config, OPTION_NEVER);
    ***REMOVED***

    function shouldCheckForMissingCurly(parent, config) ***REMOVED***
      if (
        parent.children &&
        parent.children.length === 1 &&
        containsWhitespaceExpression(parent.children[0])
      ) ***REMOVED***
        return false;
      ***REMOVED***

      return areRuleConditionsSatisfied(parent, config, OPTION_ALWAYS);
    ***REMOVED***

    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------

    return ***REMOVED***
      JSXExpressionContainer: (node) => ***REMOVED***
        if (shouldCheckForUnnecessaryCurly(node.parent, userConfig)) ***REMOVED***
          lintUnnecessaryCurly(node);
        ***REMOVED***
      ***REMOVED***,

      'Literal, JSXText': (node) => ***REMOVED***
        if (shouldCheckForMissingCurly(node.parent, userConfig)) ***REMOVED***
          reportMissingCurly(node);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
