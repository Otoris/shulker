'use strict'
exports.__esModule = true

const pkgDir = require('pkg-dir')

const fs = require('fs')
const Module = require('module')
const path = require('path')

const hashObject = require('./hash').hashObject
    , ModuleCache = require('./ModuleCache').default

const CASE_SENSITIVE_FS = !fs.existsSync(path.join(__dirname, 'reSOLVE.js'))
exports.CASE_SENSITIVE_FS = CASE_SENSITIVE_FS

const ERROR_NAME = 'EslintPluginImportResolveError'

const fileExistsCache = new ModuleCache()

// Polyfill Node's `Module.createRequireFromPath` if not present (added in Node v10.12.0)
// Use `Module.createRequire` if available (added in Node v12.2.0)
const createRequire = Module.createRequire || Module.createRequireFromPath || function (filename) ***REMOVED***
  const mod = new Module(filename, null)
  mod.filename = filename
  mod.paths = Module._nodeModulePaths(path.dirname(filename))

  mod._compile(`module.exports = require;`, filename)

  return mod.exports
***REMOVED***

function tryRequire(target, sourceFile) ***REMOVED***
  let resolved
  try ***REMOVED***
    // Check if the target exists
    if (sourceFile != null) ***REMOVED***
      try ***REMOVED***
        resolved = createRequire(path.resolve(sourceFile)).resolve(target)
      ***REMOVED*** catch (e) ***REMOVED***
        resolved = require.resolve(target)
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      resolved = require.resolve(target)
    ***REMOVED***
  ***REMOVED*** catch(e) ***REMOVED***
    // If the target does not exist then just return undefined
    return undefined
  ***REMOVED***

  // If the target exists then return the loaded module
  return require(resolved)
***REMOVED***

// http://stackoverflow.com/a/27382838
exports.fileExistsWithCaseSync = function fileExistsWithCaseSync(filepath, cacheSettings) ***REMOVED***
  // don't care if the FS is case-sensitive
  if (CASE_SENSITIVE_FS) return true

  // null means it resolved to a builtin
  if (filepath === null) return true
  if (filepath.toLowerCase() === process.cwd().toLowerCase()) return true
  const parsedPath = path.parse(filepath)
      , dir = parsedPath.dir

  let result = fileExistsCache.get(filepath, cacheSettings)
  if (result != null) return result

  // base case
  if (dir === '' || parsedPath.root === filepath) ***REMOVED***
    result = true
  ***REMOVED*** else ***REMOVED***
    const filenames = fs.readdirSync(dir)
    if (filenames.indexOf(parsedPath.base) === -1) ***REMOVED***
      result = false
    ***REMOVED*** else ***REMOVED***
      result = fileExistsWithCaseSync(dir, cacheSettings)
    ***REMOVED***
  ***REMOVED***
  fileExistsCache.set(filepath, result)
  return result
***REMOVED***

function relative(modulePath, sourceFile, settings) ***REMOVED***
  return fullResolve(modulePath, sourceFile, settings).path
***REMOVED***

function fullResolve(modulePath, sourceFile, settings) ***REMOVED***
  // check if this is a bonus core module
  const coreSet = new Set(settings['import/core-modules'])
  if (coreSet.has(modulePath)) return ***REMOVED*** found: true, path: null ***REMOVED***

  const sourceDir = path.dirname(sourceFile)
      , cacheKey = sourceDir + hashObject(settings).digest('hex') + modulePath

  const cacheSettings = ModuleCache.getSettings(settings)

  const cachedPath = fileExistsCache.get(cacheKey, cacheSettings)
  if (cachedPath !== undefined) return ***REMOVED*** found: true, path: cachedPath ***REMOVED***

  function cache(resolvedPath) ***REMOVED***
    fileExistsCache.set(cacheKey, resolvedPath)
  ***REMOVED***

  function withResolver(resolver, config) ***REMOVED***

    function v1() ***REMOVED***
      try ***REMOVED***
        const resolved = resolver.resolveImport(modulePath, sourceFile, config)
        if (resolved === undefined) return ***REMOVED*** found: false ***REMOVED***
        return ***REMOVED*** found: true, path: resolved ***REMOVED***
      ***REMOVED*** catch (err) ***REMOVED***
        return ***REMOVED*** found: false ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    function v2() ***REMOVED***
      return resolver.resolve(modulePath, sourceFile, config)
    ***REMOVED***

    switch (resolver.interfaceVersion) ***REMOVED***
      case 2:
        return v2()

      default:
      case 1:
        return v1()
    ***REMOVED***
  ***REMOVED***

  const configResolvers = (settings['import/resolver']
    || ***REMOVED*** 'node': settings['import/resolve'] ***REMOVED***) // backward compatibility

  const resolvers = resolverReducer(configResolvers, new Map())

  for (let pair of resolvers) ***REMOVED***
    let name = pair[0]
      , config = pair[1]
    const resolver = requireResolver(name, sourceFile)
        , resolved = withResolver(resolver, config)

    if (!resolved.found) continue

    // else, counts
    cache(resolved.path)
    return resolved
  ***REMOVED***

  // failed
  // cache(undefined)
  return ***REMOVED*** found: false ***REMOVED***
***REMOVED***
exports.relative = relative

function resolverReducer(resolvers, map) ***REMOVED***
  if (resolvers instanceof Array) ***REMOVED***
    resolvers.forEach(r => resolverReducer(r, map))
    return map
  ***REMOVED***

  if (typeof resolvers === 'string') ***REMOVED***
    map.set(resolvers, null)
    return map
  ***REMOVED***

  if (typeof resolvers === 'object') ***REMOVED***
    for (let key in resolvers) ***REMOVED***
      map.set(key, resolvers[key])
    ***REMOVED***
    return map
  ***REMOVED***

  const err = new Error('invalid resolver config')
  err.name = ERROR_NAME
  throw err
***REMOVED***

function getBaseDir(sourceFile) ***REMOVED***
  return pkgDir.sync(sourceFile) || process.cwd()
***REMOVED***
function requireResolver(name, sourceFile) ***REMOVED***
  // Try to resolve package with conventional name
  let resolver = tryRequire(`eslint-import-resolver-$***REMOVED***name***REMOVED***`, sourceFile) ||
    tryRequire(name, sourceFile) ||
    tryRequire(path.resolve(getBaseDir(sourceFile), name))

  if (!resolver) ***REMOVED***
    const err = new Error(`unable to load resolver "$***REMOVED***name***REMOVED***".`)
    err.name = ERROR_NAME
    throw err
  ***REMOVED***
  if (!isResolverValid(resolver)) ***REMOVED***
    const err = new Error(`$***REMOVED***name***REMOVED*** with invalid interface loaded as resolver`)
    err.name = ERROR_NAME
    throw err
  ***REMOVED***

  return resolver
***REMOVED***

function isResolverValid(resolver) ***REMOVED***
  if (resolver.interfaceVersion === 2) ***REMOVED***
    return resolver.resolve && typeof resolver.resolve === 'function'
  ***REMOVED*** else ***REMOVED***
    return resolver.resolveImport && typeof resolver.resolveImport === 'function'
  ***REMOVED***
***REMOVED***

const erroredContexts = new Set()

/**
 * Given
 * @param  ***REMOVED***string***REMOVED*** p - module path
 * @param  ***REMOVED***object***REMOVED*** context - ESLint context
 * @return ***REMOVED***string***REMOVED*** - the full module filesystem path;
 *                    null if package is core;
 *                    undefined if not found
 */
function resolve(p, context) ***REMOVED***
  try ***REMOVED***
    return relative( p
                   , context.getFilename()
                   , context.settings
                   )
  ***REMOVED*** catch (err) ***REMOVED***
    if (!erroredContexts.has(context)) ***REMOVED***
      // The `err.stack` string starts with `err.name` followed by colon and `err.message`.
      // We're filtering out the default `err.name` because it adds little value to the message.
      let errMessage = err.message
      if (err.name !== ERROR_NAME && err.stack) ***REMOVED***
        errMessage = err.stack.replace(/^Error: /, '')
      ***REMOVED***
      context.report(***REMOVED***
        message: `Resolve error: $***REMOVED***errMessage***REMOVED***`,
        loc: ***REMOVED*** line: 1, column: 0 ***REMOVED***,
      ***REMOVED***)
      erroredContexts.add(context)
    ***REMOVED***
  ***REMOVED***
***REMOVED***
resolve.relative = relative
exports.default = resolve
