'use strict';

const XHTMLEntities = require('./xhtml');

const hexNumber = /^[\da-fA-F]+$/;
const decimalNumber = /^\d+$/;

// The map to `acorn-jsx` tokens from `acorn` namespace objects.
const acornJsxMap = new WeakMap();

// Get the original tokens for the given `acorn` namespace object.
function getJsxTokens(acorn) ***REMOVED***
  acorn = acorn.Parser.acorn || acorn;
  let acornJsx = acornJsxMap.get(acorn);
  if (!acornJsx) ***REMOVED***
    const tt = acorn.tokTypes;
    const TokContext = acorn.TokContext;
    const TokenType = acorn.TokenType;
    const tc_oTag = new TokContext('<tag', false);
    const tc_cTag = new TokContext('</tag', false);
    const tc_expr = new TokContext('<tag>...</tag>', true, true);
    const tokContexts = ***REMOVED***
      tc_oTag: tc_oTag,
      tc_cTag: tc_cTag,
      tc_expr: tc_expr
    ***REMOVED***;
    const tokTypes = ***REMOVED***
      jsxName: new TokenType('jsxName'),
      jsxText: new TokenType('jsxText', ***REMOVED***beforeExpr: true***REMOVED***),
      jsxTagStart: new TokenType('jsxTagStart'),
      jsxTagEnd: new TokenType('jsxTagEnd')
    ***REMOVED***;

    tokTypes.jsxTagStart.updateContext = function() ***REMOVED***
      this.context.push(tc_expr); // treat as beginning of JSX expression
      this.context.push(tc_oTag); // start opening tag context
      this.exprAllowed = false;
    ***REMOVED***;
    tokTypes.jsxTagEnd.updateContext = function(prevType) ***REMOVED***
      let out = this.context.pop();
      if (out === tc_oTag && prevType === tt.slash || out === tc_cTag) ***REMOVED***
        this.context.pop();
        this.exprAllowed = this.curContext() === tc_expr;
      ***REMOVED*** else ***REMOVED***
        this.exprAllowed = true;
      ***REMOVED***
    ***REMOVED***;

    acornJsx = ***REMOVED*** tokContexts: tokContexts, tokTypes: tokTypes ***REMOVED***;
    acornJsxMap.set(acorn, acornJsx);
  ***REMOVED***

  return acornJsx;
***REMOVED***

// Transforms JSX element name to string.

function getQualifiedJSXName(object) ***REMOVED***
  if (!object)
    return object;

  if (object.type === 'JSXIdentifier')
    return object.name;

  if (object.type === 'JSXNamespacedName')
    return object.namespace.name + ':' + object.name.name;

  if (object.type === 'JSXMemberExpression')
    return getQualifiedJSXName(object.object) + '.' +
    getQualifiedJSXName(object.property);
***REMOVED***

module.exports = function(options) ***REMOVED***
  options = options || ***REMOVED******REMOVED***;
  return function(Parser) ***REMOVED***
    return plugin(***REMOVED***
      allowNamespaces: options.allowNamespaces !== false,
      allowNamespacedObjects: !!options.allowNamespacedObjects
    ***REMOVED***, Parser);
  ***REMOVED***;
***REMOVED***;

// This is `tokTypes` of the peer dep.
// This can be different instances from the actual `tokTypes` this plugin uses.
Object.defineProperty(module.exports, "tokTypes", ***REMOVED***
  get: function get_tokTypes() ***REMOVED***
    return getJsxTokens(require("acorn")).tokTypes;
  ***REMOVED***,
  configurable: true,
  enumerable: true
***REMOVED***);

function plugin(options, Parser) ***REMOVED***
  const acorn = Parser.acorn || require("acorn");
  const acornJsx = getJsxTokens(acorn);
  const tt = acorn.tokTypes;
  const tok = acornJsx.tokTypes;
  const tokContexts = acorn.tokContexts;
  const tc_oTag = acornJsx.tokContexts.tc_oTag;
  const tc_cTag = acornJsx.tokContexts.tc_cTag;
  const tc_expr = acornJsx.tokContexts.tc_expr;
  const isNewLine = acorn.isNewLine;
  const isIdentifierStart = acorn.isIdentifierStart;
  const isIdentifierChar = acorn.isIdentifierChar;

  return class extends Parser ***REMOVED***
    // Expose actual `tokTypes` and `tokContexts` to other plugins.
    static get acornJsx() ***REMOVED***
      return acornJsx;
    ***REMOVED***

    // Reads inline JSX contents token.
    jsx_readToken() ***REMOVED***
      let out = '', chunkStart = this.pos;
      for (;;) ***REMOVED***
        if (this.pos >= this.input.length)
          this.raise(this.start, 'Unterminated JSX contents');
        let ch = this.input.charCodeAt(this.pos);

        switch (ch) ***REMOVED***
        case 60: // '<'
        case 123: // '***REMOVED***'
          if (this.pos === this.start) ***REMOVED***
            if (ch === 60 && this.exprAllowed) ***REMOVED***
              ++this.pos;
              return this.finishToken(tok.jsxTagStart);
            ***REMOVED***
            return this.getTokenFromCode(ch);
          ***REMOVED***
          out += this.input.slice(chunkStart, this.pos);
          return this.finishToken(tok.jsxText, out);

        case 38: // '&'
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readEntity();
          chunkStart = this.pos;
          break;

        default:
          if (isNewLine(ch)) ***REMOVED***
            out += this.input.slice(chunkStart, this.pos);
            out += this.jsx_readNewLine(true);
            chunkStart = this.pos;
          ***REMOVED*** else ***REMOVED***
            ++this.pos;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    jsx_readNewLine(normalizeCRLF) ***REMOVED***
      let ch = this.input.charCodeAt(this.pos);
      let out;
      ++this.pos;
      if (ch === 13 && this.input.charCodeAt(this.pos) === 10) ***REMOVED***
        ++this.pos;
        out = normalizeCRLF ? '\n' : '\r\n';
      ***REMOVED*** else ***REMOVED***
        out = String.fromCharCode(ch);
      ***REMOVED***
      if (this.options.locations) ***REMOVED***
        ++this.curLine;
        this.lineStart = this.pos;
      ***REMOVED***

      return out;
    ***REMOVED***

    jsx_readString(quote) ***REMOVED***
      let out = '', chunkStart = ++this.pos;
      for (;;) ***REMOVED***
        if (this.pos >= this.input.length)
          this.raise(this.start, 'Unterminated string constant');
        let ch = this.input.charCodeAt(this.pos);
        if (ch === quote) break;
        if (ch === 38) ***REMOVED*** // '&'
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readEntity();
          chunkStart = this.pos;
        ***REMOVED*** else if (isNewLine(ch)) ***REMOVED***
          out += this.input.slice(chunkStart, this.pos);
          out += this.jsx_readNewLine(false);
          chunkStart = this.pos;
        ***REMOVED*** else ***REMOVED***
          ++this.pos;
        ***REMOVED***
      ***REMOVED***
      out += this.input.slice(chunkStart, this.pos++);
      return this.finishToken(tt.string, out);
    ***REMOVED***

    jsx_readEntity() ***REMOVED***
      let str = '', count = 0, entity;
      let ch = this.input[this.pos];
      if (ch !== '&')
        this.raise(this.pos, 'Entity must start with an ampersand');
      let startPos = ++this.pos;
      while (this.pos < this.input.length && count++ < 10) ***REMOVED***
        ch = this.input[this.pos++];
        if (ch === ';') ***REMOVED***
          if (str[0] === '#') ***REMOVED***
            if (str[1] === 'x') ***REMOVED***
              str = str.substr(2);
              if (hexNumber.test(str))
                entity = String.fromCharCode(parseInt(str, 16));
            ***REMOVED*** else ***REMOVED***
              str = str.substr(1);
              if (decimalNumber.test(str))
                entity = String.fromCharCode(parseInt(str, 10));
            ***REMOVED***
          ***REMOVED*** else ***REMOVED***
            entity = XHTMLEntities[str];
          ***REMOVED***
          break;
        ***REMOVED***
        str += ch;
      ***REMOVED***
      if (!entity) ***REMOVED***
        this.pos = startPos;
        return '&';
      ***REMOVED***
      return entity;
    ***REMOVED***

    // Read a JSX identifier (valid tag or attribute name).
    //
    // Optimized version since JSX identifiers can't contain
    // escape characters and so can be read as single slice.
    // Also assumes that first character was already checked
    // by isIdentifierStart in readToken.

    jsx_readWord() ***REMOVED***
      let ch, start = this.pos;
      do ***REMOVED***
        ch = this.input.charCodeAt(++this.pos);
      ***REMOVED*** while (isIdentifierChar(ch) || ch === 45); // '-'
      return this.finishToken(tok.jsxName, this.input.slice(start, this.pos));
    ***REMOVED***

    // Parse next token as JSX identifier

    jsx_parseIdentifier() ***REMOVED***
      let node = this.startNode();
      if (this.type === tok.jsxName)
        node.name = this.value;
      else if (this.type.keyword)
        node.name = this.type.keyword;
      else
        this.unexpected();
      this.next();
      return this.finishNode(node, 'JSXIdentifier');
    ***REMOVED***

    // Parse namespaced identifier.

    jsx_parseNamespacedName() ***REMOVED***
      let startPos = this.start, startLoc = this.startLoc;
      let name = this.jsx_parseIdentifier();
      if (!options.allowNamespaces || !this.eat(tt.colon)) return name;
      var node = this.startNodeAt(startPos, startLoc);
      node.namespace = name;
      node.name = this.jsx_parseIdentifier();
      return this.finishNode(node, 'JSXNamespacedName');
    ***REMOVED***

    // Parses element name in any form - namespaced, member
    // or single identifier.

    jsx_parseElementName() ***REMOVED***
      if (this.type === tok.jsxTagEnd) return '';
      let startPos = this.start, startLoc = this.startLoc;
      let node = this.jsx_parseNamespacedName();
      if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !options.allowNamespacedObjects) ***REMOVED***
        this.unexpected();
      ***REMOVED***
      while (this.eat(tt.dot)) ***REMOVED***
        let newNode = this.startNodeAt(startPos, startLoc);
        newNode.object = node;
        newNode.property = this.jsx_parseIdentifier();
        node = this.finishNode(newNode, 'JSXMemberExpression');
      ***REMOVED***
      return node;
    ***REMOVED***

    // Parses any type of JSX attribute value.

    jsx_parseAttributeValue() ***REMOVED***
      switch (this.type) ***REMOVED***
      case tt.braceL:
        let node = this.jsx_parseExpressionContainer();
        if (node.expression.type === 'JSXEmptyExpression')
          this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');
        return node;

      case tok.jsxTagStart:
      case tt.string:
        return this.parseExprAtom();

      default:
        this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');
      ***REMOVED***
    ***REMOVED***

    // JSXEmptyExpression is unique type since it doesn't actually parse anything,
    // and so it should start at the end of last read token (left brace) and finish
    // at the beginning of the next one (right brace).

    jsx_parseEmptyExpression() ***REMOVED***
      let node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
      return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);
    ***REMOVED***

    // Parses JSX expression enclosed into curly brackets.

    jsx_parseExpressionContainer() ***REMOVED***
      let node = this.startNode();
      this.next();
      node.expression = this.type === tt.braceR
        ? this.jsx_parseEmptyExpression()
        : this.parseExpression();
      this.expect(tt.braceR);
      return this.finishNode(node, 'JSXExpressionContainer');
    ***REMOVED***

    // Parses following JSX attribute name-value pair.

    jsx_parseAttribute() ***REMOVED***
      let node = this.startNode();
      if (this.eat(tt.braceL)) ***REMOVED***
        this.expect(tt.ellipsis);
        node.argument = this.parseMaybeAssign();
        this.expect(tt.braceR);
        return this.finishNode(node, 'JSXSpreadAttribute');
      ***REMOVED***
      node.name = this.jsx_parseNamespacedName();
      node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
      return this.finishNode(node, 'JSXAttribute');
    ***REMOVED***

    // Parses JSX opening tag starting after '<'.

    jsx_parseOpeningElementAt(startPos, startLoc) ***REMOVED***
      let node = this.startNodeAt(startPos, startLoc);
      node.attributes = [];
      let nodeName = this.jsx_parseElementName();
      if (nodeName) node.name = nodeName;
      while (this.type !== tt.slash && this.type !== tok.jsxTagEnd)
        node.attributes.push(this.jsx_parseAttribute());
      node.selfClosing = this.eat(tt.slash);
      this.expect(tok.jsxTagEnd);
      return this.finishNode(node, nodeName ? 'JSXOpeningElement' : 'JSXOpeningFragment');
    ***REMOVED***

    // Parses JSX closing tag starting after '</'.

    jsx_parseClosingElementAt(startPos, startLoc) ***REMOVED***
      let node = this.startNodeAt(startPos, startLoc);
      let nodeName = this.jsx_parseElementName();
      if (nodeName) node.name = nodeName;
      this.expect(tok.jsxTagEnd);
      return this.finishNode(node, nodeName ? 'JSXClosingElement' : 'JSXClosingFragment');
    ***REMOVED***

    // Parses entire JSX element, including it's opening tag
    // (starting after '<'), attributes, contents and closing tag.

    jsx_parseElementAt(startPos, startLoc) ***REMOVED***
      let node = this.startNodeAt(startPos, startLoc);
      let children = [];
      let openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
      let closingElement = null;

      if (!openingElement.selfClosing) ***REMOVED***
        contents: for (;;) ***REMOVED***
          switch (this.type) ***REMOVED***
          case tok.jsxTagStart:
            startPos = this.start; startLoc = this.startLoc;
            this.next();
            if (this.eat(tt.slash)) ***REMOVED***
              closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
              break contents;
            ***REMOVED***
            children.push(this.jsx_parseElementAt(startPos, startLoc));
            break;

          case tok.jsxText:
            children.push(this.parseExprAtom());
            break;

          case tt.braceL:
            children.push(this.jsx_parseExpressionContainer());
            break;

          default:
            this.unexpected();
          ***REMOVED***
        ***REMOVED***
        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) ***REMOVED***
          this.raise(
            closingElement.start,
            'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');
        ***REMOVED***
      ***REMOVED***
      let fragmentOrElement = openingElement.name ? 'Element' : 'Fragment';

      node['opening' + fragmentOrElement] = openingElement;
      node['closing' + fragmentOrElement] = closingElement;
      node.children = children;
      if (this.type === tt.relational && this.value === "<") ***REMOVED***
        this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
      ***REMOVED***
      return this.finishNode(node, 'JSX' + fragmentOrElement);
    ***REMOVED***

    // Parse JSX text

    jsx_parseText(value) ***REMOVED***
      let node = this.parseLiteral(value);
      node.type = "JSXText";
      return node;
    ***REMOVED***

    // Parses entire JSX element from current position.

    jsx_parseElement() ***REMOVED***
      let startPos = this.start, startLoc = this.startLoc;
      this.next();
      return this.jsx_parseElementAt(startPos, startLoc);
    ***REMOVED***

    parseExprAtom(refShortHandDefaultPos) ***REMOVED***
      if (this.type === tok.jsxText)
        return this.jsx_parseText(this.value);
      else if (this.type === tok.jsxTagStart)
        return this.jsx_parseElement();
      else
        return super.parseExprAtom(refShortHandDefaultPos);
    ***REMOVED***

    readToken(code) ***REMOVED***
      let context = this.curContext();

      if (context === tc_expr) return this.jsx_readToken();

      if (context === tc_oTag || context === tc_cTag) ***REMOVED***
        if (isIdentifierStart(code)) return this.jsx_readWord();

        if (code == 62) ***REMOVED***
          ++this.pos;
          return this.finishToken(tok.jsxTagEnd);
        ***REMOVED***

        if ((code === 34 || code === 39) && context == tc_oTag)
          return this.jsx_readString(code);
      ***REMOVED***

      if (code === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33) ***REMOVED***
        ++this.pos;
        return this.finishToken(tok.jsxTagStart);
      ***REMOVED***
      return super.readToken(code);
    ***REMOVED***

    updateContext(prevType) ***REMOVED***
      if (this.type == tt.braceL) ***REMOVED***
        var curContext = this.curContext();
        if (curContext == tc_oTag) this.context.push(tokContexts.b_expr);
        else if (curContext == tc_expr) this.context.push(tokContexts.b_tmpl);
        else super.updateContext(prevType);
        this.exprAllowed = true;
      ***REMOVED*** else if (this.type === tt.slash && prevType === tok.jsxTagStart) ***REMOVED***
        this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
        this.context.push(tc_cTag); // reconsider as closing tag context
        this.exprAllowed = false;
      ***REMOVED*** else ***REMOVED***
        return super.updateContext(prevType);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;
***REMOVED***
