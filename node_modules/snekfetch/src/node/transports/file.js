const fs = require('fs');
const path = require('path');
const mime = require('../mime');
const EventEmitter = require('events');
const ResponseStream = require('./ResponseStream');

const methods = ***REMOVED***
  GET: (filename, req) => ***REMOVED***
    req.end = () => ***REMOVED***
      const stream = should404(filename) ?
        new ResponseStream().error(404, `ENOENT: no such file or directory, open '$***REMOVED***filename***REMOVED***'`) :
        fs.createReadStream(filename);
      req.res = stream;
      stream.headers = ***REMOVED***
        'content-length': 0,
        'content-type': mime.lookup(path.extname(filename)),
      ***REMOVED***;
      stream.on('open', () => ***REMOVED***
        req.emit('response', stream);
      ***REMOVED***);
      if (stream instanceof ResponseStream)
        return;
      stream.statusCode = 200;
      stream.on('end', () => ***REMOVED***
        stream.headers['content-length'] = stream.bytesRead;
      ***REMOVED***);
      /* istanbul ignore next */
      stream.on('error', (err) => ***REMOVED***
        stream.statusCode = 400;
        stream.status = err.message;
      ***REMOVED***);
    ***REMOVED***;
  ***REMOVED***,
  POST: (filename, req) => ***REMOVED***
    const chunks = [];
    /* istanbul ignore next */
    req.write = (data) => ***REMOVED***
      chunks.push(data);
    ***REMOVED***;
    req.end = (data) => ***REMOVED***
      chunks.push(data);
      const stream = fs.createWriteStream(filename);
      const standin = new ResponseStream();
      req.res = standin;
      standin.headers = ***REMOVED***
        'content-length': 0,
        'content-type': mime.lookup(path.extname(filename)),
      ***REMOVED***;
      stream.on('finish', () => ***REMOVED***
        req.emit('response', standin);
      ***REMOVED***);
      stream.on('open', () => ***REMOVED***
        (function write() ***REMOVED***
          const chunk = chunks.shift();
          if (!chunk)
            return;
          /* istanbul ignore next */
          if (!stream.write(chunk))
            stream.once('drain', write);
          else
            write();
        ***REMOVED***());
        stream.end();
      ***REMOVED***);
    ***REMOVED***;
  ***REMOVED***,
  DELETE: (filename, req) => ***REMOVED***
    req.end = () => ***REMOVED***
      const stream = new ResponseStream();
      req.res = stream;
      stream.headers = ***REMOVED***
        'content-length': 0,
        'content-type': mime.lookup(path.extname(filename)),
      ***REMOVED***;
      fs.unlink(filename, (err) => ***REMOVED***
        req.emit('response', err ? stream.error(400, err.message) : stream);
      ***REMOVED***);
    ***REMOVED***;
  ***REMOVED***,
***REMOVED***;

class Req extends EventEmitter ***REMOVED***
  constructor() ***REMOVED***
    super();
    this._headers = ***REMOVED******REMOVED***;
  ***REMOVED***

  setHeader() ***REMOVED******REMOVED*** // eslint-disable-line no-empty-function
  getHeader() ***REMOVED******REMOVED*** // eslint-disable-line no-empty-function
***REMOVED***

function request(options) ***REMOVED***
  const method = methods[options.method];
  if (!method)
    throw new Error(`Invalid request method for file: "$***REMOVED***options.method***REMOVED***"`);
  const filename = options.href.replace('file://', '');

  const req = new Req();
  method(filename, req, options);
  return req;
***REMOVED***

function should404(p) ***REMOVED***
  try ***REMOVED***
    return fs.lstatSync(p).isDirectory();
  ***REMOVED*** catch (err) ***REMOVED***
    return true;
  ***REMOVED***
***REMOVED***

module.exports = ***REMOVED***
  request,
***REMOVED***;
