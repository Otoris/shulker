const zlib = require('zlib');
const http = require('http');
const https = require('https');
const URL = require('url');
const Stream = require('stream');
const FormData = require('./FormData');

const Package = require('../../package.json');

const transports = ***REMOVED***
  'http:': http,
  'https:': https,
  'file:': require('./transports/file'),
***REMOVED***;

function buildRequest(method, url) ***REMOVED***
  /* istanbul ignore next */
  this._read = () => ***REMOVED***
    this.resume();
    if (this._response)
      return;
    this.catch((err) => this.emit('error', err));
  ***REMOVED***;

  this.options.lastBuiltUrl = url;

  const options = URL.parse(url);
  options.encoding = 'utf8';

  if (!options.protocol)
    throw new Error('URL must have a valid protocol');

  const transport = transports[options.protocol];
  options.method = method.toUpperCase();

  if (this.options.headers)
    options.headers = this.options.headers;

  if (this.options.agent)
    options.agent = this.options.agent;
  else if (transport.Agent && this.options.followRedirects !== false)
    options.agent = new transport.Agent(***REMOVED*** keepAlive: true ***REMOVED***);

  if (options.port)
    options.port = parseInt(options.port);

  this.options._req = options;
  const request = transport.request(options);
  if (request.setNoDelay)
    request.setNoDelay(true);
  return request;
***REMOVED***

function finalizeRequest() ***REMOVED***
  return new Promise((resolve, reject) => ***REMOVED***
    const request = this.request;

    let socket;

    const handleError = (err) => ***REMOVED***
      if (!err)
        err = new Error('Unknown error occured');
      err.request = request;
      reject(err);
      if (socket)
        socket.removeListener('error', handleError);
    ***REMOVED***;

    request.once('abort', handleError);
    request.once('error', handleError);
    request.once('socket', (s) => ***REMOVED***
      socket = s;
      s.once('error', handleError);
    ***REMOVED***);

    request.once('response', (response) => ***REMOVED***
      if (socket)
        socket.removeListener('error', handleError);
      let stream = response;
      if (shouldUnzip(response)) ***REMOVED***
        stream = response.pipe(zlib.createUnzip(***REMOVED***
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH,
        ***REMOVED***));
      ***REMOVED***

      if (this.options.followRedirects !== false && [301, 302, 303, 307, 308].includes(response.statusCode)) ***REMOVED***
        resolve(***REMOVED***
          response,
          redirect: URL.resolve(this.options.lastBuiltUrl, response.headers.location),
        ***REMOVED***);
        response.destroy();
      ***REMOVED*** else ***REMOVED***
        const body = [];

        stream.on('data', (chunk) => ***REMOVED***
          if (!this.push(chunk))
            this.pause();
          body.push(chunk);
        ***REMOVED***);

        stream.once('end', () => ***REMOVED***
          this.push(null);
          const raw = Buffer.concat(body);
          resolve(***REMOVED*** response, raw, redirect: false ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***);

    if (!this.request.getHeader('user-agent'))
      this.set('User-Agent', `snekfetch/$***REMOVED***Package.version***REMOVED*** ($***REMOVED***Package.homepage***REMOVED***)`);

    this._finalizeRequest();
    let data = this.data;
    if (data && data.end)
      data = data.end();
    if (Array.isArray(data)) ***REMOVED***
      for (const chunk of data)
        request.write(chunk);
      request.end();
    ***REMOVED*** else if (data instanceof Stream) ***REMOVED***
      data.pipe(request);
    ***REMOVED*** else if (data instanceof Buffer) ***REMOVED***
      request.end(data);
    ***REMOVED*** else if (data) ***REMOVED***
      request.end(data);
    ***REMOVED*** else ***REMOVED***
      request.end();
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

function shouldSendRaw(data) ***REMOVED***
  return data instanceof Buffer || data instanceof Stream;
***REMOVED***

function shouldUnzip(res) ***REMOVED***
  if (res.statusCode === 204 || res.statusCode === 304)
    return false;
  if (res.headers['content-length'] === '0')
    return false;
  return /^\s*(?:deflate|gzip)\s*$/.test(res.headers['content-encoding']);
***REMOVED***

module.exports = ***REMOVED***
  buildRequest, finalizeRequest, shouldSendRaw,
  METHODS: http.METHODS,
  STATUS_CODES: http.STATUS_CODES,
  FormData,
  Extension: Stream.Readable,
***REMOVED***;
