// Generated by LiveScript 1.4.0
(function()***REMOVED***
  var identifierRegex, tokenRegex;
  identifierRegex = /[\$\w]+/;
  function peek(tokens)***REMOVED***
    var token;
    token = tokens[0];
    if (token == null) ***REMOVED***
      throw new Error('Unexpected end of input.');
    ***REMOVED***
    return token;
  ***REMOVED***
  function consumeIdent(tokens)***REMOVED***
    var token;
    token = peek(tokens);
    if (!identifierRegex.test(token)) ***REMOVED***
      throw new Error("Expected text, got '" + token + "' instead.");
    ***REMOVED***
    return tokens.shift();
  ***REMOVED***
  function consumeOp(tokens, op)***REMOVED***
    var token;
    token = peek(tokens);
    if (token !== op) ***REMOVED***
      throw new Error("Expected '" + op + "', got '" + token + "' instead.");
    ***REMOVED***
    return tokens.shift();
  ***REMOVED***
  function maybeConsumeOp(tokens, op)***REMOVED***
    var token;
    token = tokens[0];
    if (token === op) ***REMOVED***
      return tokens.shift();
    ***REMOVED*** else ***REMOVED***
      return null;
    ***REMOVED***
  ***REMOVED***
  function consumeArray(tokens)***REMOVED***
    var types;
    consumeOp(tokens, '[');
    if (peek(tokens) === ']') ***REMOVED***
      throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
    ***REMOVED***
    types = consumeTypes(tokens);
    consumeOp(tokens, ']');
    return ***REMOVED***
      structure: 'array',
      of: types
    ***REMOVED***;
  ***REMOVED***
  function consumeTuple(tokens)***REMOVED***
    var components;
    components = [];
    consumeOp(tokens, '(');
    if (peek(tokens) === ')') ***REMOVED***
      throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
    ***REMOVED***
    for (;;) ***REMOVED***
      components.push(consumeTypes(tokens));
      maybeConsumeOp(tokens, ',');
      if (')' === peek(tokens)) ***REMOVED***
        break;
      ***REMOVED***
    ***REMOVED***
    consumeOp(tokens, ')');
    return ***REMOVED***
      structure: 'tuple',
      of: components
    ***REMOVED***;
  ***REMOVED***
  function consumeFields(tokens)***REMOVED***
    var fields, subset, ref$, key, types;
    fields = ***REMOVED******REMOVED***;
    consumeOp(tokens, '***REMOVED***');
    subset = false;
    for (;;) ***REMOVED***
      if (maybeConsumeOp(tokens, '...')) ***REMOVED***
        subset = true;
        break;
      ***REMOVED***
      ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];
      fields[key] = types;
      maybeConsumeOp(tokens, ',');
      if ('***REMOVED***' === peek(tokens)) ***REMOVED***
        break;
      ***REMOVED***
    ***REMOVED***
    consumeOp(tokens, '***REMOVED***');
    return ***REMOVED***
      structure: 'fields',
      of: fields,
      subset: subset
    ***REMOVED***;
  ***REMOVED***
  function consumeField(tokens)***REMOVED***
    var key, types;
    key = consumeIdent(tokens);
    consumeOp(tokens, ':');
    types = consumeTypes(tokens);
    return [key, types];
  ***REMOVED***
  function maybeConsumeStructure(tokens)***REMOVED***
    switch (tokens[0]) ***REMOVED***
    case '[':
      return consumeArray(tokens);
    case '(':
      return consumeTuple(tokens);
    case '***REMOVED***':
      return consumeFields(tokens);
    ***REMOVED***
  ***REMOVED***
  function consumeType(tokens)***REMOVED***
    var token, wildcard, type, structure;
    token = peek(tokens);
    wildcard = token === '*';
    if (wildcard || identifierRegex.test(token)) ***REMOVED***
      type = wildcard
        ? consumeOp(tokens, '*')
        : consumeIdent(tokens);
      structure = maybeConsumeStructure(tokens);
      if (structure) ***REMOVED***
        return structure.type = type, structure;
      ***REMOVED*** else ***REMOVED***
        return ***REMOVED***
          type: type
        ***REMOVED***;
      ***REMOVED***
    ***REMOVED*** else ***REMOVED***
      structure = maybeConsumeStructure(tokens);
      if (!structure) ***REMOVED***
        throw new Error("Unexpected character: " + token);
      ***REMOVED***
      return structure;
    ***REMOVED***
  ***REMOVED***
  function consumeTypes(tokens)***REMOVED***
    var lookahead, types, typesSoFar, typeObj, type;
    if ('::' === peek(tokens)) ***REMOVED***
      throw new Error("No comment before comment separator '::' found.");
    ***REMOVED***
    lookahead = tokens[1];
    if (lookahead != null && lookahead === '::') ***REMOVED***
      tokens.shift();
      tokens.shift();
    ***REMOVED***
    types = [];
    typesSoFar = ***REMOVED******REMOVED***;
    if ('Maybe' === peek(tokens)) ***REMOVED***
      tokens.shift();
      types = [
        ***REMOVED***
          type: 'Undefined'
        ***REMOVED***, ***REMOVED***
          type: 'Null'
        ***REMOVED***
      ];
      typesSoFar = ***REMOVED***
        Undefined: true,
        Null: true
      ***REMOVED***;
    ***REMOVED***
    for (;;) ***REMOVED***
      typeObj = consumeType(tokens), type = typeObj.type;
      if (!typesSoFar[type]) ***REMOVED***
        types.push(typeObj);
      ***REMOVED***
      typesSoFar[type] = true;
      if (!maybeConsumeOp(tokens, '|')) ***REMOVED***
        break;
      ***REMOVED***
    ***REMOVED***
    return types;
  ***REMOVED***
  tokenRegex = RegExp('\\.\\.\\.|::|->|' + identifierRegex.source + '|\\S', 'g');
  module.exports = function(input)***REMOVED***
    var tokens, e;
    if (!input.length) ***REMOVED***
      throw new Error('No type specified.');
    ***REMOVED***
    tokens = input.match(tokenRegex) || [];
    if (in$('->', tokens)) ***REMOVED***
      throw new Error("Function types are not supported.\ To validate that something is a function, you may use 'Function'.");
    ***REMOVED***
    try ***REMOVED***
      return consumeTypes(tokens);
    ***REMOVED*** catch (e$) ***REMOVED***
      e = e$;
      throw new Error(e.message + " - Remaining tokens: " + JSON.stringify(tokens) + " - Initial input: '" + input + "'");
    ***REMOVED***
  ***REMOVED***;
  function in$(x, xs)***REMOVED***
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  ***REMOVED***
***REMOVED***).call(this);
