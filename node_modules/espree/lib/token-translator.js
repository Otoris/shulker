/**
 * @fileoverview Translates tokens between Acorn format and Esprima format.
 * @author Nicholas C. Zakas
 */
/* eslint no-underscore-dangle: 0 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

// none!

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------


// Esprima Token Types
const Token = ***REMOVED***
    Boolean: "Boolean",
    EOF: "<end>",
    Identifier: "Identifier",
    Keyword: "Keyword",
    Null: "Null",
    Numeric: "Numeric",
    Punctuator: "Punctuator",
    String: "String",
    RegularExpression: "RegularExpression",
    Template: "Template",
    JSXIdentifier: "JSXIdentifier",
    JSXText: "JSXText"
***REMOVED***;

/**
 * Converts part of a template into an Esprima token.
 * @param ***REMOVED***AcornToken[]***REMOVED*** tokens The Acorn tokens representing the template.
 * @param ***REMOVED***string***REMOVED*** code The source code.
 * @returns ***REMOVED***EsprimaToken***REMOVED*** The Esprima equivalent of the template token.
 * @private
 */
function convertTemplatePart(tokens, code) ***REMOVED***
    const firstToken = tokens[0],
        lastTemplateToken = tokens[tokens.length - 1];

    const token = ***REMOVED***
        type: Token.Template,
        value: code.slice(firstToken.start, lastTemplateToken.end)
    ***REMOVED***;

    if (firstToken.loc) ***REMOVED***
        token.loc = ***REMOVED***
            start: firstToken.loc.start,
            end: lastTemplateToken.loc.end
        ***REMOVED***;
    ***REMOVED***

    if (firstToken.range) ***REMOVED***
        token.start = firstToken.range[0];
        token.end = lastTemplateToken.range[1];
        token.range = [token.start, token.end];
    ***REMOVED***

    return token;
***REMOVED***

/**
 * Contains logic to translate Acorn tokens into Esprima tokens.
 * @param ***REMOVED***Object***REMOVED*** acornTokTypes The Acorn token types.
 * @param ***REMOVED***string***REMOVED*** code The source code Acorn is parsing. This is necessary
 *      to correct the "value" property of some tokens.
 * @constructor
 */
function TokenTranslator(acornTokTypes, code) ***REMOVED***

    // token types
    this._acornTokTypes = acornTokTypes;

    // token buffer for templates
    this._tokens = [];

    // track the last curly brace
    this._curlyBrace = null;

    // the source code
    this._code = code;

***REMOVED***

TokenTranslator.prototype = ***REMOVED***
    constructor: TokenTranslator,

    /**
     * Translates a single Esprima token to a single Acorn token. This may be
     * inaccurate due to how templates are handled differently in Esprima and
     * Acorn, but should be accurate for all other tokens.
     * @param ***REMOVED***AcornToken***REMOVED*** token The Acorn token to translate.
     * @param ***REMOVED***Object***REMOVED*** extra Espree extra object.
     * @returns ***REMOVED***EsprimaToken***REMOVED*** The Esprima version of the token.
     */
    translate(token, extra) ***REMOVED***

        const type = token.type,
            tt = this._acornTokTypes;

        if (type === tt.name) ***REMOVED***
            token.type = Token.Identifier;

            // TODO: See if this is an Acorn bug
            if (token.value === "static") ***REMOVED***
                token.type = Token.Keyword;
            ***REMOVED***

            if (extra.ecmaVersion > 5 && (token.value === "yield" || token.value === "let")) ***REMOVED***
                token.type = Token.Keyword;
            ***REMOVED***

        ***REMOVED*** else if (type === tt.semi || type === tt.comma ||
                 type === tt.parenL || type === tt.parenR ||
                 type === tt.braceL || type === tt.braceR ||
                 type === tt.dot || type === tt.bracketL ||
                 type === tt.colon || type === tt.question ||
                 type === tt.bracketR || type === tt.ellipsis ||
                 type === tt.arrow || type === tt.jsxTagStart ||
                 type === tt.incDec || type === tt.starstar ||
                 type === tt.jsxTagEnd || type === tt.prefix ||
                 (type.binop && !type.keyword) ||
                 type.isAssign) ***REMOVED***

            token.type = Token.Punctuator;
            token.value = this._code.slice(token.start, token.end);
        ***REMOVED*** else if (type === tt.jsxName) ***REMOVED***
            token.type = Token.JSXIdentifier;
        ***REMOVED*** else if (type.label === "jsxText" || type === tt.jsxAttrValueToken) ***REMOVED***
            token.type = Token.JSXText;
        ***REMOVED*** else if (type.keyword) ***REMOVED***
            if (type.keyword === "true" || type.keyword === "false") ***REMOVED***
                token.type = Token.Boolean;
            ***REMOVED*** else if (type.keyword === "null") ***REMOVED***
                token.type = Token.Null;
            ***REMOVED*** else ***REMOVED***
                token.type = Token.Keyword;
            ***REMOVED***
        ***REMOVED*** else if (type === tt.num) ***REMOVED***
            token.type = Token.Numeric;
            token.value = this._code.slice(token.start, token.end);
        ***REMOVED*** else if (type === tt.string) ***REMOVED***

            if (extra.jsxAttrValueToken) ***REMOVED***
                extra.jsxAttrValueToken = false;
                token.type = Token.JSXText;
            ***REMOVED*** else ***REMOVED***
                token.type = Token.String;
            ***REMOVED***

            token.value = this._code.slice(token.start, token.end);
        ***REMOVED*** else if (type === tt.regexp) ***REMOVED***
            token.type = Token.RegularExpression;
            const value = token.value;

            token.regex = ***REMOVED***
                flags: value.flags,
                pattern: value.pattern
            ***REMOVED***;
            token.value = `/$***REMOVED***value.pattern***REMOVED***/$***REMOVED***value.flags***REMOVED***`;
        ***REMOVED***

        return token;
    ***REMOVED***,

    /**
     * Function to call during Acorn's onToken handler.
     * @param ***REMOVED***AcornToken***REMOVED*** token The Acorn token.
     * @param ***REMOVED***Object***REMOVED*** extra The Espree extra object.
     * @returns ***REMOVED***void***REMOVED***
     */
    onToken(token, extra) ***REMOVED***

        const that = this,
            tt = this._acornTokTypes,
            tokens = extra.tokens,
            templateTokens = this._tokens;

        /**
         * Flushes the buffered template tokens and resets the template
         * tracking.
         * @returns ***REMOVED***void***REMOVED***
         * @private
         */
        function translateTemplateTokens() ***REMOVED***
            tokens.push(convertTemplatePart(that._tokens, that._code));
            that._tokens = [];
        ***REMOVED***

        if (token.type === tt.eof) ***REMOVED***

            // might be one last curlyBrace
            if (this._curlyBrace) ***REMOVED***
                tokens.push(this.translate(this._curlyBrace, extra));
            ***REMOVED***

            return;
        ***REMOVED***

        if (token.type === tt.backQuote) ***REMOVED***

            // if there's already a curly, it's not part of the template
            if (this._curlyBrace) ***REMOVED***
                tokens.push(this.translate(this._curlyBrace, extra));
                this._curlyBrace = null;
            ***REMOVED***

            templateTokens.push(token);

            // it's the end
            if (templateTokens.length > 1) ***REMOVED***
                translateTemplateTokens();
            ***REMOVED***

            return;
        ***REMOVED***
        if (token.type === tt.dollarBraceL) ***REMOVED***
            templateTokens.push(token);
            translateTemplateTokens();
            return;
        ***REMOVED***
        if (token.type === tt.braceR) ***REMOVED***

            // if there's already a curly, it's not part of the template
            if (this._curlyBrace) ***REMOVED***
                tokens.push(this.translate(this._curlyBrace, extra));
            ***REMOVED***

            // store new curly for later
            this._curlyBrace = token;
            return;
        ***REMOVED***
        if (token.type === tt.template || token.type === tt.invalidTemplate) ***REMOVED***
            if (this._curlyBrace) ***REMOVED***
                templateTokens.push(this._curlyBrace);
                this._curlyBrace = null;
            ***REMOVED***

            templateTokens.push(token);
            return;
        ***REMOVED***

        if (this._curlyBrace) ***REMOVED***
            tokens.push(this.translate(this._curlyBrace, extra));
            this._curlyBrace = null;
        ***REMOVED***

        tokens.push(this.translate(token, extra));
    ***REMOVED***
***REMOVED***;

//------------------------------------------------------------------------------
// Public
//------------------------------------------------------------------------------

module.exports = TokenTranslator;
