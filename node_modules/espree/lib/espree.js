"use strict";

/* eslint-disable no-param-reassign*/
const TokenTranslator = require("./token-translator");

const DEFAULT_ECMA_VERSION = 5;
const STATE = Symbol("espree's internal state");
const ESPRIMA_FINISH_NODE = Symbol("espree's esprimaFinishNode");

/**
 * Normalize ECMAScript version from the initial config
 * @param ***REMOVED***number***REMOVED*** ecmaVersion ECMAScript version from the initial config
 * @throws ***REMOVED***Error***REMOVED*** throws an error if the ecmaVersion is invalid.
 * @returns ***REMOVED***number***REMOVED*** normalized ECMAScript version
 */
function normalizeEcmaVersion(ecmaVersion = DEFAULT_ECMA_VERSION) ***REMOVED***
    if (typeof ecmaVersion !== "number") ***REMOVED***
        throw new Error(`ecmaVersion must be a number. Received value of type $***REMOVED***typeof ecmaVersion***REMOVED*** instead.`);
    ***REMOVED***

    let version = ecmaVersion;

    // Calculate ECMAScript edition number from official year version starting with
    // ES2015, which corresponds with ES6 (or a difference of 2009).
    if (version >= 2015) ***REMOVED***
        version -= 2009;
    ***REMOVED***

    switch (version) ***REMOVED***
        case 3:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
            return version;

        // no default
    ***REMOVED***

    throw new Error("Invalid ecmaVersion.");
***REMOVED***

/**
 * Normalize sourceType from the initial config
 * @param ***REMOVED***string***REMOVED*** sourceType to normalize
 * @throws ***REMOVED***Error***REMOVED*** throw an error if sourceType is invalid
 * @returns ***REMOVED***string***REMOVED*** normalized sourceType
 */
function normalizeSourceType(sourceType = "script") ***REMOVED***
    if (sourceType === "script" || sourceType === "module") ***REMOVED***
        return sourceType;
    ***REMOVED***
    throw new Error("Invalid sourceType.");
***REMOVED***

/**
 * Normalize parserOptions
 * @param ***REMOVED***Object***REMOVED*** options the parser options to normalize
 * @throws ***REMOVED***Error***REMOVED*** throw an error if found invalid option.
 * @returns ***REMOVED***Object***REMOVED*** normalized options
 */
function normalizeOptions(options) ***REMOVED***
    const ecmaVersion = normalizeEcmaVersion(options.ecmaVersion);
    const sourceType = normalizeSourceType(options.sourceType);
    const ranges = options.range === true;
    const locations = options.loc === true;

    if (sourceType === "module" && ecmaVersion < 6) ***REMOVED***
        throw new Error("sourceType 'module' is not supported when ecmaVersion < 2015. Consider adding `***REMOVED*** ecmaVersion: 2015 ***REMOVED***` to the parser options.");
    ***REMOVED***
    return Object.assign(***REMOVED******REMOVED***, options, ***REMOVED*** ecmaVersion, sourceType, ranges, locations ***REMOVED***);
***REMOVED***

/**
 * Converts an Acorn comment to a Esprima comment.
 * @param ***REMOVED***boolean***REMOVED*** block True if it's a block comment, false if not.
 * @param ***REMOVED***string***REMOVED*** text The text of the comment.
 * @param ***REMOVED***int***REMOVED*** start The index at which the comment starts.
 * @param ***REMOVED***int***REMOVED*** end The index at which the comment ends.
 * @param ***REMOVED***Location***REMOVED*** startLoc The location at which the comment starts.
 * @param ***REMOVED***Location***REMOVED*** endLoc The location at which the comment ends.
 * @returns ***REMOVED***Object***REMOVED*** The comment object.
 * @private
 */
function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) ***REMOVED***
    const comment = ***REMOVED***
        type: block ? "Block" : "Line",
        value: text
    ***REMOVED***;

    if (typeof start === "number") ***REMOVED***
        comment.start = start;
        comment.end = end;
        comment.range = [start, end];
    ***REMOVED***

    if (typeof startLoc === "object") ***REMOVED***
        comment.loc = ***REMOVED***
            start: startLoc,
            end: endLoc
        ***REMOVED***;
    ***REMOVED***

    return comment;
***REMOVED***

module.exports = () => Parser => ***REMOVED***
    const tokTypes = Object.assign(***REMOVED******REMOVED***, Parser.acorn.tokTypes);

    if (Parser.acornJsx) ***REMOVED***
        Object.assign(tokTypes, Parser.acornJsx.tokTypes);
    ***REMOVED***

    return class Espree extends Parser ***REMOVED***
        constructor(opts, code) ***REMOVED***
            if (typeof opts !== "object" || opts === null) ***REMOVED***
                opts = ***REMOVED******REMOVED***;
            ***REMOVED***
            if (typeof code !== "string" && !(code instanceof String)) ***REMOVED***
                code = String(code);
            ***REMOVED***

            const options = normalizeOptions(opts);
            const ecmaFeatures = options.ecmaFeatures || ***REMOVED******REMOVED***;
            const tokenTranslator =
                options.tokens === true
                    ? new TokenTranslator(tokTypes, code)
                    : null;

            // Initialize acorn parser.
            super(***REMOVED***

                // TODO: use ***REMOVED***...options***REMOVED*** when spread is supported(Node.js >= 8.3.0).
                ecmaVersion: options.ecmaVersion,
                sourceType: options.sourceType,
                ranges: options.ranges,
                locations: options.locations,

                // Truthy value is true for backward compatibility.
                allowReturnOutsideFunction: Boolean(ecmaFeatures.globalReturn),

                // Collect tokens
                onToken: token => ***REMOVED***
                    if (tokenTranslator) ***REMOVED***

                        // Use `tokens`, `ecmaVersion`, and `jsxAttrValueToken` in the state.
                        tokenTranslator.onToken(token, this[STATE]);
                    ***REMOVED***
                    if (token.type !== tokTypes.eof) ***REMOVED***
                        this[STATE].lastToken = token;
                    ***REMOVED***
                ***REMOVED***,

                // Collect comments
                onComment: (block, text, start, end, startLoc, endLoc) => ***REMOVED***
                    if (this[STATE].comments) ***REMOVED***
                        const comment = convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc);

                        this[STATE].comments.push(comment);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***, code);

            // Initialize internal state.
            this[STATE] = ***REMOVED***
                tokens: tokenTranslator ? [] : null,
                comments: options.comment === true ? [] : null,
                impliedStrict: ecmaFeatures.impliedStrict === true && this.options.ecmaVersion >= 5,
                ecmaVersion: this.options.ecmaVersion,
                jsxAttrValueToken: false,
                lastToken: null
            ***REMOVED***;
        ***REMOVED***

        tokenize() ***REMOVED***
            do ***REMOVED***
                this.next();
            ***REMOVED*** while (this.type !== tokTypes.eof);

            // Consume the final eof token
            this.next();

            const extra = this[STATE];
            const tokens = extra.tokens;

            if (extra.comments) ***REMOVED***
                tokens.comments = extra.comments;
            ***REMOVED***

            return tokens;
        ***REMOVED***

        finishNode(...args) ***REMOVED***
            const result = super.finishNode(...args);

            return this[ESPRIMA_FINISH_NODE](result);
        ***REMOVED***

        finishNodeAt(...args) ***REMOVED***
            const result = super.finishNodeAt(...args);

            return this[ESPRIMA_FINISH_NODE](result);
        ***REMOVED***

        parse() ***REMOVED***
            const extra = this[STATE];
            const program = super.parse();

            program.sourceType = this.options.sourceType;

            if (extra.comments) ***REMOVED***
                program.comments = extra.comments;
            ***REMOVED***
            if (extra.tokens) ***REMOVED***
                program.tokens = extra.tokens;
            ***REMOVED***

            /*
             * Adjust opening and closing position of program to match Esprima.
             * Acorn always starts programs at range 0 whereas Esprima starts at the
             * first AST node's start (the only real difference is when there's leading
             * whitespace or leading comments). Acorn also counts trailing whitespace
             * as part of the program whereas Esprima only counts up to the last token.
             */
            if (program.range) ***REMOVED***
                program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];
                program.range[1] = extra.lastToken ? extra.lastToken.range[1] : program.range[1];
            ***REMOVED***
            if (program.loc) ***REMOVED***
                program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;
                program.loc.end = extra.lastToken ? extra.lastToken.loc.end : program.loc.end;
            ***REMOVED***

            return program;
        ***REMOVED***

        parseTopLevel(node) ***REMOVED***
            if (this[STATE].impliedStrict) ***REMOVED***
                this.strict = true;
            ***REMOVED***
            return super.parseTopLevel(node);
        ***REMOVED***

        /**
         * Overwrites the default raise method to throw Esprima-style errors.
         * @param ***REMOVED***int***REMOVED*** pos The position of the error.
         * @param ***REMOVED***string***REMOVED*** message The error message.
         * @throws ***REMOVED***SyntaxError***REMOVED*** A syntax error.
         * @returns ***REMOVED***void***REMOVED***
         */
        raise(pos, message) ***REMOVED***
            const loc = Parser.acorn.getLineInfo(this.input, pos);
            const err = new SyntaxError(message);

            err.index = pos;
            err.lineNumber = loc.line;
            err.column = loc.column + 1; // acorn uses 0-based columns
            throw err;
        ***REMOVED***

        /**
         * Overwrites the default raise method to throw Esprima-style errors.
         * @param ***REMOVED***int***REMOVED*** pos The position of the error.
         * @param ***REMOVED***string***REMOVED*** message The error message.
         * @throws ***REMOVED***SyntaxError***REMOVED*** A syntax error.
         * @returns ***REMOVED***void***REMOVED***
         */
        raiseRecoverable(pos, message) ***REMOVED***
            this.raise(pos, message);
        ***REMOVED***

        /**
         * Overwrites the default unexpected method to throw Esprima-style errors.
         * @param ***REMOVED***int***REMOVED*** pos The position of the error.
         * @throws ***REMOVED***SyntaxError***REMOVED*** A syntax error.
         * @returns ***REMOVED***void***REMOVED***
         */
        unexpected(pos) ***REMOVED***
            let message = "Unexpected token";

            if (pos !== null && pos !== void 0) ***REMOVED***
                this.pos = pos;

                if (this.options.locations) ***REMOVED***
                    while (this.pos < this.lineStart) ***REMOVED***
                        this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
                        --this.curLine;
                    ***REMOVED***
                ***REMOVED***

                this.nextToken();
            ***REMOVED***

            if (this.end > this.start) ***REMOVED***
                message += ` $***REMOVED***this.input.slice(this.start, this.end)***REMOVED***`;
            ***REMOVED***

            this.raise(this.start, message);
        ***REMOVED***

        /*
        * Esprima-FB represents JSX strings as tokens called "JSXText", but Acorn-JSX
        * uses regular tt.string without any distinction between this and regular JS
        * strings. As such, we intercept an attempt to read a JSX string and set a flag
        * on extra so that when tokens are converted, the next token will be switched
        * to JSXText via onToken.
        */
        jsx_readString(quote) ***REMOVED*** // eslint-disable-line camelcase
            const result = super.jsx_readString(quote);

            if (this.type === tokTypes.string) ***REMOVED***
                this[STATE].jsxAttrValueToken = true;
            ***REMOVED***
            return result;
        ***REMOVED***

        /**
         * Performs last-minute Esprima-specific compatibility checks and fixes.
         * @param ***REMOVED***ASTNode***REMOVED*** result The node to check.
         * @returns ***REMOVED***ASTNode***REMOVED*** The finished node.
         */
        [ESPRIMA_FINISH_NODE](result) ***REMOVED***

            // Acorn doesn't count the opening and closing backticks as part of templates
            // so we have to adjust ranges/locations appropriately.
            if (result.type === "TemplateElement") ***REMOVED***

                // additional adjustment needed if $***REMOVED*** is the last token
                const terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === "$***REMOVED***";

                if (result.range) ***REMOVED***
                    result.range[0]--;
                    result.range[1] += (terminalDollarBraceL ? 2 : 1);
                ***REMOVED***

                if (result.loc) ***REMOVED***
                    result.loc.start.column--;
                    result.loc.end.column += (terminalDollarBraceL ? 2 : 1);
                ***REMOVED***
            ***REMOVED***

            if (result.type.indexOf("Function") > -1 && !result.generator) ***REMOVED***
                result.generator = false;
            ***REMOVED***

            return result;
        ***REMOVED***
    ***REMOVED***;
***REMOVED***;
