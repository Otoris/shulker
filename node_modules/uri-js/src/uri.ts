/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */

/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */

import URI_PROTOCOL from "./regexps-uri";
import IRI_PROTOCOL from "./regexps-iri";
import punycode from "punycode";
import ***REMOVED*** toUpperCase, typeOf, assign ***REMOVED*** from "./util";

export interface URIComponents ***REMOVED***
	scheme?:string;
	userinfo?:string;
	host?:string;
	port?:number|string;
	path?:string;
	query?:string;
	fragment?:string;
	reference?:string;
	error?:string;
***REMOVED***

export interface URIOptions ***REMOVED***
	scheme?:string;
	reference?:string;
	tolerant?:boolean;
	absolutePath?:boolean;
	iri?:boolean;
	unicodeSupport?:boolean;
	domainHost?:boolean;
***REMOVED***

export interface URISchemeHandler<Components extends URIComponents = URIComponents, Options extends URIOptions = URIOptions, ParentComponents extends URIComponents = URIComponents> ***REMOVED***
	scheme:string;
	parse(components:ParentComponents, options:Options):Components;
	serialize(components:Components, options:Options):ParentComponents;
	unicodeSupport?:boolean;
	domainHost?:boolean;
	absolutePath?:boolean;
***REMOVED***

export interface URIRegExps ***REMOVED***
	NOT_SCHEME : RegExp,
	NOT_USERINFO : RegExp,
	NOT_HOST : RegExp,
	NOT_PATH : RegExp,
	NOT_PATH_NOSCHEME : RegExp,
	NOT_QUERY : RegExp,
	NOT_FRAGMENT : RegExp,
	ESCAPE : RegExp,
	UNRESERVED : RegExp,
	OTHER_CHARS : RegExp,
	PCT_ENCODED : RegExp,
	IPV4ADDRESS : RegExp,
	IPV6ADDRESS : RegExp,
***REMOVED***

export const SCHEMES:***REMOVED***[scheme:string]:URISchemeHandler***REMOVED*** = ***REMOVED******REMOVED***;

export function pctEncChar(chr:string):string ***REMOVED***
	const c = chr.charCodeAt(0);
	let e:string;

	if (c < 16) e = "%0" + c.toString(16).toUpperCase();
	else if (c < 128) e = "%" + c.toString(16).toUpperCase();
	else if (c < 2048) e = "%" + ((c >> 6) | 192).toString(16).toUpperCase() + "%" + ((c & 63) | 128).toString(16).toUpperCase();
	else e = "%" + ((c >> 12) | 224).toString(16).toUpperCase() + "%" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + "%" + ((c & 63) | 128).toString(16).toUpperCase();

	return e;
***REMOVED***

export function pctDecChars(str:string):string ***REMOVED***
	let newStr = "";
	let i = 0;
	const il = str.length;

	while (i < il) ***REMOVED***
		const c = parseInt(str.substr(i + 1, 2), 16);

		if (c < 128) ***REMOVED***
			newStr += String.fromCharCode(c);
			i += 3;
		***REMOVED***
		else if (c >= 194 && c < 224) ***REMOVED***
			if ((il - i) >= 6) ***REMOVED***
				const c2 = parseInt(str.substr(i + 4, 2), 16);
				newStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
			***REMOVED*** else ***REMOVED***
				newStr += str.substr(i, 6);
			***REMOVED***
			i += 6;
		***REMOVED***
		else if (c >= 224) ***REMOVED***
			if ((il - i) >= 9) ***REMOVED***
				const c2 = parseInt(str.substr(i + 4, 2), 16);
				const c3 = parseInt(str.substr(i + 7, 2), 16);
				newStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
			***REMOVED*** else ***REMOVED***
				newStr += str.substr(i, 9);
			***REMOVED***
			i += 9;
		***REMOVED***
		else ***REMOVED***
			newStr += str.substr(i, 3);
			i += 3;
		***REMOVED***
	***REMOVED***

	return newStr;
***REMOVED***

function _normalizeComponentEncoding(components:URIComponents, protocol:URIRegExps) ***REMOVED***
	function decodeUnreserved(str:string):string ***REMOVED***
		const decStr = pctDecChars(str);
		return (!decStr.match(protocol.UNRESERVED) ? str : decStr);
	***REMOVED***

	if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
	if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
	if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);

	return components;
***REMOVED***;

function _stripLeadingZeros(str:string):string ***REMOVED***
	return str.replace(/^0*(.*)/, "$1") || "0";
***REMOVED***

function _normalizeIPv4(host:string, protocol:URIRegExps):string ***REMOVED***
	const matches = host.match(protocol.IPV4ADDRESS) || [];
	const [, address] = matches;
	
	if (address) ***REMOVED***
		return address.split(".").map(_stripLeadingZeros).join(".");
	***REMOVED*** else ***REMOVED***
		return host;
	***REMOVED***
***REMOVED***

function _normalizeIPv6(host:string, protocol:URIRegExps):string ***REMOVED***
	const matches = host.match(protocol.IPV6ADDRESS) || [];
	const [, address, zone] = matches;

	if (address) ***REMOVED***
		const [last, first] = address.toLowerCase().split('::').reverse();
		const firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
		const lastFields = last.split(":").map(_stripLeadingZeros);
		const isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
		const fieldCount = isLastFieldIPv4Address ? 7 : 8;
		const lastFieldsStart = lastFields.length - fieldCount;
		const fields = Array<string>(fieldCount);

		for (let x = 0; x < fieldCount; ++x) ***REMOVED***
			fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
		***REMOVED***

		if (isLastFieldIPv4Address) ***REMOVED***
			fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
		***REMOVED***

		const allZeroFields = fields.reduce<Array<***REMOVED***index:number,length:number***REMOVED***>>((acc, field, index) => ***REMOVED***
			if (!field || field === "0") ***REMOVED***
				const lastLongest = acc[acc.length - 1];
				if (lastLongest && lastLongest.index + lastLongest.length === index) ***REMOVED***
					lastLongest.length++;
				***REMOVED*** else ***REMOVED***
					acc.push(***REMOVED*** index, length : 1 ***REMOVED***);
				***REMOVED***
			***REMOVED***
			return acc;
		***REMOVED***, []);

		const longestZeroFields = allZeroFields.sort((a, b) => b.length - a.length)[0];

		let newHost:string;
		if (longestZeroFields && longestZeroFields.length > 1) ***REMOVED***
			const newFirst = fields.slice(0, longestZeroFields.index) ;
			const newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
			newHost = newFirst.join(":") + "::" + newLast.join(":");
		***REMOVED*** else ***REMOVED***
			newHost = fields.join(":");
		***REMOVED***

		if (zone) ***REMOVED***
			newHost += "%" + zone;
		***REMOVED***

		return newHost;
	***REMOVED*** else ***REMOVED***
		return host;
	***REMOVED***
***REMOVED***

const URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
const NO_MATCH_IS_UNDEFINED = (<RegExpMatchArray>("").match(/()***REMOVED***0***REMOVED***/))[1] === undefined;

export function parse(uriString:string, options:URIOptions = ***REMOVED******REMOVED***):URIComponents ***REMOVED***
	const components:URIComponents = ***REMOVED******REMOVED***;
	const protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);

	if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;

	const matches = uriString.match(URI_PARSE);

	if (matches) ***REMOVED***
		if (NO_MATCH_IS_UNDEFINED) ***REMOVED***
			//store each component
			components.scheme = matches[1];
			components.userinfo = matches[3];
			components.host = matches[4];
			components.port = parseInt(matches[5], 10);
			components.path = matches[6] || "";
			components.query = matches[7];
			components.fragment = matches[8];

			//fix port number
			if (isNaN(components.port)) ***REMOVED***
				components.port = matches[5];
			***REMOVED***
		***REMOVED*** else ***REMOVED***  //IE FIX for improper RegExp matching
			//store each component
			components.scheme = matches[1] || undefined;
			components.userinfo = (uriString.indexOf("@") !== -1 ? matches[3] : undefined);
			components.host = (uriString.indexOf("//") !== -1 ? matches[4] : undefined);
			components.port = parseInt(matches[5], 10);
			components.path = matches[6] || "";
			components.query = (uriString.indexOf("?") !== -1 ? matches[7] : undefined);
			components.fragment = (uriString.indexOf("#") !== -1 ? matches[8] : undefined);

			//fix port number
			if (isNaN(components.port)) ***REMOVED***
				components.port = (uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined);
			***REMOVED***
		***REMOVED***

		if (components.host) ***REMOVED***
			//normalize IP hosts
			components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
		***REMOVED***

		//determine reference type
		if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) ***REMOVED***
			components.reference = "same-document";
		***REMOVED*** else if (components.scheme === undefined) ***REMOVED***
			components.reference = "relative";
		***REMOVED*** else if (components.fragment === undefined) ***REMOVED***
			components.reference = "absolute";
		***REMOVED*** else ***REMOVED***
			components.reference = "uri";
		***REMOVED***

		//check for reference errors
		if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) ***REMOVED***
			components.error = components.error || "URI is not a " + options.reference + " reference.";
		***REMOVED***

		//find scheme handler
		const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];

		//check if scheme can't handle IRIs
		if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) ***REMOVED***
			//if host component is a domain name
			if (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) ***REMOVED***
				//convert Unicode IDN -> ASCII IDN
				try ***REMOVED***
					components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
				***REMOVED*** catch (e) ***REMOVED***
					components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
				***REMOVED***
			***REMOVED***
			//convert IRI -> URI
			_normalizeComponentEncoding(components, URI_PROTOCOL);
		***REMOVED*** else ***REMOVED***
			//normalize encodings
			_normalizeComponentEncoding(components, protocol);
		***REMOVED***

		//perform scheme specific parsing
		if (schemeHandler && schemeHandler.parse) ***REMOVED***
			schemeHandler.parse(components, options);
		***REMOVED***
	***REMOVED*** else ***REMOVED***
		components.error = components.error || "URI can not be parsed.";
	***REMOVED***

	return components;
***REMOVED***;

function _recomposeAuthority(components:URIComponents, options:URIOptions):string|undefined ***REMOVED***
	const protocol = (options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL);
	const uriTokens:Array<string> = [];

	if (components.userinfo !== undefined) ***REMOVED***
		uriTokens.push(components.userinfo);
		uriTokens.push("@");
	***REMOVED***

	if (components.host !== undefined) ***REMOVED***
		//normalize IP hosts, add brackets and escape zone separator for IPv6
		uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, (_, $1, $2) => "[" + $1 + ($2 ? "%25" + $2 : "") + "]"));
	***REMOVED***

	if (typeof components.port === "number") ***REMOVED***
		uriTokens.push(":");
		uriTokens.push(components.port.toString(10));
	***REMOVED***

	return uriTokens.length ? uriTokens.join("") : undefined;
***REMOVED***;

const RDS1 = /^\.\.?\//;
const RDS2 = /^\/\.(\/|$)/;
const RDS3 = /^\/\.\.(\/|$)/;
const RDS4 = /^\.\.?$/;
const RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;

export function removeDotSegments(input:string):string ***REMOVED***
	const output:Array<string> = [];

	while (input.length) ***REMOVED***
		if (input.match(RDS1)) ***REMOVED***
			input = input.replace(RDS1, "");
		***REMOVED*** else if (input.match(RDS2)) ***REMOVED***
			input = input.replace(RDS2, "/");
		***REMOVED*** else if (input.match(RDS3)) ***REMOVED***
			input = input.replace(RDS3, "/");
			output.pop();
		***REMOVED*** else if (input === "." || input === "..") ***REMOVED***
			input = "";
		***REMOVED*** else ***REMOVED***
			const im = input.match(RDS5);
			if (im) ***REMOVED***
				const s = im[0];
				input = input.slice(s.length);
				output.push(s);
			***REMOVED*** else ***REMOVED***
				throw new Error("Unexpected dot segment condition");
			***REMOVED***
		***REMOVED***
	***REMOVED***

	return output.join("");
***REMOVED***;

export function serialize(components:URIComponents, options:URIOptions = ***REMOVED******REMOVED***):string ***REMOVED***
	const protocol = (options.iri ? IRI_PROTOCOL : URI_PROTOCOL);
	const uriTokens:Array<string> = [];

	//find scheme handler
	const schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];

	//perform scheme specific serialization
	if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);

	if (components.host) ***REMOVED***
		//if host component is an IPv6 address
		if (protocol.IPV6ADDRESS.test(components.host)) ***REMOVED***
			//TODO: normalize IPv6 address as per RFC 5952
		***REMOVED***

		//if host component is a domain name
		else if (options.domainHost || (schemeHandler && schemeHandler.domainHost)) ***REMOVED***
			//convert IDN via punycode
			try ***REMOVED***
				components.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));
			***REMOVED*** catch (e) ***REMOVED***
				components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
			***REMOVED***
		***REMOVED***
	***REMOVED***

	//normalize encoding
	_normalizeComponentEncoding(components, protocol);

	if (options.reference !== "suffix" && components.scheme) ***REMOVED***
		uriTokens.push(components.scheme);
		uriTokens.push(":");
	***REMOVED***

	const authority = _recomposeAuthority(components, options);
	if (authority !== undefined) ***REMOVED***
		if (options.reference !== "suffix") ***REMOVED***
			uriTokens.push("//");
		***REMOVED***

		uriTokens.push(authority);

		if (components.path && components.path.charAt(0) !== "/") ***REMOVED***
			uriTokens.push("/");
		***REMOVED***
	***REMOVED***

	if (components.path !== undefined) ***REMOVED***
		let s = components.path;

		if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) ***REMOVED***
			s = removeDotSegments(s);
		***REMOVED***

		if (authority === undefined) ***REMOVED***
			s = s.replace(/^\/\//, "/%2F");  //don't allow the path to start with "//"
		***REMOVED***

		uriTokens.push(s);
	***REMOVED***

	if (components.query !== undefined) ***REMOVED***
		uriTokens.push("?");
		uriTokens.push(components.query);
	***REMOVED***

	if (components.fragment !== undefined) ***REMOVED***
		uriTokens.push("#");
		uriTokens.push(components.fragment);
	***REMOVED***

	return uriTokens.join("");  //merge tokens into a string
***REMOVED***;

export function resolveComponents(base:URIComponents, relative:URIComponents, options:URIOptions = ***REMOVED******REMOVED***, skipNormalization?:boolean):URIComponents ***REMOVED***
	const target:URIComponents = ***REMOVED******REMOVED***;

	if (!skipNormalization) ***REMOVED***
		base = parse(serialize(base, options), options);  //normalize base components
		relative = parse(serialize(relative, options), options);  //normalize relative components
	***REMOVED***
	options = options || ***REMOVED******REMOVED***;

	if (!options.tolerant && relative.scheme) ***REMOVED***
		target.scheme = relative.scheme;
		//target.authority = relative.authority;
		target.userinfo = relative.userinfo;
		target.host = relative.host;
		target.port = relative.port;
		target.path = removeDotSegments(relative.path || "");
		target.query = relative.query;
	***REMOVED*** else ***REMOVED***
		if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) ***REMOVED***
			//target.authority = relative.authority;
			target.userinfo = relative.userinfo;
			target.host = relative.host;
			target.port = relative.port;
			target.path = removeDotSegments(relative.path || "");
			target.query = relative.query;
		***REMOVED*** else ***REMOVED***
			if (!relative.path) ***REMOVED***
				target.path = base.path;
				if (relative.query !== undefined) ***REMOVED***
					target.query = relative.query;
				***REMOVED*** else ***REMOVED***
					target.query = base.query;
				***REMOVED***
			***REMOVED*** else ***REMOVED***
				if (relative.path.charAt(0) === "/") ***REMOVED***
					target.path = removeDotSegments(relative.path);
				***REMOVED*** else ***REMOVED***
					if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) ***REMOVED***
						target.path = "/" + relative.path;
					***REMOVED*** else if (!base.path) ***REMOVED***
						target.path = relative.path;
					***REMOVED*** else ***REMOVED***
						target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
					***REMOVED***
					target.path = removeDotSegments(target.path);
				***REMOVED***
				target.query = relative.query;
			***REMOVED***
			//target.authority = base.authority;
			target.userinfo = base.userinfo;
			target.host = base.host;
			target.port = base.port;
		***REMOVED***
		target.scheme = base.scheme;
	***REMOVED***

	target.fragment = relative.fragment;

	return target;
***REMOVED***;

export function resolve(baseURI:string, relativeURI:string, options?:URIOptions):string ***REMOVED***
	const schemelessOptions = assign(***REMOVED*** scheme : 'null' ***REMOVED***, options);
	return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
***REMOVED***;

export function normalize(uri:string, options?:URIOptions):string;
export function normalize(uri:URIComponents, options?:URIOptions):URIComponents;
export function normalize(uri:any, options?:URIOptions):any ***REMOVED***
	if (typeof uri === "string") ***REMOVED***
		uri = serialize(parse(uri, options), options);
	***REMOVED*** else if (typeOf(uri) === "object") ***REMOVED***
		uri = parse(serialize(<URIComponents>uri, options), options);
	***REMOVED***

	return uri;
***REMOVED***;

export function equal(uriA:string, uriB:string, options?: URIOptions):boolean;
export function equal(uriA:URIComponents, uriB:URIComponents, options?:URIOptions):boolean;
export function equal(uriA:any, uriB:any, options?:URIOptions):boolean ***REMOVED***
	if (typeof uriA === "string") ***REMOVED***
		uriA = serialize(parse(uriA, options), options);
	***REMOVED*** else if (typeOf(uriA) === "object") ***REMOVED***
		uriA = serialize(<URIComponents>uriA, options);
	***REMOVED***

	if (typeof uriB === "string") ***REMOVED***
		uriB = serialize(parse(uriB, options), options);
	***REMOVED*** else if (typeOf(uriB) === "object") ***REMOVED***
		uriB = serialize(<URIComponents>uriB, options);
	***REMOVED***

	return uriA === uriB;
***REMOVED***;

export function escapeComponent(str:string, options?:URIOptions):string ***REMOVED***
	return str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);
***REMOVED***;

export function unescapeComponent(str:string, options?:URIOptions):string ***REMOVED***
	return str && str.toString().replace((!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);
***REMOVED***;
