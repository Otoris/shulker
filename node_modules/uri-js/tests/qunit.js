/*
 * QUnit - A JavaScript Unit Testing Framework
 * 
 * http://docs.jquery.com/QUnit
 *
 * Copyright (c) 2009 John Resig, Jörn Zaefferer
 * Dual licensed under the MIT (MIT-LICENSE.txt)
 * and GPL (GPL-LICENSE.txt) licenses.
 */

(function(window) ***REMOVED***

var QUnit = ***REMOVED***

	// Initialize the configuration options
	init: function() ***REMOVED***
		config = ***REMOVED***
			stats: ***REMOVED*** all: 0, bad: 0 ***REMOVED***,
			moduleStats: ***REMOVED*** all: 0, bad: 0 ***REMOVED***,
			started: +new Date,
			blocking: false,
			autorun: false,
			assertions: [],
			filters: [],
			queue: []
		***REMOVED***;

		var tests = id("qunit-tests"),
			banner = id("qunit-banner"),
			result = id("qunit-testresult");

		if ( tests ) ***REMOVED***
			tests.innerHTML = "";
		***REMOVED***

		if ( banner ) ***REMOVED***
			banner.className = "";
		***REMOVED***

		if ( result ) ***REMOVED***
			result.parentNode.removeChild( result );
		***REMOVED***
	***REMOVED***,
	
	// call on start of module test to prepend name to all tests
	module: function(name, testEnvironment) ***REMOVED***
		config.currentModule = name;

		synchronize(function() ***REMOVED***
			if ( config.currentModule ) ***REMOVED***
				QUnit.moduleDone( config.currentModule, config.moduleStats.bad, config.moduleStats.all );
			***REMOVED***

			config.currentModule = name;
			config.moduleTestEnvironment = testEnvironment;
			config.moduleStats = ***REMOVED*** all: 0, bad: 0 ***REMOVED***;

			QUnit.moduleStart( name, testEnvironment );
		***REMOVED***);
	***REMOVED***,

	asyncTest: function(testName, expected, callback) ***REMOVED***
		if ( arguments.length === 2 ) ***REMOVED***
			callback = expected;
			expected = 0;
		***REMOVED***

		QUnit.test(testName, expected, callback, true);
	***REMOVED***,
	
	test: function(testName, expected, callback, async) ***REMOVED***
		var name = testName, testEnvironment, testEnvironmentArg;

		if ( arguments.length === 2 ) ***REMOVED***
			callback = expected;
			expected = null;
		***REMOVED***
		// is 2nd argument a testEnvironment?
		if ( expected && typeof expected === 'object') ***REMOVED***
			testEnvironmentArg =  expected;
			expected = null;
		***REMOVED***

		if ( config.currentModule ) ***REMOVED***
			name = config.currentModule + " module: " + name;
		***REMOVED***

		if ( !validTest(name) ) ***REMOVED***
			return;
		***REMOVED***

		synchronize(function() ***REMOVED***
			QUnit.testStart( testName );

			testEnvironment = extend(***REMOVED***
				setup: function() ***REMOVED******REMOVED***,
				teardown: function() ***REMOVED******REMOVED***
			***REMOVED***, config.moduleTestEnvironment);
			if (testEnvironmentArg) ***REMOVED***
				extend(testEnvironment,testEnvironmentArg);
			***REMOVED***

			// allow utility functions to access the current test environment
			QUnit.current_testEnvironment = testEnvironment;
			
			config.assertions = [];
			config.expected = expected;

			try ***REMOVED***
				if ( !config.pollution ) ***REMOVED***
					saveGlobal();
				***REMOVED***

				testEnvironment.setup.call(testEnvironment);
			***REMOVED*** catch(e) ***REMOVED***
				QUnit.ok( false, "Setup failed on " + name + ": " + e.message );
			***REMOVED***

			if ( async ) ***REMOVED***
				QUnit.stop();
			***REMOVED***

			try ***REMOVED***
				callback.call(testEnvironment);
			***REMOVED*** catch(e) ***REMOVED***
				fail("Test " + name + " died, exception and test follows", e, callback);
				QUnit.ok( false, "Died on test #" + (config.assertions.length + 1) + ": " + e.message );
				// else next test will carry the responsibility
				saveGlobal();

				// Restart the tests if they're blocking
				if ( config.blocking ) ***REMOVED***
					start();
				***REMOVED***
			***REMOVED***
		***REMOVED***);

		synchronize(function() ***REMOVED***
			try ***REMOVED***
				checkPollution();
				testEnvironment.teardown.call(testEnvironment);
			***REMOVED*** catch(e) ***REMOVED***
				QUnit.ok( false, "Teardown failed on " + name + ": " + e.message );
			***REMOVED***

			try ***REMOVED***
				QUnit.reset();
			***REMOVED*** catch(e) ***REMOVED***
				fail("reset() failed, following Test " + name + ", exception and reset fn follows", e, reset);
			***REMOVED***

			if ( config.expected && config.expected != config.assertions.length ) ***REMOVED***
				QUnit.ok( false, "Expected " + config.expected + " assertions, but " + config.assertions.length + " were run" );
			***REMOVED***

			var good = 0, bad = 0,
				tests = id("qunit-tests");

			config.stats.all += config.assertions.length;
			config.moduleStats.all += config.assertions.length;

			if ( tests ) ***REMOVED***
				var ol  = document.createElement("ol");
				ol.style.display = "none";

				for ( var i = 0; i < config.assertions.length; i++ ) ***REMOVED***
					var assertion = config.assertions[i];

					var li = document.createElement("li");
					li.className = assertion.result ? "pass" : "fail";
					li.appendChild(document.createTextNode(assertion.message || "(no message)"));
					ol.appendChild( li );

					if ( assertion.result ) ***REMOVED***
						good++;
					***REMOVED*** else ***REMOVED***
						bad++;
						config.stats.bad++;
						config.moduleStats.bad++;
					***REMOVED***
				***REMOVED***

				var b = document.createElement("strong");
				b.innerHTML = name + " <b style='color:black;'>(<b class='fail'>" + bad + "</b>, <b class='pass'>" + good + "</b>, " + config.assertions.length + ")</b>";
				
				addEvent(b, "click", function() ***REMOVED***
					var next = b.nextSibling, display = next.style.display;
					next.style.display = display === "none" ? "block" : "none";
				***REMOVED***);
				
				addEvent(b, "dblclick", function(e) ***REMOVED***
					var target = e && e.target ? e.target : window.event.srcElement;
					if ( target.nodeName.toLowerCase() === "strong" ) ***REMOVED***
						var text = "", node = target.firstChild;

						while ( node.nodeType === 3 ) ***REMOVED***
							text += node.nodeValue;
							node = node.nextSibling;
						***REMOVED***

						text = text.replace(/(^\s*|\s*$)/g, "");

						if ( window.location ) ***REMOVED***
							window.location.href = window.location.href.match(/^(.+?)(\?.*)?$/)[1] + "?" + encodeURIComponent(text);
						***REMOVED***
					***REMOVED***
				***REMOVED***);

				var li = document.createElement("li");
				li.className = bad ? "fail" : "pass";
				li.appendChild( b );
				li.appendChild( ol );
				tests.appendChild( li );

				if ( bad ) ***REMOVED***
					var toolbar = id("qunit-testrunner-toolbar");
					if ( toolbar ) ***REMOVED***
						toolbar.style.display = "block";
						id("qunit-filter-pass").disabled = null;
						id("qunit-filter-missing").disabled = null;
					***REMOVED***
				***REMOVED***

			***REMOVED*** else ***REMOVED***
				for ( var i = 0; i < config.assertions.length; i++ ) ***REMOVED***
					if ( !config.assertions[i].result ) ***REMOVED***
						bad++;
						config.stats.bad++;
						config.moduleStats.bad++;
					***REMOVED***
				***REMOVED***
			***REMOVED***

			QUnit.testDone( testName, bad, config.assertions.length );

			if ( !window.setTimeout && !config.queue.length ) ***REMOVED***
				done();
			***REMOVED***
		***REMOVED***);

		if ( window.setTimeout && !config.doneTimer ) ***REMOVED***
			config.doneTimer = window.setTimeout(function()***REMOVED***
				if ( !config.queue.length ) ***REMOVED***
					done();
				***REMOVED*** else ***REMOVED***
					synchronize( done );
				***REMOVED***
			***REMOVED***, 13);
		***REMOVED***
	***REMOVED***,
	
	/**
	 * Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don't slip through.
	 */
	expect: function(asserts) ***REMOVED***
		config.expected = asserts;
	***REMOVED***,

	/**
	 * Asserts true.
	 * @example ok( "asdfasdf".length > 5, "There must be at least 5 chars" );
	 */
	ok: function(a, msg) ***REMOVED***
		QUnit.log(a, msg);

		config.assertions.push(***REMOVED***
			result: !!a,
			message: msg
		***REMOVED***);
	***REMOVED***,

	/**
	 * Checks that the first two arguments are equal, with an optional message.
	 * Prints out both actual and expected values.
	 *
	 * Prefered to ok( actual == expected, message )
	 *
	 * @example equal( format("Received ***REMOVED***0***REMOVED*** bytes.", 2), "Received 2 bytes." );
	 *
	 * @param Object actual
	 * @param Object expected
	 * @param String message (optional)
	 */
	equal: function(actual, expected, message) ***REMOVED***
		push(expected == actual, actual, expected, message);
	***REMOVED***,

	notEqual: function(actual, expected, message) ***REMOVED***
		push(expected != actual, actual, expected, message);
	***REMOVED***,
	
	deepEqual: function(a, b, message) ***REMOVED***
		push(QUnit.equiv(a, b), a, b, message);
	***REMOVED***,

	notDeepEqual: function(a, b, message) ***REMOVED***
		push(!QUnit.equiv(a, b), a, b, message);
	***REMOVED***,

	strictEqual: function(actual, expected, message) ***REMOVED***
		push(expected === actual, actual, expected, message);
	***REMOVED***,

	notStrictEqual: function(actual, expected, message) ***REMOVED***
		push(expected !== actual, actual, expected, message);
	***REMOVED***,
	
	start: function() ***REMOVED***
		// A slight delay, to avoid any current callbacks
		if ( window.setTimeout ) ***REMOVED***
			window.setTimeout(function() ***REMOVED***
				if ( config.timeout ) ***REMOVED***
					clearTimeout(config.timeout);
				***REMOVED***

				config.blocking = false;
				process();
			***REMOVED***, 13);
		***REMOVED*** else ***REMOVED***
			config.blocking = false;
			process();
		***REMOVED***
	***REMOVED***,
	
	stop: function(timeout) ***REMOVED***
		config.blocking = true;

		if ( timeout && window.setTimeout ) ***REMOVED***
			config.timeout = window.setTimeout(function() ***REMOVED***
				QUnit.ok( false, "Test timed out" );
				QUnit.start();
			***REMOVED***, timeout);
		***REMOVED***
	***REMOVED***,
	
	/**
	 * Resets the test setup. Useful for tests that modify the DOM.
	 */
	reset: function() ***REMOVED***
		if ( window.jQuery ) ***REMOVED***
			jQuery("#main").html( config.fixture );
			jQuery.event.global = ***REMOVED******REMOVED***;
			jQuery.ajaxSettings = extend(***REMOVED******REMOVED***, config.ajaxSettings);
		***REMOVED***
	***REMOVED***,
	
	/**
	 * Trigger an event on an element.
	 *
	 * @example triggerEvent( document.body, "click" );
	 *
	 * @param DOMElement elem
	 * @param String type
	 */
	triggerEvent: function( elem, type, event ) ***REMOVED***
		if ( document.createEvent ) ***REMOVED***
			event = document.createEvent("MouseEvents");
			event.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,
				0, 0, 0, 0, 0, false, false, false, false, 0, null);
			elem.dispatchEvent( event );

		***REMOVED*** else if ( elem.fireEvent ) ***REMOVED***
			elem.fireEvent("on"+type);
		***REMOVED***
	***REMOVED***,
	
	// Safe object type checking
	is: function( type, obj ) ***REMOVED***
		return Object.prototype.toString.call( obj ) === "[object "+ type +"]";
	***REMOVED***,
	
	// Logging callbacks
	done: function(failures, total) ***REMOVED******REMOVED***,
	log: function(result, message) ***REMOVED******REMOVED***,
	testStart: function(name) ***REMOVED******REMOVED***,
	testDone: function(name, failures, total) ***REMOVED******REMOVED***,
	moduleStart: function(name, testEnvironment) ***REMOVED******REMOVED***,
	moduleDone: function(name, failures, total) ***REMOVED******REMOVED***
***REMOVED***;

// Backwards compatibility, deprecated
QUnit.equals = QUnit.equal;
QUnit.same = QUnit.deepEqual;

// Maintain internal state
var config = ***REMOVED***
	// The queue of tests to run
	queue: [],

	// block until document ready
	blocking: true
***REMOVED***;

// Load paramaters
(function() ***REMOVED***
	var location = window.location || ***REMOVED*** search: "", protocol: "file:" ***REMOVED***,
		GETParams = location.search.slice(1).split('&');

	for ( var i = 0; i < GETParams.length; i++ ) ***REMOVED***
		GETParams[i] = decodeURIComponent( GETParams[i] );
		if ( GETParams[i] === "noglobals" ) ***REMOVED***
			GETParams.splice( i, 1 );
			i--;
			config.noglobals = true;
		***REMOVED*** else if ( GETParams[i].search('=') > -1 ) ***REMOVED***
			GETParams.splice( i, 1 );
			i--;
		***REMOVED***
	***REMOVED***
	
	// restrict modules/tests by get parameters
	config.filters = GETParams;
	
	// Figure out if we're running the tests from a server or not
	QUnit.isLocal = !!(location.protocol === 'file:');
***REMOVED***)();

// Expose the API as global variables, unless an 'exports'
// object exists, in that case we assume we're in CommonJS
if ( typeof exports === "undefined" || typeof require === "undefined" ) ***REMOVED***
	extend(window, QUnit);
	window.QUnit = QUnit;
***REMOVED*** else ***REMOVED***
	extend(exports, QUnit);
	exports.QUnit = QUnit;
***REMOVED***

if ( typeof document === "undefined" || document.readyState === "complete" ) ***REMOVED***
	config.autorun = true;
***REMOVED***

addEvent(window, "load", function() ***REMOVED***
	// Initialize the config, saving the execution queue
	var oldconfig = extend(***REMOVED******REMOVED***, config);
	QUnit.init();
	extend(config, oldconfig);

	config.blocking = false;

	var userAgent = id("qunit-userAgent");
	if ( userAgent ) ***REMOVED***
		userAgent.innerHTML = navigator.userAgent;
	***REMOVED***
	
	var toolbar = id("qunit-testrunner-toolbar");
	if ( toolbar ) ***REMOVED***
		toolbar.style.display = "none";
		
		var filter = document.createElement("input");
		filter.type = "checkbox";
		filter.id = "qunit-filter-pass";
		filter.disabled = true;
		addEvent( filter, "click", function() ***REMOVED***
			var li = document.getElementsByTagName("li");
			for ( var i = 0; i < li.length; i++ ) ***REMOVED***
				if ( li[i].className.indexOf("pass") > -1 ) ***REMOVED***
					li[i].style.display = filter.checked ? "none" : "";
				***REMOVED***
			***REMOVED***
		***REMOVED***);
		toolbar.appendChild( filter );

		var label = document.createElement("label");
		label.setAttribute("for", "qunit-filter-pass");
		label.innerHTML = "Hide passed tests";
		toolbar.appendChild( label );

		var missing = document.createElement("input");
		missing.type = "checkbox";
		missing.id = "qunit-filter-missing";
		missing.disabled = true;
		addEvent( missing, "click", function() ***REMOVED***
			var li = document.getElementsByTagName("li");
			for ( var i = 0; i < li.length; i++ ) ***REMOVED***
				if ( li[i].className.indexOf("fail") > -1 && li[i].innerHTML.indexOf('missing test - untested code is broken code') > - 1 ) ***REMOVED***
					li[i].parentNode.parentNode.style.display = missing.checked ? "none" : "block";
				***REMOVED***
			***REMOVED***
		***REMOVED***);
		toolbar.appendChild( missing );

		label = document.createElement("label");
		label.setAttribute("for", "qunit-filter-missing");
		label.innerHTML = "Hide missing tests (untested code is broken code)";
		toolbar.appendChild( label );
	***REMOVED***

	var main = id('main');
	if ( main ) ***REMOVED***
		config.fixture = main.innerHTML;
	***REMOVED***

	if ( window.jQuery ) ***REMOVED***
		config.ajaxSettings = window.jQuery.ajaxSettings;
	***REMOVED***

	QUnit.start();
***REMOVED***);

function done() ***REMOVED***
	if ( config.doneTimer && window.clearTimeout ) ***REMOVED***
		window.clearTimeout( config.doneTimer );
		config.doneTimer = null;
	***REMOVED***

	if ( config.queue.length ) ***REMOVED***
		config.doneTimer = window.setTimeout(function()***REMOVED***
			if ( !config.queue.length ) ***REMOVED***
				done();
			***REMOVED*** else ***REMOVED***
				synchronize( done );
			***REMOVED***
		***REMOVED***, 13);

		return;
	***REMOVED***

	config.autorun = true;

	// Log the last module results
	if ( config.currentModule ) ***REMOVED***
		QUnit.moduleDone( config.currentModule, config.moduleStats.bad, config.moduleStats.all );
	***REMOVED***

	var banner = id("qunit-banner"),
		tests = id("qunit-tests"),
		html = ['Tests completed in ',
		+new Date - config.started, ' milliseconds.<br/>',
		'<span class="passed">', config.stats.all - config.stats.bad, '</span> tests of <span class="total">', config.stats.all, '</span> passed, <span class="failed">', config.stats.bad,'</span> failed.'].join('');

	if ( banner ) ***REMOVED***
		banner.className = (config.stats.bad ? "qunit-fail" : "qunit-pass");
	***REMOVED***

	if ( tests ) ***REMOVED***	
		var result = id("qunit-testresult");

		if ( !result ) ***REMOVED***
			result = document.createElement("p");
			result.id = "qunit-testresult";
			result.className = "result";
			tests.parentNode.insertBefore( result, tests.nextSibling );
		***REMOVED***

		result.innerHTML = html;
	***REMOVED***

	QUnit.done( config.stats.bad, config.stats.all );
***REMOVED***

function validTest( name ) ***REMOVED***
	var i = config.filters.length,
		run = false;

	if ( !i ) ***REMOVED***
		return true;
	***REMOVED***
	
	while ( i-- ) ***REMOVED***
		var filter = config.filters[i],
			not = filter.charAt(0) == '!';

		if ( not ) ***REMOVED***
			filter = filter.slice(1);
		***REMOVED***

		if ( name.indexOf(filter) !== -1 ) ***REMOVED***
			return !not;
		***REMOVED***

		if ( not ) ***REMOVED***
			run = true;
		***REMOVED***
	***REMOVED***

	return run;
***REMOVED***

function push(result, actual, expected, message) ***REMOVED***
	message = message || (result ? "okay" : "failed");
	QUnit.ok( result, result ? message + ": " + expected : message + ", expected: " + QUnit.jsDump.parse(expected) + " result: " + QUnit.jsDump.parse(actual) );
***REMOVED***

function synchronize( callback ) ***REMOVED***
	config.queue.push( callback );

	if ( config.autorun && !config.blocking ) ***REMOVED***
		process();
	***REMOVED***
***REMOVED***

function process() ***REMOVED***
	while ( config.queue.length && !config.blocking ) ***REMOVED***
		config.queue.shift()();
	***REMOVED***
***REMOVED***

function saveGlobal() ***REMOVED***
	config.pollution = [];
	
	if ( config.noglobals ) ***REMOVED***
		for ( var key in window ) ***REMOVED***
			config.pollution.push( key );
		***REMOVED***
	***REMOVED***
***REMOVED***

function checkPollution( name ) ***REMOVED***
	var old = config.pollution;
	saveGlobal();
	
	var newGlobals = diff( old, config.pollution );
	if ( newGlobals.length > 0 ) ***REMOVED***
		ok( false, "Introduced global variable(s): " + newGlobals.join(", ") );
		config.expected++;
	***REMOVED***

	var deletedGlobals = diff( config.pollution, old );
	if ( deletedGlobals.length > 0 ) ***REMOVED***
		ok( false, "Deleted global variable(s): " + deletedGlobals.join(", ") );
		config.expected++;
	***REMOVED***
***REMOVED***

// returns a new Array with the elements that are in a but not in b
function diff( a, b ) ***REMOVED***
	var result = a.slice();
	for ( var i = 0; i < result.length; i++ ) ***REMOVED***
		for ( var j = 0; j < b.length; j++ ) ***REMOVED***
			if ( result[i] === b[j] ) ***REMOVED***
				result.splice(i, 1);
				i--;
				break;
			***REMOVED***
		***REMOVED***
	***REMOVED***
	return result;
***REMOVED***

function fail(message, exception, callback) ***REMOVED***
	if ( typeof console !== "undefined" && console.error && console.warn ) ***REMOVED***
		console.error(message);
		console.error(exception);
		console.warn(callback.toString());

	***REMOVED*** else if ( window.opera && opera.postError ) ***REMOVED***
		opera.postError(message, exception, callback.toString);
	***REMOVED***
***REMOVED***

function extend(a, b) ***REMOVED***
	for ( var prop in b ) ***REMOVED***
		a[prop] = b[prop];
	***REMOVED***

	return a;
***REMOVED***

function addEvent(elem, type, fn) ***REMOVED***
	if ( elem.addEventListener ) ***REMOVED***
		elem.addEventListener( type, fn, false );
	***REMOVED*** else if ( elem.attachEvent ) ***REMOVED***
		elem.attachEvent( "on" + type, fn );
	***REMOVED*** else ***REMOVED***
		fn();
	***REMOVED***
***REMOVED***

function id(name) ***REMOVED***
	return !!(typeof document !== "undefined" && document && document.getElementById) &&
		document.getElementById( name );
***REMOVED***

// Test for equality any JavaScript type.
// Discussions and reference: http://philrathe.com/articles/equiv
// Test suites: http://philrathe.com/tests/equiv
// Author: Philippe Rathé <prathe@gmail.com>
QUnit.equiv = function () ***REMOVED***

    var innerEquiv; // the real equiv function
    var callers = []; // stack to decide between skip/abort functions


    // Determine what is o.
    function hoozit(o) ***REMOVED***
        if (QUnit.is("String", o)) ***REMOVED***
            return "string";
            
        ***REMOVED*** else if (QUnit.is("Boolean", o)) ***REMOVED***
            return "boolean";

        ***REMOVED*** else if (QUnit.is("Number", o)) ***REMOVED***

            if (isNaN(o)) ***REMOVED***
                return "nan";
            ***REMOVED*** else ***REMOVED***
                return "number";
            ***REMOVED***

        ***REMOVED*** else if (typeof o === "undefined") ***REMOVED***
            return "undefined";

        // consider: typeof null === object
        ***REMOVED*** else if (o === null) ***REMOVED***
            return "null";

        // consider: typeof [] === object
        ***REMOVED*** else if (QUnit.is( "Array", o)) ***REMOVED***
            return "array";
        
        // consider: typeof new Date() === object
        ***REMOVED*** else if (QUnit.is( "Date", o)) ***REMOVED***
            return "date";

        // consider: /./ instanceof Object;
        //           /./ instanceof RegExp;
        //          typeof /./ === "function"; // => false in IE and Opera,
        //                                          true in FF and Safari
        ***REMOVED*** else if (QUnit.is( "RegExp", o)) ***REMOVED***
            return "regexp";

        ***REMOVED*** else if (typeof o === "object") ***REMOVED***
            return "object";

        ***REMOVED*** else if (QUnit.is( "Function", o)) ***REMOVED***
            return "function";
        ***REMOVED*** else ***REMOVED***
            return undefined;
        ***REMOVED***
    ***REMOVED***

    // Call the o related callback with the given arguments.
    function bindCallbacks(o, callbacks, args) ***REMOVED***
        var prop = hoozit(o);
        if (prop) ***REMOVED***
            if (hoozit(callbacks[prop]) === "function") ***REMOVED***
                return callbacks[prop].apply(callbacks, args);
            ***REMOVED*** else ***REMOVED***
                return callbacks[prop]; // or undefined
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    
    var callbacks = function () ***REMOVED***

        // for string, boolean, number and null
        function useStrictEquality(b, a) ***REMOVED***
            if (b instanceof a.constructor || a instanceof b.constructor) ***REMOVED***
                // to catch short annotaion VS 'new' annotation of a declaration
                // e.g. var i = 1;
                //      var j = new Number(1);
                return a == b;
            ***REMOVED*** else ***REMOVED***
                return a === b;
            ***REMOVED***
        ***REMOVED***

        return ***REMOVED***
            "string": useStrictEquality,
            "boolean": useStrictEquality,
            "number": useStrictEquality,
            "null": useStrictEquality,
            "undefined": useStrictEquality,

            "nan": function (b) ***REMOVED***
                return isNaN(b);
            ***REMOVED***,

            "date": function (b, a) ***REMOVED***
                return hoozit(b) === "date" && a.valueOf() === b.valueOf();
            ***REMOVED***,

            "regexp": function (b, a) ***REMOVED***
                return hoozit(b) === "regexp" &&
                    a.source === b.source && // the regex itself
                    a.global === b.global && // and its modifers (gmi) ...
                    a.ignoreCase === b.ignoreCase &&
                    a.multiline === b.multiline;
            ***REMOVED***,

            // - skip when the property is a method of an instance (OOP)
            // - abort otherwise,
            //   initial === would have catch identical references anyway
            "function": function () ***REMOVED***
                var caller = callers[callers.length - 1];
                return caller !== Object &&
                        typeof caller !== "undefined";
            ***REMOVED***,

            "array": function (b, a) ***REMOVED***
                var i;
                var len;

                // b could be an object literal here
                if ( ! (hoozit(b) === "array")) ***REMOVED***
                    return false;
                ***REMOVED***

                len = a.length;
                if (len !== b.length) ***REMOVED*** // safe and faster
                    return false;
                ***REMOVED***
                for (i = 0; i < len; i++) ***REMOVED***
                    if ( ! innerEquiv(a[i], b[i])) ***REMOVED***
                        return false;
                    ***REMOVED***
                ***REMOVED***
                return true;
            ***REMOVED***,

            "object": function (b, a) ***REMOVED***
                var i;
                var eq = true; // unless we can proove it
                var aProperties = [], bProperties = []; // collection of strings

                // comparing constructors is more strict than using instanceof
                if ( a.constructor !== b.constructor) ***REMOVED***
                    return false;
                ***REMOVED***

                // stack constructor before traversing properties
                callers.push(a.constructor);

                for (i in a) ***REMOVED*** // be strict: don't ensures hasOwnProperty and go deep

                    aProperties.push(i); // collect a's properties

                    if ( ! innerEquiv(a[i], b[i])) ***REMOVED***
                        eq = false;
                    ***REMOVED***
                ***REMOVED***

                callers.pop(); // unstack, we are done

                for (i in b) ***REMOVED***
                    bProperties.push(i); // collect b's properties
                ***REMOVED***

                // Ensures identical properties name
                return eq && innerEquiv(aProperties.sort(), bProperties.sort());
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***();

    innerEquiv = function () ***REMOVED*** // can take multiple arguments
        var args = Array.prototype.slice.apply(arguments);
        if (args.length < 2) ***REMOVED***
            return true; // end transition
        ***REMOVED***

        return (function (a, b) ***REMOVED***
            if (a === b) ***REMOVED***
                return true; // catch the most you can
            ***REMOVED*** else if (a === null || b === null || typeof a === "undefined" || typeof b === "undefined" || hoozit(a) !== hoozit(b)) ***REMOVED***
                return false; // don't lose time with error prone cases
            ***REMOVED*** else ***REMOVED***
                return bindCallbacks(a, callbacks, [b, a]);
            ***REMOVED***

        // apply transition with (1..n) arguments
        ***REMOVED***)(args[0], args[1]) && arguments.callee.apply(this, args.splice(1, args.length -1));
    ***REMOVED***;

    return innerEquiv;

***REMOVED***();

/**
 * jsDump
 * Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Licensed under BSD (http://www.opensource.org/licenses/bsd-license.php)
 * Date: 5/15/2008
 * @projectDescription Advanced and extensible data dumping for Javascript.
 * @version 1.0.0
 * @author Ariel Flesler
 * @link ***REMOVED***http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html***REMOVED***
 */
QUnit.jsDump = (function() ***REMOVED***
	function quote( str ) ***REMOVED***
		return '"' + str.toString().replace(/"/g, '\\"') + '"';
	***REMOVED***;
	function literal( o ) ***REMOVED***
		return o + '';	
	***REMOVED***;
	function join( pre, arr, post ) ***REMOVED***
		var s = jsDump.separator(),
			base = jsDump.indent(),
			inner = jsDump.indent(1);
		if ( arr.join )
			arr = arr.join( ',' + s + inner );
		if ( !arr )
			return pre + post;
		return [ pre, inner + arr, base + post ].join(s);
	***REMOVED***;
	function array( arr ) ***REMOVED***
		var i = arr.length,	ret = Array(i);					
		this.up();
		while ( i-- )
			ret[i] = this.parse( arr[i] );				
		this.down();
		return join( '[', ret, ']' );
	***REMOVED***;
	
	var reName = /^function (\w+)/;
	
	var jsDump = ***REMOVED***
		parse:function( obj, type ) ***REMOVED*** //type is used mostly internally, you can fix a (custom)type in advance
			var	parser = this.parsers[ type || this.typeOf(obj) ];
			type = typeof parser;			
			
			return type == 'function' ? parser.call( this, obj ) :
				   type == 'string' ? parser :
				   this.parsers.error;
		***REMOVED***,
		typeOf:function( obj ) ***REMOVED***
			var type;
			if ( obj === null ) ***REMOVED***
				type = "null";
			***REMOVED*** else if (typeof obj === "undefined") ***REMOVED***
				type = "undefined";
			***REMOVED*** else if (QUnit.is("RegExp", obj)) ***REMOVED***
				type = "regexp";
			***REMOVED*** else if (QUnit.is("Date", obj)) ***REMOVED***
				type = "date";
			***REMOVED*** else if (QUnit.is("Function", obj)) ***REMOVED***
				type = "function";
			***REMOVED*** else if (QUnit.is("Array", obj)) ***REMOVED***
				type = "array";
			***REMOVED*** else if (QUnit.is("Window", obj) || QUnit.is("global", obj)) ***REMOVED***
				type = "window";
			***REMOVED*** else if (QUnit.is("HTMLDocument", obj)) ***REMOVED***
				type = "document";
			***REMOVED*** else if (QUnit.is("HTMLCollection", obj) || QUnit.is("NodeList", obj)) ***REMOVED***
				type = "nodelist";
			***REMOVED*** else if (/^\[object HTML/.test(Object.prototype.toString.call( obj ))) ***REMOVED***
				type = "node";
			***REMOVED*** else ***REMOVED***
				type = typeof obj;
			***REMOVED***
			return type;
		***REMOVED***,
		separator:function() ***REMOVED***
			return this.multiline ?	this.HTML ? '<br />' : '\n' : this.HTML ? '&nbsp;' : ' ';
		***REMOVED***,
		indent:function( extra ) ***REMOVED***// extra can be a number, shortcut for increasing-calling-decreasing
			if ( !this.multiline )
				return '';
			var chr = this.indentChar;
			if ( this.HTML )
				chr = chr.replace(/\t/g,'   ').replace(/ /g,'&nbsp;');
			return Array( this._depth_ + (extra||0) ).join(chr);
		***REMOVED***,
		up:function( a ) ***REMOVED***
			this._depth_ += a || 1;
		***REMOVED***,
		down:function( a ) ***REMOVED***
			this._depth_ -= a || 1;
		***REMOVED***,
		setParser:function( name, parser ) ***REMOVED***
			this.parsers[name] = parser;
		***REMOVED***,
		// The next 3 are exposed so you can use them
		quote:quote, 
		literal:literal,
		join:join,
		//
		_depth_: 1,
		// This is the list of parsers, to modify them, use jsDump.setParser
		parsers:***REMOVED***
			window: '[Window]',
			document: '[Document]',
			error:'[ERROR]', //when no parser is found, shouldn't happen
			unknown: '[Unknown]',
			'null':'null',
			undefined:'undefined',
			'function':function( fn ) ***REMOVED***
				var ret = 'function',
					name = 'name' in fn ? fn.name : (reName.exec(fn)||[])[1];//functions never have name in IE
				if ( name )
					ret += ' ' + name;
				ret += '(';
				
				ret = [ ret, this.parse( fn, 'functionArgs' ), ')***REMOVED***'].join('');
				return join( ret, this.parse(fn,'functionCode'), '***REMOVED***' );
			***REMOVED***,
			array: array,
			nodelist: array,
			arguments: array,
			object:function( map ) ***REMOVED***
				var ret = [ ];
				this.up();
				for ( var key in map )
					ret.push( this.parse(key,'key') + ': ' + this.parse(map[key]) );
				this.down();
				return join( '***REMOVED***', ret, '***REMOVED***' );
			***REMOVED***,
			node:function( node ) ***REMOVED***
				var open = this.HTML ? '&lt;' : '<',
					close = this.HTML ? '&gt;' : '>';
					
				var tag = node.nodeName.toLowerCase(),
					ret = open + tag;
					
				for ( var a in this.DOMAttrs ) ***REMOVED***
					var val = node[this.DOMAttrs[a]];
					if ( val )
						ret += ' ' + a + '=' + this.parse( val, 'attribute' );
				***REMOVED***
				return ret + close + open + '/' + tag + close;
			***REMOVED***,
			functionArgs:function( fn ) ***REMOVED***//function calls it internally, it's the arguments part of the function
				var l = fn.length;
				if ( !l ) return '';				
				
				var args = Array(l);
				while ( l-- )
					args[l] = String.fromCharCode(97+l);//97 is 'a'
				return ' ' + args.join(', ') + ' ';
			***REMOVED***,
			key:quote, //object calls it internally, the key part of an item in a map
			functionCode:'[code]', //function calls it internally, it's the content of the function
			attribute:quote, //node calls it internally, it's an html attribute value
			string:quote,
			date:quote,
			regexp:literal, //regex
			number:literal,
			'boolean':literal
		***REMOVED***,
		DOMAttrs:***REMOVED***//attributes to dump from nodes, name=>realName
			id:'id',
			name:'name',
			'class':'className'
		***REMOVED***,
		HTML:true,//if true, entities are escaped ( <, >, \t, space and \n )
		indentChar:'   ',//indentation unit
		multiline:true //if true, items in a collection, are separated by a \n, else just a space.
	***REMOVED***;

	return jsDump;
***REMOVED***)();

***REMOVED***)(this);
