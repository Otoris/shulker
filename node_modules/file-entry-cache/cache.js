var path = require( 'path' );
var crypto = require( 'crypto' );

module.exports = ***REMOVED***
  createFromFile: function ( filePath, useChecksum ) ***REMOVED***
    var fname = path.basename( filePath );
    var dir = path.dirname( filePath );
    return this.create( fname, dir, useChecksum );
  ***REMOVED***,

  create: function ( cacheId, _path, useChecksum ) ***REMOVED***
    var fs = require( 'fs' );
    var flatCache = require( 'flat-cache' );
    var cache = flatCache.load( cacheId, _path );
    var normalizedEntries = ***REMOVED*** ***REMOVED***;

    var removeNotFoundFiles = function removeNotFoundFiles() ***REMOVED***
      const cachedEntries = cache.keys();
      // remove not found entries
      cachedEntries.forEach( function remover( fPath ) ***REMOVED***
        try ***REMOVED***
          fs.statSync( fPath );
        ***REMOVED*** catch (err) ***REMOVED***
          if ( err.code === 'ENOENT' ) ***REMOVED***
            cache.removeKey( fPath );
          ***REMOVED***
        ***REMOVED***
      ***REMOVED*** );
    ***REMOVED***;

    removeNotFoundFiles();

    return ***REMOVED***
      /**
       * the flat cache storage used to persist the metadata of the `files
       * @type ***REMOVED***Object***REMOVED***
       */
      cache: cache,

      /**
       * Given a buffer, calculate md5 hash of its content.
       * @method getHash
       * @param  ***REMOVED***Buffer***REMOVED*** buffer   buffer to calculate hash on
       * @return ***REMOVED***String***REMOVED***          content hash digest
       */
      getHash: function ( buffer ) ***REMOVED***
        return crypto
          .createHash( 'md5' )
          .update( buffer )
          .digest( 'hex' );
      ***REMOVED***,

      /**
       * Return whether or not a file has changed since last time reconcile was called.
       * @method hasFileChanged
       * @param  ***REMOVED***String***REMOVED***  file  the filepath to check
       * @return ***REMOVED***Boolean***REMOVED***       wheter or not the file has changed
       */
      hasFileChanged: function ( file ) ***REMOVED***
        return this.getFileDescriptor( file ).changed;
      ***REMOVED***,

      /**
       * given an array of file paths it return and object with three arrays:
       *  - changedFiles: Files that changed since previous run
       *  - notChangedFiles: Files that haven't change
       *  - notFoundFiles: Files that were not found, probably deleted
       *
       * @param  ***REMOVED***Array***REMOVED*** files the files to analyze and compare to the previous seen files
       * @return ***REMOVED***[type]***REMOVED***       [description]
       */
      analyzeFiles: function ( files ) ***REMOVED***
        var me = this;
        files = files || [ ];

        var res = ***REMOVED***
          changedFiles: [],
          notFoundFiles: [],
          notChangedFiles: []
        ***REMOVED***;

        me.normalizeEntries( files ).forEach( function ( entry ) ***REMOVED***
          if ( entry.changed ) ***REMOVED***
            res.changedFiles.push( entry.key );
            return;
          ***REMOVED***
          if ( entry.notFound ) ***REMOVED***
            res.notFoundFiles.push( entry.key );
            return;
          ***REMOVED***
          res.notChangedFiles.push( entry.key );
        ***REMOVED*** );
        return res;
      ***REMOVED***,

      getFileDescriptor: function ( file ) ***REMOVED***
        var fstat;

        try ***REMOVED***
          fstat = fs.statSync( file );
        ***REMOVED*** catch (ex) ***REMOVED***
          this.removeEntry( file );
          return ***REMOVED*** key: file, notFound: true, err: ex ***REMOVED***;
        ***REMOVED***

        if ( useChecksum ) ***REMOVED***
          return this._getFileDescriptorUsingChecksum( file );
        ***REMOVED***

        return this._getFileDescriptorUsingMtimeAndSize( file, fstat );
      ***REMOVED***,

      _getFileDescriptorUsingMtimeAndSize: function ( file, fstat ) ***REMOVED***
        var meta = cache.getKey( file );
        var cacheExists = !!meta;

        var cSize = fstat.size;
        var cTime = fstat.mtime.getTime();

        var isDifferentDate;
        var isDifferentSize;

        if ( !meta ) ***REMOVED***
          meta = ***REMOVED*** size: cSize, mtime: cTime ***REMOVED***;
        ***REMOVED*** else ***REMOVED***
          isDifferentDate = cTime !== meta.mtime;
          isDifferentSize = cSize !== meta.size;
        ***REMOVED***

        var nEntry = normalizedEntries[ file ] = ***REMOVED***
          key: file,
          changed: !cacheExists || isDifferentDate || isDifferentSize,
          meta: meta
        ***REMOVED***;

        return nEntry;
      ***REMOVED***,

      _getFileDescriptorUsingChecksum: function ( file ) ***REMOVED***
        var meta = cache.getKey( file );
        var cacheExists = !!meta;

        var contentBuffer;
        try ***REMOVED***
          contentBuffer = fs.readFileSync( file );
        ***REMOVED*** catch (ex) ***REMOVED***
          contentBuffer = '';
        ***REMOVED***

        var isDifferent = true;
        var hash = this.getHash( contentBuffer );

        if ( !meta ) ***REMOVED***
          meta = ***REMOVED*** hash: hash ***REMOVED***;
        ***REMOVED*** else ***REMOVED***
          isDifferent = hash !== meta.hash;
        ***REMOVED***

        var nEntry = normalizedEntries[ file ] = ***REMOVED***
          key: file,
          changed: !cacheExists || isDifferent,
          meta: meta
        ***REMOVED***;

        return nEntry;
      ***REMOVED***,

      /**
       * Return the list o the files that changed compared
       * against the ones stored in the cache
       *
       * @method getUpdated
       * @param files ***REMOVED***Array***REMOVED*** the array of files to compare against the ones in the cache
       * @returns ***REMOVED***Array***REMOVED***
       */
      getUpdatedFiles: function ( files ) ***REMOVED***
        var me = this;
        files = files || [ ];

        return me.normalizeEntries( files ).filter( function ( entry ) ***REMOVED***
          return entry.changed;
        ***REMOVED*** ).map( function ( entry ) ***REMOVED***
          return entry.key;
        ***REMOVED*** );
      ***REMOVED***,

      /**
       * return the list of files
       * @method normalizeEntries
       * @param files
       * @returns ***REMOVED*******REMOVED***
       */
      normalizeEntries: function ( files ) ***REMOVED***
        files = files || [ ];

        var me = this;
        var nEntries = files.map( function ( file ) ***REMOVED***
          return me.getFileDescriptor( file );
        ***REMOVED*** );

        //normalizeEntries = nEntries;
        return nEntries;
      ***REMOVED***,

      /**
       * Remove an entry from the file-entry-cache. Useful to force the file to still be considered
       * modified the next time the process is run
       *
       * @method removeEntry
       * @param entryName
       */
      removeEntry: function ( entryName ) ***REMOVED***
        delete normalizedEntries[ entryName ];
        cache.removeKey( entryName );
      ***REMOVED***,

      /**
       * Delete the cache file from the disk
       * @method deleteCacheFile
       */
      deleteCacheFile: function () ***REMOVED***
        cache.removeCacheFile();
      ***REMOVED***,

      /**
       * remove the cache from the file and clear the memory cache
       */
      destroy: function () ***REMOVED***
        normalizedEntries = ***REMOVED*** ***REMOVED***;
        cache.destroy();
      ***REMOVED***,

      _getMetaForFileUsingCheckSum: function ( cacheEntry ) ***REMOVED***
        var contentBuffer = fs.readFileSync( cacheEntry.key );
        var hash = this.getHash( contentBuffer );
        var meta = Object.assign( cacheEntry.meta, ***REMOVED*** hash: hash ***REMOVED*** );
        return meta;
      ***REMOVED***,

      _getMetaForFileUsingMtimeAndSize: function ( cacheEntry ) ***REMOVED***
        var stat = fs.statSync( cacheEntry.key );
        var meta = Object.assign( cacheEntry.meta, ***REMOVED***
          size: stat.size,
          mtime: stat.mtime.getTime()
        ***REMOVED*** );
        return meta;
      ***REMOVED***,

      /**
       * Sync the files and persist them to the cache
       * @method reconcile
       */
      reconcile: function ( noPrune ) ***REMOVED***
        removeNotFoundFiles();

        noPrune = typeof noPrune === 'undefined' ? true : noPrune;

        var entries = normalizedEntries;
        var keys = Object.keys( entries );

        if ( keys.length === 0 ) ***REMOVED***
          return;
        ***REMOVED***

        var me = this;

        keys.forEach( function ( entryName ) ***REMOVED***
          var cacheEntry = entries[ entryName ];

          try ***REMOVED***
            var meta = useChecksum ? me._getMetaForFileUsingCheckSum( cacheEntry ) : me._getMetaForFileUsingMtimeAndSize( cacheEntry );
            cache.setKey( entryName, meta );
          ***REMOVED*** catch (err) ***REMOVED***
            // if the file does not exists we don't save it
            // other errors are just thrown
            if ( err.code !== 'ENOENT' ) ***REMOVED***
              throw err;
            ***REMOVED***
          ***REMOVED***
        ***REMOVED*** );

        cache.save( noPrune );
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;
