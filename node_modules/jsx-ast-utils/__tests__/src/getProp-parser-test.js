/* eslint-env mocha */
import assert from 'assert';
import entries from 'object.entries';
import fromEntries from 'object.fromentries';
import ***REMOVED*** getOpeningElement, setParserName, fallbackToBabylon ***REMOVED*** from '../helper';
import getProp from '../../src/getProp';

const literal = ***REMOVED***
  source: '<div ***REMOVED***...***REMOVED*** id: "foo" ***REMOVED******REMOVED*** />',
  target: '<div id="foo" />',
  offset: ***REMOVED*** keyOffset: -6, valueOffset: -7 ***REMOVED***,
***REMOVED***;

const expression1 = ***REMOVED***
  source: '<div ***REMOVED***...***REMOVED*** id ***REMOVED******REMOVED*** />',
  target: '<div id=***REMOVED***id***REMOVED*** />',
  offset: ***REMOVED*** keyOffset: -6, valueOffset: -2 ***REMOVED***,
***REMOVED***;

const expression2 = ***REMOVED***
  source: '<div ***REMOVED***...***REMOVED*** id: `foo$***REMOVED***bar***REMOVED***baz` ***REMOVED******REMOVED*** />', // eslint-disable-line no-template-curly-in-string
  target: '<div id=***REMOVED***`foo$***REMOVED***bar***REMOVED***baz`***REMOVED*** />', // eslint-disable-line no-template-curly-in-string
  offset: ***REMOVED*** keyOffset: -6, valueOffset: -6 ***REMOVED***,
***REMOVED***;

describe('getProp', () => ***REMOVED***
  it('should create the correct AST for literal with flow parser', () => ***REMOVED***
    actualTest('flow', literal);
  ***REMOVED***);
  it('should create the correct AST for literal with babel parser', () => ***REMOVED***
    actualTest('babel', literal);
  ***REMOVED***);
  it('should create the correct AST for expression with flow parser (1)', () => ***REMOVED***
    actualTest('flow', expression1);
  ***REMOVED***);
  it('should create the correct AST for expression with babel parser (1)', () => ***REMOVED***
    actualTest('babel', expression1);
  ***REMOVED***);
  it('should create the correct AST for expression with flow parser (2)', () => ***REMOVED***
    actualTest('flow', expression2);
  ***REMOVED***);
  it('should create the correct AST for expression with babel parser (2)', () => ***REMOVED***
    actualTest('babel', expression2);
  ***REMOVED***);
***REMOVED***);

function actualTest(parserName, test) ***REMOVED***
  setParserName(parserName);
  const ***REMOVED*** source, target, offset ***REMOVED*** = test;
  const sourceProps = stripConstructors(getOpeningElement(source).attributes);
  const targetProps = stripConstructors(getOpeningElement(target).attributes);
  const prop = 'id';
  const sourceResult = getProp(sourceProps, prop);
  const targetResult = getProp(targetProps, prop);

  if (fallbackToBabylon && parserName === 'babel' && test === literal) ***REMOVED***
    // Babylon (node < 6) adds an `extra: null` prop to a literal if it is parsed from a
    // JSXAttribute, other literals don't get this.
    sourceResult.value.extra = null;
  ***REMOVED***

  assert.deepStrictEqual(
    adjustLocations(sourceResult, offset),
    targetResult,
  );
***REMOVED***

function stripConstructors(value) ***REMOVED***
  return JSON.parse(JSON.stringify(value));
***REMOVED***

function adjustLocations(node, ***REMOVED*** keyOffset, valueOffset ***REMOVED***) ***REMOVED***
  const hasExpression = !!node.value.expression;
  return ***REMOVED***
    ...adjustNodeLocations(node, ***REMOVED***
      startOffset: keyOffset,
      endOffset: valueOffset + (hasExpression ? 1 : 0),
    ***REMOVED***),
    name: adjustNodeLocations(node.name, ***REMOVED*** startOffset: keyOffset, endOffset: keyOffset ***REMOVED***),
    value: ***REMOVED***
      ...adjustNodeLocations(node.value, ***REMOVED***
        startOffset: valueOffset - (hasExpression ? 1 : 0),
        endOffset: valueOffset + (hasExpression ? 1 : 0),
      ***REMOVED***),
      ...(hasExpression
        ? ***REMOVED***
          expression: adjustLocationsRecursively(
            node.value.expression,
            ***REMOVED*** startOffset: valueOffset, endOffset: valueOffset ***REMOVED***,
          ),
        ***REMOVED***
        : ***REMOVED******REMOVED***
      ),
    ***REMOVED***,
  ***REMOVED***;
***REMOVED***

function adjustNodeLocations(node, ***REMOVED*** startOffset, endOffset ***REMOVED***) ***REMOVED***
  if (!node.loc) return node;
  const [start, end] = node.range || [];
  return ***REMOVED***
    ...node,
    ...(node.start !== undefined ? ***REMOVED*** start: node.start + startOffset ***REMOVED*** : ***REMOVED******REMOVED***),
    ...(node.end !== undefined ? ***REMOVED*** end: node.end + endOffset ***REMOVED*** : ***REMOVED******REMOVED***),
    loc: ***REMOVED***
      ...node.loc,
      start: ***REMOVED***
        ...node.loc.start,
        column: node.loc.start.column + startOffset,
      ***REMOVED***,
      end: ***REMOVED***
        ...node.loc.end,
        column: node.loc.end.column + endOffset,
      ***REMOVED***,
    ***REMOVED***,
    ...(node.range !== undefined ? ***REMOVED*** range: [start + startOffset, end + endOffset] ***REMOVED*** : ***REMOVED******REMOVED***),
  ***REMOVED***;
***REMOVED***

function adjustLocationsRecursively(node, ***REMOVED*** startOffset, endOffset ***REMOVED***) ***REMOVED***
  if (Array.isArray(node)) ***REMOVED***
    return node.map(x => adjustLocationsRecursively(x, ***REMOVED*** startOffset, endOffset ***REMOVED***));
  ***REMOVED***
  if (node && typeof node === 'object') ***REMOVED***
    return adjustNodeLocations(
      mapValues(node, x => adjustLocationsRecursively(x, ***REMOVED*** startOffset, endOffset ***REMOVED***)),
      ***REMOVED*** startOffset, endOffset ***REMOVED***,
    );
  ***REMOVED***

  return node;
***REMOVED***

function mapValues(o, f) ***REMOVED***
  return fromEntries(entries(o).map(([k, v]) => [k, f(v)]));
***REMOVED***
