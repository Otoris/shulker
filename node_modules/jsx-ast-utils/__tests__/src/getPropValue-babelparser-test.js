/* eslint-env mocha */
/* eslint no-template-curly-in-string: 0 */
import assert from 'assert';
import ***REMOVED***
  extractProp,
  changePlugins,
  fallbackToBabylon,
  describeIfNotBabylon,
  setParserName,
***REMOVED*** from '../helper';
import getPropValue from '../../src/getPropValue';

describe('getPropValue', () => ***REMOVED***
  beforeEach(() => ***REMOVED***
    setParserName('babel');
  ***REMOVED***);
  it('should export a function', () => ***REMOVED***
    const expected = 'function';
    const actual = typeof getPropValue;

    assert.equal(expected, actual);
  ***REMOVED***);

  it('should return undefined when not provided with a JSXAttribute', () => ***REMOVED***
    const expected = undefined;
    const actual = getPropValue(1);

    assert.equal(expected, actual);
  ***REMOVED***);

  it('should not throw error when trying to get value from unknown node type', () => ***REMOVED***
    const prop = ***REMOVED***
      type: 'JSXAttribute',
      value: ***REMOVED***
        type: 'JSXExpressionContainer',
      ***REMOVED***,
    ***REMOVED***;
    let counter = 0;
    // eslint-disable-next-line no-console
    const errorOrig = console.error;
    // eslint-disable-next-line no-console
    console.error = () => ***REMOVED***
      counter += 1;
    ***REMOVED***;
    let value;
    assert.doesNotThrow(() => ***REMOVED***
      value = getPropValue(prop);
    ***REMOVED***, Error);

    assert.equal(null, value);
    assert.equal(counter, 1);
    // eslint-disable-next-line no-console
    console.error = errorOrig;
  ***REMOVED***);

  describe('Null', () => ***REMOVED***
    it('should return true when no value is given', () => ***REMOVED***
      const prop = extractProp('<div foo />');

      const expected = true;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Literal', () => ***REMOVED***
    it('should return correct string if value is a string', () => ***REMOVED***
      const prop = extractProp('<div foo="bar" />');

      const expected = 'bar';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return correct string if value is a string expression', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***"bar"***REMOVED*** />');

      const expected = 'bar';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return correct integer if value is a integer expression', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***1***REMOVED*** />');

      const expected = 1;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should convert "true" to boolean type', () => ***REMOVED***
      const prop = extractProp('<div foo="true" />');

      const expected = true;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should convert "false" to boolean type', () => ***REMOVED***
      const prop = extractProp('<div foo="false" />');

      const expected = false;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('JSXElement', () => ***REMOVED***
    it('should return correct representation of JSX element as a string', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***<bar />***REMOVED*** />');

      const expected = '<bar />';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Identifier', () => ***REMOVED***
    it('should return string representation of variable identifier', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar***REMOVED*** />');

      const expected = 'bar';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return undefined when identifier is literally `undefined`', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***undefined***REMOVED*** />');

      const expected = undefined;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return String object when using a reserved JavaScript object', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***String***REMOVED*** />');

      const expected = String;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return Array object when using a reserved JavaScript object', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***Array***REMOVED*** />');

      const expected = Array;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return Date object when using a reserved JavaScript object', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***Date***REMOVED*** />');

      const expected = Date;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return Infinity object when using a reserved JavaScript object', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***Infinity***REMOVED*** />');

      const expected = Infinity;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return Math object when using a reserved JavaScript object', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***Math***REMOVED*** />');

      const expected = Math;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return Number object when using a reserved JavaScript object', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***Number***REMOVED*** />');

      const expected = Number;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return Object object when using a reserved JavaScript object', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***Object***REMOVED*** />');

      const expected = Object;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Template literal', () => ***REMOVED***
    it('should return template literal with vars wrapped in curly braces', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***`bar $***REMOVED***baz***REMOVED***`***REMOVED*** />');

      const expected = 'bar ***REMOVED***baz***REMOVED***';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return string "undefined" for expressions that evaluate to undefined', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***`bar $***REMOVED***undefined***REMOVED***`***REMOVED*** />');

      const expected = 'bar undefined';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return template literal with expression type wrapped in curly braces', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***`bar $***REMOVED***baz()***REMOVED***`***REMOVED*** />');

      const expected = 'bar ***REMOVED***CallExpression***REMOVED***';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should ignore non-expressions in the template literal', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***`bar $***REMOVED***<baz />***REMOVED***`***REMOVED*** />');

      const expected = 'bar ';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Tagged Template literal', () => ***REMOVED***
    it('should return template literal with vars wrapped in curly braces', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***noop`bar $***REMOVED***baz***REMOVED***`***REMOVED*** />');

      const expected = 'bar ***REMOVED***baz***REMOVED***';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return string "undefined" for expressions that evaluate to undefined', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***noop`bar $***REMOVED***undefined***REMOVED***`***REMOVED*** />');

      const expected = 'bar undefined';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return template literal with expression type wrapped in curly braces', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***noop`bar $***REMOVED***baz()***REMOVED***`***REMOVED*** />');

      const expected = 'bar ***REMOVED***CallExpression***REMOVED***';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should ignore non-expressions in the template literal', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***noop`bar $***REMOVED***<baz />***REMOVED***`***REMOVED*** />');

      const expected = 'bar ';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Arrow function expression', () => ***REMOVED***
    it('should return a function', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED*** () => ***REMOVED*** return "bar"; ***REMOVED******REMOVED*** />');

      const expected = 'function';
      const actual = getPropValue(prop);

      assert.equal(expected, typeof actual);

      // For code coverage ¯\_(ツ)_/¯
      actual();
    ***REMOVED***);
    it('should handle ArrowFunctionExpression as conditional consequent', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED*** (true) ? () => null : () => (***REMOVED******REMOVED***)***REMOVED*** />');

      const expected = 'function';
      const actual = getPropValue(prop);

      assert.equal(expected, typeof actual);

      // For code coverage ¯\_(ツ)_/¯
      actual();
    ***REMOVED***);
  ***REMOVED***);

  describe('Function expression', () => ***REMOVED***
    it('should return a function', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED*** function() ***REMOVED*** return "bar"; ***REMOVED*** ***REMOVED*** />');

      const expected = 'function';
      const actual = getPropValue(prop);

      assert.equal(expected, typeof actual);

      // For code coverage ¯\_(ツ)_/¯
      actual();
    ***REMOVED***);
  ***REMOVED***);

  describe('Logical expression', () => ***REMOVED***
    it('should correctly infer result of && logical expression based on derived values', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar && baz***REMOVED*** />');

      const expected = 'baz';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return undefined when evaluating `undefined && undefined` ', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***undefined && undefined***REMOVED*** />');

      const expected = undefined;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly infer result of || logical expression based on derived values', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar || baz***REMOVED*** />');

      const expected = 'bar';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly infer result of || logical expression based on derived values', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***undefined || baz***REMOVED*** />');

      const expected = 'baz';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return undefined when evaluating `undefined || undefined` ', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***undefined || undefined***REMOVED*** />');

      const expected = undefined;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Member expression', () => ***REMOVED***
    it('should return string representation of form `object.property`', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar.baz***REMOVED*** />');

      const expected = 'bar.baz';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate to a correct representation of member expression with a nullable member', () => ***REMOVED***
      const runTest = () => ***REMOVED***
        const prop = extractProp('<div foo=***REMOVED***bar?.baz***REMOVED*** />');

        const expected = 'bar?.baz';
        const actual = getPropValue(prop);

        assert.equal(expected, actual);
      ***REMOVED***;

      if (fallbackToBabylon) ***REMOVED***
        // eslint-disable-next-line no-undef
        expect(runTest).toThrow();
      ***REMOVED*** else ***REMOVED***
        runTest();
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);

  describe('Call expression', () => ***REMOVED***
    it('should return string representation of callee', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar()***REMOVED*** />');

      const expected = 'bar';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return string representation of callee', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar.call()***REMOVED*** />');

      const expected = 'bar.call';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Unary expression', () => ***REMOVED***
    it('should correctly evaluate an expression that prefixes with -', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***-bar***REMOVED*** />');

      // -"bar" => NaN
      const expected = true;
      const actual = Number.isNaN(getPropValue(prop));

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with -', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***-42***REMOVED*** />');

      const expected = -42;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with +', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***+bar***REMOVED*** />');

      // +"bar" => NaN
      const expected = true;
      const actual = Number.isNaN(getPropValue(prop));

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with +', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***+42***REMOVED*** />');

      const expected = 42;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with !', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***!bar***REMOVED*** />');

      const expected = false; // !"bar" === false
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with ~', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***~bar***REMOVED*** />');

      const expected = -1; // ~"bar" === -1
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return true when evaluating `delete foo`', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***delete x***REMOVED*** />');

      const expected = true;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return undefined when evaluating `void foo`', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***void x***REMOVED*** />');

      const expected = undefined;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    // TODO: We should fix this to check to see if we can evaluate it.
    it('should return undefined when evaluating `typeof foo`', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***typeof x***REMOVED*** />');

      const expected = undefined;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Update expression', () => ***REMOVED***
    it('should correctly evaluate an expression that prefixes with ++', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***++bar***REMOVED*** />');

      // ++"bar" => NaN
      const expected = true;
      const actual = Number.isNaN(getPropValue(prop));

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with --', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***--bar***REMOVED*** />');

      const expected = true;
      const actual = Number.isNaN(getPropValue(prop));

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that suffixes with ++', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar++***REMOVED*** />');

      // "bar"++ => NaN
      const expected = true;
      const actual = Number.isNaN(getPropValue(prop));

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that suffixes with --', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar--***REMOVED*** />');

      const expected = true;
      const actual = Number.isNaN(getPropValue(prop));

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('This expression', () => ***REMOVED***
    it('should return string value `this`', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***this***REMOVED*** />');

      const expected = 'this';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Conditional expression', () => ***REMOVED***
    it('should evaluate the conditional based on the derived values correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar ? baz : bam***REMOVED*** />');

      const expected = 'baz';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the conditional based on the derived values correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***undefined ? baz : bam***REMOVED*** />');

      const expected = 'bam';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the conditional based on the derived values correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***(1 > 2) ? baz : bam***REMOVED*** />');

      const expected = 'bam';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Binary expression', () => ***REMOVED***
    it('should evaluate the `==` operator correctly', () => ***REMOVED***
      const trueProp = extractProp('<div foo=***REMOVED***1 == "1"***REMOVED*** />');
      const falseProp = extractProp('<div foo=***REMOVED***1 == bar***REMOVED*** />');

      const trueVal = getPropValue(trueProp);
      const falseVal = getPropValue(falseProp);

      assert.equal(true, trueVal);
      assert.equal(false, falseVal);
    ***REMOVED***);

    it('should evaluate the `!=` operator correctly', () => ***REMOVED***
      const trueProp = extractProp('<div foo=***REMOVED***1 != "2"***REMOVED*** />');
      const falseProp = extractProp('<div foo=***REMOVED***1 != "1"***REMOVED*** />');

      const trueVal = getPropValue(trueProp);
      const falseVal = getPropValue(falseProp);

      assert.equal(true, trueVal);
      assert.equal(false, falseVal);
    ***REMOVED***);

    it('should evaluate the `===` operator correctly', () => ***REMOVED***
      const trueProp = extractProp('<div foo=***REMOVED***1 === 1***REMOVED*** />');
      const falseProp = extractProp('<div foo=***REMOVED***1 === "1"***REMOVED*** />');

      const trueVal = getPropValue(trueProp);
      const falseVal = getPropValue(falseProp);

      assert.equal(true, trueVal);
      assert.equal(false, falseVal);
    ***REMOVED***);

    it('should evaluate the `!==` operator correctly', () => ***REMOVED***
      const trueProp = extractProp('<div foo=***REMOVED***1 !== "1"***REMOVED*** />');
      const falseProp = extractProp('<div foo=***REMOVED***1 !== 1***REMOVED*** />');

      const trueVal = getPropValue(trueProp);
      const falseVal = getPropValue(falseProp);

      assert.equal(true, trueVal);
      assert.equal(false, falseVal);
    ***REMOVED***);

    it('should evaluate the `<` operator correctly', () => ***REMOVED***
      const trueProp = extractProp('<div foo=***REMOVED***1 < 2***REMOVED*** />');
      const falseProp = extractProp('<div foo=***REMOVED***1 < 0***REMOVED*** />');

      const trueVal = getPropValue(trueProp);
      const falseVal = getPropValue(falseProp);

      assert.equal(true, trueVal);
      assert.equal(false, falseVal);
    ***REMOVED***);

    it('should evaluate the `>` operator correctly', () => ***REMOVED***
      const trueProp = extractProp('<div foo=***REMOVED***1 > 0***REMOVED*** />');
      const falseProp = extractProp('<div foo=***REMOVED***1 > 2***REMOVED*** />');

      const trueVal = getPropValue(trueProp);
      const falseVal = getPropValue(falseProp);

      assert.equal(true, trueVal);
      assert.equal(false, falseVal);
    ***REMOVED***);

    it('should evaluate the `<=` operator correctly', () => ***REMOVED***
      const trueProp = extractProp('<div foo=***REMOVED***1 <= 1***REMOVED*** />');
      const falseProp = extractProp('<div foo=***REMOVED***1 <= 0***REMOVED*** />');

      const trueVal = getPropValue(trueProp);
      const falseVal = getPropValue(falseProp);

      assert.equal(true, trueVal);
      assert.equal(false, falseVal);
    ***REMOVED***);

    it('should evaluate the `>=` operator correctly', () => ***REMOVED***
      const trueProp = extractProp('<div foo=***REMOVED***1 >= 1***REMOVED*** />');
      const falseProp = extractProp('<div foo=***REMOVED***1 >= 2***REMOVED*** />');

      const trueVal = getPropValue(trueProp);
      const falseVal = getPropValue(falseProp);

      assert.equal(true, trueVal);
      assert.equal(false, falseVal);
    ***REMOVED***);

    it('should evaluate the `<<` operator correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***1 << 2***REMOVED*** />');

      const expected = 4;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the `>>` operator correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***1 >> 2***REMOVED*** />');

      const expected = 0;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the `>>>` operator correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***2 >>> 1***REMOVED*** />');

      const expected = 1;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the `+` operator correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***1 + 1***REMOVED*** />');

      const expected = 2;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the `-` operator correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***1 - 1***REMOVED*** />');

      const expected = 0;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the `*` operator correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***10 * 10***REMOVED*** />');

      const expected = 100;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the `/` operator correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***10 / 2***REMOVED*** />');

      const expected = 5;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the `%` operator correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***10 % 3***REMOVED*** />');

      const expected = 1;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the `|` operator correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***10 | 1***REMOVED*** />');

      const expected = 11;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the `^` operator correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***10 ^ 1***REMOVED*** />');

      const expected = 11;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the `&` operator correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***10 & 1***REMOVED*** />');

      const expected = 0;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the `in` operator correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***foo in bar***REMOVED*** />');

      const expected = false;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the `instanceof` operator correctly', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED******REMOVED******REMOVED*** instanceof Object***REMOVED*** />');

      const expected = true;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should evaluate the `instanceof` operator when right side is not a function', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***"bar" instanceof Baz***REMOVED*** />');

      const expected = false;
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Object expression', () => ***REMOVED***
    it('should evaluate to a correct representation of the object in props', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED*** ***REMOVED*** bar: "baz" ***REMOVED*** ***REMOVED*** />');

      const expected = ***REMOVED*** bar: 'baz' ***REMOVED***;
      const actual = getPropValue(prop);

      assert.deepEqual(expected, actual);
    ***REMOVED***);

    it('should evaluate to a correct representation of the object, ignore spread properties', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED******REMOVED***bar: "baz", ...***REMOVED***baz: "bar", foo: ***REMOVED***...***REMOVED***bar: "meh"***REMOVED******REMOVED******REMOVED******REMOVED******REMOVED*** />');

      const expected = ***REMOVED*** bar: 'baz', baz: 'bar', foo: ***REMOVED*** bar: 'meh' ***REMOVED*** ***REMOVED***;
      const actual = getPropValue(prop);

      assert.deepEqual(expected, actual);
    ***REMOVED***);

    it('should evaluate to a correct representation of the object, ignore spread properties', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED******REMOVED*** pathname: manageRoute, state: ***REMOVED***...data***REMOVED******REMOVED******REMOVED*** />');

      const expected = ***REMOVED*** pathname: 'manageRoute', state: ***REMOVED******REMOVED*** ***REMOVED***;
      const actual = getPropValue(prop);

      assert.deepEqual(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('New expression', () => ***REMOVED***
    it('should return a new empty object', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***new Bar()***REMOVED*** />');

      const expected = ***REMOVED******REMOVED***;
      const actual = getPropValue(prop);

      assert.deepEqual(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Array expression', () => ***REMOVED***
    it('should evaluate to correct representation of the the array in props', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***["bar", 42, null]***REMOVED*** />');

      const expected = ['bar', 42, null];
      const actual = getPropValue(prop);

      assert.deepEqual(expected, actual);
    ***REMOVED***);

    it('should evaluate to a correct representation of an array with spread elements', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***[...this.props.params, bar]***REMOVED*** />');

      const expected = [undefined, 'bar'];
      const actual = getPropValue(prop);

      assert.deepEqual(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  it('should return an empty array provided an empty array in props', () => ***REMOVED***
    const prop = extractProp('<div foo=***REMOVED***[]***REMOVED*** />');

    const expected = [];
    const actual = getPropValue(prop);

    assert.deepEqual(expected, actual);
  ***REMOVED***);

  describe('Bind expression', () => ***REMOVED***
    it('should return string representation of bind function call when object is null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***::this.handleClick***REMOVED*** />');

      const expected = 'this.handleClick.bind(this)';
      const actual = getPropValue(prop);

      assert.deepEqual(expected, actual);
    ***REMOVED***);

    it('should return string representation of bind function call when object is not null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***foo::bar***REMOVED*** />');

      const expected = 'bar.bind(foo)';
      const actual = getPropValue(prop);

      assert.deepEqual(expected, actual);
    ***REMOVED***);

    it('should return string representation of bind function call when binding to object properties', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***a.b::c***REMOVED*** />');
      const otherProp = extractProp('<div foo=***REMOVED***::a.b.c***REMOVED*** />');

      const expected = 'a.b.c.bind(a.b)';
      const actual = getPropValue(prop);

      const otherExpected = 'a.b.c.bind(a.b)';
      const otherActual = getPropValue(otherProp);

      assert.deepEqual(expected, actual);
      assert.deepEqual(otherExpected, otherActual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Type Cast Expression', () => ***REMOVED***
    it('should throw a parsing error', () => ***REMOVED***
      let counter = 0;
      // eslint-disable-next-line no-console
      const warnOrig = console.warn;
      // eslint-disable-next-line no-console
      console.warn = () => ***REMOVED***
        counter += 1;
      ***REMOVED***;
      // eslint-disable-next-line no-undef
      expect(() => ***REMOVED***
        extractProp('<div foo=***REMOVED***(this.handleClick: (event: MouseEvent) => void))***REMOVED*** />');
      ***REMOVED***).toThrow();
      assert.equal(counter, 1);
      // eslint-disable-next-line no-console
      console.warn = warnOrig;
    ***REMOVED***);
  ***REMOVED***);

  describeIfNotBabylon('Typescript', () => ***REMOVED***
    beforeEach(() => ***REMOVED***
      changePlugins(pls => [...pls, 'typescript']);
    ***REMOVED***);

    it('should return string representation of variable identifier wrapped in a Typescript non-null assertion', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar!***REMOVED*** />');

      const expected = 'bar';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return string representation of variable identifier wrapped in a deep Typescript non-null assertion', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***(bar!)!***REMOVED*** />');

      const expected = 'bar';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return string representation of variable identifier wrapped in a Typescript type coercion', () => ***REMOVED***
      changePlugins(pls => [...pls, 'typescript']);
      const prop = extractProp('<div foo=***REMOVED***bar as any***REMOVED*** />');

      const expected = 'bar';
      const actual = getPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***);
