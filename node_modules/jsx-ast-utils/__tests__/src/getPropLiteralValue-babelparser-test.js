/* eslint-env mocha */
/* eslint no-template-curly-in-string: 0 */
import assert from 'assert';
import ***REMOVED***
  extractProp,
  describeIfNotBabylon,
  changePlugins,
  setParserName,
***REMOVED*** from '../helper';
import ***REMOVED*** getLiteralPropValue ***REMOVED*** from '../../src/getPropValue';

describe('getLiteralPropValue', () => ***REMOVED***
  beforeEach(() => ***REMOVED***
    setParserName('babel');
  ***REMOVED***);
  it('should export a function', () => ***REMOVED***
    const expected = 'function';
    const actual = typeof getLiteralPropValue;

    assert.equal(expected, actual);
  ***REMOVED***);

  it('should return undefined when not provided with a JSXAttribute', () => ***REMOVED***
    const expected = undefined;
    const actual = getLiteralPropValue(1);

    assert.equal(expected, actual);
  ***REMOVED***);

  it('should not throw error when trying to get value from unknown node type', () => ***REMOVED***
    const prop = ***REMOVED***
      type: 'JSXAttribute',
      value: ***REMOVED***
        type: 'JSXExpressionContainer',
      ***REMOVED***,
    ***REMOVED***;
    let counter = 0;
    // eslint-disable-next-line no-console
    const errorOrig = console.error;
    // eslint-disable-next-line no-console
    console.error = () => ***REMOVED***
      counter += 1;
    ***REMOVED***;
    let value;
    assert.doesNotThrow(() => ***REMOVED***
      value = getLiteralPropValue(prop);
    ***REMOVED***, Error);

    assert.equal(null, value);
    assert.equal(counter, 1);
    // eslint-disable-next-line no-console
    console.error = errorOrig;
  ***REMOVED***);

  describe('Null', () => ***REMOVED***
    it('should return true when no value is given', () => ***REMOVED***
      const prop = extractProp('<div foo />');

      const expected = true;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Literal', () => ***REMOVED***
    it('should return correct string if value is a string', () => ***REMOVED***
      const prop = extractProp('<div foo="bar" />');

      const expected = 'bar';
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return correct string if value is a string expression', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***"bar"***REMOVED*** />');

      const expected = 'bar';
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return correct integer if value is a integer expression', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***1***REMOVED*** />');

      const expected = 1;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should convert "true" to boolean type', () => ***REMOVED***
      const prop = extractProp('<div foo="true" />');

      const expected = true;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should convert "TrUE" to boolean type', () => ***REMOVED***
      const prop = extractProp('<div foo="TrUE" />');

      const expected = true;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should convert "false" to boolean type', () => ***REMOVED***
      const prop = extractProp('<div foo="false" />');

      const expected = false;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should convert "FaLsE" to boolean type', () => ***REMOVED***
      const prop = extractProp('<div foo="FaLsE" />');

      const expected = false;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return String null when value is null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***null***REMOVED*** />');

      const expected = 'null';
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('JSXElement', () => ***REMOVED***
    it('should return null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***<bar />***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Identifier', () => ***REMOVED***
    it('should return null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return undefined when identifier is literally `undefined`', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***undefined***REMOVED*** />');

      const expected = undefined;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Template literal', () => ***REMOVED***
    it('should return template literal with vars wrapped in curly braces', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***`bar $***REMOVED***baz***REMOVED***`***REMOVED*** />');

      const expected = 'bar ***REMOVED***baz***REMOVED***';
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return string "undefined" for expressions that evaluate to undefined', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***`bar $***REMOVED***undefined***REMOVED***`***REMOVED*** />');

      const expected = 'bar undefined';
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Tagged Template literal', () => ***REMOVED***
    it('should return template literal with vars wrapped in curly braces', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***noop`bar $***REMOVED***baz***REMOVED***`***REMOVED*** />');

      const expected = 'bar ***REMOVED***baz***REMOVED***';
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return string "undefined" for expressions that evaluate to undefined', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***noop`bar $***REMOVED***undefined***REMOVED***`***REMOVED*** />');

      const expected = 'bar undefined';
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Arrow function expression', () => ***REMOVED***
    it('should return null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED*** () => ***REMOVED*** return "bar"; ***REMOVED******REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Function expression', () => ***REMOVED***
    it('should return null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED*** function() ***REMOVED*** return "bar"; ***REMOVED*** ***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Logical expression', () => ***REMOVED***
    it('should return null for && operator', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar && baz***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return null for || operator', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar || baz***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Member expression', () => ***REMOVED***
    it('should return null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar.baz***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Call expression', () => ***REMOVED***
    it('should return null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar()***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Unary expression', () => ***REMOVED***
    it('should correctly evaluate an expression that prefixes with -', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***-bar***REMOVED*** />');

      // -"bar" => NaN
      const expected = true;
      const actual = Number.isNaN(getLiteralPropValue(prop));

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with -', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***-42***REMOVED*** />');

      const expected = -42;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with +', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***+bar***REMOVED*** />');

      // +"bar" => NaN
      const expected = true;
      const actual = Number.isNaN(getLiteralPropValue(prop));

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with +', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***+42***REMOVED*** />');

      const expected = 42;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with !', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***!bar***REMOVED*** />');

      const expected = false; // !"bar" === false
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with ~', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***~bar***REMOVED*** />');

      const expected = -1; // ~"bar" === -1
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return true when evaluating `delete foo`', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***delete x***REMOVED*** />');

      const expected = true;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return undefined when evaluating `void foo`', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***void x***REMOVED*** />');

      const expected = undefined;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    // TODO: We should fix this to check to see if we can evaluate it.
    it('should return undefined when evaluating `typeof foo`', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***typeof x***REMOVED*** />');

      const expected = undefined;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Update expression', () => ***REMOVED***
    it('should correctly evaluate an expression that prefixes with ++', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***++bar***REMOVED*** />');

      // ++"bar" => NaN
      const expected = true;
      const actual = Number.isNaN(getLiteralPropValue(prop));

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with --', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***--bar***REMOVED*** />');

      // --"bar" => NaN
      const expected = true;
      const actual = Number.isNaN(getLiteralPropValue(prop));

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that suffixes with ++', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar++***REMOVED*** />');

      // "bar"++ => NaN
      const expected = true;
      const actual = Number.isNaN(getLiteralPropValue(prop));

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should correctly evaluate an expression that suffixes with --', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar--***REMOVED*** />');

      // "bar"-- => NaN
      const expected = true;
      const actual = Number.isNaN(getLiteralPropValue(prop));

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('This expression', () => ***REMOVED***
    it('should return null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***this***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Conditional expression', () => ***REMOVED***
    it('should return null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar ? baz : bam***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Binary expression', () => ***REMOVED***
    it('should return null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***1 == "1"***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Object expression', () => ***REMOVED***
    it('should return null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED*** ***REMOVED*** bar: "baz" ***REMOVED*** ***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.deepEqual(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('New expression', () => ***REMOVED***
    it('should return null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***new Bar()***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.deepEqual(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describe('Array expression', () => ***REMOVED***
    it('should evaluate to correct representation of the the array in props', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***["bar", 42, null]***REMOVED*** />');

      const expected = ['bar', 42];
      const actual = getLiteralPropValue(prop);

      assert.deepEqual(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  it('should return an empty array provided an empty array in props', () => ***REMOVED***
    const prop = extractProp('<div foo=***REMOVED***[]***REMOVED*** />');

    const expected = [];
    const actual = getLiteralPropValue(prop);

    assert.deepEqual(expected, actual);
  ***REMOVED***);

  describe('Bind expression', () => ***REMOVED***
    it('should return null', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***::this.handleClick***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.deepEqual(expected, actual);
    ***REMOVED***);
  ***REMOVED***);

  describeIfNotBabylon('Typescript', () => ***REMOVED***
    beforeEach(() => ***REMOVED***
      changePlugins(pls => [...pls, 'typescript']);
    ***REMOVED***);

    it('should return string representation of variable identifier wrapped in a Typescript non-null assertion', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***bar!***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return string representation of variable identifier wrapped in a deep Typescript non-null assertion', () => ***REMOVED***
      const prop = extractProp('<div foo=***REMOVED***(bar!)!***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);

    it('should return string representation of variable identifier wrapped in a Typescript type coercion', () => ***REMOVED***
      changePlugins(pls => [...pls, 'typescript']);
      const prop = extractProp('<div foo=***REMOVED***bar as any***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(expected, actual);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***);
