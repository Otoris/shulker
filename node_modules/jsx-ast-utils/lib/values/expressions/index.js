'use strict';

Object.defineProperty(exports, "__esModule", ***REMOVED***
  value: true
***REMOVED***);
exports.default = extract;
exports.extractLiteral = extractLiteral;

var _object = require('object.assign');

var _object2 = _interopRequireDefault(_object);

var _Literal = require('../Literal');

var _Literal2 = _interopRequireDefault(_Literal);

var _JSXElement = require('../JSXElement');

var _JSXElement2 = _interopRequireDefault(_JSXElement);

var _Identifier = require('./Identifier');

var _Identifier2 = _interopRequireDefault(_Identifier);

var _TaggedTemplateExpression = require('./TaggedTemplateExpression');

var _TaggedTemplateExpression2 = _interopRequireDefault(_TaggedTemplateExpression);

var _TemplateLiteral = require('./TemplateLiteral');

var _TemplateLiteral2 = _interopRequireDefault(_TemplateLiteral);

var _FunctionExpression = require('./FunctionExpression');

var _FunctionExpression2 = _interopRequireDefault(_FunctionExpression);

var _LogicalExpression = require('./LogicalExpression');

var _LogicalExpression2 = _interopRequireDefault(_LogicalExpression);

var _MemberExpression = require('./MemberExpression');

var _MemberExpression2 = _interopRequireDefault(_MemberExpression);

var _OptionalMemberExpression = require('./OptionalMemberExpression');

var _OptionalMemberExpression2 = _interopRequireDefault(_OptionalMemberExpression);

var _CallExpression = require('./CallExpression');

var _CallExpression2 = _interopRequireDefault(_CallExpression);

var _UnaryExpression = require('./UnaryExpression');

var _UnaryExpression2 = _interopRequireDefault(_UnaryExpression);

var _ThisExpression = require('./ThisExpression');

var _ThisExpression2 = _interopRequireDefault(_ThisExpression);

var _ConditionalExpression = require('./ConditionalExpression');

var _ConditionalExpression2 = _interopRequireDefault(_ConditionalExpression);

var _BinaryExpression = require('./BinaryExpression');

var _BinaryExpression2 = _interopRequireDefault(_BinaryExpression);

var _ObjectExpression = require('./ObjectExpression');

var _ObjectExpression2 = _interopRequireDefault(_ObjectExpression);

var _NewExpression = require('./NewExpression');

var _NewExpression2 = _interopRequireDefault(_NewExpression);

var _UpdateExpression = require('./UpdateExpression');

var _UpdateExpression2 = _interopRequireDefault(_UpdateExpression);

var _ArrayExpression = require('./ArrayExpression');

var _ArrayExpression2 = _interopRequireDefault(_ArrayExpression);

var _BindExpression = require('./BindExpression');

var _BindExpression2 = _interopRequireDefault(_BindExpression);

var _SpreadElement = require('./SpreadElement');

var _SpreadElement2 = _interopRequireDefault(_SpreadElement);

var _TypeCastExpression = require('./TypeCastExpression');

var _TypeCastExpression2 = _interopRequireDefault(_TypeCastExpression);

function _interopRequireDefault(obj) ***REMOVED*** return obj && obj.__esModule ? obj : ***REMOVED*** default: obj ***REMOVED***; ***REMOVED***

// Composition map of types to their extractor functions.
var TYPES = ***REMOVED***
  Identifier: _Identifier2.default,
  Literal: _Literal2.default,
  JSXElement: _JSXElement2.default,
  TaggedTemplateExpression: _TaggedTemplateExpression2.default,
  TemplateLiteral: _TemplateLiteral2.default,
  ArrowFunctionExpression: _FunctionExpression2.default,
  FunctionExpression: _FunctionExpression2.default,
  LogicalExpression: _LogicalExpression2.default,
  MemberExpression: _MemberExpression2.default,
  OptionalMemberExpression: _OptionalMemberExpression2.default,
  CallExpression: _CallExpression2.default,
  UnaryExpression: _UnaryExpression2.default,
  ThisExpression: _ThisExpression2.default,
  ConditionalExpression: _ConditionalExpression2.default,
  BinaryExpression: _BinaryExpression2.default,
  ObjectExpression: _ObjectExpression2.default,
  NewExpression: _NewExpression2.default,
  UpdateExpression: _UpdateExpression2.default,
  ArrayExpression: _ArrayExpression2.default,
  BindExpression: _BindExpression2.default,
  SpreadElement: _SpreadElement2.default,
  TypeCastExpression: _TypeCastExpression2.default
***REMOVED***;

var noop = function noop() ***REMOVED***
  return null;
***REMOVED***;

var errorMessage = function errorMessage(expression) ***REMOVED***
  return 'The prop value with an expression type of ' + expression + ' could not be resolved. Please file issue to get this fixed immediately.';
***REMOVED***;

/**
 * This function maps an AST value node
 * to its correct extractor function for its
 * given type.
 *
 * This will map correctly for *all* possible expression types.
 *
 * @param - value - AST Value object with type `JSXExpressionContainer`
 * @returns The extracted value.
 */
function extract(value) ***REMOVED***
  // Value will not have the expression property when we recurse.
  // The type for expression on ArrowFunctionExpression is a boolean.
  var expression = void 0;
  if (typeof value.expression !== 'boolean' && value.expression) ***REMOVED***
    expression = value.expression; // eslint-disable-line prefer-destructuring
  ***REMOVED*** else ***REMOVED***
    expression = value;
  ***REMOVED***
  var _expression = expression,
      type = _expression.type;


  while (type === 'TSNonNullExpression' || type === 'TSAsExpression') ***REMOVED***
    var _expression2 = expression;
    type = _expression2.type;

    if (expression.expression) ***REMOVED***
      var _expression3 = expression;
      expression = _expression3.expression;
    ***REMOVED***
  ***REMOVED***

  if (TYPES[type] === undefined) ***REMOVED***
    // eslint-disable-next-line no-console
    console.error(errorMessage(type));
    return null;
  ***REMOVED***

  return TYPES[type](expression);
***REMOVED***

// Composition map of types to their extractor functions to handle literals.
var LITERAL_TYPES = (0, _object2.default)(***REMOVED******REMOVED***, TYPES, ***REMOVED***
  Literal: function Literal(value) ***REMOVED***
    var extractedVal = TYPES.Literal.call(undefined, value);
    var isNull = extractedVal === null;
    // This will be convention for attributes that have null
    // value explicitly defined (<div prop=***REMOVED***null***REMOVED*** /> maps to 'null').
    return isNull ? 'null' : extractedVal;
  ***REMOVED***,
  Identifier: function Identifier(value) ***REMOVED***
    var isUndefined = TYPES.Identifier.call(undefined, value) === undefined;
    return isUndefined ? undefined : null;
  ***REMOVED***,
  JSXElement: noop,
  ArrowFunctionExpression: noop,
  FunctionExpression: noop,
  LogicalExpression: noop,
  MemberExpression: noop,
  OptionalMemberExpression: noop,
  CallExpression: noop,
  UnaryExpression: function UnaryExpression(value) ***REMOVED***
    var extractedVal = TYPES.UnaryExpression.call(undefined, value);
    return extractedVal === undefined ? null : extractedVal;
  ***REMOVED***,
  UpdateExpression: function UpdateExpression(value) ***REMOVED***
    var extractedVal = TYPES.UpdateExpression.call(undefined, value);
    return extractedVal === undefined ? null : extractedVal;
  ***REMOVED***,
  ThisExpression: noop,
  ConditionalExpression: noop,
  BinaryExpression: noop,
  ObjectExpression: noop,
  NewExpression: noop,
  ArrayExpression: function ArrayExpression(value) ***REMOVED***
    var extractedVal = TYPES.ArrayExpression.call(undefined, value);
    return extractedVal.filter(function (val) ***REMOVED***
      return val !== null;
    ***REMOVED***);
  ***REMOVED***,
  BindExpression: noop,
  SpreadElement: noop,
  TSNonNullExpression: noop,
  TSAsExpression: noop,
  TypeCastExpression: noop
***REMOVED***);

/**
 * This function maps an AST value node
 * to its correct extractor function for its
 * given type.
 *
 * This will map correctly for *some* possible types that map to literals.
 *
 * @param - value - AST Value object with type `JSXExpressionContainer`
 * @returns The extracted value.
 */
function extractLiteral(value) ***REMOVED***
  // Value will not have the expression property when we recurse.
  var expression = value.expression || value;
  var type = expression.type;


  if (LITERAL_TYPES[type] === undefined) ***REMOVED***
    // eslint-disable-next-line no-console
    console.error(errorMessage(type));
    return null;
  ***REMOVED***

  return LITERAL_TYPES[type](expression);
***REMOVED***