"use strict";

function _defineProperties(target, props) ***REMOVED*** for (var i = 0; i < props.length; i++) ***REMOVED*** var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); ***REMOVED*** ***REMOVED***

function _createClass(Constructor, protoProps, staticProps) ***REMOVED*** if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; ***REMOVED***

function _classCallCheck(instance, Constructor) ***REMOVED*** if (!(instance instanceof Constructor)) ***REMOVED*** throw new TypeError("Cannot call a class as a function"); ***REMOVED*** ***REMOVED***

// A simple implementation of make-array
function makeArray(subject) ***REMOVED***
  return Array.isArray(subject) ? subject : [subject];
***REMOVED***

var REGEX_TEST_BLANK_LINE = /^\s+$/;
var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
var REGEX_SPLITALL_CRLF = /\r?\n/g; // /foo,
// ./foo,
// ../foo,
// .
// ..

var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
var SLASH = '/';
var KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol["for"]('node-ignore')
/* istanbul ignore next */
: 'node-ignore';

var define = function define(object, key, value) ***REMOVED***
  return Object.defineProperty(object, key, ***REMOVED***
    value: value
  ***REMOVED***);
***REMOVED***;

var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g; // Sanitize the range of a regular expression
// The cases are complicated, see test cases for details

var sanitizeRange = function sanitizeRange(range) ***REMOVED***
  return range.replace(REGEX_REGEXP_RANGE, function (match, from, to) ***REMOVED***
    return from.charCodeAt(0) <= to.charCodeAt(0) ? match // Invalid range (out of order) which is ok for gitignore rules but
    //   fatal for JavaScript regular expression, so eliminate it.
    : '';
  ***REMOVED***);
***REMOVED***; // > If the pattern ends with a slash,
// > it is removed for the purpose of the following description,
// > but it would only find a match with a directory.
// > In other words, foo/ will match a directory foo and paths underneath it,
// > but will not match a regular file or a symbolic link foo
// >  (this is consistent with the way how pathspec works in general in Git).
// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'
// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call
//      you could use option `mark: true` with `glob`
// '`foo/`' should not continue with the '`..`'


var REPLACERS = [// > Trailing spaces are ignored unless they are quoted with backslash ("\")
[// (a\ ) -> (a )
// (a  ) -> (a)
// (a \ ) -> (a  )
/\\?\s+$/, function (match) ***REMOVED***
  return match.indexOf('\\') === 0 ? ' ' : '';
***REMOVED***], // replace (\ ) with ' '
[/\\\s/g, function () ***REMOVED***
  return ' ';
***REMOVED***], // Escape metacharacters
// which is written down by users but means special for regular expressions.
// > There are 12 characters with special meanings:
// > - the backslash \,
// > - the caret ^,
// > - the dollar sign $,
// > - the period or dot .,
// > - the vertical bar or pipe symbol |,
// > - the question mark ?,
// > - the asterisk or star *,
// > - the plus sign +,
// > - the opening parenthesis (,
// > - the closing parenthesis ),
// > - and the opening square bracket [,
// > - the opening curly brace ***REMOVED***,
// > These special characters are often called "metacharacters".
[/[\\^$.|*+()***REMOVED***]/g, function (match) ***REMOVED***
  return "\\".concat(match);
***REMOVED***], [// > [abc] matches any character inside the brackets
// >    (in this case a, b, or c);
/\[([^\]/]*)($|\])/g, function (match, p1, p2) ***REMOVED***
  return p2 === ']' ? "[".concat(sanitizeRange(p1), "]") : "\\".concat(match);
***REMOVED***], [// > a question mark (?) matches a single character
/(?!\\)\?/g, function () ***REMOVED***
  return '[^/]';
***REMOVED***], // leading slash
[// > A leading slash matches the beginning of the pathname.
// > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
// A leading slash matches the beginning of the pathname
/^\//, function () ***REMOVED***
  return '^';
***REMOVED***], // replace special metacharacter slash after the leading slash
[/\//g, function () ***REMOVED***
  return '\\/';
***REMOVED***], [// > A leading "**" followed by a slash means match in all directories.
// > For example, "**/foo" matches file or directory "foo" anywhere,
// > the same as pattern "foo".
// > "**/foo/bar" matches file or directory "bar" anywhere that is directly
// >   under directory "foo".
// Notice that the '*'s have been replaced as '\\*'
/^\^*\\\*\\\*\\\//, // '**/foo' <-> 'foo'
function () ***REMOVED***
  return '^(?:.*\\/)?';
***REMOVED***], // ending
[// 'js' will not match 'js.'
// 'ab' will not match 'abc'
/(?:[^*])$/, // WTF!
// https://git-scm.com/docs/gitignore
// changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
// which re-fixes #24, #38
// > If there is a separator at the end of the pattern then the pattern
// > will only match directories, otherwise the pattern can match both
// > files and directories.
// 'js*' will not match 'a.js'
// 'js/' will not match 'a.js'
// 'js' will match 'a.js' and 'a.js/'
function (match) ***REMOVED***
  return /\/$/.test(match) // foo/ will not match 'foo'
  ? "".concat(match, "$") // foo matches 'foo' and 'foo/'
  : "".concat(match, "(?=$|\\/$)");
***REMOVED***], // starting
[// there will be no leading '/'
//   (which has been replaced by section "leading slash")
// If starts with '**', adding a '^' to the regular expression also works
/^(?=[^^])/, function startingReplacer() ***REMOVED***
  // If has a slash `/` at the beginning or middle
  return !/\/(?!$)/.test(this) // > Prior to 2.22.1
  // > If the pattern does not contain a slash /,
  // >   Git treats it as a shell glob pattern
  // Actually, if there is only a trailing slash,
  //   git also treats it as a shell glob pattern
  // After 2.22.1 (compatible but clearer)
  // > If there is a separator at the beginning or middle (or both)
  // > of the pattern, then the pattern is relative to the directory
  // > level of the particular .gitignore file itself.
  // > Otherwise the pattern may also match at any level below
  // > the .gitignore level.
  ? '(?:^|\\/)' // > Otherwise, Git treats the pattern as a shell glob suitable for
  // >   consumption by fnmatch(3)
  : '^';
***REMOVED***], // two globstars
[// Use lookahead assertions so that we could match more than one `'/**'`
/\\\/\\\*\\\*(?=\\\/|$)/g, // Zero, one or several directories
// should not use '*', or it will be replaced by the next replacer
// Check if it is not the last `'/**'`
function (_, index, str) ***REMOVED***
  return index + 6 < str.length // case: /**/
  // > A slash followed by two consecutive asterisks then a slash matches
  // >   zero or more directories.
  // > For example, "a/**/b" matches "a/b", "a/x/b", "a/x/y/b" and so on.
  // '/**/'
  ? '(?:\\/[^\\/]+)*' // case: /**
  // > A trailing `"/**"` matches everything inside.
  // #21: everything inside but it should not include the current folder
  : '\\/.+';
***REMOVED***], // intermediate wildcards
[// Never replace escaped '*'
// ignore rule '\*' will match the path '*'
// 'abc.*/' -> go
// 'abc.*'  -> skip this rule
/(^|[^\\]+)\\\*(?=.+)/g, // '*.js' matches '.js'
// '*.js' doesn't match 'abc'
function (_, p1) ***REMOVED***
  return "".concat(p1, "[^\\/]*");
***REMOVED***], // trailing wildcard
[/(\^|\\\/)?\\\*$/, function (_, p1) ***REMOVED***
  var prefix = p1 // '\^':
  // '/*' does not match ''
  // '/*' does not match everything
  // '\\\/':
  // 'abc/*' does not match 'abc/'
  ? "".concat(p1, "[^/]+") // 'a*' matches 'a'
  // 'a*' matches 'aa'
  : '[^/]*';
  return "".concat(prefix, "(?=$|\\/$)");
***REMOVED***], [// unescape
/\\\\\\/g, function () ***REMOVED***
  return '\\';
***REMOVED***]]; // A simple cache, because an ignore rule only has only one certain meaning

var regexCache = Object.create(null); // @param ***REMOVED***pattern***REMOVED***

var makeRegex = function makeRegex(pattern, negative, ignorecase) ***REMOVED***
  var r = regexCache[pattern];

  if (r) ***REMOVED***
    return r;
  ***REMOVED*** // const replacers = negative
  //   ? NEGATIVE_REPLACERS
  //   : POSITIVE_REPLACERS


  var source = REPLACERS.reduce(function (prev, current) ***REMOVED***
    return prev.replace(current[0], current[1].bind(pattern));
  ***REMOVED***, pattern);
  return regexCache[pattern] = ignorecase ? new RegExp(source, 'i') : new RegExp(source);
***REMOVED***;

var isString = function isString(subject) ***REMOVED***
  return typeof subject === 'string';
***REMOVED***; // > A blank line matches no files, so it can serve as a separator for readability.


var checkPattern = function checkPattern(pattern) ***REMOVED***
  return pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) // > A line starting with # serves as a comment.
  && pattern.indexOf('#') !== 0;
***REMOVED***;

var splitPattern = function splitPattern(pattern) ***REMOVED***
  return pattern.split(REGEX_SPLITALL_CRLF);
***REMOVED***;

var IgnoreRule = function IgnoreRule(origin, pattern, negative, regex) ***REMOVED***
  _classCallCheck(this, IgnoreRule);

  this.origin = origin;
  this.pattern = pattern;
  this.negative = negative;
  this.regex = regex;
***REMOVED***;

var createRule = function createRule(pattern, ignorecase) ***REMOVED***
  var origin = pattern;
  var negative = false; // > An optional prefix "!" which negates the pattern;

  if (pattern.indexOf('!') === 0) ***REMOVED***
    negative = true;
    pattern = pattern.substr(1);
  ***REMOVED***

  pattern = pattern // > Put a backslash ("\") in front of the first "!" for patterns that
  // >   begin with a literal "!", for example, `"\!important!.txt"`.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!') // > Put a backslash ("\") in front of the first hash for patterns that
  // >   begin with a hash.
  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');
  var regex = makeRegex(pattern, negative, ignorecase);
  return new IgnoreRule(origin, pattern, negative, regex);
***REMOVED***;

var throwError = function throwError(message, Ctor) ***REMOVED***
  throw new Ctor(message);
***REMOVED***;

var checkPath = function checkPath(path, originalPath, doThrow) ***REMOVED***
  if (!isString(path)) ***REMOVED***
    return doThrow("path must be a string, but got `".concat(originalPath, "`"), TypeError);
  ***REMOVED*** // We don't know if we should ignore '', so throw


  if (!path) ***REMOVED***
    return doThrow("path must not be empty", TypeError);
  ***REMOVED*** // Check if it is a relative path


  if (checkPath.isNotRelative(path)) ***REMOVED***
    var r = '`path.relative()`d';
    return doThrow("path should be a ".concat(r, " string, but got \"").concat(originalPath, "\""), RangeError);
  ***REMOVED***

  return true;
***REMOVED***;

var isNotRelative = function isNotRelative(path) ***REMOVED***
  return REGEX_TEST_INVALID_PATH.test(path);
***REMOVED***;

checkPath.isNotRelative = isNotRelative;

checkPath.convert = function (p) ***REMOVED***
  return p;
***REMOVED***;

var Ignore =
/*#__PURE__*/
function () ***REMOVED***
  function Ignore() ***REMOVED***
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ***REMOVED******REMOVED***,
        _ref$ignorecase = _ref.ignorecase,
        ignorecase = _ref$ignorecase === void 0 ? true : _ref$ignorecase;

    _classCallCheck(this, Ignore);

    this._rules = [];
    this._ignorecase = ignorecase;
    define(this, KEY_IGNORE, true);

    this._initCache();
  ***REMOVED***

  _createClass(Ignore, [***REMOVED***
    key: "_initCache",
    value: function _initCache() ***REMOVED***
      this._ignoreCache = Object.create(null);
      this._testCache = Object.create(null);
    ***REMOVED***
  ***REMOVED***, ***REMOVED***
    key: "_addPattern",
    value: function _addPattern(pattern) ***REMOVED***
      // #32
      if (pattern && pattern[KEY_IGNORE]) ***REMOVED***
        this._rules = this._rules.concat(pattern._rules);
        this._added = true;
        return;
      ***REMOVED***

      if (checkPattern(pattern)) ***REMOVED***
        var rule = createRule(pattern, this._ignorecase);
        this._added = true;

        this._rules.push(rule);
      ***REMOVED***
    ***REMOVED*** // @param ***REMOVED***Array<string> | string | Ignore***REMOVED*** pattern

  ***REMOVED***, ***REMOVED***
    key: "add",
    value: function add(pattern) ***REMOVED***
      this._added = false;
      makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this); // Some rules have just added to the ignore,
      // making the behavior changed.

      if (this._added) ***REMOVED***
        this._initCache();
      ***REMOVED***

      return this;
    ***REMOVED*** // legacy

  ***REMOVED***, ***REMOVED***
    key: "addPattern",
    value: function addPattern(pattern) ***REMOVED***
      return this.add(pattern);
    ***REMOVED*** //          |           ignored : unignored
    // negative |   0:0   |   0:1   |   1:0   |   1:1
    // -------- | ------- | ------- | ------- | --------
    //     0    |  TEST   |  TEST   |  SKIP   |    X
    //     1    |  TESTIF |  SKIP   |  TEST   |    X
    // - SKIP: always skip
    // - TEST: always test
    // - TESTIF: only test if checkUnignored
    // - X: that never happen
    // @param ***REMOVED***boolean***REMOVED*** whether should check if the path is unignored,
    //   setting `checkUnignored` to `false` could reduce additional
    //   path matching.
    // @returns ***REMOVED***TestResult***REMOVED*** true if a file is ignored

  ***REMOVED***, ***REMOVED***
    key: "_testOne",
    value: function _testOne(path, checkUnignored) ***REMOVED***
      var ignored = false;
      var unignored = false;

      this._rules.forEach(function (rule) ***REMOVED***
        var negative = rule.negative;

        if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) ***REMOVED***
          return;
        ***REMOVED***

        var matched = rule.regex.test(path);

        if (matched) ***REMOVED***
          ignored = !negative;
          unignored = negative;
        ***REMOVED***
      ***REMOVED***);

      return ***REMOVED***
        ignored: ignored,
        unignored: unignored
      ***REMOVED***;
    ***REMOVED*** // @returns ***REMOVED***TestResult***REMOVED***

  ***REMOVED***, ***REMOVED***
    key: "_test",
    value: function _test(originalPath, cache, checkUnignored, slices) ***REMOVED***
      var path = originalPath // Supports nullable path
      && checkPath.convert(originalPath);
      checkPath(path, originalPath, throwError);
      return this._t(path, cache, checkUnignored, slices);
    ***REMOVED***
  ***REMOVED***, ***REMOVED***
    key: "_t",
    value: function _t(path, cache, checkUnignored, slices) ***REMOVED***
      if (path in cache) ***REMOVED***
        return cache[path];
      ***REMOVED***

      if (!slices) ***REMOVED***
        // path/to/a.js
        // ['path', 'to', 'a.js']
        slices = path.split(SLASH);
      ***REMOVED***

      slices.pop(); // If the path has no parent directory, just test it

      if (!slices.length) ***REMOVED***
        return cache[path] = this._testOne(path, checkUnignored);
      ***REMOVED***

      var parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices); // If the path contains a parent directory, check the parent first


      return cache[path] = parent.ignored // > It is not possible to re-include a file if a parent directory of
      // >   that file is excluded.
      ? parent : this._testOne(path, checkUnignored);
    ***REMOVED***
  ***REMOVED***, ***REMOVED***
    key: "ignores",
    value: function ignores(path) ***REMOVED***
      return this._test(path, this._ignoreCache, false).ignored;
    ***REMOVED***
  ***REMOVED***, ***REMOVED***
    key: "createFilter",
    value: function createFilter() ***REMOVED***
      var _this = this;

      return function (path) ***REMOVED***
        return !_this.ignores(path);
      ***REMOVED***;
    ***REMOVED***
  ***REMOVED***, ***REMOVED***
    key: "filter",
    value: function filter(paths) ***REMOVED***
      return makeArray(paths).filter(this.createFilter());
    ***REMOVED*** // @returns ***REMOVED***TestResult***REMOVED***

  ***REMOVED***, ***REMOVED***
    key: "test",
    value: function test(path) ***REMOVED***
      return this._test(path, this._testCache, true);
    ***REMOVED***
  ***REMOVED***]);

  return Ignore;
***REMOVED***();

var factory = function factory(options) ***REMOVED***
  return new Ignore(options);
***REMOVED***;

var returnFalse = function returnFalse() ***REMOVED***
  return false;
***REMOVED***;

var isPathValid = function isPathValid(path) ***REMOVED***
  return checkPath(path && checkPath.convert(path), path, returnFalse);
***REMOVED***;

factory.isPathValid = isPathValid; // Fixes typescript

factory["default"] = factory;
module.exports = factory; // Windows
// --------------------------------------------------------------

/* istanbul ignore if  */

if ( // Detect `process` so that it can run in browsers.
typeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) ***REMOVED***
  /* eslint no-control-regex: "off" */
  var makePosix = function makePosix(str) ***REMOVED***
    return /^\\\\\?\\/.test(str) || /[\0-\x1F"<>\|]+/.test(str) ? str : str.replace(/\\/g, '/');
  ***REMOVED***;

  checkPath.convert = makePosix; // 'C:\\foo'     <- 'C:\\foo' has been converted to 'C:/'
  // 'd:\\foo'

  var REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;

  checkPath.isNotRelative = function (path) ***REMOVED***
    return REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
  ***REMOVED***;
***REMOVED***
