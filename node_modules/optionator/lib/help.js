// Generated by LiveScript 1.6.0
(function()***REMOVED***
  var ref$, id, find, sort, min, max, map, unlines, nameToRaw, dasherize, naturalJoin, wordWrap, wordwrap, getPreText, setHelpStyleDefaults, generateHelpForOption, generateHelp;
  ref$ = require('prelude-ls'), id = ref$.id, find = ref$.find, sort = ref$.sort, min = ref$.min, max = ref$.max, map = ref$.map, unlines = ref$.unlines;
  ref$ = require('./util'), nameToRaw = ref$.nameToRaw, dasherize = ref$.dasherize, naturalJoin = ref$.naturalJoin;
  wordWrap = require('word-wrap');
  wordwrap = function(a, b)***REMOVED***
    var ref$, indent, width;
    ref$ = b === undefined
      ? ['', a - 1]
      : [repeatString$(' ', a), b - a - 1], indent = ref$[0], width = ref$[1];
    return function(text)***REMOVED***
      return wordWrap(text, ***REMOVED***
        indent: indent,
        width: width,
        trim: true
      ***REMOVED***);
    ***REMOVED***;
  ***REMOVED***;
  getPreText = function(option, arg$, maxWidth)***REMOVED***
    var mainName, shortNames, ref$, longNames, type, description, aliasSeparator, typeSeparator, initialIndent, names, namesString, namesStringLen, typeSeparatorString, typeSeparatorStringLen, wrap;
    mainName = option.option, shortNames = (ref$ = option.shortNames) != null
      ? ref$
      : [], longNames = (ref$ = option.longNames) != null
      ? ref$
      : [], type = option.type, description = option.description;
    aliasSeparator = arg$.aliasSeparator, typeSeparator = arg$.typeSeparator, initialIndent = arg$.initialIndent;
    if (option.negateName) ***REMOVED***
      mainName = "no-" + mainName;
      if (longNames) ***REMOVED***
        longNames = map(function(it)***REMOVED***
          return "no-" + it;
        ***REMOVED***, longNames);
      ***REMOVED***
    ***REMOVED***
    names = mainName.length === 1
      ? [mainName].concat(shortNames, longNames)
      : shortNames.concat([mainName], longNames);
    namesString = map(nameToRaw, names).join(aliasSeparator);
    namesStringLen = namesString.length;
    typeSeparatorString = mainName === 'NUM' ? '::' : typeSeparator;
    typeSeparatorStringLen = typeSeparatorString.length;
    if (maxWidth != null && !option.boolean && initialIndent + namesStringLen + typeSeparatorStringLen + type.length > maxWidth) ***REMOVED***
      wrap = wordwrap(initialIndent + namesStringLen + typeSeparatorStringLen, maxWidth);
      return namesString + "" + typeSeparatorString + wrap(type).replace(/^\s+/, '');
    ***REMOVED*** else ***REMOVED***
      return namesString + "" + (option.boolean
        ? ''
        : typeSeparatorString + "" + type);
    ***REMOVED***
  ***REMOVED***;
  setHelpStyleDefaults = function(helpStyle)***REMOVED***
    helpStyle.aliasSeparator == null && (helpStyle.aliasSeparator = ', ');
    helpStyle.typeSeparator == null && (helpStyle.typeSeparator = ' ');
    helpStyle.descriptionSeparator == null && (helpStyle.descriptionSeparator = '  ');
    helpStyle.initialIndent == null && (helpStyle.initialIndent = 2);
    helpStyle.secondaryIndent == null && (helpStyle.secondaryIndent = 4);
    helpStyle.maxPadFactor == null && (helpStyle.maxPadFactor = 1.5);
  ***REMOVED***;
  generateHelpForOption = function(getOption, arg$)***REMOVED***
    var stdout, helpStyle, ref$;
    stdout = arg$.stdout, helpStyle = (ref$ = arg$.helpStyle) != null
      ? ref$
      : ***REMOVED******REMOVED***;
    setHelpStyleDefaults(helpStyle);
    return function(optionName)***REMOVED***
      var maxWidth, wrap, option, e, pre, defaultString, restPositionalString, description, fullDescription, that, preDescription, descriptionString, exampleString, examples, seperator;
      maxWidth = stdout != null && stdout.isTTY ? stdout.columns - 1 : null;
      wrap = maxWidth ? wordwrap(maxWidth) : id;
      try ***REMOVED***
        option = getOption(dasherize(optionName));
      ***REMOVED*** catch (e$) ***REMOVED***
        e = e$;
        return e.message;
      ***REMOVED***
      pre = getPreText(option, helpStyle);
      defaultString = option['default'] && !option.negateName ? "\ndefault: " + option['default'] : '';
      restPositionalString = option.restPositional ? 'Everything after this option is considered a positional argument, even if it looks like an option.' : '';
      description = option.longDescription || option.description && sentencize(option.description);
      fullDescription = description && restPositionalString
        ? description + " " + restPositionalString
        : (that = description || restPositionalString) ? that : '';
      preDescription = 'description:';
      descriptionString = !fullDescription
        ? ''
        : maxWidth && fullDescription.length - 1 - preDescription.length > maxWidth
          ? "\n" + preDescription + "\n" + wrap(fullDescription)
          : "\n" + preDescription + " " + fullDescription;
      exampleString = (that = option.example) ? (examples = [].concat(that), examples.length > 1
        ? "\nexamples:\n" + unlines(examples)
        : "\nexample: " + examples[0]) : '';
      seperator = defaultString || descriptionString || exampleString ? "\n" + repeatString$('=', pre.length) : '';
      return pre + "" + seperator + defaultString + descriptionString + exampleString;
    ***REMOVED***;
  ***REMOVED***;
  generateHelp = function(arg$)***REMOVED***
    var options, prepend, append, helpStyle, ref$, stdout, aliasSeparator, typeSeparator, descriptionSeparator, maxPadFactor, initialIndent, secondaryIndent;
    options = arg$.options, prepend = arg$.prepend, append = arg$.append, helpStyle = (ref$ = arg$.helpStyle) != null
      ? ref$
      : ***REMOVED******REMOVED***, stdout = arg$.stdout;
    setHelpStyleDefaults(helpStyle);
    aliasSeparator = helpStyle.aliasSeparator, typeSeparator = helpStyle.typeSeparator, descriptionSeparator = helpStyle.descriptionSeparator, maxPadFactor = helpStyle.maxPadFactor, initialIndent = helpStyle.initialIndent, secondaryIndent = helpStyle.secondaryIndent;
    return function(arg$)***REMOVED***
      var ref$, showHidden, interpolate, maxWidth, output, out, data, optionCount, totalPreLen, preLens, i$, len$, item, that, pre, descParts, desc, preLen, sortedPreLens, maxPreLen, preLenMean, x, padAmount, descSepLen, fullWrapCount, partialWrapCount, descLen, totalLen, initialSpace, wrapAllFull, i, wrap;
      ref$ = arg$ != null
        ? arg$
        : ***REMOVED******REMOVED***, showHidden = ref$.showHidden, interpolate = ref$.interpolate;
      maxWidth = stdout != null && stdout.isTTY ? stdout.columns - 1 : null;
      output = [];
      out = function(it)***REMOVED***
        return output.push(it != null ? it : '');
      ***REMOVED***;
      if (prepend) ***REMOVED***
        out(interpolate ? interp(prepend, interpolate) : prepend);
        out();
      ***REMOVED***
      data = [];
      optionCount = 0;
      totalPreLen = 0;
      preLens = [];
      for (i$ = 0, len$ = (ref$ = options).length; i$ < len$; ++i$) ***REMOVED***
        item = ref$[i$];
        if (showHidden || !item.hidden) ***REMOVED***
          if (that = item.heading) ***REMOVED***
            data.push(***REMOVED***
              type: 'heading',
              value: that
            ***REMOVED***);
          ***REMOVED*** else ***REMOVED***
            pre = getPreText(item, helpStyle, maxWidth);
            descParts = [];
            if ((that = item.description) != null) ***REMOVED***
              descParts.push(that);
            ***REMOVED***
            if (that = item['enum']) ***REMOVED***
              descParts.push("either: " + naturalJoin(that));
            ***REMOVED***
            if (item['default'] && !item.negateName) ***REMOVED***
              descParts.push("default: " + item['default']);
            ***REMOVED***
            desc = descParts.join(' - ');
            data.push(***REMOVED***
              type: 'option',
              pre: pre,
              desc: desc,
              descLen: desc.length
            ***REMOVED***);
            preLen = pre.length;
            optionCount++;
            totalPreLen += preLen;
            preLens.push(preLen);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      sortedPreLens = sort(preLens);
      maxPreLen = sortedPreLens[sortedPreLens.length - 1];
      preLenMean = initialIndent + totalPreLen / optionCount;
      x = optionCount > 2 ? min(preLenMean * maxPadFactor, maxPreLen) : maxPreLen;
      for (i$ = sortedPreLens.length - 1; i$ >= 0; --i$) ***REMOVED***
        preLen = sortedPreLens[i$];
        if (preLen <= x) ***REMOVED***
          padAmount = preLen;
          break;
        ***REMOVED***
      ***REMOVED***
      descSepLen = descriptionSeparator.length;
      if (maxWidth != null) ***REMOVED***
        fullWrapCount = 0;
        partialWrapCount = 0;
        for (i$ = 0, len$ = data.length; i$ < len$; ++i$) ***REMOVED***
          item = data[i$];
          if (item.type === 'option') ***REMOVED***
            pre = item.pre, desc = item.desc, descLen = item.descLen;
            if (descLen === 0) ***REMOVED***
              item.wrap = 'none';
            ***REMOVED*** else ***REMOVED***
              preLen = max(padAmount, pre.length) + initialIndent + descSepLen;
              totalLen = preLen + descLen;
              if (totalLen > maxWidth) ***REMOVED***
                if (descLen / 2.5 > maxWidth - preLen) ***REMOVED***
                  fullWrapCount++;
                  item.wrap = 'full';
                ***REMOVED*** else ***REMOVED***
                  partialWrapCount++;
                  item.wrap = 'partial';
                ***REMOVED***
              ***REMOVED*** else ***REMOVED***
                item.wrap = 'none';
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      initialSpace = repeatString$(' ', initialIndent);
      wrapAllFull = optionCount > 1 && fullWrapCount + partialWrapCount * 0.5 > optionCount * 0.5;
      for (i$ = 0, len$ = data.length; i$ < len$; ++i$) ***REMOVED***
        i = i$;
        item = data[i$];
        if (item.type === 'heading') ***REMOVED***
          if (i !== 0) ***REMOVED***
            out();
          ***REMOVED***
          out(item.value + ":");
        ***REMOVED*** else ***REMOVED***
          pre = item.pre, desc = item.desc, descLen = item.descLen, wrap = item.wrap;
          if (maxWidth != null) ***REMOVED***
            if (wrapAllFull || wrap === 'full') ***REMOVED***
              wrap = wordwrap(initialIndent + secondaryIndent, maxWidth);
              out(initialSpace + "" + pre + "\n" + wrap(desc));
              continue;
            ***REMOVED*** else if (wrap === 'partial') ***REMOVED***
              wrap = wordwrap(initialIndent + descSepLen + max(padAmount, pre.length), maxWidth);
              out(initialSpace + "" + pad(pre, padAmount) + descriptionSeparator + wrap(desc).replace(/^\s+/, ''));
              continue;
            ***REMOVED***
          ***REMOVED***
          if (descLen === 0) ***REMOVED***
            out(initialSpace + "" + pre);
          ***REMOVED*** else ***REMOVED***
            out(initialSpace + "" + pad(pre, padAmount) + descriptionSeparator + desc);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      if (append) ***REMOVED***
        out();
        out(interpolate ? interp(append, interpolate) : append);
      ***REMOVED***
      return unlines(output);
    ***REMOVED***;
  ***REMOVED***;
  function pad(str, num)***REMOVED***
    var len, padAmount;
    len = str.length;
    padAmount = num - len;
    return str + "" + repeatString$(' ', padAmount > 0 ? padAmount : 0);
  ***REMOVED***
  function sentencize(str)***REMOVED***
    var first, rest, period;
    first = str.charAt(0).toUpperCase();
    rest = str.slice(1);
    period = /[\.!\?]$/.test(str) ? '' : '.';
    return first + "" + rest + period;
  ***REMOVED***
  function interp(string, object)***REMOVED***
    return string.replace(/***REMOVED******REMOVED***([a-zA-Z$_][a-zA-Z$_0-9]*)***REMOVED******REMOVED***/g, function(arg$, key)***REMOVED***
      var ref$;
      return (ref$ = object[key]) != null
        ? ref$
        : "***REMOVED******REMOVED***" + key + "***REMOVED******REMOVED***";
    ***REMOVED***);
  ***REMOVED***
  module.exports = ***REMOVED***
    generateHelp: generateHelp,
    generateHelpForOption: generateHelpForOption
  ***REMOVED***;
  function repeatString$(str, n)***REMOVED***
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  ***REMOVED***
***REMOVED***).call(this);
